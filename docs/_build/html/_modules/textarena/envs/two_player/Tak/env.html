<!DOCTYPE html>

<html lang="en" data-content_root="../../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>textarena.envs.two_player.Tak.env &#8212; TextArena 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for textarena.envs.two_player.Tak.env</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">ast</span><span class="o">,</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">textarena</span> <span class="k">as</span> <span class="nn">ta</span>

<div class="viewcode-block" id="TakEnv">
<a class="viewcode-back" href="../../../../../source/textarena.envs.two_player.Tak.html#textarena.envs.two_player.Tak.env.TakEnv">[docs]</a>
<span class="k">class</span> <span class="nc">TakEnv</span><span class="p">(</span><span class="n">ta</span><span class="o">.</span><span class="n">Env</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tak environment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">difficulty</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;easy&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Tak game environment</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            difficulty: Difficulty of the game. Can be &quot;easy&quot;, &quot;medium&quot;, &quot;hard&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">difficulty</span> <span class="o">=</span> <span class="n">difficulty</span>

        <span class="c1"># Initialize the gamm setting the board size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">difficulty</span> <span class="o">==</span> <span class="s2">&quot;easy&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stones</span> <span class="o">=</span> <span class="mi">15</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">capstones</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">difficulty</span> <span class="o">==</span> <span class="s2">&quot;medium&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stones</span> <span class="o">=</span> <span class="mi">21</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">capstones</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">difficulty</span> <span class="o">==</span> <span class="s2">&quot;hard&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="o">=</span> <span class="mi">6</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stones</span> <span class="o">=</span> <span class="mi">30</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">capstones</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid difficulty level. Choose between &#39;easy&#39;, &#39;medium&#39;, &#39;hard&#39;.&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">State</span><span class="p">(</span>
            <span class="n">num_players</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">max_turns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">players</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">board</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">offline_renderer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">textarena.envs.two_player.Tak.render.renderer</span> <span class="kn">import</span> <span class="n">TakRenderer</span>
        <span class="k">return</span> <span class="n">TakRenderer</span>

    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">terminal_render_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;rendered_board&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="TakEnv.reset">
<a class="viewcode-back" href="../../../../../source/textarena.envs.two_player.Tak.html#textarena.envs.two_player.Tak.env.TakEnv.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the environment to set a new game.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            seed: Seed for the random number generator.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Observations: Initial observations for the players.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1">## initialize the board</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">board</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_board</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">players</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;stones&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stones</span><span class="p">,</span>
                <span class="s2">&quot;capstones&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">capstones</span>
            <span class="p">},</span>
            <span class="mi">1</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;stones&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stones</span><span class="p">,</span>
                <span class="s2">&quot;capstones&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">capstones</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span>
            <span class="n">game_state</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;board&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">,</span>
                <span class="s2">&quot;rendered_board&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_render_board</span><span class="p">(),</span>
            <span class="p">},</span>
            <span class="n">player_prompt_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_player_prompt</span>
        <span class="p">)</span></div>

    
    <span class="k">def</span> <span class="nf">_generate_board</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the initial board state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">board</span> <span class="o">=</span> <span class="p">[[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">board_size</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">board_size</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">board</span>

    <span class="k">def</span> <span class="nf">_render_board</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renders the board as a string and returns it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the maximum cell width across the board</span>
        <span class="n">max_cell_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_format_stack</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span>
        <span class="p">)</span>
        <span class="n">cell_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_cell_width</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Ensure minimum cell width for readability</span>

        <span class="c1"># Create the column headers</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;      &quot;</span> <span class="o">+</span> <span class="s2">&quot;   &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">^</span><span class="si">{</span><span class="n">cell_width</span><span class="si">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">board_size</span><span class="p">))</span>

        <span class="c1"># Create the separator line</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="s2">&quot;     &quot;</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">cell_width</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create rows</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row_idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">):</span>
            <span class="c1"># Format each cell and align it</span>
            <span class="n">row_display</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pad_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_format_stack</span><span class="p">(</span><span class="n">cell</span><span class="p">),</span> <span class="n">cell_width</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">row_idx</span><span class="si">:</span><span class="s2">&gt;3</span><span class="si">}</span><span class="s2"> | &quot;</span> <span class="o">+</span> <span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row_display</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; |&quot;</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>

        <span class="c1"># Combine header, separator, and rows into a single string</span>
        <span class="n">board_string</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">header</span><span class="p">,</span> <span class="n">separator</span><span class="p">]</span> <span class="o">+</span> <span class="n">rows</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">board_string</span>


    <span class="k">def</span> <span class="nf">_format_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to format stacks in each cell,</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>  <span class="c1"># Empty cell</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>  <span class="c1"># Full stack representation</span>
    
    <span class="c1">## Helper function to pad cells for uniform display</span>
    <span class="k">def</span> <span class="nf">_pad_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">cell_width</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">content</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">cell_width</span><span class="p">)</span>

    <span class="c1">## Helper function to generate the player prompt</span>
    <span class="k">def</span> <span class="nf">_generate_player_prompt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">player_id</span><span class="p">,</span> <span class="n">game_state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the player prompt.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prompt</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;You are Player </span><span class="si">{</span><span class="n">player_id</span><span class="si">}</span><span class="s2"> in Tak.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Your goal is to connect two opposite edges of the board with your pieces to form a road while blocking your opponent from doing the same.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;You can perform the following actions on your turn:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Place a piece on an empty square.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Move a stack of pieces from one square to one or more squares. You can stack your pieces on top of other pieces on the target square. The topmost piece determines ownership of the stack.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Split a stack of pieces into two or more stacks and distribute them to adjacent squares.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Flatten a wall stone into a flat stone using your capstone.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Place a Capstone on an empty square.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Move a Capstone from one square to one or more squares. A capstone can also flatten a wall stone during its move.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;For each move, submit your action using the format:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;[ACTION SOURCE ALLOCATION]</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- ACTION: The type of move you are making (&#39;place&#39; or &#39;move&#39;).</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- SOURCE: The grid coordinates where the stones originate. Use () for &#39;place&#39;.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- ALLOCATION: A dictionary where keys are target grid coordinates and values are the stones or pieces being moved or placed.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Stone Types and Their Abilities:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Flat Stone (&#39;F&#39;):</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  - Forms part of a road (used to connect edges of the board).</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  - Can be stacked on top of other pieces or have other pieces stacked on it.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  - Can be moved as part of a stack or individually.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Wall Stone (&#39;W&#39;):</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  - Blocks roads and prevents opponents from completing their connections.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  - Cannot be part of a road.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  - Can be flattened into a flat stone by a capstone.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Capstone (&#39;C&#39;):</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  - Acts as a flat stone and can form part of a road.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  - Can flatten wall stones, removing their blocking effect.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  - Cannot be covered by other pieces, always remains on top of the stack.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  - Is a powerful tool for both road-building and disrupting your opponent&#39;s plans.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;The stones will be identified by the player as follows:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Flat Stone for Player 0: &#39;F0&#39;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Wall Stone for Player 1: &#39;W1&#39;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- Capstone for Player 1: &#39;C1&#39;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Examples:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- To place a capstone on (3,2):</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  [place () {(3,2): [C0]}]</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- To move all pieces from (2,2) to (2,3):</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  [move (2,2) {(2,3): [F0]}]</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- To split a stack of 5 pieces from (2,2) into two squares:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  [move (2,2) {(2,3): [F0, F0], (2,4): [W0, F0, C0]}]</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;- To move and stack one piece from (2,2) onto an existing stack at (2,3):</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  [move (2,2) {(2,3): [F0]}]</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;When submitting your move, think strategically about your road-building goals and your opponent&#39;s potential moves.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Here is the current board:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_render_board</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Note that you have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">[</span><span class="n">player_id</span><span class="p">][</span><span class="s1">&#39;stones&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> stones and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">[</span><span class="n">player_id</span><span class="p">][</span><span class="s1">&#39;capstones&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> capstones to begin with.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">prompt</span>


<div class="viewcode-block" id="TakEnv.step">
<a class="viewcode-back" href="../../../../../source/textarena.envs.two_player.Tak.html#textarena.envs.two_player.Tak.env.TakEnv.step">[docs]</a>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ta</span><span class="o">.</span><span class="n">Info</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the action for the player.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            action: Action taken by the player.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Done: Whether the game is over.</span>
<span class="sd">            Info: Additional information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">## Update the observation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">add_observation</span><span class="p">(</span>
            <span class="n">from_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">,</span>
            <span class="n">to_id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="c1">## broadcasting to all players</span>
            <span class="n">message</span><span class="o">=</span><span class="n">action</span><span class="p">,</span>
            <span class="n">for_logging</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1">## action search pattern</span>
        <span class="n">action_search_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;\[(place|move)\s&quot;</span>                <span class="c1"># Match action: &quot;place&quot; or &quot;move&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\((\d+,\d+|\s*)\)\s&quot;</span>            <span class="c1"># Match source: &quot;(row,col)&quot; or &quot;()&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;({.*?})\]&quot;</span>                      <span class="c1"># Match allocation dictionary</span>
        <span class="p">)</span>  <span class="c1"># Example: [move (2,2) {&#39;(2,3)&#39;: [&#39;F0&#39;, &#39;W0&#39;], &#39;(2,4)&#39;: [&#39;C1&#39;]}]</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">action_search_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="c1">## no matching action</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">set_invalid_move</span><span class="p">(</span>
                <span class="n">player_ids</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">],</span>
                <span class="n">reasons</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Invalid move format. Player </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="si">}</span><span class="s2"> did not respond with a valid move in square brackets.&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">## found the matching action</span>
            <span class="n">action</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">allocation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_values</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;place&quot;</span><span class="p">:</span>
                <span class="c1">## place a piece on an empty square</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_placement</span><span class="p">(</span><span class="n">allocation</span><span class="p">):</span>
                    <span class="c1">## invalid placement</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">set_invalid_move</span><span class="p">(</span>
                        <span class="n">player_ids</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">],</span>
                        <span class="n">reasons</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Invalid placement. Player </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="si">}</span><span class="s2"> tried to place a piece on an invalid square.&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_apply_placement</span><span class="p">(</span><span class="n">allocation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">add_observation</span><span class="p">(</span>
                        <span class="n">from_id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">to_id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Player </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="si">}</span><span class="s2"> placed a piece on (</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">allocation</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">). New board state:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_render_board</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">for_logging</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;move&quot;</span><span class="p">:</span>
                <span class="c1">## move a stack of pieces from one square to another</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_movement</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">allocation</span><span class="p">):</span>
                    <span class="c1">## invalid movement</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">set_invalid_move</span><span class="p">(</span>
                        <span class="n">player_ids</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">],</span>
                        <span class="n">reasons</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Invalid movement. Player </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="si">}</span><span class="s2"> tried to move pieces in an invalid way.&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">## valid movement</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_apply_movement</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">allocation</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">add_observation</span><span class="p">(</span>
                        <span class="n">from_id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">to_id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Player </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="si">}</span><span class="s2"> moved pieces from </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">allocation</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">. New board state:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_render_board</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">for_logging</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1">## invalid action</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">set_invalid_move</span><span class="p">(</span>
                    <span class="n">player_ids</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">],</span>
                    <span class="n">reasons</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Invalid action. Player </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="si">}</span><span class="s2"> tried to perform an unknown action.&quot;</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="c1">## update the rendered board</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">game_state</span><span class="p">[</span><span class="s2">&quot;rendered_board&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_render_board</span><span class="p">()</span>

        <span class="c1">## check if the game is over</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_win</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">):</span>
            <span class="c1">## game is over</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">set_winners</span><span class="p">(</span>
                <span class="n">player_ids</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">],</span>
                <span class="n">reason</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Player </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="si">}</span><span class="s2"> has connected two opposite edges of the board.&quot;</span>
            <span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_check_win</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">player_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the specified player has won by forming a continuous road</span>
<span class="sd">        connecting two opposite edges of the board.</span>

<span class="sd">        Args:</span>
<span class="sd">            player_id: The ID of the player to check.</span>
<span class="sd">            board: The 2D grid representing the game board.</span>
<span class="sd">            board_size: The size of the square board (e.g., 4 for a 4x4 board).</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the player has won, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">directions</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>  <span class="c1"># Right, Down, Left, Up</span>

        <span class="k">def</span> <span class="nf">is_valid_cell</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Check if the cell is valid for the player.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span><span class="p">:</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">player_id</span><span class="p">))</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">edges_reached</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Depth-first search to explore all valid paths and update edges reached.</span>

<span class="sd">            Args:</span>
<span class="sd">                row, col: Current cell position.</span>
<span class="sd">                edges_reached: A set of edges the current path has connected to.</span>

<span class="sd">            Returns:</span>
<span class="sd">                bool: True if the player has connected two opposite edges, False otherwise.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># If already visited, return False</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># Mark the current cell as visited</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>

            <span class="c1"># Update edges reached based on the current cell&#39;s position</span>
            <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">edges_reached</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">edges_reached</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;bottom&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">edges_reached</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">edges_reached</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>

            <span class="c1"># Check if two opposite edges have been connected</span>
            <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;top&quot;</span> <span class="ow">in</span> <span class="n">edges_reached</span> <span class="ow">and</span> <span class="s2">&quot;bottom&quot;</span> <span class="ow">in</span> <span class="n">edges_reached</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="s2">&quot;left&quot;</span> <span class="ow">in</span> <span class="n">edges_reached</span> <span class="ow">and</span> <span class="s2">&quot;right&quot;</span> <span class="ow">in</span> <span class="n">edges_reached</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># Explore neighboring cells</span>
            <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
                <span class="n">new_row</span><span class="p">,</span> <span class="n">new_col</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="n">dc</span>
                <span class="k">if</span> <span class="n">is_valid_cell</span><span class="p">(</span><span class="n">new_row</span><span class="p">,</span> <span class="n">new_col</span><span class="p">):</span>
                    <span class="c1"># Pass a copy of edges_reached to avoid shared mutation</span>
                    <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">new_row</span><span class="p">,</span> <span class="n">new_col</span><span class="p">,</span> <span class="n">edges_reached</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
                        <span class="k">return</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Start DFS from all cells on the top edge (for top-to-bottom path)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">board_size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_valid_cell</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>  <span class="c1"># Valid starting point on the top edge</span>
                <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;top&quot;</span><span class="p">}):</span>
                    <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Start DFS from all cells on the left edge (for left-to-right path)</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">board_size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_valid_cell</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># Valid starting point on the left edge</span>
                <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">}):</span>
                    <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_update_pieces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">player_id</span><span class="p">,</span> <span class="n">piece</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the player&#39;s piece count if a new piece is placed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">piece</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span> <span class="ow">or</span> <span class="n">piece</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;W&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">[</span><span class="n">player_id</span><span class="p">][</span><span class="s2">&quot;stones&quot;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">[</span><span class="n">player_id</span><span class="p">][</span><span class="s2">&quot;capstones&quot;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
    
<div class="viewcode-block" id="TakEnv.extract_values">
<a class="viewcode-back" href="../../../../../source/textarena.envs.two_player.Tak.html#textarena.envs.two_player.Tak.env.TakEnv.extract_values">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matched_groups</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract and process the matched groups from the action string.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            matched_groups: Tuple of matched groups from the action string.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Tuple: Processed action, source, and allocation values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">action</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">allocation</span> <span class="o">=</span> <span class="n">matched_groups</span>
    
        <span class="c1"># Process source: Convert to a tuple of integers or None</span>
        <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="n">source</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)))</span>  <span class="c1"># Convert &quot;row,col&quot; to (row, col)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># For place actions with no source</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">allocation_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_to_dict</span><span class="p">(</span><span class="n">allocation</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># Return processed values</span>
        <span class="k">return</span> <span class="n">action</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">allocation_dict</span></div>



    <span class="k">def</span> <span class="nf">_is_valid_placement</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">allocation</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the placement is valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allocation</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">## needs to be a single allocation</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">allocation</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">piece</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">allocation</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">piece</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">][</span><span class="s2">&quot;capstones&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">## no capstones left</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">piece</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">][</span><span class="s2">&quot;stones&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">## no stones left</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span><span class="p">):</span>
            <span class="c1">## needs to be within the board</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">## needs to be a single piece</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]:</span>
            <span class="c1">## needs to be an empty square</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="n">piece</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">]:</span>
            <span class="c1">## unacceptable piece</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span> <span class="nf">_apply_placement</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">allocation</span><span class="p">,</span>
        <span class="n">player_id</span>
    <span class="p">):</span>
        <span class="c1">## valid placement</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">allocation</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">piece</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">allocation</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># piece = [p.upper() + f&quot;{player_id}&quot; for p in piece]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_pieces</span><span class="p">(</span><span class="n">player_id</span><span class="p">,</span> <span class="n">piece</span><span class="p">)</span>

    
    <span class="k">def</span> <span class="nf">_is_valid_movement</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">allocation</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if the movement is valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">## source must be provided</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">source_row</span><span class="p">,</span> <span class="n">source_col</span> <span class="o">=</span> <span class="n">source</span>

        <span class="k">if</span> <span class="n">source_col</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="ow">or</span> <span class="n">source_row</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span><span class="p">:</span>
            <span class="c1">## source must be within the board</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">source_row</span><span class="p">][</span><span class="n">source_col</span><span class="p">]:</span>
            <span class="c1">## source must have pieces</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">source_type</span><span class="p">,</span> <span class="n">source_player_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">source_row</span><span class="p">][</span><span class="n">source_col</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">source_row</span><span class="p">][</span><span class="n">source_col</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">source_player_id</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">):</span>
            <span class="c1">## source must have the current player&#39;s stone on top</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">source_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">source_row</span><span class="p">][</span><span class="n">source_col</span><span class="p">]</span>
        <span class="n">pieces_to_move</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">allocation</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">pieces_to_move</span> <span class="o">!=</span> <span class="n">source_stack</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">pieces_to_move</span><span class="p">):]:</span>
            <span class="c1">## pieces to move must match the top of the stack in order</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">top_piece_type</span> <span class="o">=</span> <span class="n">source_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pieces_to_move</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">## single pieces retain the power of the capstone - to flatten wall stones.</span>
            <span class="n">target_row</span><span class="p">,</span> <span class="n">target_col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">allocation</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">target_row</span> <span class="o">-</span> <span class="n">source_row</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target_col</span> <span class="o">-</span> <span class="n">source_col</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">## target must be adjacent to the source</span>
                <span class="k">return</span> <span class="kc">False</span>
            
            <span class="k">if</span> <span class="n">target_row</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="ow">or</span> <span class="n">target_col</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span><span class="p">:</span>
                <span class="c1">## target must be within the board</span>
                <span class="k">return</span> <span class="kc">False</span>
            
            <span class="k">if</span> <span class="n">top_piece_type</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
                <span class="c1">## capstone cannot be moved over another capstone</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">top_piece_type</span> <span class="o">==</span> <span class="s2">&quot;W&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">]:</span>
                <span class="c1">## wall stone cannot be moved over capstone</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">top_piece_type</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">]:</span>
                <span class="c1">## flat stone cannot be moved over wall stone or capstone</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">pieces</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">allocation</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">target_row</span><span class="p">,</span> <span class="n">target_col</span> <span class="o">=</span> <span class="n">target</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">target_row</span> <span class="o">-</span> <span class="n">source_row</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target_col</span> <span class="o">-</span> <span class="n">source_col</span><span class="p">))</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1">## target must be adjacent to the source</span>
                    <span class="k">return</span> <span class="kc">False</span>
                
                <span class="k">if</span> <span class="n">target_row</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span> <span class="ow">or</span> <span class="n">target_col</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board_size</span><span class="p">:</span>
                    <span class="c1">## target must be within the board</span>
                    <span class="k">return</span> <span class="kc">False</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
                        <span class="c1">## nothing can be moved over another capstone</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;W&quot;</span><span class="p">:</span>
                        <span class="c1">## nothing can be moved over a wall stone</span>
                        <span class="k">return</span> <span class="kc">False</span>
                
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span> <span class="nf">_apply_movement</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">allocation</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the movement to the board.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source_row</span><span class="p">,</span> <span class="n">source_col</span> <span class="o">=</span> <span class="n">source</span>
        <span class="n">source_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">source_row</span><span class="p">][</span><span class="n">source_col</span><span class="p">]</span>
        <span class="n">pieces_to_move</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">allocation</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
        <span class="n">top_piece_type</span> <span class="o">=</span> <span class="n">source_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pieces_to_move</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">target_row</span><span class="p">,</span> <span class="n">target_col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">allocation</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">top_piece_type</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;W&quot;</span><span class="p">:</span>
                    <span class="c1">## capstone can flatten wall stone</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pieces_to_move</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">pieces</span> <span class="ow">in</span> <span class="n">allocation</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">target_row</span><span class="p">,</span> <span class="n">target_col</span> <span class="o">=</span> <span class="n">target</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">target_row</span><span class="p">][</span><span class="n">target_col</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pieces</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">source_row</span><span class="p">][</span><span class="n">source_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_stack</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">pieces_to_move</span><span class="p">)]</span>            
    
    <span class="k">def</span> <span class="nf">_convert_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a string representation of a dictionary with tuple keys and list-like values</span>
<span class="sd">        into a valid Python dictionary, ensuring:</span>
<span class="sd">        - Tuple keys retain their integer types.</span>
<span class="sd">        - List elements are converted to strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Preprocess the string to wrap unquoted words with quotes</span>
        <span class="k">def</span> <span class="nf">add_quotes</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        
        <span class="c1"># Use regex to find unquoted words in the list-like values</span>
        <span class="n">input_str</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b([A-Za-z0-9_]+)\b&#39;</span><span class="p">,</span> <span class="n">add_quotes</span><span class="p">,</span> <span class="n">input_str</span><span class="p">)</span>
        
        <span class="c1"># Safely evaluate the corrected string</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">parsed_dict</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">input_str</span><span class="p">)</span>
            
            <span class="c1"># Convert keys back to tuples with integers, and ensure list elements are strings</span>
            <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="k">else</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">parsed_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
            
            <span class="k">return</span> <span class="n">result_dict</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid input string: </span><span class="si">{</span><span class="n">input_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../index.html">TextArena</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../source/modules.html">textarena</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Leon Guertler, Bobby Cheng.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>