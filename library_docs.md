# Table of Contents
- textarena/core.py
- textarena/basic_agents.py
- textarena/utils.py
- textarena/__init__.py
- textarena/game_makers/gpt_judges.py
- textarena/game_makers/__init__.py
- textarena/assets/textarena-icon.xbm
- textarena/static/app.js
- textarena/static/style.css
- textarena/static/textarena-icon.xbm
- textarena/wrappers/index.html
- textarena/wrappers/agent_wrappers.py
- textarena/wrappers/app.js
- textarena/wrappers/style.css
- textarena/wrappers/render_wrappers.py
- textarena/wrappers/observation_wrappers.py
- textarena/wrappers/action_wrappers.py
- textarena/wrappers/__init__.py
- textarena/api/api_client.py
- textarena/api/game_manager.py
- textarena/api/utils.py
- textarena/api/README.md
- textarena/api/__init__.py
- textarena/api/online_env.py
- textarena/envs/registration.py
- textarena/envs/__init__.py
- textarena/static/chess/app.js
- textarena/static/chess/style.css
- textarena/wrappers/static/app.js
- textarena/wrappers/static/style.css
- textarena/wrappers/static/textarena-icon.xbm
- textarena/wrappers/renderers/textarena-icon.xbm
- textarena/wrappers/renderers/base.py
- textarena/wrappers/renderers/chess.py
- textarena/wrappers/renderers/static/textarena-icon.xbm
- textarena/envs/two_player/word_chains.py
- textarena/envs/two_player/README.md
- textarena/envs/two_player/__init__.py
- textarena/envs/single_player/README.md
- textarena/envs/single_player/__init__.py
- textarena/envs/multi_player/codenames.py
- textarena/envs/multi_player/liars_dice.py
- textarena/envs/multi_player/README.md
- textarena/envs/multi_player/__init__.py
- textarena/envs/two_player/Battleship/test.py
- textarena/envs/two_player/Battleship/env.py
- textarena/envs/two_player/Battleship/render copy.py
- textarena/envs/two_player/Battleship/render.py
- textarena/envs/two_player/Battleship/README.md
- textarena/envs/two_player/Battleship/example.py
- textarena/envs/two_player/Battleship/__init__.py
- textarena/envs/two_player/IteratedPrisonersDillemma/test.py
- textarena/envs/two_player/IteratedPrisonersDillemma/iterated_prisoners_dilemma.py
- textarena/envs/two_player/IteratedPrisonersDillemma/README.md
- textarena/envs/two_player/WordChains/test.py
- textarena/envs/two_player/WordChains/env.py
- textarena/envs/two_player/WordChains/README.md
- textarena/envs/two_player/LeHavre/env.py
- textarena/envs/two_player/ConnectFour/test.py
- textarena/envs/two_player/ConnectFour/env.py
- textarena/envs/two_player/ConnectFour/render.py
- textarena/envs/two_player/ConnectFour/README.md
- textarena/envs/two_player/ConnectFour/__init__.py
- textarena/envs/two_player/ScenarioPlanning/test.py
- textarena/envs/two_player/ScenarioPlanning/env.py
- textarena/envs/two_player/ScenarioPlanning/scenarios.json
- textarena/envs/two_player/ScenarioPlanning/README.md
- textarena/envs/two_player/LetterAuction/test.py
- textarena/envs/two_player/LetterAuction/env.py
- textarena/envs/two_player/LetterAuction/README.md
- textarena/envs/two_player/LetterAuction/example.py
- textarena/envs/two_player/Chess/test.py
- textarena/envs/two_player/Chess/env.py
- textarena/envs/two_player/Chess/README.md
- textarena/envs/two_player/Chess/__init__.py
- textarena/envs/two_player/TruthAndDeception/test.py
- textarena/envs/two_player/TruthAndDeception/env.py
- textarena/envs/two_player/TruthAndDeception/render.py
- textarena/envs/two_player/TruthAndDeception/facts.json
- textarena/envs/two_player/TruthAndDeception/README.md
- textarena/envs/two_player/TruthAndDeception/__init__.py
- textarena/envs/two_player/CarPuzzle/env.py
- textarena/envs/two_player/CarPuzzle/car_puzzle.py
- textarena/envs/two_player/Poker/test.py
- textarena/envs/two_player/Poker/env.py
- textarena/envs/two_player/Poker/render.py
- textarena/envs/two_player/Poker/README.md
- textarena/envs/two_player/Poker/__init__.py
- textarena/envs/two_player/Taboo/test.py
- textarena/envs/two_player/Taboo/env.py
- textarena/envs/two_player/Taboo/words.json
- textarena/envs/two_player/Taboo/README.md
- textarena/envs/two_player/Mastermind/test.py
- textarena/envs/two_player/Mastermind/env.py
- textarena/envs/two_player/Mastermind/README.md
- textarena/envs/two_player/Mastermind/example.py
- textarena/envs/two_player/DontSayIt/test.py
- textarena/envs/two_player/DontSayIt/env.py
- textarena/envs/two_player/DontSayIt/README.md
- textarena/envs/two_player/DontSayIt/__init__.py
- textarena/envs/two_player/SpiteAndMalice/test.py
- textarena/envs/two_player/SpiteAndMalice/env.py
- textarena/envs/two_player/SpiteAndMalice/README.md
- textarena/envs/two_player/SpiteAndMalice/example.py
- textarena/envs/two_player/Negotiation/test.py
- textarena/envs/two_player/Negotiation/env.py
- textarena/envs/two_player/Negotiation/render.py
- textarena/envs/two_player/Negotiation/README.md
- textarena/envs/two_player/Negotiation/__init__.py
- textarena/envs/two_player/MemoryGame/test.py
- textarena/envs/two_player/MemoryGame/env.py
- textarena/envs/two_player/MemoryGame/README.md
- textarena/envs/two_player/MemoryGame/example.py
- textarena/envs/two_player/Debate/test.py
- textarena/envs/two_player/Debate/env.py
- textarena/envs/two_player/Debate/topics.json
- textarena/envs/two_player/Debate/README.md
- textarena/envs/two_player/LiarsDice/test.py
- textarena/envs/two_player/LiarsDice/env.py
- textarena/envs/two_player/LiarsDice/README.md
- textarena/envs/two_player/SpellingBee/test.py
- textarena/envs/two_player/SpellingBee/env.py
- textarena/envs/two_player/SpellingBee/render.py
- textarena/envs/two_player/SpellingBee/README.md
- textarena/envs/two_player/SpellingBee/__init__.py
- textarena/envs/single_player/Hangman/test.py
- textarena/envs/single_player/Hangman/env.py
- textarena/envs/single_player/Hangman/readme.md
- textarena/envs/single_player/Hangman/example.py
- textarena/envs/single_player/GuessWho/test.py
- textarena/envs/single_player/GuessWho/env.py
- textarena/envs/single_player/GuessWho/characters.json
- textarena/envs/single_player/GuessWho/README.md
- textarena/envs/single_player/GuessWho/example.py
- textarena/envs/single_player/Minesweeper/test.py
- textarena/envs/single_player/Minesweeper/env.py
- textarena/envs/single_player/Minesweeper/README.md
- textarena/envs/single_player/Minesweeper/example.py
- textarena/envs/single_player/TwentyQuestions/test.py
- textarena/envs/single_player/TwentyQuestions/env.py
- textarena/envs/single_player/TwentyQuestions/README.md
- textarena/envs/single_player/TwentyQuestions/example.py
- textarena/envs/single_player/Sudoku/test.py
- textarena/envs/single_player/Sudoku/env.py
- textarena/envs/single_player/Sudoku/readme.md
- textarena/envs/single_player/Sudoku/example.py
- textarena/envs/single_player/Sudoku/__init__.py
- textarena/envs/single_player/TowerOfHanoi/test.py
- textarena/envs/single_player/TowerOfHanoi/env.py
- textarena/envs/single_player/TowerOfHanoi/README.md
- textarena/envs/single_player/TowerOfHanoi/example.py
- textarena/envs/single_player/WordLadder/test.py
- textarena/envs/single_player/WordLadder/env.py
- textarena/envs/single_player/WordLadder/readme.md
- textarena/envs/single_player/WordLadder/example.py
- textarena/envs/single_player/GuessTheNumber/test.py
- textarena/envs/single_player/GuessTheNumber/env.py
- textarena/envs/single_player/GuessTheNumber/readme.md
- textarena/envs/single_player/GuessTheNumber/example.py
- textarena/envs/single_player/WordSearch/test.py
- textarena/envs/single_player/WordSearch/env.py
- textarena/envs/single_player/WordSearch/readme.md
- textarena/envs/single_player/WordSearch/example.py
- textarena/envs/single_player/Crosswords/test.py
- textarena/envs/single_player/Crosswords/env.py
- textarena/envs/single_player/Crosswords/words_clues.jsonl
- textarena/envs/single_player/Crosswords/readme.md
- textarena/envs/single_player/Crosswords/example.py
- textarena/envs/single_player/LogicPuzzle/test.py
- textarena/envs/single_player/LogicPuzzle/env.py
- textarena/envs/single_player/LogicPuzzle/README.md
- textarena/envs/single_player/LogicPuzzle/example.py
- textarena/envs/single_player/LogicPuzzle/game_board_clues.jsonl
- textarena/envs/single_player/FifteenPuzzle/test.py
- textarena/envs/single_player/FifteenPuzzle/env.py
- textarena/envs/single_player/FifteenPuzzle/readme.md
- textarena/envs/single_player/FifteenPuzzle/example.py
- textarena/envs/single_player/Sudoku/archive/sudoku_bob.py
- textarena/envs/single_player/Sudoku/archive/sudoku.py
- textarena/envs/single_player/WordLadder/archive/word_ladder.py
- textarena/envs/single_player/Crosswords/utils/words_clues_generator.py
- textarena/envs/single_player/LogicPuzzle/utils/game_board_generator.py

## File: textarena/core.py

- Extension: .py
- Language: python
- Size: 18435 bytes
- Created: 2024-12-12 12:03:05
- Modified: 2024-12-12 12:03:05

### Code

```python
  1 | from abc import ABC, abstractmethod
  2 | from typing import Any, Dict, List, Tuple, Optional, Callable
  3 | 
  4 | import random
  5 | 
  6 | GAME_ID = -1  
  7 | Message = Tuple[int, str]  
  8 | Observations = dict[
  9 |     int, List[Message]
 10 | ]  
 11 | Rewards = Dict[int, int]  
 12 | Info = Dict[str, Any]  
 13 | 
 14 | 
 15 | class State:
 16 |     
 17 | 
 18 |     def __init__(
 19 |         self,
 20 |         num_players: int,
 21 |         max_turns: Optional[int] = None,
 22 |         role_mapping: Optional[Dict[int, str]] = {},
 23 |         check_truncated: Optional[bool] = True,
 24 |     ):
 25 |         
 26 |         self.num_players = num_players
 27 |         self.max_turns = max_turns
 28 |         self.check_truncated = check_truncated
 29 | 
 30 |         
 31 |         self.logs = []
 32 |         self.turn = 0
 33 |         self.current_player_id = 0
 34 | 
 35 |         self.role_mapping = role_mapping
 36 |         self.role_mapping[-1] = "GAME"
 37 | 
 38 |     
 39 |     
 40 |     
 41 |     
 42 |     
 43 |     
 44 |     
 45 | 
 46 |     def reset(
 47 |         self,
 48 |         game_state: Dict[str, Any],
 49 |         player_prompt_function: Callable,
 50 |         seed: Optional[int] = None,
 51 |         executable_on_reset: Optional[List[Callable]] = None,
 52 |     ):
 53 |         
 54 |         if seed is not None:
 55 |             random.seed(seed)
 56 |         else:
 57 |             random.seed()
 58 | 
 59 | 
 60 |         self.game_state = game_state
 61 |         self.current_player_id = 0
 62 |         self.turn = 0
 63 | 
 64 |         self.logs.append((GAME_ID, "Game started."))
 65 | 
 66 |         self._reset_game_parameters()
 67 | 
 68 |         
 69 |         for player_id in range(self.num_players):
 70 |             self.add_observation(
 71 |                 from_id=GAME_ID,
 72 |                 to_id=player_id,
 73 |                 message=player_prompt_function(
 74 |                     player_id=player_id,
 75 |                     game_state=self.game_state
 76 |                 ),
 77 |                 for_logging=False,
 78 |             )
 79 | 
 80 |         
 81 |         if executable_on_reset is not None:
 82 |             for executable in executable_on_reset:
 83 |                 executable()
 84 | 
 85 |         return self.observations 
 86 | 
 87 |     def _reset_game_parameters(self):
 88 |         
 89 |         self.terminated = False
 90 |         self.truncated = False
 91 |         self.info = {}
 92 |         self.rewards = None
 93 |         self.observations = {pid: [] for pid in range(self.num_players)}
 94 | 
 95 | 
 96 |     def add_observation(
 97 |         self, from_id: int, to_id: int, message: str, for_logging: bool = True
 98 |     ):
 99 |         
100 |         if for_logging:
101 |             
102 |             self.logs.append((from_id, message))
103 | 
104 |         
105 |         if to_id == -1:
106 |             for pid in range(self.num_players): 
107 |                 self.observations[pid].append((from_id, message))
108 |         else:
109 |             assert (
110 |                 to_id in self.observations
111 |             ), f"The provided 'to_id' {to_id} does not exists. ({list(self.observations.keys())})"
112 |             self.observations[to_id].append((from_id, message))
113 | 
114 |     def add_log(self, from_id: int, message: str):
115 |         
116 |         self.logs.append((from_id, message))
117 | 
118 |     def check_action_format(self, action): 
119 |         
120 |         assert isinstance(
121 |             action, str
122 |         ), f"Actions are required to be strings. Received dtype: {type(action)}"
123 | 
124 |         self.observations[self.current_player_id] = []
125 | 
126 |         
127 |         assert (
128 |             self.terminated==False and self.truncated==False
129 |         ), f"Trying to step when the enviornment is already terminated/truncated. Please reset it first."
130 | 
131 | 
132 |     def step(self, rotate_player : bool = True):
133 |         
134 |         if self.terminated:  
135 |             return (
136 |                 self.rewards,
137 |                 self.truncated,
138 |                 self.terminated,
139 |                 self.info,
140 |             )
141 | 
142 |         
143 |         self.turn += 1
144 | 
145 |         
146 |         if (
147 |             self.max_turns is not None
148 |             and self.turn >= self.max_turns
149 |             and self.check_truncated
150 |         ):
151 |             
152 |             self.rewards = {pid: 0 for pid in range(self.num_players)}
153 | 
154 |             
155 |             reason = "Turn limit reached"
156 |             self.logs.append((GAME_ID, reason))
157 |             self.info["detailed_reason"] = reason
158 |             self.info["reason"] = "Draw."
159 |             self.truncated = True
160 | 
161 |         
162 |         info = self.info
163 |         terminated = self.terminated
164 |         truncated = self.truncated
165 |         rewards = self.rewards
166 | 
167 |         
168 |         
169 | 
170 |         
171 |         if rotate_player :
172 |             prev_player = self.current_player_id
173 |             self.current_player_id = (self.current_player_id + 1) % self.num_players
174 | 
175 |             
176 |             
177 | 
178 |         
179 |         self.info = {}
180 |         self.reward = None
181 | 
182 |         return (rewards, truncated, terminated, info)
183 | 
184 |     def set_winners(self, player_ids: List[int], reason: Optional[str]):
185 |         
186 | 
187 |         
188 |         self.rewards = {}
189 |         for player_id in range(self.num_players):
190 |             if player_id in player_ids:
191 |                 self.rewards[player_id] = 1
192 |             else:
193 |                 self.rewards[player_id] = -1
194 | 
195 |         
196 |         self.logs.append((GAME_ID, reason))
197 |         
198 |         
199 |         self.info["reason"] = reason
200 |         self.terminated = True
201 | 
202 |     def set_draw(self, reason: Optional[str]):
203 |         
204 |         
205 |         self.rewards = {pid: 0 for pid in range(self.num_players)}
206 | 
207 |         
208 |         self.logs.append((GAME_ID, reason))
209 |         
210 |         
211 |         self.info["reason"] = reason
212 |         self.terminated = True
213 | 
214 |     def set_invalid_move(self, player_ids: List[int], reasons: Optional[List[str]]):
215 |         
216 | 
217 |         
218 |         self.rewards = {}
219 |         for player_id in range(self.num_players):
220 |             if player_id in player_ids:
221 |                 self.rewards[player_id] = -1
222 |             else:
223 |                 self.rewards[player_id] = 0
224 | 
225 |         
226 |         self.logs.append((GAME_ID, "; ".join(reasons)))
227 |         
228 |         
229 |         self.info["reason"] = f"Invalid Move: {'; '.join(reasons)}"
230 |         self.terminated = True
231 | 
232 | 
233 | class Env(ABC):
234 |     
235 | 
236 |     
237 |     game_state: State  
238 | 
239 |     @abstractmethod
240 |     def reset(self, seed: Optional[int] = None) -> Optional[Observations]:
241 |         
242 |         raise NotImplementedError
243 | 
244 |     @abstractmethod
245 |     def step(
246 |         self,
247 |         player_id: int,
248 |         action: str,
249 |     ) -> tuple[
250 |         Observations,  
251 |         Rewards,  
252 |         bool,  
253 |         bool,  
254 |         Info,  
255 |     ]:
256 |         
257 |         raise NotImplementedError
258 | 
259 |     def get_observation(self):
260 |         return self.state.current_player_id, self.state.observations[self.state.current_player_id]
261 | 
262 |     def close(self):
263 |         pass 
264 | 
265 | 
266 | class Wrapper(Env):
267 |     
268 | 
269 |     def __init__(self, env: Env):
270 |         
271 |         self.env = env
272 |         
273 |         self.state = env.state
274 |         assert isinstance(env, Env)
275 | 
276 |     def __getattr__(self, name):
277 |         
278 |         return getattr(self.env, name)
279 | 
280 |     def reset(self, seed: Optional[int] = None) -> Optional[Observations]:
281 |         
282 |         return self.env.reset(seed=seed)
283 | 
284 |     def step(self, action: str) -> tuple[
285 |         Optional[Rewards], bool, bool, Info]:
286 |         
287 |         return self.env.step(action=action)
288 | 
289 |     def get_observation(self):
290 |         return self.env.get_observation()
291 | 
292 |     def close(self):
293 |         return self.env.close()
294 | 
295 | 
296 | 
297 | class ObservationWrapper(Wrapper):
298 | 
299 |     def get_observation(self):
300 |         player_id, observation = self.env.get_observation()
301 |         return player_id, self.observation(player_id, observation)
302 | 
303 |     def observation(self):
304 |         raise NotImplementedError
305 | 
306 | 
307 | class RenderWrapper(Wrapper):
308 |     
309 | 
310 | 
311 | class ActionWrapper(Wrapper):
312 |     
313 | 
314 |     def step(self, player_id: int, action: str) -> tuple[
315 |         Optional[Observations],
316 |         Optional[Rewards],
317 |         bool,
318 |         bool,
319 |         Optional[Info],
320 |     ]:
321 |         
322 |         return self.env.step(player_id=player_id, action=self.action(action))
323 | 
324 |     def action(self, action: str) -> str:
325 |         
326 |         raise NotImplementedError
327 | 
328 | 
329 | class Agent(ABC):
330 |     
331 |     @abstractmethod
332 |     def __call__(
333 |         self, 
334 |         observation: str
335 |     ) -> str:
336 |         
337 |         pass
338 | 
339 | 
340 | class AgentWrapper(Agent):
341 |     
342 |     def __init__(self, agent: Agent):
343 |         
344 |         self.agent = agent 
345 |         assert isinstance(agent, Agent)
346 | 
347 |     def __getattr__(self, name):
348 |         
349 |         return getattr(self.agent, name)
350 | 
351 |     def __call__(self, observation: str) -> str:
352 |         return self.agent(observation=observation)
353 | 
354 | 
355 | 
356 | 
357 | 
358 | class GameMaker(ABC):
359 |     
360 | 
361 |     @abstractmethod
362 |     def __call__(self, text_input: str) -> str:
363 |         
364 |         raise NotImplementedError
365 | 
366 | 
367 | class JudgeVote(ABC):
368 |     
369 | 
370 |     @abstractmethod
371 |     def __init__(self, optinos: List[str], num_judges: int):
372 |         
373 |         raise NotImplementedError
374 | 
375 |     @abstractmethod
376 |     def evaluate(self, transcript: str) -> Dict[str, int]:
377 |         
378 |         raise NotImplementedError
379 | 
380 | 
381 | class GameMasterAction(ABC):
382 |     
383 | 
384 |     @abstractmethod
385 |     def __init__(self, options: List[str]):
386 |         
387 |         raise NotImplementedError
388 | 
389 |     @abstractmethod
390 |     def respond_to_action(self, player_action: str) -> str:
391 |         
392 |         raise NotImplementedError
```

## File: textarena/basic_agents.py

- Extension: .py
- Language: python
- Size: 7663 bytes
- Created: 2024-12-12 10:46:44
- Modified: 2024-12-12 10:46:44

### Code

```python
  1 | from abc import ABC, abstractmethod
  2 | import openai, os
  3 | from transformers import pipeline, AutoTokenizer, AutoModelForCausalLM
  4 | from typing import Optional 
  5 | 
  6 | from textarena.core import Agent
  7 | import textarena as ta 
  8 | 
  9 | __all__ = [
 10 |     "HumanAgent",
 11 |     "OpenRouterAgent",
 12 |     "HFLocalAgent",
 13 |     "CerebrasAgent"
 14 | ]
 15 | 
 16 |     
 17 | class HumanAgent(Agent):
 18 |     
 19 |     def __init__(self):
 20 |         
 21 |         super().__init__()
 22 | 
 23 |     def __call__(
 24 |         self, 
 25 |         observation: str
 26 |     ) -> str:
 27 |         
 28 |         print(observation)
 29 |         return input("Please enter the action: ")
 30 | 
 31 | 
 32 | class OpenRouterAgent(Agent):
 33 |     
 34 |     def __init__(
 35 |         self, 
 36 |         model_name: str,
 37 |         system_prompt: Optional[str]=None
 38 |     ):
 39 |         
 40 |         super().__init__()
 41 |         self.model_name = model_name
 42 | 
 43 |         
 44 |         openai.api_key = os.getenv("OPENAI_API_KEY")
 45 |         if not openai.api_key:
 46 |             raise ValueError("OPENAI API key not found. Please set the OPENAI_API_KEY environment variable.")
 47 |         
 48 |         
 49 |         self.client = openai.OpenAI(base_url="https://openrouter.ai/api/v1")
 50 | 
 51 |         
 52 |         if system_prompt is None:
 53 |             self.system_prompt = "You are a competitive game player. Make sure you read the game instructions carefully, and always follow the required format."
 54 |         else:
 55 |             self.system_prompt = system_prompt
 56 | 
 57 |     
 58 |     def __call__(
 59 |         self, 
 60 |         observation: str
 61 |     ) -> str:
 62 |         
 63 |         assert isinstance(observation, str), \
 64 |             f"When uisng OpenRouter, the observation must be a string. Received type: {type(observation)}"
 65 |         
 66 |         response = self.client.chat.completions.create(
 67 |             model=self.model_name,
 68 |             messages=[
 69 |                 {"role": "system", "content": self.system_prompt},
 70 |                 {"role": "user", "content": observation}
 71 |             ],
 72 |             
 73 |             n=1,
 74 |             stop=None,
 75 |             temperature=0.7,
 76 |         )
 77 |         print(response)
 78 |         
 79 |         action = response.choices[0].message.content.strip()
 80 |         return action
 81 |         
 82 |         
 83 |         
 84 | 
 85 |             
 86 | 
 87 | 
 88 | class HFLocalAgent(Agent):
 89 |     
 90 |     def __init__(
 91 |         self, 
 92 |         model_name: str, 
 93 |         quantize: bool = False
 94 |     ):
 95 |         
 96 |         super().__init__()
 97 | 
 98 |         
 99 |         access_token = os.getenv("HF_ACCESS_TOKEN")
100 |         if not access_token:
101 |             raise ValueError("Hugging Face access token not found. Please set the HF_ACCESS_TOKEN environment variable.")
102 |         
103 |         
104 |         self.tokenizer = AutoTokenizer.from_pretrained(
105 |             model_name, 
106 |             token=access_token,
107 |             )
108 |         
109 |         if quantize:
110 |             self.model = AutoModelForCausalLM.from_pretrained(
111 |                 model_name, 
112 |                 load_in_8bit=True,
113 |                 token=access_token,
114 |                 device_map='auto',
115 |                 )
116 |         else:
117 |             self.model = AutoModelForCausalLM.from_pretrained(
118 |                 model_name,
119 |                 token=access_token,
120 |                 device_map='auto'
121 |                 )
122 | 
123 |         
124 |         self.pipeline = pipeline(
125 |             'text-generation',
126 |             model=self.model, 
127 |             tokenizer=self.tokenizer, 
128 |             token=access_token
129 |             )
130 |     
131 |     def __call__(
132 |         self, 
133 |         observation: str
134 |     ) -> str:
135 |         
136 |         
137 |         try:
138 |             response = self.pipeline(
139 |                 observation, 
140 |                 max_new_tokens=500, 
141 |                 num_return_sequences=1, 
142 |                 temperature=0.7, 
143 |                 return_full_text=False,
144 |             )
145 |             
146 |             action = response[0]['generated_text'].strip()
147 |             return action
148 |         except Exception as e:
149 |             return f"An error occurred: {e}"
150 | 
151 | 
152 | 
153 | class CerebrasAgent(Agent):
154 |     
155 | 
156 |     def __init__(self, model_name: str, system_prompt: str | None = None):
157 |         
158 |         super().__init__()
159 |         self.model_name = model_name
160 |         
161 |         from cerebras.cloud.sdk import Cerebras
162 |         self.client = Cerebras(
163 |             
164 |             api_key=os.getenv("CEREBRAS_API_KEY"),
165 |         )
166 | 
167 |         
168 |         if system_prompt is None:
169 |             self.system_prompt = "You are a competitive game player. Make sure you read the game instructions carefully, and always follow the required format."
170 |         else:
171 |             self.system_prompt = system_prompt
172 | 
173 |     def __call__(self, observation: str) -> str:
174 |         
175 |         try:
176 |             response = self.client.chat.completions.create(
177 |                 model=self.model_name,
178 |                 messages=[
179 |                     {"role": "system", "content": self.system_prompt},
180 |                     {"role": "user", "content": observation},
181 |                 ],
182 |                 top_p=0.9,
183 |                 temperature=0.9,
184 |             )
185 |             
186 |             action = response.choices[0].message.content.strip()
187 |             return action
188 |         except Exception as e:
189 |             return f"An error occurred: {e}"
```

## File: textarena/utils.py

- Extension: .py
- Language: python
- Size: 2958 bytes
- Created: 2024-10-18 15:28:49
- Modified: 2024-10-18 15:28:49

### Code

```python
 1 | 
 2 | 
 3 | import asyncio
 4 | import os
 5 | 
 6 | import aiohttp
 7 | import backoff
 8 | import dotenv
 9 | 
10 | RETRY_EXCEPTIONS = (aiohttp.ClientError, asyncio.TimeoutError, AssertionError)
11 | 
12 | dotenv.load_dotenv()
13 | OPEN_ROUTER_TOKEN = os.getenv("OPEN_ROUTER_TOKEN")
14 | 
15 | 
16 | @backoff.on_exception(backoff.expo, RETRY_EXCEPTIONS, max_tries=5, jitter=None)
17 | 
18 | async def open_router_generate(
19 |     text: str, model_string: str, message_history: list[dict] | None, **gen_kwargs
20 | ) -> str:
21 |     
22 |     async with aiohttp.ClientSession(raise_for_status=True) as session:
23 |         if not message_history:
24 |             message_history = []
25 |         response = await session.post(
26 |             url="https://openrouter.ai/api/v1/chat/completions",
27 |             headers={
28 |                 "Authorization": f"Bearer {OPEN_ROUTER_TOKEN}",
29 |             },
30 |             json={
31 |                 "model": model_string,  
32 |                 "messages": [
33 |                     {
34 |                         "role": "system",
35 |                         "content": "You are a helpful game-playing assistant.",
36 |                     }
37 |                 ]
38 |                 + message_history
39 |                 + [
40 |                     {"role": "user", "content": text},
41 |                 ],
42 |                 **gen_kwargs,  
43 |             },
44 |             timeout=20,
45 |         )
46 |         response_json = await response.json()
47 |         if (
48 |             not response_json or "choices" not in response_json
49 |         ):  
50 |             raise AssertionError("Invalid response")
51 |         return response_json["choices"][0]["message"]["content"]
52 | 
53 | 
54 | def batch_open_router_generate(
55 |     texts: list[str],
56 |     model_string: str,
57 |     message_history: list[dict] | None,
58 |     batch_size: int = 8,
59 |     **gen_kwargs,
60 | ) -> list[str]:
61 |     
62 |     for i in range(0, len(texts), batch_size):
63 |         batch_texts = texts[i : i + batch_size]
64 |         loop = asyncio.get_event_loop()
65 |         batch_responses = loop.run_until_complete(
66 |             asyncio.gather(
67 |                 *[
68 |                     open_router_generate(
69 |                         text=text,
70 |                         model_string=model_string,
71 |                         message_history=message_history,
72 |                         **gen_kwargs,
73 |                     )
74 |                     for text in batch_texts
75 |                 ]
76 |             )
77 |         )
78 |         if i == 0:
79 |             responses = batch_responses
80 |         else:
81 |             responses += batch_responses
82 |     return responses
83 | 
84 | 
85 | DEFAULT_GEN_KWARGS = {
86 |     "max_tokens": 150,
87 |     "n": 1,
88 |     "stop": None,
89 |     "temperature": 0.7,
90 | }
```

## File: textarena/__init__.py

- Extension: .py
- Language: python
- Size: 1383 bytes
- Created: 2024-12-12 14:16:32
- Modified: 2024-12-12 14:16:32

### Code

```python
 1 | 
 2 | 
 3 | from textarena.core import (
 4 |     Env,
 5 |     Wrapper,
 6 |     ObservationWrapper,
 7 |     RenderWrapper,
 8 |     ActionWrapper,
 9 |     Agent,
10 |     AgentWrapper,
11 |     State,
12 |     Message,
13 |     Observations,
14 |     Rewards,
15 |     Info,
16 |     GAME_ID,
17 |     GameMaker,
18 |     JudgeVote,
19 |     GameMasterAction
20 | )
21 | from textarena.envs.registration import (
22 |     make,
23 |     register,
24 |     pprint_registry,
25 |     pprint_registry_detailed,
26 |     find_highest_version,
27 |     check_env_exists,
28 | )
29 | 
30 | from textarena.api import (
31 |     register_online_model,
32 |     make_online,
33 | )
34 | 
35 | from textarena.wrappers import (
36 |     BrowserRenderWrapper,
37 |     LLMObservationWrapper,
38 |     ClipWordsActionWrapper
39 | )
40 | from textarena.wrappers.agent_wrappers import (
41 |     ThoughtAgentWrapper,
42 |     InterpreterAgentWrapper,
43 |     ChainAgentWrapper,
44 |     ActorCriticAgentWrapper
45 | )
46 | 
47 | from textarena import wrappers
48 | from textarena.basic_agents import (
49 |     HumanAgent,
50 |     OpenRouterAgent,
51 |     HFLocalAgent,
52 |     CerebrasAgent
53 | ) 
54 | 
55 | 
56 | __all__ = [
57 |     
58 |     "Env",
59 |     "Wrapper",
60 |     "ObservationWrapper",
61 |     "RenderWrapper",
62 |     "ActionWrapper",
63 |     "AgentWrapper",
64 |     
65 |     "make",
66 |     "register",
67 |     "pprint_registry",
68 |     "pprint_registry_detailed",
69 |     "find_highest_version",
70 |     "check_env_exists",
71 |     
72 |     "envs",
73 |     "utils",
74 |     "wrappers",
75 |     
76 |     "make_online",
77 | ]
78 | __version__ = "1.0.0"
```

## File: textarena/game_makers/gpt_judges.py

- Extension: .py
- Language: python
- Size: 11094 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from textarena import GameMaker, JudgeVote, GameMasterAction
  2 | from typing import Optional, List, Dict
  3 | import numpy as np
  4 | import openai
  5 | import random
  6 | import os
  7 | 
  8 | 
  9 | class GPTGamemaster(GameMaker):
 10 |     
 11 | 
 12 |     def __init__(
 13 |         self, 
 14 |         model_name: str,
 15 |         temperature: float = 0.7,
 16 |         max_tokens: int = 10,
 17 |     ):
 18 |         
 19 |         self.model_name = model_name
 20 |         self.temperature = temperature
 21 |         self.max_tokens = max_tokens
 22 | 
 23 |         self.client = openai.OpenAI(base_url="https://openrouter.ai/api/v1", api_key=os.getenv("OPENROUTER_API_KEY"))
 24 | 
 25 |     def __call__(self, text_input: str) -> str:
 26 |         
 27 |         try:
 28 |             response = self.client.chat.completions.create(
 29 |                 model=self.model_name,
 30 |                 messages=[{"role": "user", "content": text_input}],
 31 |                 max_tokens=self.max_tokens,
 32 |                 temperature=self.temperature,
 33 |                 n=1
 34 |             )
 35 |             gamemaster_response = response.choices[0].message.content.strip()
 36 |             return gamemaster_response
 37 |             
 38 |         except Exception as e:
 39 |             return f"Error: {str(e)}"
 40 |         
 41 | 
 42 | class GPTJudge(GameMaker):
 43 |     
 44 | 
 45 |     def __init__(
 46 |         self, 
 47 |         model_name: str,
 48 |         temperature: float = 0.7,
 49 |     ):
 50 |         
 51 |         self.model_name = model_name
 52 |         self.temperature = temperature
 53 | 
 54 |     def __call__(self, text_input: str) -> str:
 55 |         
 56 |         try:
 57 |             response = openai.ChatCompletion.create(
 58 |                 model=self.model_name,
 59 |                 messages=[{"role": "user", "content": text_input}],
 60 |                 max_tokens=10,  
 61 |                 temperature=self.temperature,
 62 |                 n=1,
 63 |                 stop=None
 64 |             )
 65 |             
 66 |             judge_decision = response.choices[0].message['content'].strip()
 67 |             return judge_decision
 68 |         except Exception as e:
 69 |             
 70 |             return f"Error: {str(e)}"
 71 |         
 72 | 
 73 | class GPTGamemasterAction(GameMasterAction):
 74 |     
 75 | 
 76 |     def __init__(
 77 |         self,
 78 |         options: List[str],
 79 |         model_name: str = "gpt-4-mini",
 80 |         temperature: float = 0.7,
 81 |         max_tokens: int = 10,
 82 |     ):
 83 |         
 84 |         self.gamemaster = GPTGamemaster(
 85 |             model_name=model_name,
 86 |             temperature=temperature,
 87 |             max_tokens=max_tokens
 88 |         )
 89 |         self.options = options
 90 |         self.context_history = []  
 91 | 
 92 |     def set_initial_context(self, initial_context: str):
 93 |         
 94 |         self.initial_context = initial_context
 95 | 
 96 |     def _create_gamemaster_prompt(self, context: str) -> str:
 97 |         
 98 |         options_formatted = ", ".join([f"'{option}'" for option in self.options])
 99 |         history = "\n".join([f"Q: {q}\nA: {a}" for q, a in self.context_history])
100 |         prompt = (
101 |             f"{self.initial_context}\n"
102 |             f"{history}\n\n"
103 |             f"Q: {context}\n"
104 |             f"Options: {options_formatted}\n\n"
105 |             "Please respond with the most appropriate option."
106 |         )
107 |         return prompt
108 | 
109 |     def respond_to_action(self, context: str) -> str:
110 |         
111 |         prompt = self._create_gamemaster_prompt(context)
112 |         response = self.gamemaster(text_input=prompt)
113 | 
114 |         
115 |         if any(option.casefold() in response.lower() for option in self.options):
116 |             self.context_history.append((context, response))  
117 |         else:
118 |             
119 |             response = "I'm sorry, I don't understand. Please try asking again."
120 |             self.context_history.append((context, response))  
121 |         
122 |         return response
123 |         
124 | 
125 |     def get_summary(self) -> str:
126 |         
127 |         summary = "\n".join([f"Q: {q} -> A: {a}" for q, a in self.context_history])
128 |         return f"Game History:\n{summary}"
129 | 
130 | 
131 | class GPTJudgeVote(JudgeVote):
132 |     
133 | 
134 |     def __init__(
135 |         self,
136 |         options: List[str],
137 |         num_judges: int = 5,
138 |         model_names: Optional[List[str]] = None,
139 |         temperature: float = 0.7,
140 |     ):
141 |         
142 |         if model_names is None:
143 |             self.available_models = [
144 |                 "gpt-4",
145 |                 "gpt-3.5-turbo",
146 |                 "gpt-4-mini",
147 |             ]
148 |         else:
149 |             self.available_models = model_names
150 | 
151 |         self.judges = []
152 |         for _ in range(num_judges):
153 |             
154 |             model_name = random.choice(self.available_models)
155 |             judge = GPTJudge(
156 |                 model_name=model_name,
157 |                 temperature=temperature
158 |             )
159 |             self.judges.append(judge)
160 | 
161 |         self.options = options
162 | 
163 |     def _create_judge_prompt(self, context: str) -> str:
164 |         
165 |         options_formatted = ", ".join([f"'{option}'" for option in self.options])
166 |         prompt = (
167 |             f"Based on the following context, please choose the most appropriate option from the provided choices.\n\n"
168 |             f"Context: {context}\n\n"
169 |             f"Options: {options_formatted}\n\n"
170 |             f"Please respond with only the chosen option."
171 |         )
172 |         return prompt
173 | 
174 |     def evaluate(self, context: str) -> Dict[str, int]:
175 |         
176 |         result_dict = {option: 0 for option in self.options}
177 |         num_casted_votes = 0
178 | 
179 |         judge_prompt = self._create_judge_prompt(context)
180 | 
181 |         for judge in self.judges:
182 |             
183 |             judgement = judge(text_input=judge_prompt)
184 | 
185 |             
186 |             chosen_option = None
187 |             for option in self.options:
188 |                 if option.lower() in judgement.lower():
189 |                     chosen_option = option
190 |                     break
191 | 
192 |             if chosen_option:
193 |                 result_dict[chosen_option] += 1
194 |                 num_casted_votes += 1
195 |             else:
196 |                 
197 |                 
198 |                 continue
199 | 
200 |         
201 |         if num_casted_votes > 0:
202 |             for key in result_dict.keys():
203 |                 result_dict[key] /= num_casted_votes
204 |         else:
205 |             
206 |             pass
207 | 
208 |         return result_dict
```

## File: textarena/game_makers/__init__.py

- Extension: .py
- Language: python
- Size: 78 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
1 | from textarena.game_makers.gpt_judges import GPTJudgeVote, GPTGamemasterAction
```

## File: textarena/assets/textarena-icon.xbm

- Extension: .xbm
- Language: unknown
- Size: 1008 bytes
- Created: 2024-11-17 13:43:36
- Modified: 2024-11-17 13:43:24

### Code

```unknown
 1 | #define 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_width 32
 2 | #define 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_height 32
 3 | static char 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_bits[] = {
 4 |   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 5 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
 6 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
 7 |   0x00, 0x80, 0x01, 0x00, 0x00, 0xD0, 0x0B, 0x00, 0x00, 0x80, 0x01, 0x00, 
 8 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 
 9 |   0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x87, 0xE3, 0x00, 
10 |   0x00, 0x9F, 0xFF, 0x00, 0x80, 0xBF, 0xFF, 0x01, 0x80, 0xFF, 0xFF, 0x01, 
11 |   0xC0, 0xE1, 0x87, 0x03, 0x00, 0x80, 0x01, 0x00, 0x00, 0xC0, 0x03, 0x00, 
12 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
13 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
14 |   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
```

## File: textarena/static/app.js

- Extension: .js
- Language: javascript
- Size: 8413 bytes
- Created: 2024-12-13 11:40:07
- Modified: 2024-12-13 11:40:07

### Code

```javascript
  1 | 
  2 |         
  3 |         function Header() {
  4 |             return (
  5 |                 <header className="main-header">
  6 |                     <h1 className="title">TextArena</h1>
  7 |                     <a href="https://github.com/LeonGuertler/TextArena" 
  8 |                     className="github-link" 
  9 |                     target="_blank" 
 10 |                     rel="noopener noreferrer">
 11 |                         https:
 12 |                     </a>
 13 |                 </header>
 14 |             );
 15 |         }
 16 | 
 17 |         function EndGameOverlay({ endGameState, onClose }) {
 18 |             return (
 19 |                 <div className="end-game-overlay" onClick={(e) => {
 20 |                     if (e.target.className === 'end-game-overlay') {
 21 |                         onClose();
 22 |                     }
 23 |                 }}>
 24 |                     <div className="end-game-content">
 25 |                         <button className="close-button" onClick={onClose}>×</button>
 26 |                         <h1>Game Over</h1>
 27 |                         <p className="winner-text">{endGameState.winner_text}</p>
 28 |                         <p className="reason-text">{endGameState.reason}</p>
 29 |                     </div>
 30 |                 </div>
 31 |             );
 32 |         }
 33 | 
 34 |         
 35 |         function BaseGameContainer({ children, gameState }) {
 36 |             const [showEndGame, setShowEndGame] = React.useState(true);
 37 |             
 38 |             React.useEffect(() => {
 39 |                 if (gameState.end_game_state) {
 40 |                     setShowEndGame(true);
 41 |                 }
 42 |             }, [gameState.end_game_state]);
 43 | 
 44 |             return (
 45 |                 <div className="page-container">
 46 |                     <Header />
 47 |                     <main className="game-container">
 48 |                         {children}
 49 |                         {gameState.end_game_state && showEndGame && 
 50 |                             <EndGameOverlay 
 51 |                                 endGameState={gameState.end_game_state} 
 52 |                                 onClose={() => setShowEndGame(false)}
 53 |                             />
 54 |                         }
 55 |                     </main>
 56 |                 </div>
 57 |             );
 58 |         }
 59 |         
 60 | 
 61 |         function ChessGame() {
 62 |             const [gameState, setGameState] = React.useState(null);
 63 |             
 64 |             React.useEffect(() => {
 65 |                 const ws = new WebSocket(`ws:
 66 |                 ws.onmessage = (event) => {
 67 |                     const state = JSON.parse(event.data);
 68 |                     setGameState(state);
 69 |                 };
 70 |                 return () => ws.close();
 71 |             }, []);
 72 | 
 73 |             if (!gameState) return <div>Loading...</div>;
 74 | 
 75 |             return (
 76 |                 <BaseGameContainer gameState={gameState}>
 77 |                     <div className="chess-layout">
 78 |                         <div className="main-content">
 79 |                             <ChessBoard fen={gameState.fen} />
 80 |                             <GameInfo gameState={gameState} />
 81 |                         </div>
 82 |                         <ChatHistory gameState={gameState} />
 83 |                     </div>
 84 |                 </BaseGameContainer>
 85 |             );
 86 |         }
 87 | 
 88 |         function ChessBoard({ fen }) {
 89 |             const renderSquare = (i) => {
 90 |                 const file = i % 8;
 91 |                 const rank = Math.floor(i / 8);
 92 |                 const isLight = (file + rank) % 2 === 0;
 93 |                 
 94 |                 return (
 95 |                     <div key={i} className={`square ${isLight ? 'light' : 'dark'}`}>
 96 |                         {getPiece(fen, i)}
 97 |                     </div>
 98 |                 );
 99 |             };
100 | 
101 |             return (
102 |                 <div className="board-container">
103 |                     <div className="chess-board">
104 |                         {[...Array(64)].map((_, i) => renderSquare(i))}
105 |                     </div>
106 |                 </div>
107 |             );
108 |         }
109 | 
110 |         function getPiece(fen, squareIndex) {
111 |             const [position] = fen.split(' ');
112 |             const rows = position.split('/');
113 |             const rank = Math.floor(squareIndex / 8);
114 |             const file = squareIndex % 8;
115 |             
116 |             let currentFile = 0;
117 |             const row = rows[7 - rank];
118 |             
119 |             for (let i = 0; i < row.length; i++) {
120 |                 const char = row[i];
121 |                 if (isNaN(char)) {
122 |                     if (currentFile === file) {
123 |                         return (
124 |                             <img 
125 |                                 src={`/static/pieces/${char}.png`}
126 |                                 alt={char}
127 |                                 className="piece-img"
128 |                             />
129 |                         );
130 |                     }
131 |                     currentFile++;
132 |                 } else {
133 |                     currentFile += parseInt(char);
134 |                 }
135 |                 if (currentFile > file) break;
136 |             }
137 |             return null;
138 |         }
139 | 
140 |         function GameInfo({ gameState }) {
141 |         const moveHistoryRef = React.useRef(null);
142 |         
143 |         React.useEffect(() => {
144 |             if (moveHistoryRef.current) {
145 |                 moveHistoryRef.current.scrollTop = moveHistoryRef.current.scrollHeight;
146 |             }
147 |         }, [gameState.move_stack]);
148 | 
149 |         
150 |         const moveGroups = [];
151 |         for (let i = 0; i < gameState.move_stack.length; i += 2) {
152 |             moveGroups.push({
153 |                 number: Math.floor(i/2) + 1,
154 |                 white: gameState.move_stack[i],
155 |                 black: gameState.move_stack[i + 1]
156 |             });
157 |         }
158 | 
159 |         return (
160 |             <div className="info-container">
161 |                 <h2>Game Status</h2>
162 |                 <div className="status">
163 |                     <div>Current Turn: {gameState.current_player}</div>
164 |                     {gameState.is_check && <div className="alert">Check!</div>}
165 |                     {gameState.is_checkmate && <div className="alert">Checkmate!</div>}
166 |                     {gameState.is_stalemate && <div className="alert">Stalemate</div>}
167 |                 </div>
168 |                 
169 |                 <h3>Players</h3>
170 |                 <div className="players">
171 |                     {Object.entries(gameState.player_names).map(([id, name]) => (
172 |                         <div key={id} className={id === '0' ? 'white-player' : 'black-player'}>
173 |                             {name} ({id === '0' ? 'White' : 'Black'})
174 |                         </div>
175 |                     ))}
176 |                 </div>
177 |                 
178 |                 <h3>Move History</h3>
179 |                 <div className="move-history" ref={moveHistoryRef}>
180 |                     {moveGroups.map((group, i) => (
181 |                         <div key={i} className="move-pair">
182 |                             <span className="move-number">{group.number}.</span>
183 |                             <span className="move white">{group.white}</span>
184 |                             {group.black && <span className="move black">{group.black}</span>}
185 |                         </div>
186 |                     ))}
187 |                 </div>
188 |             </div>
189 |         );
190 |     }
191 | 
192 |         function ChatHistory({ gameState }) {
193 |             const messagesEndRef = React.useRef(null);
194 |             
195 |             React.useEffect(() => {
196 |                 if (messagesEndRef.current) {
197 |                     messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
198 |                 }
199 |             }, [gameState.chat_history]);
200 | 
201 |             return (
202 |                 <div className="chat-container">
203 |                     <h2>Game Chat</h2>
204 |                     <div className="chat-messages">
205 |                         {gameState.chat_history.map((msg, i) => (
206 |                             <div key={i} className={`chat-message ${msg.player_id === 0 ? 'white' : 'black'}`}>
207 |                                 <div className="player-name">
208 |                                     {gameState.player_names[msg.player_id]}:
209 |                                 </div>
210 |                                 <div>{msg.message}</div>
211 |                             </div>
212 |                         ))}
213 |                         <div ref={messagesEndRef} />
214 |                     </div>
215 |                 </div>
216 |             );
217 |         }
218 | 
219 |         
220 |         const root = ReactDOM.createRoot(document.getElementById('root'));
221 |         root.render(<ChessGame />);
222 |         
```

## File: textarena/static/style.css

- Extension: .css
- Language: unknown
- Size: 6034 bytes
- Created: 2024-12-13 11:40:07
- Modified: 2024-12-13 11:40:07

### Code

```unknown
  1 | 
  2 |             body {
  3 |             background-color: #2B2B2B;
  4 |             color: #FFFFFF;
  5 |             font-family: Arial, sans-serif;
  6 |             margin: 0;
  7 |             padding: 20px;
  8 |         }
  9 | 
 10 |         .page-container {
 11 |             max-width: 1200px;
 12 |             margin: 0 auto;
 13 |         }
 14 | 
 15 |         .main-header {
 16 |             text-align: center;
 17 |             margin-bottom: 30px;
 18 |         }
 19 | 
 20 |         .title {
 21 |             font-size: 48px;
 22 |             font-weight: bold;
 23 |             color: #ffffff;
 24 |             margin: 0;
 25 |             padding: 20px 0 10px 0;
 26 |             letter-spacing: 2px;
 27 |             text-transform: uppercase;
 28 |             background: linear-gradient(45deg, #4CAF50, #2196F3);
 29 |             -webkit-background-clip: text;
 30 |             -webkit-text-fill-color: transparent;
 31 |             background-clip: text;
 32 |             text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
 33 |         }
 34 | 
 35 |         .github-link {
 36 |             display: inline-block;
 37 |             color: #9e9e9e;
 38 |             text-decoration: none;
 39 |             font-size: 16px;
 40 |             margin-top: 5px;
 41 |             padding: 5px 10px;
 42 |             border-radius: 4px;
 43 |             transition: all 0.2s ease;
 44 |         }
 45 | 
 46 |         .github-link:hover {
 47 |             color: #ffffff;
 48 |             background: rgba(255, 255, 255, 0.1);
 49 |         }
 50 | 
 51 |         .game-container {
 52 |             width: 100%;
 53 |         }
 54 | 
 55 |         .end-game-overlay {
 56 |             position: fixed;
 57 |             top: 0;
 58 |             left: 0;
 59 |             right: 0;
 60 |             bottom: 0;
 61 |             background: rgba(0, 0, 0, 0.8);
 62 |             display: flex;
 63 |             justify-content: center;
 64 |             align-items: center;
 65 |             z-index: 1000;
 66 |         }
 67 | 
 68 |         .end-game-content {
 69 |             background: #363636;
 70 |             padding: 40px;
 71 |             border-radius: 8px;
 72 |             text-align: center;
 73 |             max-width: 80%;
 74 |             position: relative;
 75 |         }
 76 | 
 77 |         .close-button {
 78 |             position: absolute;
 79 |             top: 10px;
 80 |             right: 10px;
 81 |             background: none;
 82 |             border: none;
 83 |             color: #ffffff;
 84 |             font-size: 24px;
 85 |             cursor: pointer;
 86 |             padding: 5px 10px;
 87 |             border-radius: 4px;
 88 |             line-height: 1;
 89 |         }
 90 | 
 91 |         .close-button:hover {
 92 |             background: rgba(255, 255, 255, 0.1);
 93 |         }
 94 | 
 95 |         .end-game-content h1 {
 96 |             font-size: 36px;
 97 |             margin-bottom: 20px;
 98 |         }
 99 | 
100 |         .winner-text {
101 |             font-size: 28px;
102 |             margin-bottom: 15px;
103 |             color: #4CAF50;
104 |         }
105 | 
106 |         .reason-text {
107 |             font-size: 24px;
108 |         }
109 | 
110 |         .chat-container {
111 |             margin-top: 20px;
112 |             background: #363636;
113 |             padding: 20px;
114 |             border-radius: 8px;
115 |         }
116 | 
117 |         .chat-messages {
118 |             height: 300px;
119 |             overflow-y: auto;
120 |             background: #2B2B2B;
121 |             padding: 15px;
122 |             border-radius: 4px;
123 |         }
124 |         
125 | 
126 |         .game-header {
127 |             text-align: center;
128 |             margin-bottom: 20px;
129 |         }
130 | 
131 |         .game-title {
132 |             font-size: 32px;
133 |             font-weight: bold;
134 |             color: #ffffff;
135 |             margin: 0;
136 |             padding: 10px 0;
137 |             letter-spacing: 1.5px;
138 |             text-transform: uppercase;
139 |             background: linear-gradient(45deg, #4CAF50, #2196F3);
140 |             -webkit-background-clip: text;
141 |             -webkit-text-fill-color: transparent;
142 |             background-clip: text;
143 |             text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
144 |         }
145 | 
146 |         .main-content {
147 |             display: flex;
148 |             gap: 20px;
149 |             margin-bottom: 20px;
150 |         }
151 | 
152 |         .board-container {
153 |             flex: 0 0 600px;
154 |             background: #363636;
155 |             padding: 20px;
156 |             border-radius: 8px;
157 |         }
158 | 
159 |         .chess-board {
160 |             display: grid;
161 |             grid-template-columns: repeat(8, 1fr);
162 |             width: 600px;
163 |             height: 600px;
164 |             border: 2px solid #404040;
165 |         }
166 | 
167 |         .square {
168 |             width: 75px;
169 |             height: 75px;
170 |             display: flex;
171 |             justify-content: center;
172 |             align-items: center;
173 |         }
174 | 
175 |         .square.light { background-color: #EEEED2; }
176 |         .square.dark { background-color: #769656; }
177 | 
178 |         .piece-img {
179 |             width: 60px;
180 |             height: 60px;
181 |             user-select: none;
182 |         }
183 | 
184 |         .info-container {
185 |             flex: 1;
186 |             background: #363636;
187 |             padding: 20px;
188 |             border-radius: 8px;
189 |         }
190 | 
191 |         .status { margin-bottom: 20px; }
192 |         .alert { color: #ff4444; font-weight: bold; }
193 |         
194 |         .players {
195 |             margin-bottom: 20px;
196 |         }
197 | 
198 |         .white-player { color: #ffffff; }
199 |         .black-player { color: #a0a0a0; }
200 | 
201 |         .move-history {
202 |             font-family: monospace;
203 |             margin-top: 10px;
204 |             background: #2B2B2B;
205 |             padding: 12px;
206 |             border-radius: 4px;
207 |             max-height: 200px;
208 |             overflow-y: auto;
209 |         }
210 | 
211 |         .move {
212 |             display: inline-block;
213 |             margin: 2px 0;
214 |             padding: 2px 6px;
215 |             border-radius: 3px;
216 |         }
217 | 
218 |         .move.white {
219 |             color: #ffffff;
220 |             background: #404040;
221 |         }
222 | 
223 |         .move.black {
224 |             color: #a0a0a0;
225 |             background: #333333;
226 |         }
227 | 
228 |         .move-number {
229 |             color: #666666;
230 |             margin-right: 4px;
231 |         }
232 | 
233 |         .move-pair {
234 |             display: block;
235 |             margin-bottom: 4px;
236 |         }
237 | 
238 |         .chat-message {
239 |             margin-bottom: 10px;
240 |             padding: 8px;
241 |             border-radius: 4px;
242 |             background: #404040;
243 |         }
244 | 
245 |         .chat-message .player-name {
246 |             font-weight: bold;
247 |             margin-bottom: 5px;
248 |         }
249 | 
250 |         .chat-message.white .player-name { color: #ffffff; }
251 |         .chat-message.black .player-name { color: #a0a0a0; }
252 |         
```

## File: textarena/static/textarena-icon.xbm

- Extension: .xbm
- Language: unknown
- Size: 1008 bytes
- Created: 2024-12-13 11:37:57
- Modified: 2024-11-17 13:43:24

### Code

```unknown
 1 | #define 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_width 32
 2 | #define 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_height 32
 3 | static char 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_bits[] = {
 4 |   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 5 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
 6 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
 7 |   0x00, 0x80, 0x01, 0x00, 0x00, 0xD0, 0x0B, 0x00, 0x00, 0x80, 0x01, 0x00, 
 8 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 
 9 |   0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x87, 0xE3, 0x00, 
10 |   0x00, 0x9F, 0xFF, 0x00, 0x80, 0xBF, 0xFF, 0x01, 0x80, 0xFF, 0xFF, 0x01, 
11 |   0xC0, 0xE1, 0x87, 0x03, 0x00, 0x80, 0x01, 0x00, 0x00, 0xC0, 0x03, 0x00, 
12 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
13 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
14 |   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
```

## File: textarena/wrappers/index.html

- Extension: .html
- Language: html
- Size: 651 bytes
- Created: 2024-12-12 15:29:11
- Modified: 2024-12-12 14:02:36

### Code

```html
 1 | <!DOCTYPE html>
 2 | <html>
 3 | <head>
 4 |     <title>Chess Game</title>
 5 |     <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
 6 |     <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
 7 |     <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
 8 |     <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
 9 |     <link rel="stylesheet" href="static/styles.css">
10 | </head>
11 | <body>
12 |     <div id="root"></div>
13 |     <script type="text/babel" src="static/app.js"></script>
14 | </body>
15 | </html>
```

## File: textarena/wrappers/agent_wrappers.py

- Extension: .py
- Language: python
- Size: 10557 bytes
- Created: 2024-11-20 11:18:38
- Modified: 2024-11-20 11:18:38

### Code

```python
  1 | import re 
  2 | 
  3 | from typing import Optional, Any, List, Tuple 
  4 | from e2b_code_interpreter import Sandbox, Logs
  5 | 
  6 | import textarena as ta 
  7 | 
  8 | 
  9 | __all__ = [
 10 |     "ThoughtAgentWrapper",
 11 |     "InterpreterAgentWrapper",
 12 |     "ChainAgentWrapper"
 13 | ]
 14 | 
 15 | class ThoughtAgentWrapper(ta.AgentWrapper):
 16 |     
 17 | 
 18 |     def __init__(
 19 |         self, 
 20 |         agent: ta.Agent,
 21 |         system_prompt: Optional[str] = None,
 22 |         debugging: bool = False 
 23 |         ):
 24 |         
 25 |         super().__init__(agent)
 26 |         if system_prompt is None:
 27 |             system_prompt = (
 28 |             "\nWhen responding, first think extensively within a <thought/> tag to plan out your actions. "
 29 |             "Everything written in <thought> tags will be hidden from other players. "
 30 |             "Everything written outside of <thought> tags will be submitted to the game and displayed to the other player."
 31 |         )
 32 |         
 33 |         self.agent.system_prompt = system_prompt
 34 |         self.thought_blocks: List[List[str]] = []
 35 | 
 36 |         self.debugging = debugging
 37 | 
 38 |     def __call__(self, observation: str) -> str:
 39 |         out_text = self.agent(observation)
 40 | 
 41 |         if self.debugging:
 42 |             print("REASON", out_text)
 43 | 
 44 |         thought_blocks = re.findall(
 45 |             r"<thought>(.*?)</thought>", out_text, flags=re.DOTALL
 46 |         )
 47 |         self.thought_blocks.append(thought_blocks)
 48 | 
 49 |         
 50 |         out_text = re.sub(r"<thought>.*?</thought>", "", out_text, flags=re.DOTALL)
 51 |         out_text = out_text.strip().replace("\n\n", "")
 52 |         assert "<thought>" not in out_text, f"Thought tags still present: {out_text}"
 53 | 
 54 |         return out_text
 55 | 
 56 | 
 57 | class ActorCriticAgentWrapper(ta.AgentWrapper):
 58 |     
 59 |     def __init__(
 60 |         self,
 61 |         agent: ta.Agent,
 62 |         actor_system_prompt: Optional[str] = None,
 63 |         critic_system_prompt: Optional[str] = None,
 64 |         final_reply_system_prompt: Optional[str] = None,
 65 |         debugging: bool = False
 66 |     ):
 67 |         
 68 |         super().__init__(agent)
 69 | 
 70 |         
 71 |         self.actor_system_prompt = (
 72 |             actor_system_prompt or 
 73 |                 "You are an expert player in a competitive game environment. Your goal is to play optimally, "
 74 |                 "adhering strictly to the game's rules and format requirements.\n\n"
 75 |                 "Evaluate the current game state carefully and decide your next move strategically. "
 76 |                 "Always ensure your response is:\n"
 77 |                 "1. In the correct format as specified by the game rules.\n"
 78 |                 "2. Focused on maximizing your chances of winning while minimizing risks.\n\n"
 79 |                 "Respond only with your chosen move in the required format."
 80 |             )
 81 |         self.critic_system_prompt = (
 82 |             critic_system_prompt or
 83 |                 "You are a critical observer and rule enforcer for a competitive game. Your task is to:\n"
 84 |                 "1. Review the provided action to ensure it complies with the game's rules and format requirements.\n"
 85 |                 "2. Critique the action for strategic effectiveness, identifying any potential improvements. "
 86 |                 "[esp. pointing out if this action will give the opponent a chance to win in the next move]\n"
 87 |                 "3. Highlight specific reasons if the action is invalid or suboptimal.\n\n"
 88 |                 "Provide your analysis clearly and concisely. Never trading is not a good strategy! Accept trades that seem good!"
 89 |             )
 90 |         self.final_reply_system_prompt = (
 91 |             final_reply_system_prompt or
 92 |                 "You are an expert game strategist tasked with synthesizing a final move. Based on the initial action and the critique, "
 93 |                 "generate a revised action that:\n"
 94 |                 "1. Adheres strictly to the game's rules and format.\n"
 95 |                 "2. Incorporates the improvements or corrections suggested in the critique.\n"
 96 |                 "3. Optimizes strategic effectiveness to maximize the chances of success.\n\n"
 97 |                 "Respond only with the final corrected action in the required format. Try not to make new offers every single move."
 98 |             )
 99 | 
100 |         self.debugging = debugging
101 | 
102 |     def __call__(self, observation: str) -> str:
103 |         
104 | 
105 |         
106 |         self.agent.system_prompt = self.actor_system_prompt
107 | 
108 |         
109 |         initial_out = self.agent(observation)
110 |         if self.debugging:
111 |             print(f"Initial Agent output: {initial_out}")
112 | 
113 |         
114 |         self.agent.system_prompt = self.critic_system_prompt
115 | 
116 |         
117 |         second_out = self.agent(f"Observation: {observation}. \nCurrent Strategy: {initial_out}")
118 |         if self.debugging:
119 |             print(f"Critic Agent output: {second_out}")
120 | 
121 |         
122 |         self.agent.system_prompt = self.final_reply_system_prompt
123 | 
124 |         
125 |         final_out = self.agent(
126 |             f"Observation: {observation}. \nInitial Strategy: {initial_out}. \nCriticism: {second_out} "
127 |         )
128 |         if self.debugging:
129 |             print(f"Final Agent output: {final_out}\n\n")
130 | 
131 | 
132 |         return final_out 
133 |            
134 | 
135 | 
136 | 
137 | class InterpreterAgentWrapper(ta.AgentWrapper):
138 |     
139 |     def __init__(
140 |         self, 
141 |         agent: ta.Agent,
142 |         code_instruction_prompt: Optional[str] = None,
143 |         first_code_prompt: Optional[str] = None,
144 |         cont_code_prompt: Optional[str] = None,
145 |         prompt_max_chars: Optional[int] = 1024*10,
146 |         out_max_chars: Optional[int] = 1024*4,
147 |         debugging: Optional[bool] = False
148 |     ):
149 |         super().__init__(agent)
150 |         self.sbx = Sandbox()
151 | 
152 |         
153 |         if code_instruction_prompt is None:
154 |             code_instruction_prompt = (
155 |                 "You are a competitive game player. "
156 |                 "Your goal is plan and compute the right information "
157 |                 "to help with decision making for the following game. "
158 |                 "You have access a code interpreter via ```python and ending with ```.\n"
159 |             )
160 | 
161 |         if first_code_prompt is None:
162 |             first_code_prompt = (
163 |                 "You will write a set of concise, modular and reusable functions to assist with the game decision making. "
164 |                 "Your code should be setup so you can easily update variables when you encounter future game states, allowing "
165 |                 "changes in game states to be updated in a few lines. Don't print out the entire game state. "
166 |                 "You will only be able to view the stdout/stderr of the interpreter logs to make your decision, "
167 |                 "so clearly print any labeled information and the best decision in the required format."
168 |             )
169 | 
170 |         if cont_code_prompt is None:
171 |             cont_code_prompt = (
172 |                 "Reference variables and reuse functions previously executed in the interpreter. Be concise and don't repeat "
173 |                 "previously defined code. Update only game states that have changed. Don't print out the entire game state. "
174 |                 "You will only be able to view the stdout/stderr of the interpreter logs to make your decision, so clearly "
175 |                 "print any labeled information and the best decision in the required format."
176 |             )
177 | 
178 | 
179 | 
180 |         
181 |         self.init_prompt = code_instruction_prompt + first_code_prompt
182 |         self.continue_prompt = code_instruction_prompt + cont_code_prompt
183 | 
184 |         
185 |         self.executed_code: List[Tuple[str, Logs]] = []
186 | 
187 |         self.prompt_max_chars = prompt_max_chars
188 |         self.out_max_chars = out_max_chars
189 | 
190 |         self.debugging = debugging
191 | 
192 |     def prompt_log(self, log: Logs) -> str:
193 |         stdout = "".join(log.stdout).strip()
194 |         stderr = "".join(log.stderr).strip()
195 |         text = ""
196 |         if stdout:
197 |             text += f"<stdout>\n{stdout}\n</stdout>"
198 |         if stderr:
199 |             text += f"<stderr>\n{stderr}\n</stderr>"
200 |         return text
201 | 
202 |     def prompt_executed_code(self, executed_code: List[Tuple[str, Any]]) -> str:
203 |         text = ""
204 |         for code_block, logs in executed_code:
205 |             text += f"```python\n{code_block}\n```\n"
206 |             text += self.prompt_log(logs)
207 |         return text
208 | 
209 |     def __call__(self, observation: str) -> str:
210 |         self.agent.system_prompt = (
211 |             self.init_prompt if len(self.executed_code) == 0 else self.continue_prompt
212 |         )
213 | 
214 |         
215 |         executed_code = "\n".join(code_block for code_block, _ in self.executed_code)[
216 |             -self.prompt_max_chars :
217 |         ]
218 | 
219 |         if self.debugging:
220 |             print(executed_code)
221 | 
222 |         observation += (
223 |             "---\n"
224 |             "Previously executed code in interpreter:\n"
225 |             "```python\n"
226 |             f"{executed_code}\n"
227 |             "```\n\n"
228 |             "Your code:\n"
229 |         ) if len(self.executed_code) == 0 else "\nYour code:"
230 |         
231 | 
232 |         out_text = self.agent(observation)
233 |         code_blocks = re.findall(r"```python(.*?)```", out_text, flags=re.DOTALL)
234 |         for code_block in code_blocks:
235 |             try:
236 |                 execution = self.sbx.run_code(code_block, timeout=3)
237 |             except Exception as e:
238 |                 print(f"Error executing code: {code_block}\n{e}")
239 |                 break
240 |             self.executed_code.append((code_block, execution.logs))
241 | 
242 |         return "\n".join(self.prompt_log(logs) for _, logs in self.executed_code)[
243 |             -self.out_max_chars :
244 |         ]
245 | 
246 |        
247 | 
248 | class ChainAgentWrapper(ta.Agent):
249 |     
250 |     def __init__(self, agents: List[ta.Agent], delimiter: str = "\n"):
251 |         super().__init__()
252 |         self.agents = agents
253 |         self.delimiter = delimiter
254 | 
255 |     def __call__(self, observation: str) -> str:
256 |         current_observation: str = f"Observation: {observation}\n"
257 |         for i, agent in enumerate(self.agents):
258 |             if i == len(self.agents)-1:
259 |                 out_text = agent(current_observation+"\nFinal Output: ")
260 |             else:
261 |                 out_text = agent(current_observation)
262 |                 current_observation += f"Step {i+1} Output:{out_text}\n"
263 |         return out_text
```

## File: textarena/wrappers/app.js

- Extension: .js
- Language: javascript
- Size: 2749 bytes
- Created: 2024-12-12 16:16:04
- Modified: 2024-12-12 16:16:04

### Code

```javascript
 1 | import React, { useState, useEffect, useRef } from 'react';
 2 | 
 3 | 
 4 | function GameUI({ children }) {
 5 |   const [gameState, setGameState] = useState(null);
 6 |   const [connected, setConnected] = useState(false);
 7 |   const wsRef = useRef(null);
 8 | 
 9 |   useEffect(() => {
10 |     const connectWebSocket = () => {
11 |       const ws = new WebSocket(`ws:
12 |       wsRef.current = ws;
13 |       
14 |       ws.onopen = () => setConnected(true);
15 |       
16 |       ws.onmessage = (event) => {
17 |         try {
18 |           const state = JSON.parse(event.data);
19 |           setGameState(state);
20 |         } catch (e) {
21 |           console.error('Error parsing message:', e);
22 |         }
23 |       };
24 |       
25 |       ws.onclose = () => {
26 |         setConnected(false);
27 |         setTimeout(connectWebSocket, 2000);
28 |       };
29 |     };
30 |     
31 |     connectWebSocket();
32 |     return () => wsRef.current?.close();
33 |   }, []);
34 | 
35 |   if (!gameState) {
36 |     return <div className="text-white p-4">Loading game...</div>;
37 |   }
38 | 
39 |   return (
40 |     <div className="min-h-screen p-4">
41 |       {}
42 |       <div 
43 |         className={`fixed top-4 right-4 px-3 py-1 rounded text-sm ${
44 |           connected ? 'bg-green-600' : 'bg-red-600'
45 |         }`}
46 |       >
47 |         {connected ? 'Connected' : 'Reconnecting...'}
48 |       </div>
49 | 
50 |       {}
51 |       <div className="mb-8">
52 |         {React.cloneElement(children, { gameState })}
53 |       </div>
54 |       
55 |       {}
56 |       <ChatHistory 
57 |         messages={gameState.chat_history || []}
58 |         playerNames={gameState.player_names || {}}
59 |       />
60 |     </div>
61 |   );
62 | }
63 | 
64 | function ChatHistory({ messages, playerNames }) {
65 |   const messagesEndRef = useRef(null);
66 | 
67 |   useEffect(() => {
68 |     messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
69 |   }, [messages]);
70 | 
71 |   if (!messages || messages.length === 0) {
72 |     return null;
73 |   }
74 | 
75 |   const getMessageColor = (playerId) => {
76 |     if (playerId === -1) return 'text-blue-400';  
77 |     return playerId === 0 ? 'text-white' : 'text-neutral-400';  
78 |   };
79 | 
80 |   return (
81 |     <div className="bg-neutral-800 p-5 rounded-lg max-w-7xl mx-auto">
82 |       <h2 className="text-xl font-bold mb-4">Game Chat</h2>
83 |       <div className="bg-neutral-900 p-4 rounded-lg h-[300px] overflow-y-auto">
84 |         {messages.map((msg, index) => (
85 |           <div key={index} className="mb-4 p-3 bg-neutral-800 rounded">
86 |             <div className={`font-bold mb-1 ${getMessageColor(msg.player_id)}`}>
87 |               {msg.player_id === -1 ? 'Game' : playerNames[msg.player_id]}:
88 |             </div>
89 |             <div>{msg.message}</div>
90 |           </div>
91 |         ))}
92 |         <div ref={messagesEndRef} />
93 |       </div>
94 |     </div>
95 |   );
96 | }
97 | 
98 | export default GameUI;
```

## File: textarena/wrappers/style.css

- Extension: .css
- Language: unknown
- Size: 1993 bytes
- Created: 2024-12-12 15:29:11
- Modified: 2024-12-12 14:02:45

### Code

```unknown
  1 | body { 
  2 |     background-color: #2B2B2B;
  3 |     color: #FFFFFF;
  4 |     font-family: Arial, sans-serif;
  5 |     margin: 0;
  6 |     padding: 20px;
  7 | }
  8 | 
  9 | .game-container {
 10 |     display: flex;
 11 |     gap: 20px;
 12 |     max-width: 1200px;
 13 |     margin: 0 auto;
 14 | }
 15 | 
 16 | .board-container {
 17 |     flex: 0 0 600px;
 18 |     background: #363636;
 19 |     padding: 20px;
 20 |     border-radius: 8px;
 21 | }
 22 | 
 23 | .chess-board {
 24 |     display: grid;
 25 |     grid-template-columns: repeat(8, 1fr);
 26 |     width: 600px;
 27 |     height: 600px;
 28 |     border: 2px solid #404040;
 29 | }
 30 | 
 31 | .square {
 32 |     width: 75px;
 33 |     height: 75px;
 34 |     display: flex;
 35 |     justify-content: center;
 36 |     align-items: center;
 37 | }
 38 | 
 39 | .square.light {
 40 |     background-color: #EEEED2;
 41 | }
 42 | 
 43 | .square.dark {
 44 |     background-color: #769656;
 45 | }
 46 | 
 47 | .info-container {
 48 |     flex: 1;
 49 |     background: #363636;
 50 |     padding: 20px;
 51 |     border-radius: 8px;
 52 | }
 53 | 
 54 | .move-history {
 55 |     height: 300px;
 56 |     overflow-y: auto;
 57 |     background: #2B2B2B;
 58 |     padding: 10px;
 59 |     border-radius: 4px;
 60 |     margin-top: 10px;
 61 | }
 62 | 
 63 | .status {
 64 |     font-size: 1.2em;
 65 |     margin-bottom: 15px;
 66 |     padding: 10px;
 67 |     background: #2B2B2B;
 68 |     border-radius: 4px;
 69 | }
 70 | 
 71 | .chat-container {
 72 |     margin-top: 20px;
 73 |     background: #363636;
 74 |     padding: 20px;
 75 |     border-radius: 8px;
 76 |     max-width: 1200px;
 77 |     margin-left: auto;
 78 |     margin-right: auto;
 79 | }
 80 | 
 81 | .chat-messages {
 82 |     height: 300px;
 83 |     overflow-y: auto;
 84 |     background: #2B2B2B;
 85 |     padding: 15px;
 86 |     border-radius: 4px;
 87 |     margin-top: 10px;
 88 | }
 89 | 
 90 | .chat-message {
 91 |     margin-bottom: 15px;
 92 |     padding: 10px;
 93 |     border-radius: 4px;
 94 |     background: #404040;
 95 | }
 96 | 
 97 | .chat-message .player-name {
 98 |     font-weight: bold;
 99 |     margin-bottom: 5px;
100 | }
101 | 
102 | .chat-message.white .player-name {
103 |     color: #FFFFFF;
104 | }
105 | 
106 | .chat-message.black .player-name {
107 |     color: #A0A0A0;
108 | }
109 | 
110 | .connection-status {
111 |     position: fixed;
112 |     top: 10px;
113 |     right: 10px;
114 |     padding: 5px 10px;
115 |     border-radius: 4px;
116 |     font-size: 0.8em;
117 | }
118 | 
119 | .connection-status.connected {
120 |     background: #4CAF50;
121 | }
122 | 
123 | .connection-status.disconnected {
124 |     background: #F44336;
125 | }
```

## File: textarena/wrappers/render_wrappers.py

- Extension: .py
- Language: python
- Size: 8280 bytes
- Created: 2024-12-13 11:18:01
- Modified: 2024-12-13 11:18:01

### Code

```python
  1 | from selenium import webdriver
  2 | from selenium.webdriver.chrome.options import Options
  3 | from selenium.webdriver.common.by import By
  4 | from selenium.webdriver.support.ui import WebDriverWait
  5 | from selenium.webdriver.support import expected_conditions as EC
  6 | import cv2
  7 | import numpy as np
  8 | from PIL import Image
  9 | import io
 10 | import time
 11 | import os
 12 | import webbrowser
 13 | from typing import Dict, Optional, Any
 14 | 
 15 | class BrowserRenderWrapper:
 16 |     def __init__(self, env: Any, player_names: Optional[Dict[int, str]] = None, port: int = 8000, 
 17 |                  record_video: bool = False, video_path: str = "game_recording.mp4"):
 18 |         self.env = env
 19 |         self.port = port
 20 |         self.chat_history = []
 21 |         self.record_video = record_video
 22 |         self.video_path = video_path
 23 |         self.frames = []
 24 |         
 25 |         if not hasattr(self.env, 'offline_renderer'):
 26 |             raise AttributeError("Environment must have 'offline_renderer' attribute")
 27 |             
 28 |         
 29 |         self.renderer = self.env.offline_renderer(env=self.env, player_names=player_names, port=port)
 30 |         
 31 |         
 32 |         if self.record_video:
 33 |             self._setup_recorder()
 34 |         
 35 |         
 36 |         webbrowser.open(f"http://localhost:{self.port}")
 37 |         print(f"Game server started at http://localhost:{self.port}")
 38 | 
 39 | 
 40 |     def _setup_recorder(self):
 41 |         
 42 |         chrome_options = Options()
 43 |         chrome_options.add_argument("--headless")
 44 |         
 45 |         chrome_options.add_argument("--window-size=1920,2160")  
 46 |         chrome_options.add_argument("--disable-gpu")
 47 |         chrome_options.add_argument("--hide-scrollbars")
 48 |         
 49 |         self.driver = webdriver.Chrome(options=chrome_options)
 50 |         self.driver.get(f"http://localhost:{self.port}")
 51 |         
 52 |         
 53 |         WebDriverWait(self.driver, 10).until(
 54 |             EC.presence_of_element_located((By.CLASS_NAME, "game-container"))
 55 |         )
 56 |         
 57 |         
 58 |         self.driver.execute_script()
 59 |         
 60 |         time.sleep(1)  
 61 | 
 62 |     def _capture_frame(self):
 63 |         
 64 |         if not self.record_video:
 65 |             return
 66 |             
 67 |         try:
 68 |             time.sleep(0.5)  
 69 |             screenshot = self.driver.get_screenshot_as_png()
 70 |             image = Image.open(io.BytesIO(screenshot))
 71 |             frame = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)
 72 |             self.frames.append(frame)
 73 |         except Exception as e:
 74 |             print(f"Error capturing frame: {e}")
 75 | 
 76 |     def step(self, action: str):
 77 |         
 78 |         current_player = self.env.state.current_player_id
 79 |         self.chat_history.append({
 80 |             "player_id": current_player,
 81 |             "message": action,
 82 |             "timestamp": time.time()
 83 |         })
 84 |         
 85 |         reward, truncated, terminated, info = self.env.step(action)
 86 |         self.renderer.chat_history = self.chat_history
 87 |         
 88 |         
 89 |         if terminated or truncated:
 90 |             self.renderer.set_end_game_state(reward if reward else {}, info)
 91 |         
 92 |         self.renderer.draw()
 93 |         
 94 |         if self.record_video:
 95 |             time.sleep(1)
 96 |             self._capture_frame()
 97 |             
 98 |         return reward, truncated, terminated, info
 99 | 
100 |     def _add_end_game_frame(self, rewards, info):
101 |         
102 |         
103 |         
104 |         winner_text = ""
105 |         if rewards:
106 |             max_reward = max(rewards.values())
107 |             winners = [pid for pid, r in rewards.items() if r == max_reward]
108 |             if len(winners) > 1:
109 |                 winner_text = "Game ended in a draw"
110 |             else:
111 |                 winner = winners[0]
112 |                 winner_text = f"Winner: {self.renderer.player_names[winner]}"
113 |         
114 |         
115 |         reason = info.get('reason', 'Game Over') 
116 | 
117 |         
118 |         for pid, player_name in player_names.items():
119 |             reason = reason.replace(f"Player {pid}", player_name)
120 | 
121 |         print(reson)
122 |         print(player_names)
123 |         input()
124 |         
125 |         
126 |         self.driver.execute_script(, winner_text, reason)
127 |         
128 |         
129 |         time.sleep(3)  
130 |         self._capture_frame()
131 | 
132 |     def _save_video(self):
133 |         
134 |         if not self.frames:
135 |             return
136 |             
137 |         try:
138 |             height, width = self.frames[0].shape[:2]
139 |             
140 |             
141 |             fourcc = cv2.VideoWriter_fourcc(*'mp4v')
142 |             out = cv2.VideoWriter(
143 |                 self.video_path,
144 |                 fourcc,
145 |                 1.0,  
146 |                 (width, height),
147 |                 True
148 |             )
149 |             
150 |             
151 |             for frame in self.frames:
152 |                 out.write(frame)
153 |             
154 |             out.release()
155 |             
156 |             
157 |             try:
158 |                 import subprocess
159 |                 temp_path = self.video_path + ".temp.mp4"
160 |                 os.rename(self.video_path, temp_path)
161 |                 subprocess.run([
162 |                     'ffmpeg', '-i', temp_path,
163 |                     '-c:v', 'libx264',
164 |                     '-preset', 'medium',
165 |                     '-crf', '18',
166 |                     '-y',
167 |                     self.video_path
168 |                 ])
169 |                 os.remove(temp_path)
170 |             except:
171 |                 if os.path.exists(temp_path):
172 |                     os.rename(temp_path, self.video_path)
173 |             
174 |             print(f"Video saved to {self.video_path}")
175 |             
176 |         except Exception as e:
177 |             print(f"Error saving video: {e}")
178 | 
179 |     def reset(self, seed: Optional[int] = None):
180 |         
181 |         obs = self.env.reset(seed)
182 |         self.chat_history = []
183 |         self.renderer.chat_history = []
184 |         self.renderer.draw()
185 |         
186 |         if self.record_video:
187 |             time.sleep(1)
188 |             self._capture_frame()
189 |             
190 |         return obs
191 | 
192 |     def close(self):
193 |         if self.record_video:
194 |             try:
195 |                 self._save_video()
196 |                 self.driver.quit()
197 |             except Exception as e:
198 |                 print(f"Error during cleanup: {e}")
199 | 
200 |     def __getattr__(self, name):
201 |         return getattr(self.env, name)
```

## File: textarena/wrappers/observation_wrappers.py

- Extension: .py
- Language: python
- Size: 2179 bytes
- Created: 2024-12-12 10:49:49
- Modified: 2024-12-12 10:49:49

### Code

```python
 1 | import textarena as ta 
 2 | from textarena.core import ObservationWrapper, Env, Observations, Info
 3 | from typing import Dict, Optional, Tuple, List
 4 | 
 5 | __all__ = [
 6 |     "LLMObservationWrapper"
 7 | ]
 8 | 
 9 | 
10 | class LLMObservationWrapper(ObservationWrapper):
11 |     
12 | 
13 |     def __init__(self, env: Env):
14 |         
15 |         super().__init__(env)
16 |         self.full_observations: Dict[int, List[Tuple[int, str]]] = {}
17 |         self.state = self.env.state
18 | 
19 |     def _convert_obs_to_str(self, player_id: int) -> Observations:
20 |         
21 |         str_observation = ""
22 | 
23 |         for sender_id, message in self.full_observations[player_id]:
24 |             if sender_id == ta.GAME_ID:
25 |                 sender_name = "GAME"
26 |             else:
27 |                 sender_name = self.state.role_mapping.get(sender_id, f"Player {sender_id}")
28 |             str_observation += f"\n[{sender_name}] {message}"
29 | 
30 |         recipient_name = self.state.role_mapping.get(player_id, f"Player {player_id}")
31 |         str_observation += f"\n[{recipient_name}]"
32 | 
33 |         return str_observation
34 | 
35 |     def observation(self, player_id: int, observation: Optional[ta.Observations]):
36 |         if observation is None:
37 |             return self._convert_obs_to_str(player_id=player_id)
38 | 
39 |         
40 |         if player_id not in self.full_observations:
41 |             self.full_observations[player_id] = []
42 |             
43 |         for obs in observation:
44 |             if obs not in self.full_observations[player_id]:
45 |                 self.full_observations[player_id].append(obs)
46 | 
47 |         return self._convert_obs_to_str(player_id=player_id)
```

## File: textarena/wrappers/action_wrappers.py

- Extension: .py
- Language: python
- Size: 2212 bytes
- Created: 2024-10-18 15:28:49
- Modified: 2024-10-18 15:28:49

### Code

```python
 1 | from textarena.core import ActionWrapper, Env
 2 | 
 3 | __all__ = ["ClipWordsActionWrapper", "ClipCharactersActionWrapper"]
 4 | 
 5 | 
 6 | class ClipWordsActionWrapper(ActionWrapper):
 7 |     
 8 | 
 9 |     def __init__(self, env: Env, max_num_words: int):
10 |         
11 |         super().__init__(env)
12 |         self.max_num_words = max_num_words
13 | 
14 |     def action(self, action: str) -> str:
15 |         
16 |         word_list = action.split()
17 |         if len(word_list) <= self.max_num_words:
18 |             return action
19 |         else:
20 |             
21 |             return " ".join(word_list[: self.max_num_words])
22 | 
23 | 
24 | class ClipCharactersActionWrapper(ActionWrapper):
25 |     
26 | 
27 |     def __init__(self, env: Env, max_num_characters: int):
28 |         
29 |         super().__init__(env)
30 |         self.max_num_characters = max_num_characters
31 | 
32 |     def action(self, action: str) -> str:
33 |         
34 |         if len(action) <= self.max_num_characters:
35 |             return action
36 |         else:
37 |             
38 |             return action[: self.max_num_characters]
```

## File: textarena/wrappers/__init__.py

- Extension: .py
- Language: python
- Size: 368 bytes
- Created: 2024-12-12 14:16:21
- Modified: 2024-12-12 14:16:21

### Code

```python
 1 | from textarena.wrappers.render_wrappers import BrowserRenderWrapper
 2 | from textarena.wrappers.observation_wrappers import LLMObservationWrapper
 3 | from textarena.wrappers.action_wrappers import ClipWordsActionWrapper
 4 | 
 5 | from textarena.wrappers.agent_wrappers import (
 6 |     ThoughtAgentWrapper,
 7 |     InterpreterAgentWrapper,
 8 |     ChainAgentWrapper,
 9 |     ActorCriticAgentWrapper,
10 | )
```

## File: textarena/api/api_client.py

- Extension: .py
- Language: python
- Size: 5457 bytes
- Created: 2024-11-22 12:08:51
- Modified: 2024-11-22 12:08:51

### Code

```python
  1 | import requests
  2 | import json
  3 | from textarena.api.utils import try_loading_token, store_token
  4 | 
  5 | BASE_URL = "http://127.0.0.1:8000" 
  6 | 
  7 | def wrapped_request(url, data, request_type="get"):
  8 |     
  9 |     try:
 10 |         print(url, data)
 11 |         if request_type == "get":
 12 |             response = requests.get(url, params=data, timeout=10)
 13 |             print(response)
 14 |         elif request_type == "post":
 15 |             response = requests.post(url, json=data, timeout=10)
 16 |             print(response)
 17 |         else:
 18 |             raise Exception(f"Unexpected request type: {request_type}")
 19 |         response.raise_for_status()
 20 |         return response.json()
 21 |     except requests.exceptions.HTTPError as err:
 22 |         
 23 |         if err.response is not None and err.response.status_code >= 400:
 24 |             detail = err.response.json().get("detail", "An error occurred.")
 25 |             print(f"Error {err.response.status_code}: {detail}")
 26 |         else:
 27 |             print("An unexpected error occurred.")
 28 |         raise
 29 | 
 30 | 
 31 | 
 32 | def register_online_model(model_name, model_description, email):
 33 |     
 34 |     
 35 |     model_token, token_key = try_loading_token(model_name=model_name)
 36 |     if model_token is None:
 37 |         print(f"No model_token found in .env. Expected key: {token_key}")
 38 |         
 39 |         url = f"{BASE_URL}/register_model"
 40 |         data = {
 41 |             "model_name": model_name,
 42 |             "description": model_description,
 43 |             "email": email
 44 |         }
 45 |         response = wrapped_request(
 46 |             url=url, 
 47 |             data=data,
 48 |             request_type="post"
 49 |         )
 50 |         
 51 |         store_token(token_key=token_key, model_token=response["model_token"])
 52 |         return response["model_token"]
 53 |     return model_token
 54 | 
 55 | def join_matchmaking(env_id, model_name, model_token, queue_time_limit=300):
 56 |     
 57 |     url = f"{BASE_URL}/join_matchmaking"
 58 |     data = {
 59 |         "env_id": env_id,
 60 |         "model_name": model_name,
 61 |         "model_token": model_token,
 62 |         "queue_time_limit": queue_time_limit
 63 |     }
 64 |     
 65 |     response = wrapped_request(
 66 |         url=url, 
 67 |         data=data,
 68 |         request_type="post"
 69 |     )
 70 |     return response["message"]
 71 | 
 72 | def check_matchmaking_status(env_id, model_name, model_token):
 73 |     
 74 |     url = f"{BASE_URL}/check_matchmaking_status"
 75 |     data = {
 76 |         "env_id": env_id,
 77 |         "model_name": model_name,
 78 |         "model_token": model_token
 79 |     }
 80 |     response = wrapped_request(
 81 |         url=url, 
 82 |         data=data,
 83 |         request_type="get"
 84 |     )
 85 |     return response
 86 | 
 87 | def check_turn(env_id, model_name, model_token, game_id, player_id):
 88 |     
 89 |     url = f"{BASE_URL}/check_turn"
 90 |     data = {
 91 |         "env_id": env_id,
 92 |         "model_name": model_name,
 93 |         "model_token": model_token,
 94 |         "game_id": game_id,
 95 |         "player_id": player_id
 96 |     }
 97 |     response = wrapped_request(
 98 |         url=url, 
 99 |         data=data,
100 |         request_type="get"
101 |     )
102 |     return response
103 | 
104 | def submit_step(env_id, model_name, model_token, game_id, action_text):
105 |     
106 |     url = f"{BASE_URL}/step"
107 |     data = {
108 |         "env_id": env_id,
109 |         "model_name": model_name,
110 |         "model_token": model_token,
111 |         "game_id": game_id,
112 |         "action_text": action_text
113 |     }
114 |     response = wrapped_request(
115 |         url=url, 
116 |         data=data,
117 |         request_type="post"
118 |     )
119 |     return response
120 | 
121 | 
122 | def get_results(game_id, model_name, env_id):
123 |     
124 |     url = f"{BASE_URL}/get_results"
125 |     data = {
126 |         "game_id": game_id,
127 |         "model_name": model_name,
128 |         "env_id": env_id
129 |     }
130 |     response = wrapped_request(
131 |         url=url, 
132 |         data=data,
133 |         request_type="post"    
134 |     )
135 |     return response
```

## File: textarena/api/game_manager.py

- Extension: .py
- Language: python
- Size: 2848 bytes
- Created: 2024-11-22 11:22:01
- Modified: 2024-11-22 11:22:01

### Code

```python
 1 | import textarena as ta
 2 | from textarena.api.online_env import OnlineEnv
 3 | import time
 4 | from typing import Optional, Tuple
 5 | 
 6 | 
 7 | def make_online(
 8 |     env_id: str, 
 9 |     model_name: str, 
10 |     model_token: str,
11 |     queue_time_limit: Optional[float] = None
12 | ) -> Tuple[OnlineEnv, int]:
13 |     
14 |     
15 |     result = ta.api.join_matchmaking(
16 |         env_id=env_id,
17 |         model_name=model_name,
18 |         model_token=model_token,
19 |         queue_time_limit=queue_time_limit
20 |     )
21 |     print(result)
22 | 
23 |     time.sleep(10)
24 |     from datetime import datetime
25 |     print(f"Joined the matchmaking queue ", datetime.now().strftime("%H:%M:%S"))
26 | 
27 |     
28 |     while True:
29 |         current_matchmaking_status = ta.api.check_matchmaking_status(
30 |             env_id=env_id,
31 |             model_name=model_name,
32 |             model_token=model_token
33 |         )
34 |         
35 |         status = current_matchmaking_status.get("status")
36 |         if status == "Searching":
37 |             queue_time = current_matchmaking_status.get("queue_time", 0)
38 |             queue_time_limit = current_matchmaking_status.get("queue_time_limit", 300)
39 |             print(f"Waiting in matchmaking queue for {env_id}...({queue_time:.0f}s/{queue_time_limit:.0f}s)", end="\r")
40 |         elif status == "Match found":
41 |             game_id = current_matchmaking_status["game_id"]
42 |             player_id = current_matchmaking_status["player_id"]
43 |             opponent_names = current_matchmaking_status["opponent_name"]
44 |             num_players = current_matchmaking_status["num_players"]
45 | 
46 |             
47 |             online_env = OnlineEnv(
48 |                 env_id=env_id,
49 |                 model_name=model_name,
50 |                 model_token=model_token,
51 |                 game_id=game_id,
52 |                 player_id=player_id,
53 |                 num_players=num_players
54 |             )
55 | 
56 |             print("\n")
57 |             print("="*30, "[MATCH FOUND]", "="*30)
58 |             print(f"Environment:\t {env_id}")
59 |             print(f"Opponent(s):\t {opponent_names}")
60 |             print(f"You are playing as Player {player_id}\n\n\n")
61 |             time.sleep(5)
62 |             
63 |             return online_env
64 |         else:
65 |             
66 |             raise Exception(f"Unexpected matchmaking status: {status}")
67 |         
68 |         time.sleep(5)  
69 | 
```

## File: textarena/api/utils.py

- Extension: .py
- Language: python
- Size: 739 bytes
- Created: 2024-11-22 10:52:19
- Modified: 2024-11-22 10:52:19

### Code

```python
 1 | import os
 2 | from pathlib import Path
 3 | from typing import Optional
 4 | import dotenv
 5 | import textarena as ta
 6 | 
 7 | def try_loading_token(model_name):
 8 |     
 9 |     
10 |     token_key = f"MODEL_TOKEN_{model_name.replace(' ', '_').replace('-', '_').replace('(', '_').replace(')', '_').upper()}"
11 |     
12 |     
13 |     token = os.getenv(token_key)
14 | 
15 |     return token, token_key 
16 | 
17 | 
18 | def store_token(token_key, model_token):
19 |     
20 |     
21 |     if model_token is not None:
22 |         
23 |         with open(".env", "a") as f:
24 |             f.write(f'\n{token_key}="{model_token}"')
25 | 
26 |         
27 |         dotenv.load_dotenv(".env", override=True)
28 | 
```

## File: textarena/api/README.md

- Extension: .md
- Language: markdown
- Size: 2906 bytes
- Created: 2024-11-11 13:53:40
- Modified: 2024-11-11 13:53:40

### Code

```markdown
 1 | # Online LLM Competition Environment
 2 | 
 3 | This project facilitates online competitions where different language models (LLMs) can play against each other in various environments. It consists of client-side and server-side components that handle model registration, matchmaking, game management, and action submissions.
 4 | 
 5 | ## Table of Contents
 6 | 
 7 | - [Client-Side](#client-side)
 8 |   - [api_client.py](#api_clientpy)
 9 |   - [game_manager.py](#game_managerpy)
10 |   - [online_env.py](#online_envpy)
11 | - [Server-Side](#server-side)
12 |   - [schemas.py](#schemaspy)
13 |   - [main.py](#mainpy)
14 |   - [models.py](#modelspy)
15 |   - [database.py](#databasepy)
16 |   - [config.py](#configpy)
17 |   - [register_environments.py](#register_environmentspy)
18 |   - [cont_matchmaking.py](#cont_matchmakingpy)
19 |   - [requirements.txt](#requirementstxt)
20 | - [Setup Instructions](#setup-instructions)
21 | - [Usage](#usage)
22 | - [Contributing](#contributing)
23 | - [License](#license)
24 | 
25 | ## Client-Side
26 | 
27 | ### `api_client.py`
28 | 
29 | Handles interactions with the server API, including model registration, joining matchmaking queues, checking matchmaking status, verifying turns, and submitting actions. Now, it consistently sends `env_id`, `model_name`, and `model_token` for enhanced security.
30 | 
31 | ### `game_manager.py`
32 | 
33 | Manages the process of joining matchmaking queues and initializing online game environments once a match is found. Now includes `env_id`, `model_name`, and `model_token` during matchmaking status checks.
34 | 
35 | ### `online_env.py`
36 | 
37 | Defines the `OnlineEnv` class, which interacts with the server to manage game states, handle turns, and submit actions. All interactions now include `env_id`, `model_name`, and `model_token` for secure communication.
38 | 
39 | ## Server-Side
40 | 
41 | ### `schemas.py`
42 | 
43 | Defines the Pydantic models for request validation and data serialization. Now includes `env_id`, `model_name`, and `model_token` in relevant request schemas to ensure secure and authenticated requests.
44 | 
45 | ### `main.py`
46 | 
47 | Contains the FastAPI application with endpoints for model registration, matchmaking, turn checking, and action submission. All endpoints now expect `env_id`, `model_name`, and `model_token` for enhanced security. It also includes the `OnlineEnvHandler` class to manage game states.
48 | 
49 | ### `models.py`
50 | 
51 | Defines the SQLAlchemy ORM models for the database, including `Model`, `Elo`, `Environment`, `Matchmaking`, `Game`, and `PlayerGame`.
52 | 
53 | ### `database.py`
54 | 
55 | Sets up the SQLAlchemy engine and session management for database interactions.
56 | 
57 | ### `config.py`
58 | 
59 | Contains configuration variables, such as the database URL.
60 | 
61 | ### `register_environments.py`
62 | 
63 | Registers new environments in the database for which models can compete.
64 | 
65 | ### `cont_matchmaking.py`
66 | 
67 | Continuously runs to match players based on their Elo scores and queue times, creating games when suitable matches are found.
68 | 
69 | ### `requirements.txt`
70 | 
71 | Lists all Python dependencies required to run the server and client applications.
72 | 
```

## File: textarena/api/__init__.py

- Extension: .py
- Language: python
- Size: 711 bytes
- Created: 2024-11-12 10:35:09
- Modified: 2024-11-12 10:35:09

### Code

```python
 1 | from textarena.api.api_client import (
 2 |     register_online_model,       
 3 |     join_matchmaking,            
 4 |     check_matchmaking_status,    
 5 |     check_turn,                  
 6 |     submit_step,                 
 7 |     get_results,                 
 8 | )
 9 | 
10 | from textarena.api.game_manager import make_online  
11 | 
12 | __all__ = [
13 |     "register_online_model",
14 |     "join_matchmaking",
15 |     "check_matchmaking_status",
16 |     "check_turn",
17 |     "submit_step",
18 |     "make_online",
19 |     "get_results"
20 | ]
```

## File: textarena/api/online_env.py

- Extension: .py
- Language: python
- Size: 7683 bytes
- Created: 2024-11-22 11:25:10
- Modified: 2024-11-22 11:25:10

### Code

```python
  1 | import requests
  2 | import time
  3 | import warnings
  4 | from typing import Optional, Tuple, List, Dict, Any
  5 | import textarena as ta  
  6 | 
  7 | 
  8 | class OnlineState:
  9 |     
 10 |     def __init__(
 11 |         self,
 12 |         num_players: int,
 13 |         max_turns: Optional[int] = None,
 14 |         render_keys: Optional[List[str]] = None,
 15 |         role_mapping: Optional[Dict[int, str]] = {}
 16 |     ):
 17 |         self.num_players = num_players
 18 |         self.role_mapping = role_mapping
 19 |         self.render_keys = render_keys
 20 | 
 21 | 
 22 | 
 23 | class OnlineEnv(ta.Env):
 24 |     
 25 | 
 26 |     def __init__(
 27 |         self,
 28 |         env_id: str,
 29 |         model_name: str,
 30 |         model_token: str,
 31 |         player_id: int,
 32 |         game_id: int,
 33 |         num_players: int,
 34 |     ):
 35 |         self.env_id = env_id 
 36 |         self.model_name = model_name 
 37 |         self.model_token = model_token 
 38 |         self.player_id = player_id
 39 |         self.game_id = game_id 
 40 |         self.done = False 
 41 | 
 42 |         self.state = OnlineState(
 43 |             num_players=num_players,
 44 |         )
 45 | 
 46 |         self.ID_TO_STR_DICT = {
 47 |             -1: "GAME",
 48 |             self.player_id: "You"
 49 |         }
 50 |         for player_nr in range(self.state.num_players):
 51 |             if player_nr != self.player_id:
 52 |                 self.ID_TO_STR_DICT[player_nr] = f"Opponent {len(self.ID_TO_STR_DICT)-1}"
 53 | 
 54 |         self.most_recent_observations = []
 55 | 
 56 |     def _wait_until_player_turn(self) -> Dict[str, Any]:
 57 |         
 58 |         start_time = time.time()
 59 |         while True:
 60 |             turn_status = ta.api.check_turn(
 61 |                 env_id=self.env_id,
 62 |                 model_name=self.model_name,
 63 |                 model_token=self.model_token,
 64 |                 game_id=self.game_id,
 65 |                 player_id=self.player_id
 66 |             )
 67 | 
 68 |             status = turn_status.get("status")
 69 |             
 70 |             if status == "Your turn":
 71 |                 observations = turn_status.get("observations")
 72 |                 
 73 |                 observations = {int(k): v for k, v in observations.items()}
 74 |                 self.done = turn_status.get("done", False)
 75 |                 self.most_recent_observations = observations[self.player_id]
 76 |                 return {"observations": observations, "done": self.done}
 77 |             elif status == "Not your turn":
 78 |                 print(f"Waiting for turn...({time.time()-start_time:.0f}s)", end="\r")
 79 |                 time.sleep(1)  
 80 |             elif status == "Game concluded":
 81 |                 print(f"\nGame has concluded.")
 82 |                 observations = turn_status.get("observations")
 83 |                 
 84 |                 observations = {int(k): v for k, v in observations.items()}
 85 |                 self.done = turn_status["done"]
 86 |                 return {"observations": observations, "done": self.done}
 87 | 
 88 |             else:
 89 |                 
 90 |                 raise Exception(f"Unexpected turn status: {status}")
 91 | 
 92 |     def reset(self, seed: Optional[int] = None) -> Optional[Dict[int, Tuple[int, str]]]:
 93 |         
 94 |         if seed is not None:
 95 |             warnings.warn("No seed should be provided when using the online environment.")
 96 |             
 97 | 
 98 |         
 99 |         result = self._wait_until_player_turn()
100 | 
101 |         return result["observations"]
102 | 
103 | 
104 |     def get_current_player_id(self):
105 |         return self.player_id 
106 | 
107 |     def step(
108 |         self,
109 |         player_id: int,
110 |         action: str,
111 |     ) -> Tuple[
112 |         Optional[Dict[int, Tuple[int, str]]],  
113 |         Optional[Dict[int, int]],               
114 |         bool,                                    
115 |         bool,                                    
116 |         Optional[Dict[str, Any]]                
117 |     ]:  
118 |         
119 |         
120 |         assert self.player_id is not None, "Player ID is not set."
121 | 
122 |         if self.done:
123 |             return None, None, self.done, self.done, None 
124 |         
125 |         
126 |         result = ta.api.submit_step(
127 |             env_id=self.env_id,
128 |             model_name=self.model_name,
129 |             model_token=self.model_token,
130 |             game_id=self.game_id,
131 |             action_text=action
132 |         )
133 |         print(f"\nAction submitted.")
134 | 
135 |         if result["done"]:
136 |             self.done = True
137 |             return None, None, True, True, None
138 | 
139 |         
140 |         result = self._wait_until_player_turn()
141 |         observations = result["observations"]
142 |         self.done = result["done"]
143 | 
144 |         
145 |         
146 | 
147 |         
148 |         return observations, None, self.done, self.done, None
149 | 
150 |     def close(self):
151 |         
152 |         if not self.done:
153 |             raise Exception(f"Should not .close() and ongoing game.")
154 | 
155 |         
156 |         result_status = ta.api.get_results(
157 |             game_id=self.game_id,
158 |             model_name=self.model_name,
159 |             env_id=self.env_id 
160 |         )
161 |         current_elo_score = result_status['current_elo_score']
162 |         prev_elo_score = result_status['prev_elo_score']
163 |         if prev_elo_score is None:
164 |             prev_elo_score = 1_000
165 | 
166 |         elo_delt_symb = "+" if current_elo_score>prev_elo_score else "-"
167 |         abs_elo_delta = abs(current_elo_score-prev_elo_score)
168 | 
169 |         print("\n\n\n")
170 |         print("="*30, f"[{result_status['outcome']}]", "="*30)
171 |         print(f"Environment:\t {self.env_id}")
172 |         print(f"Model Name: \t {self.model_name}")
173 |         print(f"Player Nr.: \t {self.player_id}")
174 |         print(f"Opponent(s):\t {result_status['opponent_names']}")
175 |         print(f"Reason(s):  \t {result_status['reason']}")
176 |         print(f"Prev. Elo:  \t {prev_elo_score}")
177 |         print(f"New Elo:    \t {current_elo_score}")
178 |         print(f"Elo Delta:  \t {elo_delt_symb}{abs_elo_delta}")
179 |         print("="*(62+len(f"[{result_status['outcome']}]")))
180 | 
181 | 
182 |     def render(self):
183 |         
184 |         for from_id, obs in self.most_recent_observations:
185 |             print(f"\n[{self.ID_TO_STR_DICT[from_id]}] {obs}")
186 |         
187 |         
```

## File: textarena/envs/registration.py

- Extension: .py
- Language: python
- Size: 4938 bytes
- Created: 2024-11-11 15:32:36
- Modified: 2024-11-11 15:32:36

### Code

```python
  1 | import re
  2 | import importlib
  3 | from typing import Any, Callable, Dict, Tuple, Optional
  4 | from dataclasses import dataclass, field
  5 | 
  6 | 
  7 | ENV_REGISTRY: Dict[str, Callable] = {}
  8 | 
  9 | @dataclass
 10 | class EnvSpec:
 11 |     
 12 |     id: str
 13 |     entry_point: Callable
 14 |     kwargs: Dict[str, Any] = field(default_factory=dict)
 15 |     
 16 |     def make(self, **kwargs) -> Any:
 17 |         
 18 |         all_kwargs = {**self.kwargs, **kwargs}
 19 |         return self.entry_point(**all_kwargs)
 20 | 
 21 | def register(id: str, entry_point: Callable, **kwargs: Any):
 22 |     
 23 |     if id in ENV_REGISTRY:
 24 |         raise ValueError(f"Environment {id} already registered.")
 25 |     ENV_REGISTRY[id] = EnvSpec(id=id, entry_point=entry_point, kwargs=kwargs)
 26 | 
 27 | def pprint_registry():
 28 |     
 29 |     if not ENV_REGISTRY:
 30 |         print("No environments registered.")
 31 |     else:
 32 |         print("Registered Environments:")
 33 |         for env_id, env_spec in ENV_REGISTRY.items():
 34 |             print(f"  - {env_id}: {env_spec.entry_point}")
 35 | 
 36 | def pprint_registry_detailed():
 37 |     
 38 |     if not ENV_REGISTRY:
 39 |         print("No environments registered.")
 40 |     else:
 41 |         print("Detailed Registered Environments:")
 42 |         for env_id, env_spec in ENV_REGISTRY.items():
 43 |             print(f"  - {env_id}:")
 44 |             print(f"      Entry Point: {env_spec.entry_point}")
 45 |             print(f"      Kwargs: {env_spec.kwargs}")
 46 | 
 47 | def find_highest_version(name: str):
 48 |     
 49 |     versions = []
 50 |     
 51 |     
 52 |     version_pattern = re.compile(r"-v(\d+)")
 53 |     
 54 |     for env_id in ENV_REGISTRY.keys():
 55 |         if env_id.startswith(name):
 56 |             match = version_pattern.search(env_id)
 57 |             if match:
 58 |                 version_number = int(match.group(1))
 59 |                 versions.append(version_number)
 60 |     
 61 |     return max(versions) if versions else None
 62 | 
 63 | def check_env_exists(env_id: str):
 64 |     
 65 |     if env_id not in ENV_REGISTRY:
 66 |         raise ValueError(f"Environment {env_id} is not registered.")
 67 |     else:
 68 |         print(f"Environment {env_id} is registered.")
 69 | 
 70 | 
 71 | 
 72 | 
 73 | 
 74 | 
 75 |     
 76 | 
 77 |     
 78 | 
 79 | 
 80 | 
 81 | 
 82 | 
 83 | 
 84 | 
 85 |     
 86 | 
 87 | 
 88 | 
 89 | def make(env_id: str, **kwargs) -> Any:
 90 |     
 91 |     if env_id not in ENV_REGISTRY:
 92 |         raise ValueError(f"Environment {env_id} not found in registry.")
 93 |     
 94 |     env_spec = ENV_REGISTRY[env_id]
 95 |     
 96 |     
 97 |     if isinstance(env_spec.entry_point, str):
 98 |         module_path, class_name = env_spec.entry_point.split(":")
 99 |         try:
100 |             module = importlib.import_module(module_path)
101 |             env_class = getattr(module, class_name)
102 |         except (ModuleNotFoundError, AttributeError) as e:
103 |             raise ImportError(f"Could not import {module_path}.{class_name}. Error: {e}")
104 |     else:
105 |         env_class = env_spec.entry_point
106 |     
107 |     return env_class(**{**env_spec.kwargs, **kwargs})
108 | 
109 | 
110 | def classify_games(filter_category: str = "all"):
111 |     
112 |     classified_games = {}
113 | 
114 |     for env_id, env_spec in ENV_REGISTRY.items():
115 |         entry_point = env_spec.entry_point if isinstance(env_spec.entry_point, str) else ""
116 |         
117 |         
118 |         match = re.search(r"(multi_player|two_player|single_player|[\w]+_player)", entry_point)
119 |         category = match.group(0) if match else "Other"
120 |         
121 |         
122 |         if category not in classified_games:
123 |             classified_games[category] = []
124 |         
125 |         
126 |         classified_games[category].append(env_id)
127 | 
128 |     
129 |     if filter_category != "all":
130 |         return {filter_category: classified_games.get(filter_category, [])}
131 |     
132 |     return classified_games
```

## File: textarena/envs/__init__.py

- Extension: .py
- Language: python
- Size: 13124 bytes
- Created: 2024-12-12 12:02:10
- Modified: 2024-12-12 12:02:10

### Code

```python
  1 | 
  2 | 
  3 | from textarena.envs.registration import (
  4 |     make,
  5 |     register,
  6 | )  
  7 | from textarena.utils import batch_open_router_generate
  8 | 
  9 | from textarena.game_makers import GPTJudgeVote
 10 | 
 11 | 
 12 | register(
 13 |     id="LiarsDice-v0-multi",
 14 |     entry_point="textarena.envs.multi_player.liars_dice:LiarsDice",
 15 |     num_dice=5,
 16 |     num_players=5,
 17 | )
 18 | 
 19 | 
 20 | 
 21 | register(
 22 |     id="Crosswords-v0",
 23 |     entry_point="textarena.envs.single_player.Crosswords.env:CrosswordsEnv",
 24 |     hardcore=False,
 25 |     max_turns=30,
 26 |     num_words=3,
 27 | )
 28 | 
 29 | register(
 30 |     id="Crosswords-v0-hardcore",
 31 |     entry_point="textarena.envs.single_player.Crosswords.env:CrosswordsEnv",
 32 |     hardcore=True,
 33 |     max_turns=30,
 34 |     num_words=3,
 35 | )
 36 | 
 37 | register(
 38 |     id="Sudoku-v0-easy",
 39 |     entry_point="textarena.envs.single_player.Sudoku.env:SudokuEnv",
 40 |     difficulty="easy",
 41 |     max_turns=31,
 42 | )
 43 | 
 44 | register(
 45 |     id="Sudoku-v0-medium",
 46 |     entry_point="textarena.envs.single_player.Sudoku.env:SudokuEnv",
 47 |     difficulty="medium",
 48 |     max_turns=41,
 49 | )
 50 | 
 51 | register(
 52 |     id="Sudoku-v0-hard",
 53 |     entry_point="textarena.envs.single_player.Sudoku.env:SudokuEnv",
 54 |     difficulty="hard",
 55 |     max_turns=51,
 56 | )
 57 | 
 58 | register(
 59 |     id="Hangman-v0",
 60 |     entry_point="textarena.envs.single_player.Hangman.env:HangmanEnv",
 61 |     hardcore=False,
 62 | )
 63 | 
 64 | register(
 65 |     id="Hangman-v0-hardcore",
 66 |     entry_point="textarena.envs.single_player.Hangman.env:HangmanEnv",
 67 |     hardcore=True,
 68 | )
 69 | 
 70 | register(
 71 |     id="GuessTheNumber-v0",
 72 |     entry_point="textarena.envs.single_player.GuessTheNumber.env:GuessTheNumberEnv",
 73 |     hardcore=False,
 74 | )
 75 | 
 76 | register(
 77 |     id="GuessTheNumber-v0-hardcore",
 78 |     entry_point="textarena.envs.single_player.GuessTheNumber.env:GuessTheNumberEnv",
 79 |     hardcore=True,
 80 | )
 81 | 
 82 | register(
 83 |     id="WordSearch-v0",
 84 |     entry_point="textarena.envs.single_player.WordSearch.env:WordSearchEnv",
 85 |     hardcore=False,
 86 | )
 87 | 
 88 | register(
 89 |     id="WordSearch-v0-hardcore",
 90 |     entry_point="textarena.envs.single_player.WordSearch.env:WordSearchEnv",
 91 |     hardcore=True,
 92 | )
 93 | 
 94 | register(
 95 |     id="WordLadder-v0",
 96 |     entry_point="textarena.envs.single_player.WordLadder.env:WordLadderEnv",
 97 |     hardcore=False,
 98 |     word_len=5,
 99 | )
100 | 
101 | register(
102 |     id="WordLadder-v0-hardcore",
103 |     entry_point="textarena.envs.single_player.WordLadder.env:WordLadderEnv",
104 |     hardcore=True,
105 |     word_len=5,
106 | )
107 | 
108 | register(
109 |     id="WordLadder-v0-hardcore-10",
110 |     entry_point="textarena.envs.single_player.WordLadder.env:WordLadderEnv",
111 |     hardcore=True,
112 |     word_len=10,
113 | )
114 | 
115 | register(
116 |     id="FifteenPuzzle-v0",
117 |     entry_point="textarena.envs.single_player.FifteenPuzzle.env:FifteenPuzzleEnv",
118 | )
119 | 
120 | register(
121 |     id="LogicPuzzle-v0",
122 |     entry_point="textarena.envs.single_player.LogicPuzzle.env:LogicPuzzleEnv",
123 |     difficulty="easy",
124 | )
125 | 
126 | register(
127 |     id="LogicPuzzle-v0-hard",
128 |     entry_point="textarena.envs.single_player.LogicPuzzle.env:LogicPuzzleEnv",
129 |     difficulty="hard",
130 | )
131 | 
132 | register(
133 |     id="TwentyQuestions-v0",
134 |     entry_point="textarena.envs.single_player.TwentyQuestions.env:TwentyQuestionsEnv",
135 |     hardcore=False,
136 | )
137 | 
138 | register(
139 |     id="TwentyQuestions-v0-hardcore",
140 |     entry_point="textarena.envs.single_player.TwentyQuestions.env:TwentyQuestionsEnv",
141 |     hardcore=True,
142 | )
143 | 
144 | register(
145 |     id="TowerOfHanoi-v0-easy",
146 |     entry_point="textarena.envs.single_player.TowerOfHanoi.env:TowerOfHanoiEnv",
147 |     difficulty="easy"
148 | )
149 | 
150 | register(
151 |     id="TowerOfHanoi-v0-medium",
152 |     entry_point="textarena.envs.single_player.TowerOfHanoi.env:TowerOfHanoiEnv",
153 |     difficulty="medium"
154 | )
155 | 
156 | register(
157 |     id="TowerOfHanoi-v0-hard",
158 |     entry_point="textarena.envs.single_player.TowerOfHanoi.env:TowerOfHanoiEnv",
159 |     difficulty="hard"
160 | )
161 | 
162 | register(
163 |     id="Minesweeper-v0-easy",
164 |     entry_point="textarena.envs.single_player.Minesweeper.env:MinesweeperEnv",
165 |     difficulty="easy",
166 | )
167 | 
168 | register(
169 |     id="Minesweeper-v0-medium",
170 |     entry_point="textarena.envs.single_player.Minesweeper.env:MinesweeperEnv",
171 |     difficulty="medium",
172 | )
173 | 
174 | register(
175 |     id="Minesweeper-v0-hard",
176 |     entry_point="textarena.envs.single_player.Minesweeper.env:MinesweeperEnv",
177 |     difficulty="hard",
178 | )
179 | 
180 | register(
181 |     id="GuessWho-v0",
182 |     entry_point="textarena.envs.single_player.GuessWho.env:GuessWhoEnv",
183 | )
184 | 
185 | register(
186 |     id="Chess-v0-singleplayer",
187 |     entry_point="textarena.envs.single_player.Chess.env:ChessEnv",
188 | )
189 | 
190 | register(
191 |     id="ConnectFour-v0-singleplayer",
192 |     entry_point="textarena.envs.single_player.ConnectFour.env:ConnectFourEnv",
193 | )
194 | 
195 | 
196 | register(
197 |     id="DontSayIt-v0",
198 |     entry_point="textarena.envs.two_player.DontSayIt.env:DontSayItEnv",
199 |     hardcore=False,
200 |     max_turns=30,
201 | )
202 | register(
203 |     id="DontSayIt-v0-hardcore",
204 |     entry_point="textarena.envs.two_player.DontSayIt.env:DontSayItEnv",
205 |     hardcore=True,
206 |     max_turns=30,
207 | )
208 | register(
209 |     id="DontSayIt-v0-unlimited",
210 |     entry_point="textarena.envs.two_player.DontSayIt.env:DontSayItEnv",
211 |     hardcore=False,
212 |     max_turns=None,
213 | )
214 | 
215 | register(
216 |     id="Negotiation-v0",
217 |     entry_point="textarena.envs.two_player.Negotiation.env:NegotiationEnv",
218 |     max_turns=20,
219 | )
220 | register(
221 |     id="Negotiation-v0-short",
222 |     entry_point="textarena.envs.two_player.Negotiation.env:NegotiationEnv",
223 |     max_turns=10,
224 | )
225 | register(
226 |     id="Negotiation-v0-long",
227 |     entry_point="textarena.envs.two_player.Negotiation.env:NegotiationEnv",
228 |     max_turns=50,
229 | )
230 | 
231 | 
232 | register(
233 |     id="Chess-v0",
234 |     entry_point="textarena.envs.two_player.Chess.env:ChessEnv",
235 |     is_open=False,
236 |     max_turns=30,
237 |     show_valid=True,
238 | )
239 | register(
240 |     id="Chess-v0-open",
241 |     entry_point="textarena.envs.two_player.Chess.env:ChessEnv",
242 |     is_open=True,
243 |     max_turns=30,
244 |     show_valid=False,
245 | )
246 | register(
247 |     id="Chess-v0-long",
248 |     entry_point="textarena.envs.two_player.Chess.env:ChessEnv",
249 |     is_open=False,
250 |     max_turns=50,
251 |     show_valid=True,
252 | )
253 | register(
254 |     id="Chess-v0-blind",
255 |     entry_point="textarena.envs.two_player.Chess.env:ChessEnv",
256 |     is_open=False,
257 |     max_turns=50,
258 |     show_valid=False,
259 | )
260 | 
261 | 
262 | register(
263 |     id="TruthAndDeception-v0",
264 |     entry_point="textarena.envs.two_player.TruthAndDeception.env:TruthAndDeceptionEnv",
265 |     max_turns=6,
266 | )
267 | register(
268 |     id="TruthAndDeception-v0-long",
269 |     entry_point="textarena.envs.two_player.TruthAndDeception.env:TruthAndDeceptionEnv",
270 |     max_turns=12,
271 | )
272 | register(
273 |     id="TruthAndDeception-v0-super-long",
274 |     entry_point="textarena.envs.two_player.TruthAndDeception.env:TruthAndDeceptionEnv",
275 |     max_turns=50,
276 | )
277 | 
278 | register(
279 |     id="WordChains-v0",
280 |     entry_point="textarena.envs.two_player.word_chains:WordChainsEnv",
281 |     max_turns=100,
282 | )
283 | register(
284 |     id="WordChains-v0-infinite",
285 |     entry_point="textarena.envs.two_player.word_chains:WordChainsEnv",
286 |     max_turns=None,
287 | )
288 | 
289 | register(
290 |     id="ConnectFour-v0",
291 |     entry_point="textarena.envs.two_player.ConnectFour.env:ConnectFourEnv",
292 |     is_open=True,
293 |     num_rows=6,
294 |     num_cols=7,
295 | )
296 | register(
297 |     id="ConnectFour-v0-blind",
298 |     entry_point="textarena.envs.two_player.ConnectFour.env:ConnectFourEnv",
299 |     is_open=False,
300 |     num_rows=6,
301 |     num_cols=7,
302 | )
303 | register(
304 |     id="ConnectFour-v0-large",
305 |     entry_point="textarena.envs.two_player.ConnectFour.env:ConnectFourEnv",
306 |     is_open=True,
307 |     num_rows=12,
308 |     num_cols=15,
309 | )
310 | 
311 | register(
312 |     id="SpellingBee-v0",
313 |     entry_point="textarena.envs.two_player.SpellingBee.env:SpellingBeeEnv",
314 |     num_letters=6,
315 | )
316 | register(
317 |     id="SpellingBee-v0-small",
318 |     entry_point="textarena.envs.two_player.SpellingBee.env:SpellingBeeEnv",
319 |     num_letters=4,
320 | )
321 | register(
322 |     id="SpellingBee-v0-large",
323 |     entry_point="textarena.envs.two_player.SpellingBee.env:SpellingBeeEnv",
324 |     num_letters=10,
325 | )
326 | 
327 | register(
328 |     id="LiarsDice-v0",
329 |     entry_point="textarena.envs.two_player.LiarsDice.env:LiarsDiceEnv",
330 |     num_dice=5,
331 | )
332 | register(
333 |     id="LiarsDice-v0-large",
334 |     entry_point="textarena.envs.two_player.LiarsDice.env:LiarsDiceEnv",
335 |     num_dice=12,
336 | )
337 | 
338 | register(
339 |     id="Poker-v0",
340 |     entry_point="textarena.envs.two_player.Poker.env:PokerEnv",
341 |     num_rounds=5,
342 |     starting_chips=1_000,
343 |     small_blind=10,
344 |     big_blind=20
345 | )
346 | 
347 | register(
348 |     id="Poker-v0-long",
349 |     entry_point="textarena.envs.two_player.Poker.env:PokerEnv",
350 |     num_rounds=15,
351 |     starting_chips=1_000,
352 |     small_blind=10,
353 |     big_blind=20
354 | )
355 | 
356 | 
357 | register(
358 |     id="Poker-v0-super-long",
359 |     entry_point="textarena.envs.two_player.Poker.env:PokerEnv",
360 |     num_rounds=50,
361 |     starting_chips=1_000,
362 |     small_blind=10,
363 |     big_blind=20
364 | )
365 | 
366 | register(
367 |     id="Taboo-v0",
368 |     entry_point="textarena.envs.two_player.Taboo.env:TabooEnv",
369 |     max_turns=6,
370 |     categories=["things"],
371 | )
372 | register(
373 |     id="Taboo-v0-animals",
374 |     entry_point="textarena.envs.two_player.Taboo.env:TabooEnv",
375 |     max_turns=6,
376 |     categories=["animals"],
377 | )
378 | register(
379 |     id="Taboo-v0-cars",
380 |     entry_point="textarena.envs.two_player.Taboo.env:TabooEnv",
381 |     max_turns=6,
382 |     categories=["cars"],
383 | )
384 | register(
385 |     id="Taboo-v0-city/country",
386 |     entry_point="textarena.envs.two_player.Taboo.env:TabooEnv",
387 |     max_turns=6,
388 |     categories=["city/country"],
389 | )
390 | register(
391 |     id="Taboo-v0-food",
392 |     entry_point="textarena.envs.two_player.Taboo.env:TabooEnv",
393 |     max_turns=6,
394 |     categories=["food"],
395 | )
396 | register(
397 |     id="Taboo-v0-literature",
398 |     entry_point="textarena.envs.two_player.Taboo.env:TabooEnv",
399 |     max_turns=6,
400 |     categories=["literature"],
401 | )
402 | register(
403 |     id="Taboo-v0-people",
404 |     entry_point="textarena.envs.two_player.Taboo.env:TabooEnv",
405 |     max_turns=6,
406 |     categories=["people"],
407 | )
408 | register(
409 |     id="Taboo-v0-tv",
410 |     entry_point="textarena.envs.two_player.Taboo.env:TabooEnv",
411 |     max_turns=6,
412 |     categories=["tv"],
413 | )
414 | register(
415 |     id="Taboo-v0-long",
416 |     entry_point="textarena.envs.two_player.Taboo.env:TabooEnv",
417 |     max_turns=24,
418 |     categories=["things"],
419 | )
420 | register(
421 |     id="Taboo-v0-full",
422 |     entry_point="textarena.envs.two_player.Taboo.env:TabooEnv",
423 |     max_turns=6,
424 |     categories=[
425 |         "animals",
426 |         "cars",
427 |         "city/country",
428 |         "food",
429 |         "literature",
430 |         "people",
431 |         "things",
432 |         "tv",
433 |     ],
434 | )
435 | 
436 | register(
437 |     id="Debate-v0",
438 |     entry_point="textarena.envs.two_player.Debate.env:DebateEnv",
439 |     max_turns=6,
440 |     judge_class=GPTJudgeVote,
441 |     num_judges=7,
442 | )
443 | register(
444 |     id="Debate-v0-long",
445 |     entry_point="textarena.envs.two_player.Debate.env:DebateEnv",
446 |     max_turns=12,
447 |     judge_class=GPTJudgeVote,
448 |     num_judges=11,
449 | )
450 | register(
451 |     id="Debate-v0-super-long",
452 |     entry_point="textarena.envs.two_player.Debate.env:DebateEnv",
453 |     max_turns=30,
454 |     judge_class=GPTJudgeVote,
455 |     num_judges=15,
456 | )
457 | 
458 | 
459 | register(
460 |     id="ScenarioPlanning-v0",
461 |     entry_point="textarena.envs.two_player.ScenarioPlanning.env:ScenarioPlanningEnv",
462 |     num_judges=11,
463 | )
464 | 
465 | register(
466 |     id="CarPuzzle-v0",
467 |     entry_point="textarena.envs.two_player.car_puzzle:CarPuzzleEnv",
468 | )
469 | 
470 | register(
471 |     "IteratedPrisonersDilemma-v0",
472 |     entry_point="textarena.envs.two_player.IteratedPrisonersDilemma.env:PrisonersDilemmaEnv",
473 |     max_turns=30,
474 | )
475 | 
476 | register(
477 |     "MemoryGame-v0-easy",
478 |     entry_point="textarena.envs.two_player.MemoryGame.env:MemoryGameEnv",
479 |     difficulty="easy",
480 | )
481 | 
482 | register(
483 |     "MemoryGame-v0-medium",
484 |     entry_point="textarena.envs.two_player.MemoryGame.env:MemoryGameEnv",
485 |     difficulty="medium",
486 | )
487 | 
488 | register(
489 |     "MemoryGame-v0-hard",
490 |     entry_point="textarena.envs.two_player.MemoryGame.env:MemoryGameEnv",
491 |     difficulty="hard",
492 | )
493 | 
494 | register(
495 |     "Battleship-v0-easy",
496 |     entry_point="textarena.envs.two_player.Battleship.env:BattleshipEnv",
497 |     difficulty="easy",
498 | )
499 | 
500 | register(
501 |     "Battleship-v0-medium",
502 |     entry_point="textarena.envs.two_player.Battleship.env:BattleshipEnv",
503 |     difficulty="medium",
504 | )
505 | 
506 | register(
507 |     "Battleship-v0-hard",
508 |     entry_point="textarena.envs.two_player.Battleship.env:BattleshipEnv",
509 |     difficulty="hard",
510 | )
511 | 
512 | register(
513 |     "Mastermind-v0-easy",
514 |     entry_point="textarena.envs.two_player.Mastermind.env:MastermindEnv",
515 |     difficulty="easy",
516 | )
517 | 
518 | register(
519 |     "Mastermind-v0-medium",
520 |     entry_point="textarena.envs.two_player.Mastermind.env:MastermindEnv",
521 |     difficulty="medium",
522 | )
523 | 
524 | register(
525 |     "Mastermind-v0-hard",
526 |     entry_point="textarena.envs.two_player.Mastermind.env:MastermindEnv",
527 |     difficulty="hard",
528 | )
529 | 
530 | register(
531 |     "LetterAuction-v0-easy",
532 |     entry_point="textarena.envs.two_player.LetterAuction.env:LetterAuctionEnv",
533 |     difficulty="easy"
534 | )
535 | 
536 | register(
537 |     "LetterAuction-v0-medium",
538 |     entry_point="textarena.envs.two_player.LetterAuction.env:LetterAuctionEnv",
539 |     difficulty="medium"
540 | )
541 | 
542 | register(
543 |     "LetterAuction-v0-hard",
544 |     entry_point="textarena.envs.two_player.LetterAuction.env:LetterAuctionEnv",
545 |     difficulty="hard"
546 | )
547 | 
548 | register(
549 |     "SpiteAndMalice-v0",
550 |     entry_point="textarena.envs.two_player.SpiteAndMalice.env:SpiteAndMaliceEnv",
551 | )
552 | 
553 | 
554 | register(
555 |     "LeHavre-v0",
556 |     entry_point="textarena.envs.two_player.LeHavre.env:LeHavreEnv",
557 |     max_turns=20
558 | )
```

## File: textarena/static/chess/app.js

- Extension: .js
- Language: javascript
- Size: 5405 bytes
- Created: 2024-12-13 10:59:09
- Modified: 2024-12-13 10:59:09

### Code

```javascript
  1 | 
  2 |         function ChessGame() {
  3 |             const [gameState, setGameState] = React.useState(null);
  4 |             
  5 |             React.useEffect(() => {
  6 |                 const ws = new WebSocket(`ws:
  7 |                 ws.onmessage = (event) => {
  8 |                     const state = JSON.parse(event.data);
  9 |                     setGameState(state);
 10 |                 };
 11 |                 return () => ws.close();
 12 |             }, []);
 13 | 
 14 |             if (!gameState) return <div>Loading...</div>;
 15 | 
 16 |             return (
 17 |                 <div className="game-container">
 18 |                     <div className="main-content">
 19 |                         <ChessBoard fen={gameState.fen} />
 20 |                         <GameInfo gameState={gameState} />
 21 |                     </div>
 22 |                     <ChatHistory gameState={gameState} />
 23 |                 </div>
 24 |             );
 25 |         }
 26 | 
 27 |         function ChessBoard({ fen }) {
 28 |             const renderSquare = (i) => {
 29 |                 const file = i % 8;
 30 |                 const rank = Math.floor(i / 8);
 31 |                 const isLight = (file + rank) % 2 === 0;
 32 |                 
 33 |                 return (
 34 |                     <div key={i} className={`square ${isLight ? 'light' : 'dark'}`}>
 35 |                         {getPiece(fen, i)}
 36 |                     </div>
 37 |                 );
 38 |             };
 39 | 
 40 |             return (
 41 |                 <div className="board-container">
 42 |                     <div className="chess-board">
 43 |                         {[...Array(64)].map((_, i) => renderSquare(i))}
 44 |                     </div>
 45 |                 </div>
 46 |             );
 47 |         }
 48 | 
 49 |         function getPiece(fen, squareIndex) {
 50 |             const [position] = fen.split(' ');
 51 |             const rows = position.split('/');
 52 |             const rank = Math.floor(squareIndex / 8);
 53 |             const file = squareIndex % 8;
 54 |             
 55 |             let currentFile = 0;
 56 |             const row = rows[7 - rank];
 57 |             
 58 |             for (let i = 0; i < row.length; i++) {
 59 |                 const char = row[i];
 60 |                 if (isNaN(char)) {
 61 |                     if (currentFile === file) {
 62 |                         return (
 63 |                             <img 
 64 |                                 src={`/static/chess/pieces/${char}.png`}
 65 |                                 alt={char}
 66 |                                 className="piece-img"
 67 |                             />
 68 |                         );
 69 |                     }
 70 |                     currentFile++;
 71 |                 } else {
 72 |                     currentFile += parseInt(char);
 73 |                 }
 74 |                 if (currentFile > file) break;
 75 |             }
 76 |             return null;
 77 |         }
 78 | 
 79 |         function GameInfo({ gameState }) {
 80 |             return (
 81 |                 <div className="info-container">
 82 |                     <h2>Game Status</h2>
 83 |                     <div>Current Turn: {gameState.current_player}</div>
 84 |                     {gameState.is_check && <div className="text-red-500">Check!</div>}
 85 |                     {gameState.is_checkmate && <div className="text-red-500">Checkmate!</div>}
 86 |                     {gameState.is_stalemate && <div className="text-yellow-500">Stalemate</div>}
 87 |                     
 88 |                     <h3>Players</h3>
 89 |                     <div>
 90 |                         {Object.entries(gameState.player_names).map(([id, name]) => (
 91 |                             <div key={id} className={id === '0' ? 'white-player' : 'black-player'}>
 92 |                                 {name} ({id === '0' ? 'White' : 'Black'})
 93 |                             </div>
 94 |                         ))}
 95 |                     </div>
 96 |                     
 97 |                     <h3>Move History</h3>
 98 |                     <div className="move-history">
 99 |                         {gameState.move_stack.map((move, i) => (
100 |                             <span key={i} style={{marginRight: '10px'}}>
101 |                                 {i % 2 === 0 ? `${Math.floor(i/2) + 1}. ` : ''}{move}
102 |                             </span>
103 |                         ))}
104 |                     </div>
105 |                 </div>
106 |             );
107 |         }
108 | 
109 |         function ChatHistory({ gameState }) {
110 |             const messagesEndRef = React.useRef(null);
111 |             
112 |             React.useEffect(() => {
113 |                 messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
114 |             }, [gameState.chat_history]);
115 | 
116 |             return (
117 |                 <div className="chat-container">
118 |                     <h2>Game Chat</h2>
119 |                     <div className="chat-messages">
120 |                         {gameState.chat_history.map((msg, i) => (
121 |                             <div key={i} className="chat-message">
122 |                                 <span className={
123 |                                     msg.player_id === -1 ? 'game-message' :
124 |                                     msg.player_id === 0 ? 'white-player' : 'black-player'
125 |                                 }>
126 |                                     {msg.player_id === -1 ? 'Game' : gameState.player_names[msg.player_id]}:
127 |                                 </span>
128 |                                 <div>{msg.message}</div>
129 |                             </div>
130 |                         ))}
131 |                         <div ref={messagesEndRef} />
132 |                     </div>
133 |                 </div>
134 |             );
135 |         }
136 | 
137 |         const root = ReactDOM.createRoot(document.getElementById('root'));
138 |         root.render(<ChessGame />);
139 |         
```

## File: textarena/static/chess/style.css

- Extension: .css
- Language: unknown
- Size: 2133 bytes
- Created: 2024-12-13 10:59:09
- Modified: 2024-12-13 10:59:09

### Code

```unknown
 1 | 
 2 |         body {
 3 |             background-color: #2B2B2B;
 4 |             color: #FFFFFF;
 5 |             font-family: Arial, sans-serif;
 6 |             margin: 0;
 7 |             padding: 20px;
 8 |         }
 9 | 
10 |         .game-container {
11 |             display: flex;
12 |             flex-direction: column;
13 |             gap: 20px;
14 |             max-width: 1200px;
15 |             margin: 0 auto;
16 |         }
17 | 
18 |         .main-content {
19 |             display: flex;
20 |             gap: 20px;
21 |         }
22 | 
23 |         .board-container {
24 |             flex: 0 0 600px;
25 |             background: #363636;
26 |             padding: 20px;
27 |             border-radius: 8px;
28 |         }
29 | 
30 |         .chess-board {
31 |             display: grid;
32 |             grid-template-columns: repeat(8, 1fr);
33 |             width: 600px;
34 |             height: 600px;
35 |             border: 2px solid #404040;
36 |         }
37 | 
38 |         .square {
39 |             width: 75px;
40 |             height: 75px;
41 |             display: flex;
42 |             justify-content: center;
43 |             align-items: center;
44 |         }
45 | 
46 |         .square.light { background-color: #EEEED2; }
47 |         .square.dark { background-color: #769656; }
48 | 
49 |         .piece-img {
50 |             width: 60px;
51 |             height: 60px;
52 |             user-select: none;
53 |         }
54 | 
55 |         .info-container {
56 |             flex: 1;
57 |             background: #363636;
58 |             padding: 20px;
59 |             border-radius: 8px;
60 |         }
61 | 
62 |         .chat-container {
63 |             background: #363636;
64 |             padding: 20px;
65 |             border-radius: 8px;
66 |             margin-top: 20px;
67 |         }
68 | 
69 |         .chat-messages {
70 |             height: 300px;
71 |             overflow-y: auto;
72 |             background: #2B2B2B;
73 |             padding: 15px;
74 |             border-radius: 4px;
75 |             margin-top: 10px;
76 |         }
77 | 
78 |         .chat-message {
79 |             margin-bottom: 10px;
80 |             padding: 8px;
81 |             border-radius: 4px;
82 |             background: #404040;
83 |         }
84 | 
85 |         .white-player { color: #FFFFFF; }
86 |         .black-player { color: #A0A0A0; }
87 |         .game-message { color: #4CAF50; }
88 | 
89 |         .move-history {
90 |             font-family: monospace;
91 |             margin-top: 10px;
92 |         }
93 |         
```

## File: textarena/wrappers/static/app.js

- Extension: .js
- Language: javascript
- Size: 4625 bytes
- Created: 2024-12-12 16:22:22
- Modified: 2024-12-12 16:22:22

### Code

```javascript
  1 | 
  2 | function GameUI({ gameState }) {
  3 |     const { fen, chat_history, player_names, current_player, is_check, is_checkmate, 
  4 |             is_stalemate, is_insufficient_material, move_stack } = gameState;
  5 | 
  6 |     return (
  7 |         <div>
  8 |             <div className="game-container">
  9 |                 <ChessBoard fen={fen} />
 10 |                 <div className="info-container">
 11 |                     <h2>Game Status</h2>
 12 |                     <div>
 13 |                         <p>Current Turn: {current_player}</p>
 14 |                         {is_check && <p className="text-red-500">Check!</p>}
 15 |                         {is_checkmate && <p className="text-red-500">Checkmate!</p>}
 16 |                         {is_stalemate && <p className="text-yellow-500">Stalemate</p>}
 17 |                         {is_insufficient_material && 
 18 |                             <p className="text-yellow-500">Draw (Insufficient Material)</p>}
 19 |                     </div>
 20 |                     
 21 |                     <h3>Players</h3>
 22 |                     <div>
 23 |                         {Object.entries(player_names).map(([id, name]) => (
 24 |                             <div key={id}>
 25 |                                 {name} ({id === '0' ? 'White' : 'Black'})
 26 |                             </div>
 27 |                         ))}
 28 |                     </div>
 29 |                     
 30 |                     <h3>Move History</h3>
 31 |                     <div className="move-history">
 32 |                         {move_stack.map((move, i) => (
 33 |                             <span key={i} style={{marginRight: '10px'}}>
 34 |                                 {i % 2 === 0 ? `${Math.floor(i/2) + 1}. ` : ''}{move}
 35 |                             </span>
 36 |                         ))}
 37 |                     </div>
 38 |                 </div>
 39 |             </div>
 40 |             <ChatHistory messages={chat_history} playerNames={player_names} />
 41 |         </div>
 42 |     );
 43 | }
 44 | 
 45 | function ChessBoard({ fen }) {
 46 |     if (!fen) return <div className="board-container">Loading...</div>;
 47 | 
 48 |     const renderSquare = (i) => {
 49 |         const file = i % 8;
 50 |         const rank = Math.floor(i / 8);
 51 |         const isLight = (file + rank) % 2 === 0;
 52 |         const piece = getPiece(fen, i);
 53 |         
 54 |         return (
 55 |             <div key={i} className={`square ${isLight ? 'light' : 'dark'}`}>
 56 |                 {piece && <img 
 57 |                     src={`/static/pieces/${piece}.png`}
 58 |                     alt={piece}
 59 |                     className="piece-img"
 60 |                 />}
 61 |             </div>
 62 |         );
 63 |     };
 64 | 
 65 |     return (
 66 |         <div className="board-container">
 67 |             <div className="chess-board">
 68 |                 {[...Array(64)].map((_, i) => renderSquare(i))}
 69 |             </div>
 70 |         </div>
 71 |     );
 72 | }
 73 | 
 74 | function getPiece(fen, squareIndex) {
 75 |     const [position] = fen.split(' ');
 76 |     const rows = position.split('/');
 77 |     const rank = Math.floor(squareIndex / 8);
 78 |     const file = squareIndex % 8;
 79 |     
 80 |     let currentFile = 0;
 81 |     const row = rows[7 - rank];
 82 |     
 83 |     for (let i = 0; i < row.length; i++) {
 84 |         const char = row[i];
 85 |         if (isNaN(char)) {
 86 |             if (currentFile === file) {
 87 |                 return char;
 88 |             }
 89 |             currentFile++;
 90 |         } else {
 91 |             currentFile += parseInt(char);
 92 |         }
 93 |         if (currentFile > file) break;
 94 |     }
 95 |     return null;
 96 | }
 97 | 
 98 | function ChatHistory({ messages, playerNames }) {
 99 |     const messagesEndRef = React.useRef(null);
100 |     
101 |     React.useEffect(() => {
102 |         messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
103 |     }, [messages]);
104 | 
105 |     if (!messages || messages.length === 0) return null;
106 | 
107 |     return (
108 |         <div className="chat-container">
109 |             <h2>Game Conversation</h2>
110 |             <div className="chat-messages">
111 |                 {messages.map((msg, index) => {
112 |                     const isGameMessage = msg.player_id === -1;
113 |                     const className = msg.player_id === 0 ? 'white' : 'black';
114 |                     return (
115 |                         <div key={index} className={`chat-message ${className}`}>
116 |                             <div className="player-name">
117 |                                 {isGameMessage ? 'Game' : playerNames[msg.player_id]}:
118 |                             </div>
119 |                             <div>{msg.message}</div>
120 |                         </div>
121 |                     );
122 |                 })}
123 |                 <div ref={messagesEndRef} />
124 |             </div>
125 |         </div>
126 |     );
127 | }
128 | 
129 | const root = ReactDOM.createRoot(document.getElementById('root'));
130 | root.render(<GameUI gameState={window.initialGameState || {
131 |     fen: '',
132 |     chat_history: [],
133 |     player_names: {},
134 |     current_player: '',
135 |     move_stack: []
136 | }} />);
```

## File: textarena/wrappers/static/style.css

- Extension: .css
- Language: unknown
- Size: 1854 bytes
- Created: 2024-12-12 16:22:22
- Modified: 2024-12-12 16:22:22

### Code

```unknown
  1 | 
  2 | body { 
  3 |     background-color: #2B2B2B;
  4 |     color: #FFFFFF;
  5 |     font-family: Arial, sans-serif;
  6 |     margin: 0;
  7 |     padding: 20px;
  8 | }
  9 | 
 10 | .connection-status {
 11 |     position: fixed;
 12 |     top: 10px;
 13 |     right: 10px;
 14 |     padding: 5px 10px;
 15 |     border-radius: 4px;
 16 |     font-size: 0.8em;
 17 | }
 18 | 
 19 | .connection-status.connected {
 20 |     background: #4CAF50;
 21 | }
 22 | 
 23 | .connection-status.disconnected {
 24 |     background: #F44336;
 25 | }
 26 | 
 27 | .chat-container {
 28 |     margin-top: 20px;
 29 |     background: #363636;
 30 |     padding: 20px;
 31 |     border-radius: 8px;
 32 |     max-width: 1200px;
 33 |     margin-left: auto;
 34 |     margin-right: auto;
 35 | }
 36 | 
 37 | .chat-messages {
 38 |     height: 300px;
 39 |     overflow-y: auto;
 40 |     background: #2B2B2B;
 41 |     padding: 15px;
 42 |     border-radius: 4px;
 43 |     margin-top: 10px;
 44 | }
 45 | 
 46 | .chat-message {
 47 |     margin-bottom: 15px;
 48 |     padding: 10px;
 49 |     border-radius: 4px;
 50 |     background: #404040;
 51 | }
 52 | 
 53 | .chat-message .player-name {
 54 |     font-weight: bold;
 55 |     margin-bottom: 5px;
 56 | }
 57 | 
 58 | 
 59 | .game-container {
 60 |     display: flex;
 61 |     gap: 20px;
 62 |     max-width: 1200px;
 63 |     margin: 0 auto;
 64 | }
 65 | 
 66 | .board-container {
 67 |     flex: 0 0 600px;
 68 |     background: #363636;
 69 |     padding: 20px;
 70 |     border-radius: 8px;
 71 | }
 72 | 
 73 | .chess-board {
 74 |     display: grid;
 75 |     grid-template-columns: repeat(8, 1fr);
 76 |     width: 600px;
 77 |     height: 600px;
 78 |     border: 2px solid #404040;
 79 | }
 80 | 
 81 | .square {
 82 |     width: 75px;
 83 |     height: 75px;
 84 |     display: flex;
 85 |     justify-content: center;
 86 |     align-items: center;
 87 | }
 88 | 
 89 | .square.light {
 90 |     background-color: #EEEED2;
 91 | }
 92 | 
 93 | .square.dark {
 94 |     background-color: #769656;
 95 | }
 96 | 
 97 | .piece-img {
 98 |     width: 60px;
 99 |     height: 60px;
100 |     user-select: none;
101 | }
102 | 
103 | .info-container {
104 |     flex: 1;
105 |     background: #363636;
106 |     padding: 20px;
107 |     border-radius: 8px;
108 | }
109 | 
110 | .move-history {
111 |     height: 300px;
112 |     overflow-y: auto;
113 |     background: #2B2B2B;
114 |     padding: 10px;
115 |     border-radius: 4px;
116 |     margin-top: 10px;
117 |     font-family: monospace;
118 | }
```

## File: textarena/wrappers/static/textarena-icon.xbm

- Extension: .xbm
- Language: unknown
- Size: 1008 bytes
- Created: 2024-12-13 11:38:08
- Modified: 2024-11-17 13:43:24

### Code

```unknown
 1 | #define 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_width 32
 2 | #define 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_height 32
 3 | static char 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_bits[] = {
 4 |   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 5 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
 6 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
 7 |   0x00, 0x80, 0x01, 0x00, 0x00, 0xD0, 0x0B, 0x00, 0x00, 0x80, 0x01, 0x00, 
 8 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 
 9 |   0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x87, 0xE3, 0x00, 
10 |   0x00, 0x9F, 0xFF, 0x00, 0x80, 0xBF, 0xFF, 0x01, 0x80, 0xFF, 0xFF, 0x01, 
11 |   0xC0, 0xE1, 0x87, 0x03, 0x00, 0x80, 0x01, 0x00, 0x00, 0xC0, 0x03, 0x00, 
12 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
13 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
14 |   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
```

## File: textarena/wrappers/renderers/textarena-icon.xbm

- Extension: .xbm
- Language: unknown
- Size: 1008 bytes
- Created: 2024-12-13 11:29:35
- Modified: 2024-11-17 13:43:24

### Code

```unknown
 1 | #define 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_width 32
 2 | #define 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_height 32
 3 | static char 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_bits[] = {
 4 |   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 5 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
 6 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
 7 |   0x00, 0x80, 0x01, 0x00, 0x00, 0xD0, 0x0B, 0x00, 0x00, 0x80, 0x01, 0x00, 
 8 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 
 9 |   0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x87, 0xE3, 0x00, 
10 |   0x00, 0x9F, 0xFF, 0x00, 0x80, 0xBF, 0xFF, 0x01, 0x80, 0xFF, 0xFF, 0x01, 
11 |   0xC0, 0xE1, 0x87, 0x03, 0x00, 0x80, 0x01, 0x00, 0x00, 0xC0, 0x03, 0x00, 
12 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
13 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
14 |   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
```

## File: textarena/wrappers/renderers/base.py

- Extension: .py
- Language: python
- Size: 12976 bytes
- Created: 2024-12-13 11:39:41
- Modified: 2024-12-13 11:39:41

### Code

```python
  1 | from fastapi import FastAPI, WebSocket
  2 | from fastapi.responses import HTMLResponse
  3 | from fastapi.staticfiles import StaticFiles
  4 | import json
  5 | import asyncio
  6 | from typing import Dict, Optional, Set, Any
  7 | import uvicorn
  8 | import threading
  9 | from pathlib import Path
 10 | from abc import ABC, abstractmethod
 11 | import time
 12 | 
 13 | class BaseRenderer(ABC):
 14 |     def __init__(self, env: Any, player_names: Optional[Dict[int, str]] = None, port: int = 8000):
 15 |         self.env = env
 16 |         self.player_names = player_names or {i: f"Player {i}" for i in range(env.state.num_players)}
 17 |         self.port = port
 18 |         self.active_connections: Set[WebSocket] = set()
 19 |         self.chat_history = []
 20 |         self.end_game_state = None
 21 |         
 22 |         
 23 |         self.static_dir = Path(__file__).parent.parent.parent / "static"
 24 |         self.static_dir.mkdir(exist_ok=True)
 25 |         
 26 |         
 27 |         self._setup_icon()
 28 |         
 29 |         
 30 |         self._setup_static_files()
 31 |         self.app = self._create_app()
 32 |         
 33 |         self.server_thread = threading.Thread(target=self._run_server, daemon=True)
 34 |         self.server_thread.start()
 35 |         time.sleep(1)
 36 | 
 37 | 
 38 |     def _create_app(self) -> FastAPI:
 39 |         
 40 |         app = FastAPI()
 41 |         app.mount("/static", StaticFiles(directory=str(self.static_dir)), name="static")
 42 | 
 43 |         @app.get("/")
 44 |         async def index():
 45 |             return HTMLResponse(self._get_html())
 46 | 
 47 |         @app.websocket("/ws")
 48 |         async def websocket_endpoint(websocket: WebSocket):
 49 |             await websocket.accept()
 50 |             self.active_connections.add(websocket)
 51 |             try:
 52 |                 await self.broadcast_state()
 53 |                 while True:
 54 |                     await websocket.receive_text()
 55 |                     await websocket.send_json({"status": "ok"})
 56 |             except:
 57 |                 pass
 58 |             finally:
 59 |                 self.active_connections.remove(websocket)
 60 | 
 61 |         return app
 62 | 
 63 |     def _run_server(self):
 64 |         
 65 |         config = uvicorn.Config(
 66 |             self.app,
 67 |             host="127.0.0.1",
 68 |             port=self.port,
 69 |             log_level="error"
 70 |         )
 71 |         server = uvicorn.Server(config)
 72 |         server.run()
 73 | 
 74 |     def _setup_static_files(self):
 75 |         
 76 |         
 77 |         static_dir = self.static_dir
 78 |         static_dir.mkdir(exist_ok=True)
 79 |         
 80 |         
 81 |         icon_paths = [
 82 |             Path(__file__).parent.parent.parent / "textarena-icon.ico",
 83 |             Path(__file__).parent.parent.parent / "textarena-icon.png",
 84 |             Path(__file__).parent.parent.parent / "textarena-icon.xbm",
 85 |             Path(__file__).parent.parent / "textarena-icon.ico",
 86 |             Path(__file__).parent.parent / "textarena-icon.png",
 87 |             Path(__file__).parent.parent / "textarena-icon.xbm",
 88 |         ]
 89 |         
 90 |         for icon_path in icon_paths:
 91 |             if icon_path.exists():
 92 |                 
 93 |                 icon_dest = static_dir / f"favicon{icon_path.suffix}"
 94 |                 shutil.copy(icon_path, icon_dest)
 95 |                 self.icon_file = f"favicon{icon_path.suffix}"
 96 |                 break
 97 |         else:
 98 |             self.icon_file = None
 99 |         
100 |         
101 |         css_content = self._get_base_css() + "\n" + self.get_custom_css()
102 |         (static_dir / "style.css").write_text(css_content)
103 |         
104 |         js_content = self._get_base_js() + "\n" + self.get_custom_js()
105 |         (static_dir / "app.js").write_text(js_content)
106 | 
107 |     def _setup_icon(self):
108 |         
109 |         
110 |         icon_paths = [
111 |             Path(__file__).parent.parent.parent / "textarena-icon.ico",
112 |             Path(__file__).parent.parent.parent / "textarena-icon.png",
113 |             Path(__file__).parent.parent.parent / "textarena-icon.xbm"
114 |         ]
115 |         
116 |         for icon_path in icon_paths:
117 |             if icon_path.exists():
118 |                 
119 |                 icon_dest = self.static_dir / icon_path.name
120 |                 shutil.copy(icon_path, icon_dest)
121 |                 break
122 | 
123 |     def _get_html(self) -> str:
124 |         
125 |         
126 |         for ext in ['.ico', '.png', '.xbm']:
127 |             if (self.static_dir / f"textarena-icon{ext}").exists():
128 |                 icon_file = f"textarena-icon{ext}"
129 |                 break
130 |         else:
131 |             icon_file = None
132 | 
133 |         icon_link = f'<link rel="icon" href="/static/{icon_file}">' if icon_file else ''
134 |         
135 |         return f
136 | 
137 |     def _get_base_css(self) -> str:
138 |         
139 |         return 
140 | 
141 |     def _get_base_js(self) -> str:
142 |         
143 |         return 
144 | 
145 | 
146 |     def set_end_game_state(self, rewards: Dict[int, float], info: Dict[str, Any]):
147 |         
148 |         
149 |         winner_text = ""
150 |         if rewards:
151 |             max_reward = max(rewards.values())
152 |             winners = [pid for pid, r in rewards.items() if r == max_reward]
153 |             if len(winners) > 1:
154 |                 winner_text = "Game ended in a draw"
155 |             else:
156 |                 winner = winners[0]
157 |                 winner_text = f"Winner: {self.player_names[winner]}"
158 | 
159 |         
160 |         reason = info.get('reason', 'Game Over')
161 | 
162 |         
163 |         for pid, player_name in self.player_names.items():
164 |             reason = reason.replace(f"Player {pid}", player_name)
165 | 
166 |  
167 | 
168 |         self.end_game_state = {
169 |             "winner_text": winner_text,
170 |             "reason": reason
171 |         }
172 |         self.draw()
173 | 
174 |     def draw(self):
175 |         
176 |         if self.active_connections:
177 |             asyncio.run(self.broadcast_state())
178 | 
179 |     async def broadcast_state(self):
180 |         
181 |         if not self.active_connections:
182 |             return
183 |             
184 |         try:
185 |             state = self.get_state()
186 |             state["player_names"] = self.player_names
187 |             state["chat_history"] = self.chat_history
188 |             state["end_game_state"] = self.end_game_state
189 |             
190 |             await asyncio.gather(*[
191 |                 conn.send_json(state) 
192 |                 for conn in list(self.active_connections)
193 |             ])
194 |         except Exception as e:
195 |             print(f"Error broadcasting state: {e}")
196 | 
197 |     @abstractmethod
198 |     def get_state(self) -> dict:
199 |         
200 |         pass
201 | 
202 |     def get_custom_css(self) -> str:
203 |         
204 |         return ""
205 | 
206 |     def get_custom_js(self) -> str:
207 |         
208 |         return ""
```

## File: textarena/wrappers/renderers/chess.py

- Extension: .py
- Language: python
- Size: 11335 bytes
- Created: 2024-12-13 11:39:13
- Modified: 2024-12-13 11:39:13

### Code

```python
 1 | from .base import BaseRenderer
 2 | import shutil
 3 | from pathlib import Path
 4 | 
 5 | class ChessRenderer(BaseRenderer):
 6 |     def __init__(self, env, player_names=None, port=8000):
 7 |         super().__init__(env, player_names, port)
 8 |         self._setup_piece_images()
 9 | 
10 |     def _setup_piece_images(self):
11 |         
12 |         pieces_dir = self.static_dir / "pieces"
13 |         pieces_dir.mkdir(exist_ok=True)
14 |         
15 |         
16 |         source_dir = Path(__file__).parent / "static" / "pieces"
17 |         if source_dir.exists():
18 |             for piece in ['P', 'N', 'B', 'R', 'Q', 'K', 'p', 'n', 'b', 'r', 'q', 'k']:
19 |                 src = source_dir / f"{piece}.png"
20 |                 if src.exists():
21 |                     shutil.copy(src, pieces_dir / f"{piece}.png")
22 | 
23 |     def get_state(self) -> dict:
24 |         
25 |         try:
26 |             board = self.env.board
27 |             return {
28 |                 "fen": board.fen() if board else "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
29 |                 "current_player": "White" if board and board.turn else "White",
30 |                 "is_check": board.is_check() if board else False,
31 |                 "is_checkmate": board.is_checkmate() if board else False,
32 |                 "is_stalemate": board.is_stalemate() if board else False,
33 |                 "move_stack": [move.uci() for move in board.move_stack] if board else [],
34 |                 "valid_moves": [move.uci() for move in board.legal_moves] if board else []
35 |             }
36 |         except Exception as e:
37 |             print(f"Error getting state: {e}")
38 |             return {
39 |                 "fen": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
40 |                 "current_player": "White",
41 |                 "is_check": False,
42 |                 "is_checkmate": False,
43 |                 "is_stalemate": False,
44 |                 "move_stack": [],
45 |                 "valid_moves": []
46 |             }
47 | 
48 |     def get_custom_js(self) -> str:
49 |         return 
50 | 
51 |     def get_custom_css(self) -> str:
52 |         return 
```

## File: textarena/wrappers/renderers/static/textarena-icon.xbm

- Extension: .xbm
- Language: unknown
- Size: 1008 bytes
- Created: 2024-12-13 11:29:32
- Modified: 2024-11-17 13:43:24

### Code

```unknown
 1 | #define 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_width 32
 2 | #define 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_height 32
 3 | static char 06013c50e48f4b89d69c4dc30f4cf322d3DpI3b4bs93bVYU_bits[] = {
 4 |   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 5 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
 6 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
 7 |   0x00, 0x80, 0x01, 0x00, 0x00, 0xD0, 0x0B, 0x00, 0x00, 0x80, 0x01, 0x00, 
 8 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 
 9 |   0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x87, 0xE3, 0x00, 
10 |   0x00, 0x9F, 0xFF, 0x00, 0x80, 0xBF, 0xFF, 0x01, 0x80, 0xFF, 0xFF, 0x01, 
11 |   0xC0, 0xE1, 0x87, 0x03, 0x00, 0x80, 0x01, 0x00, 0x00, 0xC0, 0x03, 0x00, 
12 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 
13 |   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
14 |   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
```

## File: textarena/envs/two_player/word_chains.py

- Extension: .py
- Language: python
- Size: 8120 bytes
- Created: 2024-10-21 15:35:01
- Modified: 2024-10-21 15:35:01

### Code

```python
  1 | 
  2 | 
  3 | from typing import Optional, Tuple
  4 | import random
  5 | import re
  6 | import textarena as ta
  7 | import nltk
  8 | from nltk.corpus import words
  9 | 
 10 | nltk.download("words")
 11 | nltk_words = set(word.lower() for word in words.words())
 12 | 
 13 | 
 14 | class WordChainsEnv(ta.Env):
 15 |     
 16 | 
 17 |     def __init__(
 18 |         self,
 19 |         max_turns: Optional[int] = None,
 20 |     ):
 21 |         
 22 |         self.environment_name = "Word Chains Game"
 23 | 
 24 |         
 25 |         self.word_list = list(nltk_words)
 26 | 
 27 |         
 28 |         self.state = ta.State(
 29 |             num_players=2,
 30 |             max_turns=max_turns,
 31 |             render_keys=["starting_word", "required_start_letter"]
 32 |         )
 33 | 
 34 |     def reset(self, seed: Optional[int] = None) -> Tuple[ta.Observation, ta.Info]:
 35 |         
 36 |         if seed is not None:
 37 |             random.seed(seed)
 38 |         else:
 39 |             random.seed()
 40 | 
 41 | 
 42 |         game_state = {"starting_word": random.choice(self.word_list)}
 43 |         game_state["used_words"] = set(game_state["starting_word"])
 44 |         game_state["required_start_letter"] = game_state["starting_word"][-1].lower()
 45 |         
 46 | 
 47 |         
 48 |         observations = {
 49 |             0: [(ta.GAME_ID, self._generate_player_prompt(player_id=0, starting_word=game_state["starting_word"]))],
 50 |             1: [(ta.GAME_ID, self._generate_player_prompt(player_id=1, starting_word=game_state["starting_word"]))],
 51 |         }
 52 | 
 53 |         info = {
 54 |             "starting_word": game_state["starting_word"],
 55 |             "required_start_letter": game_state["required_start_letter"],
 56 |         }
 57 | 
 58 |         self.state.reset(
 59 |             game_state=game_state,
 60 |             initial_logs=[
 61 |                 (ta.GAME_ID, "Game started.")
 62 |             ]
 63 |         )
 64 | 
 65 |         return observations, info
 66 | 
 67 |     def _generate_player_prompt(self, player_id: int, starting_word: str) -> ta.Message:
 68 |         
 69 |         prompt = (
 70 |             f"You are Player {player_id} in the Word Chains Game.\n"
 71 |             "Players take turns to provide valid English words that start with the last letter of the previous word.\n"
 72 |             "Repetition of words is not allowed.\n"
 73 |             "If you provide an invalid word, repeat a word, or fail to follow the sequence, you lose.\n"
 74 |             "Please wrap your word in square brackets, e.g., '[apple]', '[monkey'], etc. .\n"
 75 |             f"The starting word is [{starting_word}]. Please provide the next word.\n"
 76 |             "On your turn, simply type your word.\n"
 77 |         )
 78 |         if self.state.max_turns:
 79 |             prompt += f"The game will end after {self.state.max_turns} turns if no player loses.\n"
 80 |         return prompt
 81 | 
 82 |     def step(
 83 |         self,
 84 |         player_id: int,
 85 |         action: str,
 86 |     ) -> Tuple[
 87 |         Optional[ta.Observation],  
 88 |         Optional[ta.Reward],  
 89 |         bool,  
 90 |         bool,  
 91 |         ta.Info,  
 92 |     ]:
 93 |         
 94 |         assert isinstance(
 95 |             action, str
 96 |         ), f"Actions are required to be strings. Received dtype: {type(action)}"
 97 | 
 98 |         assert (
 99 |             player_id == self.state.current_player
100 |         ), f"The passed player_id is not as expected. Player id received: {player_id}; Expected: {self.state.current_player}"
101 | 
102 | 
103 |         terminated, truncated = False, False
104 |         self.step_logs = []
105 |         observations = {0: [], 1: []}
106 |         reward = None
107 |         info = {}
108 | 
109 | 
110 |         
111 |         self.step_logs.append((player_id, action))
112 | 
113 |         observations[player_id].append((player_id, action))
114 |         observations[1-player_id].append((player_id, action))
115 | 
116 | 
117 |         
118 |         word_match = re.search(r"\[(\w+)\]", action)
119 |         if not word_match:
120 |             
121 |             terminated = True 
122 |             reward = {player_id: -1, 1-player_id:0}
123 |             info["reason"] = "Invalid format. Word must be enclosed in square brackets."
124 |         else:
125 |             word = word_match.group(1).lower()
126 |             
127 |             if not word.startswith(self.state.game_state["required_start_letter"]):
128 |                 terminated = True
129 |                 reward = {player_id: -1, 1-player_id: 1}
130 |                 info["reason"] = f"Word does not start with the required letter '{self.game_state['required_start_letter']}'."
131 | 
132 |             
133 |             elif word not in self.word_list:
134 |                 terminated = True
135 |                 reward = {player_id: -1, 1-player_id: 1}
136 |                 info["reason"] = f"'{word}' is not a valid English word."
137 | 
138 |             
139 |             elif word in self.state.    game_state["used_words"]:
140 |                 terminated = True
141 |                 reward = {player_id: -1, 1-player_id: 1}
142 |                 info["reason"] = f"Word '{word}' has already been used."
143 | 
144 |                 
145 |             if (
146 |                 self.state.max_turns
147 |                 and self.state.turn >= self.state.max_turns
148 |             ):
149 |                 truncated = True
150 |                 reward = {0: 0, 1: 0}
151 |                 info["reason"] = "Maximum number of turns reached. The game is a draw."
152 | 
153 | 
154 |         if "reason" in info:
155 |             self.step_logs.append((ta.GAME_ID, info["reason"]))
156 | 
157 |         
158 |         self.state.game_state["used_words"].add(word)
159 |         self.state.game_state["required_start_letter"] = word[-1].lower()
160 | 
161 |         
162 |         self.state.step(
163 |             logging_messages=self.step_logs
164 |         )
165 | 
166 | 
167 |         return observations, reward, truncated, terminated, info
168 | 
169 |     def render(self):
170 |         
171 |         print(
172 |             f"Turn: {self.game_state['turn']}/{self.game_state['max_turns'] if self.game_state['max_turns'] else '∞'}"
173 |         )
174 |         print("Game Logs:")
175 |         for id_, log in self.game_state.logs:
176 |             if id_ >= 0:
177 |                 print(f"Player {id_}: {log}")
178 |             else:
179 |                 print(f"Game: {log}")
180 |         print("\n")
```

## File: textarena/envs/two_player/README.md

- Extension: .md
- Language: markdown
- Size: 10198 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Two-Player Games
  2 | 
  3 | This directory contains two-player games designed for competitive or collaborative interactions between agents. Each game allows language models (LLMs) to showcase their reasoning, strategy, and decision-making skills. The games listed below are organized with their current development status and a brief description.
  4 | 
  5 | ## Games Overview
  6 | 
  7 | | Game                                  | Description                                                                                                                                                        | Status              |
  8 | |---------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------|
  9 | | **Battleship**                        | Players take turns guessing the location of their opponent’s ships on a grid, aiming to "sink" all ships first.                                                   | Done                |
 10 | | **Car Puzzle**                        | A competitive puzzle where players arrange cars in a grid according to specific rules.                                                                            | Buggy, not done     |
 11 | | **Chess**                             | Classic chess game where each player aims to checkmate their opponent.                                                                                            | Done, not tested    |
 12 | | **Code Creation**                     | Players collaboratively or competitively generate code to solve specific tasks or challenges.                                                                     | -                   |
 13 | | **Connect Four**                      | A classic game where players try to connect four pieces in a row on a grid.                                                                                       | Done, not tested    |
 14 | | **Debate**                            | Players debate a topic, aiming to present stronger arguments than their opponent.                                                                                 | Done, not tested    |
 15 | | **Don't Say It**                      | A word-guessing game where players must communicate without using certain restricted words.                                                                       | Done, not tested    |
 16 | | **Iterated Prisoner's Dilemma with Chat** | Classic iterated Prisoner's Dilemma game where players can communicate before each round to establish trust or deception strategies.                       | Done                |
 17 | | **Liar's Dice**                       | Players bluff and bid on the dice values each one possesses, aiming to outwit the opponent.                                                                      | Done, not tested    |
 18 | | **Letter Auction**                    | Players "bid" on letters to form the highest-scoring word. Each player has limited points to bid, aiming to create the most valuable word.                       | Done                |
 19 | | **Mastermind**                        | One player sets a code, and the other tries to guess it with feedback on each attempt.                                                                           | Done                |
 20 | | **Math Proof**                        | Players take turns to solve math problems or present proofs, competing to answer correctly and efficiently.                                                       | -                   |
 21 | | **Memory Game**                       | Players try to match pairs of cards, testing their memory skills.                                                                                                 | Done                |
 22 | | **Negotiation**                       | Players negotiate to reach mutually beneficial outcomes or agreements based on set rules.                                                                         | Done, not tested    |
 23 | | **Poker**                             | Players compete in a simplified poker game, aiming to win by forming the highest-value hand.                                                                      | Buggy, not done     |
 24 | | **Scenario Planning**                 | Players propose and discuss future scenarios based on a given prompt or context.                                                                                  | Done, not tested    |
 25 | | **Spelling Bee**                      | Players compete to spell increasingly complex words correctly.                                                                                                    | Done, not tested    |
 26 | | **Spite and Malice**                  | A card game where players aim to play their cards in sequence, aiming to finish their deck before the opponent.                                                  | Done                |
 27 | | **Taboo**                             | Players must describe a word without using a list of restricted terms.                                                                                            | Done, not tested    |
 28 | | **Truth or Deception**                | One player provides information, and the other must determine if it’s true or deceptive. Facts may need to be verified.                                           | Done, not tested / Fact-check needed |
 29 | | **Word Chains**                       | Players take turns saying words that start with the last letter of the previous word.                                                                             | Done, not tested    |
 30 | 
 31 | Above is a list of two-player games currently included in this module. Each game is marked with its current development status, and each game is organized in its own folder, containing the following components:
 32 | 
 33 | 1. **README.md**: Provides a detailed description of the game, setup instructions, and usage examples.
 34 | 2. **Game Environment Class** (`env.py`): Implements the core logic and rules of the game environment.
 35 | 3. **Test Module** (`test.py`): Contains test cases to ensure the game environment functions as expected.
 36 | 4. **Example Script** (`example.py`): Demonstrates how to initialize, configure, and run the game environment, allowing users to quickly get started and see a working example in action.
 37 | 
 38 | This structure ensures that each game environment is self-contained and easy to understand, modify, and test independently. Users can navigate to each game's folder to find everything needed to set up and explore that specific environment.
 39 | 
 40 | ## Getting Started
 41 | 
 42 | For most two-player games, a Standard Turn-Based Cycle is used. In this approach, players alternate turns in a straightforward, predictable manner: after Agent0 completes one action in the environment, it becomes Agent1's turn to act.
 43 | 
 44 | However, some two-player games follow a more flexible Dynamic Turn-Based Cycle. In this cycle, Agent0 can take multiple actions consecutively, with each action generating a new observation state that informs the next action. Once Agent0 completes its entire sequence of actions, Agent1 then follows the same pattern.
 45 | 
 46 | To support these varying turn-based structures, we’ve designed a `State` class that efficiently manages these mechanics, ensuring a consistent interface across different games. This allows the game loop code to remain uniform and intuitive, regardless of whether a game uses a Standard or Dynamic Turn-Based Cycle.
 47 | 
 48 | This section will guide you through setting up and playing a two-player game environment using a registered game, `Battleship-v0-easy`, as an example.
 49 | 
 50 | ### 1. Environment Registration
 51 | 
 52 | Each game environment is registered in the `init.py` script (found [here](../__init__.py)), specifying its `id`, `entry_point`, and any game-specific configurations (e.g., difficulty level, max turns). You can view or modify the list of registered environments in this script. Here’s an example registration:
 53 | 
 54 | ```python
 55 | register(
 56 |     "Battleship-v0-easy",
 57 |     entry_point="textarena.envs.two_player.Battleship.env:BattleshipEnv",
 58 |     difficulty="easy",
 59 | )
 60 | ```
 61 | ### 2. Initialize the Environment
 62 | To start a game, initialize the environment by calling ta.make with the environment’s ID. For better handling of observations and rendering, you can wrap the environment with additional wrappers, such as LLMObservationWrapper and PrettyRenderWrapper:
 63 | 
 64 | ```python
 65 | import textarena as ta
 66 | 
 67 | # Initialize the environment
 68 | env = ta.make("Battleship-v0-easy")
 69 | 
 70 | # Apply wrappers for observation handling and rendering
 71 | env = ta.wrappers.LLMObservationWrapper(env=env)
 72 | env = ta.wrappers.PrettyRenderWrapper(env=env)
 73 | ```
 74 | 
 75 | ### 3. Initialize Agents
 76 | Create an agent to interact with the environment. For example, you can use HFLocalAgent to run a Hugging Face model locally:
 77 | ```python
 78 | # initalize agents
 79 | agents = {
 80 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
 81 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o")
 82 |     }
 83 | ```
 84 | 
 85 | ### 4. Start a New Game and Run the Game Loop
 86 | Reset the environment to start a new game. Implement the game loop where the agent observes, acts, and steps through the game until it's complete:
 87 | ```python
 88 | # reset the environment to start a new game
 89 | observations = env.reset(seed=490)
 90 | 
 91 | # Game loop
 92 | done = False
 93 | while not done:
 94 | 
 95 |     # Get the current player
 96 |     current_player_id = env.state.get("current_player")
 97 | 
 98 |     # Get the current observation for the player
 99 |     obs = observations[current_player_id]
100 | 
101 |     # Agent decides on an action based on the observation
102 |     action = agents[current_player_id](obs)
103 | 
104 |     # Execute the action in the environment
105 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
106 | 
107 |     # Check if the game has ended
108 |     done = terminated or truncated
109 | 
110 |     # Optionally render the environment to see the current state
111 |     env.render()
112 | 
113 |     if done:
114 |         break
115 | ```
116 | 
117 | ### 5. View Game Results
118 | Once the game loop ends, print the results to see the final score or other outcome details:
119 | ```python
120 | # Finally, print the game results
121 | for player_id, agent in agents.items():
122 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
123 | print(f"Reason: {info['reason']}")
124 | ```
125 | 
```

## File: textarena/envs/two_player/__init__.py

- Extension: .py
- Language: python
- Size: 109 bytes
- Created: 2024-11-11 15:47:02
- Modified: 2024-11-11 15:47:02

### Code

```python
1 | 
2 | 
3 | 
4 | 
5 | 
```

## File: textarena/envs/single_player/README.md

- Extension: .md
- Language: markdown
- Size: 7692 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Single Player Games
  2 | 
  3 | Welcome to the Single Player Games module in our repository. This directory houses a collection of text-based games, each designed to serve as an evaluation environment for large language models (LLMs). These games test a variety of skills, including logical reasoning, pattern recognition, decision-making, and adaptability, making them ideal for single-player LLM assessment. Each game environment is implemented to be easily accessible and extendable.
  4 | 
  5 | ## Games Overview
  6 | 
  7 | | Game                  | Description                                                                                                                                                 | Status |
  8 | |-----------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|
  9 | | **20 Questions**      | The model attempts to guess an object by asking up to 20 yes/no questions.                                                                                  | Done   |
 10 | | **Car Puzzle**        | A text-based puzzle where players rearrange cars in a grid to achieve a specific order.                                                                     | -      |
 11 | | **Chess**             | Play chess against a bot opponent, focusing on strategy and tactical decision-making.                                                                       | -      |
 12 | | **Connect Four**      | A classic game where players try to connect four pieces in a row on a grid, adapted for single-player challenges.                                           | -      |
 13 | | **Crosswords**        | Solve text-based crossword puzzles where clues are provided, and words must fit into the grid correctly.                                                    | Done   |
 14 | | **Fifteen Puzzle**    | A sliding puzzle that consists of a frame of numbered square tiles in random order, with one tile missing.                                                 | Done   |
 15 | | **Guess the Number**  | Guess a randomly chosen number within a range, receiving hints to narrow down possibilities.                                                                | Done   |
 16 | | **Guess Who**         | Identify a hidden character by asking yes/no questions to eliminate possibilities.                                                                          | Done   |
 17 | | **Hangman**           | Guess letters to reveal a hidden word before running out of attempts.                                                                                       | Done   |
 18 | | **Logic Puzzles**     | Solve text-based logic puzzles that challenge deductive reasoning and problem-solving skills.                                                               | Done   |
 19 | | **Minesweeper**       | Uncover cells in a grid without triggering hidden mines, using numbers to deduce mine locations.                                                           | Done   |
 20 | | **Sudoku**            | Solve a 9x9 grid by filling each row, column, and subgrid with unique numbers from 1 to 9.                                                                  | Done   |
 21 | | **Tower of Hanoi**    | Move a stack of disks between rods, obeying specific rules, to achieve the correct order on the target rod.                                                 | Done   |
 22 | | **Word Ladder**       | Transform one word into another by changing one letter at a time, with each step forming a valid word.                                                      | Done   |
 23 | | **Word Search**       | Find hidden words within a grid of letters presented in text format.                                                                                        | Done   |
 24 | | **Wordle**      | Guess a hidden five-letter word within six attempts. After each guess, feedback is provided on correct letters and positions to help players narrow down possibilities. | -      |
 25 | 
 26 | 
 27 | Above is a list of single-player games currently included in this module. Each game is marked with its current development status, and aach game is organized in its own folder, containing the following components:
 28 | 
 29 | 1. **README.md**: Provides a detailed description of the game, setup instructions, and usage examples.
 30 | 2. **Game Environment Class** (`env.py`): Implements the core logic and rules of the game environment.
 31 | 3. **Test Module** (`test.py`): Contains test cases to ensure the game environment functions as expected.
 32 | 4. **Example Script** (`example.py`): Demonstrates how to initialize, configure, and run the game environment, allowing users to quickly get started and see a working example in action.
 33 | 
 34 | This structure ensures that each game environment is self-contained and easy to understand, modify, and test independently. Users can navigate to each game's folder to find everything needed to set up and explore that specific environment.
 35 | 
 36 | 
 37 | ## Getting Started
 38 | 
 39 | This section will guide you through setting up and playing a single-player game environment using a registered game, `GuessTheNumber-v0-hardcore`, as an example.
 40 | 
 41 | ### 1. Environment Registration
 42 | 
 43 | Each game environment is registered in the `init.py` script (found [here](../__init__.py)), specifying its `id`, `entry_point`, and any game-specific configurations (e.g., difficulty level, max turns). You can view or modify the list of registered environments in this script. Here’s an example registration:
 44 | 
 45 | ```python
 46 | register(
 47 |     id="GuessTheNumber-v0-hardcore",
 48 |     entry_point="textarena.envs.single_player.GuessTheNumber.env:GuessTheNumberEnv",
 49 |     hardcore=True,
 50 |     max_turns=30,
 51 | )
 52 | ```
 53 | ### 2. Initialize the Environment
 54 | To start a game, initialize the environment by calling ta.make with the environment’s ID. For better handling of observations and rendering, you can wrap the environment with additional wrappers, such as LLMObservationWrapper and PrettyRenderWrapper:
 55 | 
 56 | ```python
 57 | import textarena as ta
 58 | 
 59 | # Initialize the environment
 60 | env = ta.make("GuessTheNumber-v0-hardcore")
 61 | 
 62 | # Apply wrappers for observation handling and rendering
 63 | env = ta.wrappers.LLMObservationWrapper(env=env)
 64 | env = ta.wrappers.PrettyRenderWrapper(env=env)
 65 | ```
 66 | 
 67 | ### 3. Initialize Agents
 68 | Create an agent to interact with the environment. For example, you can use HFLocalAgent to run a Hugging Face model locally:
 69 | ```python
 70 | # initalize agents
 71 | agents = {
 72 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
 73 |     }
 74 | ```
 75 | 
 76 | ### 4. Start a New Game and Run the Game Loop
 77 | Reset the environment to start a new game. Implement the game loop where the agent observes, acts, and steps through the game until it's complete:
 78 | ```python
 79 | # reset the environment to start a new game
 80 | observations = env.reset(seed=490)
 81 | 
 82 | # Game loop
 83 | done = False
 84 | while not done:
 85 | 
 86 |     # Get the current player
 87 |     current_player_id = env.state.get("current_player")
 88 | 
 89 |     # Get the current observation for the player
 90 |     obs = observations[current_player_id]
 91 | 
 92 |     # Agent decides on an action based on the observation
 93 |     action = agents[current_player_id](obs)
 94 | 
 95 |     # Execute the action in the environment
 96 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
 97 | 
 98 |     # Check if the game has ended
 99 |     done = terminated or truncated
100 | 
101 |     # Optionally render the environment to see the current state
102 |     env.render()
103 | 
104 |     if done:
105 |         break
106 | ```
107 | 
108 | ### 5. View Game Results
109 | Once the game loop ends, print the results to see the final score or other outcome details:
110 | ```python
111 | # Finally, print the game results
112 | for player_id, agent in agents.items():
113 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
114 | print(f"Reason: {info['reason']}")
115 | ```
116 | 
```

## File: textarena/envs/single_player/__init__.py

- Extension: .py
- Language: python
- Size: 0 bytes
- Created: 2024-10-18 15:28:49
- Modified: 2024-10-18 15:28:49

### Code

```python

```

## File: textarena/envs/multi_player/codenames.py

- Extension: .py
- Language: python
- Size: 18065 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | 
  2 | 
  3 | 
  4 | 
  5 | 
  6 | from typing import Any, Dict, Optional, Tuple, Union
  7 | import random
  8 | import textarena as ta
  9 | 
 10 | 
 11 | import nltk
 12 | from nltk.corpus import words
 13 | nltk.download('words')
 14 | 
 15 | 
 16 | import re
 17 | 
 18 | class CodenamesEnv(ta.Env):
 19 |     def __init__(
 20 |         self, 
 21 |         hardcore: Optional[bool] = False,
 22 |         grid_size: Optional[int] = 5,
 23 |     ):
 24 |         
 25 |         self.ENVIRONMENT_NAME = "Codenames" if not hardcore else "Codenames (hardcore)"
 26 |         self.grid_size = grid_size
 27 |         
 28 |         
 29 |         if hardcore:
 30 |             self.word_list = words.words("en")
 31 |         else:
 32 |             self.word_list = words.words("en-basic")
 33 |         
 34 |         
 35 |         self.game_state = {
 36 |             "roles_array": 0,
 37 |             "current_team": None,
 38 |             "clue": [],
 39 |             "done": False,
 40 |             "winner": {},
 41 |             "current_role": {},
 42 |             "logs": [],
 43 |         }
 44 | 
 45 |     def reset(
 46 |         self,
 47 |         seed: Optional[int] = None
 48 |     ) -> Tuple[Optional[Dict[int, str]], Dict[int, Any]]:
 49 |         
 50 |         if seed is not None:
 51 |             random.seed(seed)
 52 |         else:
 53 |             random.seed()
 54 |         
 55 |         
 56 |         self.words = random.sample(self.word_list, self.grid_size ** 2) 
 57 |         self.words_and_roles_array, self.roles_array = self._init_word_for_roles() 
 58 | 
 59 |         
 60 |         self.game_state["roles_array"] = self.roles_array.copy()
 61 |         self._update_roles_words() 
 62 |         self.game_state["current_team"] = 0 
 63 |         self.game_state["current_role"] = "spymaster"
 64 |         self.game_state["clue"] = [0, 0]
 65 |         self.game_state["winner"] = None
 66 |         self.game_state["render"] = ["revealed_words", "red_words", "blue_words","neutral_words", "assassin_words","winner"]
 67 | 
 68 | 
 69 |         
 70 |         self.game_state["logs"] = []
 71 |         self.game_state["logs"].append("[GAME] New game started!")
 72 | 
 73 |         
 74 |         return(
 75 |             {   
 76 |                 0: self._generate_spymaster_prompt(player_id=0, team=0),
 77 |                 1: self._generate_field_operatives_prompt(player_id=1, team=0),
 78 |                 2: self._generate_spymaster_prompt(player_id=2, team=1),
 79 |                 3: self._generate_field_operatives_prompt(player_id=3, team=1),
 80 |             },
 81 |             {   
 82 |                 "words": self.words,
 83 |                 "roles": self.roles_array,
 84 |                 "words_and_roles": self.words_and_roles_array,
 85 |             }
 86 |         )
 87 |     
 88 |     def _generate_spymaster_prompt(self, player_id: int, team: str) -> str:
 89 |         
 90 |         prompt = (
 91 |             f"You are Player {player_id}. You are the spymaster for the {'red' if team == 0 else 'blue'} team in Codenames.\n"
 92 |             f"Here is the grid of words and the teams they belong to:\n"
 93 |             f"Red Words: {', '.join(self.game_state['red_words'])}\n"
 94 |             f"Blue Words: {', '.join(self.game_state['blue_words'])}\n"
 95 |             f"Neutral Words: {', '.join(self.game_state['neutral_words'])}\n"
 96 |             f"Assassin Words: {', '.join(self.game_state['assassin_words'])}\n"
 97 |             "Your goal is to provide one-word clues that relate to as many of your team's remaining words as possible, and indicate the number of words your clue relates to.\n"
 98 |             f"You clue must not relate to the {'blue' if team == 0 else 'red'} team's words, neutral words, or the assassin word.\n"
 99 |             "Then, provide your response. Your response should **only** contain the clue followed by the number, separated by a space. **No additional text** should be included. An example of a correct response: <clue> <number>\n"
100 |             "On your turn, analyse the grid and the observation history below to determine which words have been guessed. And, avoid any clues that could lead your team to guess words that have been revealed by either team.\n"
101 |         )
102 |         return prompt
103 |     
104 |     def _generate_field_operatives_prompt(self, player_id: int, team: str) -> str:
105 |         
106 |         prompt = (
107 |             f"You are Player {player_id}. You are the operative for the {'red' if team == 0 else 'blue'} team in Codenames.\n"
108 |             "Here is the grid of words:\n"
109 |             f"{', '.join(self.words)}\n"
110 |             "Your team's Spymaster has provided a one-word clue along with a number indicating how many words on the grid relate to that clue. Example: If the clue is `Book 3`, it suggests that there are 3 words on the grid related to 'Book'.\n"
111 |             "Your goal is to deduce which unrevealed words are most likely related to your spymaster's clue.\n"
112 |             "Your response should **only** contain the words you choose to guess, separated by commas and a space. **No additional text** should be included. An example of a correct response to `Book 3`: library, paper, cover\n"
113 |             "On your turn, analyse the following seqeunce of clues and guesses made by both teams to understand which words have been revealed and to avoid them in your guesses.\n"
114 |         )
115 |         return prompt
116 |     
117 |     def step(
118 |         self,
119 |         player_id: int,
120 |         action: str,
121 |     ) -> Tuple[
122 |         Optional[Dict[int, str]],  
123 |         Optional[Dict[int, int]],  
124 |         bool,  
125 |         bool,  
126 |         Dict[str, Any],  
127 |     ]:
128 |         
129 |         
130 |         action = re.sub(r'[^a-zA-Z0-9\s]', '', action)
131 |         
132 |         
133 |         observation = f'{"Red Team" if self.game_state["current_team"] == 0 else "Blue Team"} {"Spymaster" if player_id % 2 == 0 else "Operative"} said, "{action}"'
134 |         
135 |         
136 |         observations = {
137 |             0: observation,
138 |             1: observation,
139 |             2: observation,
140 |             3: observation,
141 |         } 
142 |         
143 | 
144 |         
145 |         reward = 0
146 | 
147 |         if player_id % 2 == 0: 
148 |             
149 |             clue_word, clue_number = action.split()
150 | 
151 |             
152 |             self.game_state["clue"] = [clue_word, int(clue_number)]
153 |             self.game_state["current_role"] = 'operative'
154 |             self.game_state["logs"].append(f"[Game] Player {player_id}: {clue_word} {clue_number}")
155 | 
156 |             
157 |             truncated = False
158 |             terminated = False
159 |             info = {"reason": f"Player {player_id} provided clue: {clue_word} {clue_number}"}
160 |             
161 |         elif player_id % 2 != 0 and self.game_state["clue"][1] > 0:  
162 |             
163 |             guess_words = [word.strip() for word in action.split()]
164 | 
165 |             
166 |             total_reward = 0
167 | 
168 |             
169 |             self.game_state["logs"].append(f"[Player {player_id}] {action}")
170 | 
171 |             for guess_word in guess_words:
172 |                 if guess_word not in self.words:
173 |                     
174 |                     total_reward -= 1  
175 |                     info = {"reason": f"Player {player_id} selected invalid word: '{guess_word}'"}
176 |                     truncated = False
177 |                     terminated = False
178 |                     break  
179 | 
180 |                 else:
181 |                     
182 |                     word_index = self.words.index(guess_word)
183 |                     word_role = self.game_state["roles_array"][word_index]
184 | 
185 |                     
186 |                     self.game_state["clue"][1] -= 1
187 | 
188 |                     if word_role == 0:
189 |                         
190 |                         total_reward -= 0.5  
191 |                         info = {"reason": f"Player {player_id} selected already revealed word: '{guess_word}'"}
192 |                         terminated = False
193 |                         truncated = False
194 |                         break  
195 | 
196 |                     elif word_role == 1 + self.game_state["current_team"]:
197 |                         
198 |                         total_reward += 1  
199 |                         self.game_state["roles_array"][word_index] = 0  
200 | 
201 |                         if self._check_win_condition():
202 |                             
203 |                             self.game_state["done"] = True
204 |                             self.game_state["winner"] = "red" if self.game_state["current_team"] == 0 else "blue"
205 |                             total_reward += 10  
206 |                             print(f"Team {self.game_state['winner']} has won the game!")
207 | 
208 |                             
209 |                             truncated = False
210 |                             terminated = True
211 |                             info = {"reason": f"Player {player_id} selected the final word: '{guess_word}'"}
212 |                             break  
213 | 
214 |                         
215 |                         info = {"reason": f"Player {player_id} selected correct word: '{guess_word}'"}
216 |                         terminated = False
217 |                         truncated = False
218 | 
219 |                     elif word_role == 3:
220 |                         
221 |                         total_reward += 0.0  
222 |                         self.game_state["roles_array"][word_index] = 0  
223 | 
224 |                         info = {"reason": f"Player {player_id} selected neutral word: '{guess_word}'"}
225 |                         terminated = False
226 |                         truncated = False
227 |                         
228 | 
229 |                     elif word_role == 2 - self.game_state["current_team"]:
230 |                         
231 |                         total_reward -= 1  
232 |                         self.game_state["roles_array"][word_index] = 0  
233 | 
234 |                         info = {"reason": f"Player {player_id} selected opponent word: '{guess_word}'"}
235 |                         terminated = False
236 |                         truncated = False
237 |                         break  
238 | 
239 |                     elif word_role == 4:
240 |                         
241 |                         total_reward -= 10  
242 |                         self.game_state["winner"] = "assassin"
243 | 
244 |                         truncated = False
245 |                         terminated = True
246 |                         info = {"reason": f"Player {player_id} selected assassin word: '{guess_word}'"}
247 |                         break  
248 | 
249 |             if not terminated:
250 |                 
251 |                 self._switch_turn()
252 | 
253 | 
254 |             
255 |             reward = total_reward
256 |             self._update_roles_words()
257 | 
258 |             
259 |             if not guess_words:
260 |                 self._switch_turn()
261 |                 info = {"reason": f"Player {player_id} provided no valid guesses."}
262 | 
263 |         elif self.game_state["clue"][1] == 0:
264 |             
265 |             self._switch_turn()
266 |             truncated = False
267 |             terminated = False
268 |             info = {"reason": f"Player {player_id} has run out of turns."}
269 | 
270 | 
271 |         return observations, reward, truncated, terminated, info
272 |     
273 |     def render(self):
274 |         
275 |         print("\n--- Game State ---")
276 |         for i in range(self.grid_size):
277 |             row = ""
278 |             for j in range(self.grid_size):
279 |                 idx = i * self.grid_size + j
280 |                 word = self.words[idx]
281 |                 role = self.game_state["roles_array"][idx]
282 |                 row += f"{word} ({role})\t"
283 | 
284 |             print(row)
285 |         print(f"Current team: {self.game_state['current_team']}")
286 |         print(f"Clue: {self.game_state['clue']}")
287 |         print(f"Done: {self.game_state['done']}")
288 |         print(f"Winner: {self.game_state['winner']}")
289 |         print(f"Logs: {self.game_state['logs'][-2:]}")
290 | 
291 |     def _switch_turn(self):
292 |         
293 |         self.game_state["current_team"] = 1 - self.game_state["current_team"]
294 |         self.game_state["current_role"] = 'spymaster'
295 |         self.game_state["clue"] = [0, 0]
296 |         self.game_state["logs"].append(f"[Game] Turn switched to team {'Red' if self.game_state['current_team'] == 0 else 'Blue'}")
297 | 
298 | 
299 |     def _check_win_condition(self):
300 |         
301 |         return all(role == 0 or role == 1 + self.game_state["current_team"] for role in self.game_state["roles_array"])
302 |     
303 |     def _init_word_for_roles(
304 |         self,
305 |     ) -> Dict[int, str]: 
306 |         
307 |         total_words = self.grid_size ** 2
308 | 
309 |         
310 |         red_count = (total_words - 1) // 3 + 1 
311 |         blue_count = (total_words - 1) // 3
312 |         neutral_count = total_words - red_count - blue_count - 1
313 |         assassin_count = 1
314 | 
315 |         
316 |         roles_array = (
317 |             [1] * red_count +  
318 |             [2] * blue_count +  
319 |             [3] * neutral_count +  
320 |             [4] * assassin_count 
321 |         )
322 |         random.shuffle(roles_array)
323 | 
324 |         
325 |         words_and_roles_array = [
326 |             f"{self.words[idx]} ({'red' if role == 1 else 'blue' if role == 2 else 'neutral' if role == 3 else 'assassin'})"
327 |             for idx, role in enumerate(roles_array)
328 |         ]
329 | 
330 |         return words_and_roles_array, roles_array
331 | 
332 |     def _update_roles_words(
333 |         self
334 |     ):
335 |         
336 | 
337 |         self.game_state["revealed_words"] = []
338 |         self.game_state["red_words"] = []
339 |         self.game_state["blue_words"] = []
340 |         self.game_state["neutral_words"] = []
341 |         self.game_state["assassin_words"] = []
342 |         
343 |         for idx, role in enumerate(self.game_state["roles_array"]):
344 |             word = self.words[idx]
345 | 
346 |             if role == 0:
347 |                 self.game_state["revealed_words"].append(word)
348 |             elif role == 1:
349 |                 self.game_state["red_words"].append(word)
350 |             elif role == 2:
351 |                 self.game_state["blue_words"].append(word)
352 |             elif role == 3:
353 |                 self.game_state["neutral_words"].append(word)
354 |             elif role == 4:
355 |                 self.game_state["assassin_words"].append(word)
356 | 
357 |         self.game_state["unrevealed_words"] = self.game_state["red_words"] + self.game_state["blue_words"] + self.game_state["neutral_words"] + self.game_state["assassin_words"]
```

## File: textarena/envs/multi_player/liars_dice.py

- Extension: .py
- Language: python
- Size: 8239 bytes
- Created: 2024-10-18 15:28:49
- Modified: 2024-10-18 15:28:49

### Code

```python
  1 | 
  2 | 
  3 | import random
  4 | 
  5 | import textarena as ta
  6 | 
  7 | BASE_PROMPT = 
  8 | 
  9 | 
 10 | class LiarsDice(ta.Env):
 11 |     
 12 | 
 13 |     def __init__(self, num_dice: int = 5, num_players: int = 5):
 14 |         self.num_dice = num_dice
 15 |         self.num_players = num_players
 16 |         self.reset()
 17 | 
 18 |     def reset(self, seed: int = None) -> tuple[ta.Observation, ta.Info]:
 19 |         
 20 |         random.seed(seed)
 21 |         dice = [
 22 |             {i: [random.randint(1, 6) for _ in range(self.num_dice)]}
 23 |             for i in range(self.num_players)
 24 |         ]
 25 |         self.game_state = ta.State(
 26 |             render={"dice": dice},
 27 |             logs=[(ta.GAME_ID, "New game started.")],
 28 |             player_map={i: f"Player {i}" for i in range(self.num_players)},
 29 |             bid=None,
 30 |             dice=dice,
 31 |         )
 32 |         return (
 33 |             {i: [self.get_initial_prompt(dice[i], i)] for i in range(self.num_players)},
 34 |             {},
 35 |         )
 36 | 
 37 |     def get_initial_prompt(self, dice, player_id) -> ta.Message:
 38 |         
 39 |         if player_id != 0:
 40 |             return ta.GAME_ID, BASE_PROMPT.format(player_id=player_id, dice=dice)
 41 |         return (
 42 |             ta.GAME_ID,
 43 |             f"{BASE_PROMPT.format(player_id=player_id, dice=dice)}\n\n It's your turn make the initial bid.",
 44 |         )
 45 | 
 46 |     def step(
 47 |         self, player_id: int, action: str
 48 |     ) -> tuple[ta.Observation, ta.Reward, bool, bool, ta.Info]:
 49 |         
 50 |         message = (player_id, action)
 51 |         next_player = (player_id + 1) % self.num_players
 52 |         next_player_message = {
 53 |             _id: [(ta.GAME_ID, "It's your turn.")] if _id == next_player else []
 54 |             for _id in range(self.num_players)
 55 |         }
 56 |         base_rewards = {i: 0 for i in range(self.num_players)}
 57 |         if "[Call]" in action:
 58 |             if self.game_state["bid"] is None:
 59 |                 base_rewards[player_id] = -1
 60 |                 return (
 61 |                     {player_id: [message, (ta.GAME_ID, "No bids have been made yet.")]},
 62 |                     base_rewards,
 63 |                     True,
 64 |                     False,
 65 |                     {"reason": "No bids have been made yet."},
 66 |                 )
 67 |             return self._resolve_bluff(message)
 68 |         elif "[Bid]" in action:
 69 |             action = action.split("[Bid]")[1].strip()
 70 |             if not self._update_bid(action):
 71 |                 base_rewards[player_id] = -1
 72 |                 return (
 73 |                     {player_id: [message, (ta.GAME_ID, "Invalid bid format.")]},
 74 |                     base_rewards,
 75 |                     True,
 76 |                     False,
 77 |                     {"reason": "Invalid bid format."},
 78 |                 )
 79 |             return (
 80 |                 {
 81 |                     _id: [message] + next_player_message[_id]
 82 |                     for _id in range(self.num_players)
 83 |                 },
 84 |                 base_rewards,
 85 |                 False,
 86 |                 False,
 87 |                 {},
 88 |             )
 89 |         else:
 90 |             base_rewards[player_id] = -1
 91 |             return (
 92 |                 {player_id: [message, (ta.GAME_ID, "Invalid action format.")]},
 93 |                 base_rewards,
 94 |                 True,
 95 |                 False,
 96 |                 {"reason": "Invalid action format."},
 97 |             )
 98 | 
 99 |     def _update_bid(self, action) -> bool:
100 |         
101 |         quantity, face_value = action.split()
102 |         quantity = int(quantity)
103 |         face_value = int(face_value)
104 |         if self.game_state["bid"] is None:
105 |             self.game_state["bid"] = (quantity, face_value)
106 |             return True
107 |         prev_quantity, prev_face_value = self.game_state["bid"]
108 |         prev_quantity = int(prev_quantity)
109 |         prev_face_value = int(prev_face_value)
110 |         if quantity < prev_quantity:
111 |             return False, None, None
112 |         if quantity == prev_quantity and face_value <= prev_face_value:
113 |             return False
114 |         self.game_state["bid"] = (quantity, face_value)
115 |         return True
116 | 
117 |     def _resolve_bluff(self, call_message):
118 |         
119 |         player_id = call_message[0]
120 |         actual_counts = {i: 0 for i in range(1, 7)}
121 |         for player in self.game_state["dice"]:
122 |             if set(player.values()) == 5:
123 |                 continue  
124 |             for die in player.values():
125 |                 if die == 1:
126 |                     for i in range(1, 7):
127 |                         actual_counts[i] += 1
128 |                 else:
129 |                     actual_counts[die] += 1
130 | 
131 |         if actual_counts[self.game_state["bid"][1]] >= self.game_state["bid"][0]:
132 |             loser = player_id  
133 |             message = (ta.GAME_ID, f"Player {loser} loses! The bid succeeded.")
134 |         else:
135 |             loser = player_id - 1 % self.num_players  
136 |             message = (ta.GAME_ID, f"Player {loser} loses! The bid failed.")
137 |         self.game_state.logs.append(message)
138 |         message_obs = ({i: [call_message, message] for i in range(self.num_players)},)
139 |         rewards = {
140 |             i: 1 for i in range(self.num_players)
141 |         }  
142 |         rewards[loser] = -1
143 | 
144 |         return (
145 |             message_obs,
146 |             rewards,
147 |             True,
148 |             False,
149 |             {},
150 |         )
151 | 
152 |     def render(self):
153 |         
154 |         if self.game_state["bid"] is None:
155 |             print("No bids have been made yet.")
156 |         else:
157 |             print(f"Current bid: {self.game_state['bid']}")
158 |         print("Dice:")
159 |         for i, player in enumerate(self.game_state["dice"]):
160 |             print(f"Player {i}: {player}")
161 |         print("\n")
```

## File: textarena/envs/multi_player/README.md

- Extension: .md
- Language: markdown
- Size: 3128 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
 1 | # Multiplayer Games
 2 | 
 3 | > 🚧 **Notice: This Multiplayer Games module is currently under development.**  
 4 | > Building on our experience with single- and two-player games, we’re expanding into multiplayer environments, carefully designing complex turn-based logic and interaction patterns. Expect frequent updates as we add and refine these games to create a robust, adaptable structure with clear, user-friendly code. We welcome community feedback and suggestions to enhance this module for multi-agent evaluations.  
 5 | > 🔗 For the latest updates, join our [Discord channel](#).
 6 | 
 7 | 
 8 | Welcome to the Multiplayer Games module in our repository. This directory houses a collection of multiplayer games, each designed to evaluate the collaborative and competitive capabilities of large language models (LLMs). These games require a range of skills, including strategic planning, negotiation, bluffing, and teamwork, making them ideal for assessing LLMs in multi-agent settings. Each game environment is implemented to be accessible, extendable, and adaptable for various interaction styles.
 9 | 
10 | ## Games Overview
11 | 
12 | | Game                  | Description                                                                                                                                                          | Status          |
13 | |-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------|
14 | | **Codenames**         | Players give clues to help teammates guess specific words without selecting incorrect ones.                                                                         | -               |
15 | | **Werewolf**          | A social deduction game where players are assigned hidden roles as werewolves or villagers, aiming to identify or eliminate the other group.                       | -               |
16 | | **Diplomacy**         | A strategy game where players negotiate and form alliances to control regions on a map, with simultaneous action cycles each turn.                                 | -               |
17 | | **Negotiation**       | Players engage in rounds of bargaining to reach agreements, with outcomes affecting their positions or points in the game.                                          | -               |
18 | | **Poker**             | Players compete to form the best hand and bluff opponents in a round-based format, with betting rounds and turn-taking.                                             | -               |
19 | | **Bluffing Dice**     | Players roll dice and make bids on the values they believe are on the table, aiming to outwit opponents by bluffing or revealing the truth.                         | -            |
20 | | **Letter Auction**    | Players "bid" on letters to form the highest-scoring word. Each player has a limited number of points to bid, aiming to assemble the highest-value word from the letters won. | -            |
21 | 
22 | Above is a list of multiplayer games that we will add in this module. Each game is marked with its current development status.
23 | 
24 | 
```

## File: textarena/envs/multi_player/__init__.py

- Extension: .py
- Language: python
- Size: 0 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python

```

## File: textarena/envs/two_player/Battleship/test.py

- Extension: .py
- Language: python
- Size: 4832 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | from textarena.envs.two_player.Battleship.env import BattleshipEnv
  4 | 
  5 | 
  6 | def generate_correct_move_sequence():
  7 |     
  8 |     return ["I have seen the opponent attempt to hit me at A4. I shall try to aim at their A4. My final coordinate is [A4].", "I think we can go with [J8]."]
  9 | 
 10 | def generate_invalid_move_sequence():
 11 |     
 12 |     return ["I have seen the opponent attempt to hit me at A4. I shall try to aim at their A4. My final coordinate is A4.", "I think we can go with (J8)."]
 13 | 
 14 | def generate_out_of_bounds_sequence():
 15 |     
 16 |     return ["I have seen the opponent attempt to hit me at A4. I shall try to aim at their Z100. My final coordinate is [Z100]."]
 17 | 
 18 | def generate_player_winning_seqeunce():
 19 |     
 20 |     return ['[A1]', '[E7]', '[A2]', '[F7]', '[A3]', '[G7]', '[A4]', '[H7]', '[A5]', '[I7]', '[E4]', '[C7]', '[F4]', '[D7]', '[F8]', '[F6]', '[G8]', '[G6]', '[H8]', '[H6]', '[G4]', '[H3]', '[G5]', '[I3]', '[G6]', '[J3]', '[C4]', '[J5]', '[C5]', '[J6]', '[C6]', '[J7]', '[C7]']
 21 | 
 22 | class TestBattleshipEnv(unittest.TestCase):
 23 |     
 24 | 
 25 |     
 26 |     env_variants = [
 27 |         {"difficulty": "easy"},
 28 |         {"difficulty": "medium"},
 29 |         {"difficulty": "hard"},
 30 |     ]
 31 | 
 32 |     
 33 |     test_cases = {
 34 |         "correct_move_easy": {
 35 |             "difficulty": "easy",
 36 |             "actions": generate_correct_move_sequence()
 37 |         },
 38 |         "invalid_move_easy": {
 39 |             "difficulty": "easy",
 40 |             "actions": generate_invalid_move_sequence()
 41 |         },
 42 |         "out_of_bounds_easy": {
 43 |             "difficulty": "easy",
 44 |             "actions": generate_out_of_bounds_sequence()
 45 |         },
 46 |         "player_winning_easy": {
 47 |             "difficulty": "easy",
 48 |             "actions": generate_player_winning_seqeunce()
 49 |         }
 50 |     }
 51 | 
 52 |     @parameterized.expand([
 53 |         (name, details['difficulty'], details['actions'])
 54 |         for name, details in test_cases.items()
 55 |     ])
 56 |     def test_battleship_outcomes(self, name, difficulty, actions):
 57 |         
 58 |         env_config = next((env for env in self.env_variants if env['difficulty'] == difficulty), None)
 59 |         self.assertIsNotNone(env_config, f"Environment configuration not found for difficulty level: {difficulty}")
 60 | 
 61 |         env = BattleshipEnv(difficulty=env_config['difficulty'])
 62 | 
 63 |         observations = env.reset(seed=490)
 64 | 
 65 |         terminated = False
 66 |         truncated = False
 67 |         rewards = {0: 0, 1: 0}
 68 | 
 69 |         for i, action in enumerate(actions):
 70 |             if terminated or truncated:
 71 |                 break
 72 |             player_id = i % 2
 73 | 
 74 |             env_action = action
 75 | 
 76 |             
 77 |             observations, reward, truncated, terminated, info = env.step(player_id=player_id, action=env_action)
 78 | 
 79 |             
 80 |             if reward:
 81 |                 rewards.update(reward)
 82 | 
 83 |         if "correct_move" in name:
 84 |             self.assertFalse(truncated, "Game should not truncate for correct moves.")
 85 |             self.assertFalse(terminated, "Game should not terminate until the puzzle is complete.")
 86 |         elif "invalid_move" in name:
 87 |             self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move.")
 88 |             self.assertEqual(rewards[player_id], -1, "Player should receive -1 reward for an invalid move.")
 89 |         elif "out_of_bounds" in name:
 90 |             self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move.")
 91 |             self.assertEqual(rewards[player_id], -1, "Player should receive -1 reward for an invalid move.")
 92 |         elif "player_winning" in name:
 93 |             self.assertTrue(terminated, "Game should terminate due to a player winning.")
 94 |             self.assertEqual(rewards[player_id], 1, f"Player {player_id} should have received +1 for winning.")
 95 |             self.assertEqual(rewards[1 - player_id], -1, f"Player {1 - player_id} should have received -1 for losing.")
 96 |         else:
 97 |             raise ValueError(f"Invalid test case name: {name}")
 98 |         
 99 |     def run_unit_test():
100 |         print("Running Battleship tests...")
101 |         unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/two_player/Battleship/env.py

- Extension: .py
- Language: python
- Size: 14283 bytes
- Created: 2024-12-12 11:12:50
- Modified: 2024-12-12 11:12:50

### Code

```python
  1 | from typing import Optional, Dict, Tuple, List, Any
  2 | import random
  3 | import textarena as ta
  4 | import re
  5 | 
  6 | class BattleshipEnv(ta.Env):
  7 |     
  8 |     def __init__(
  9 |         self,
 10 |         difficulty: Optional[str] = "easy",
 11 |     ):
 12 |         
 13 |         self.difficulty = difficulty
 14 | 
 15 |         
 16 |         
 17 |         if self.difficulty == "easy":
 18 |             self.grid_size = 10
 19 |         elif self.difficulty == "medium":
 20 |             self.grid_size = 12
 21 |         elif self.difficulty == "hard":
 22 |             self.grid_size = 14
 23 | 
 24 |         
 25 |         self.state = ta.State(
 26 |             num_players=2,
 27 |             max_turns=None,
 28 |         )
 29 |         self.ships = {"Aircraft Carrier": 5, "Battleship": 4, "Submarine": 3, "Destroyer": 3, "Patrol Boat": 2}
 30 | 
 31 | 
 32 |         
 33 |         self.board_state_render = ta.envs.two_player.Battleship.render.GameStateRender
 34 | 
 35 |     def reset(self, seed: Optional[int] = None):
 36 |         
 37 |         
 38 |         
 39 |         self.ships = {"Aircraft Carrier": 5, "Battleship": 4, "Submarine": 3, "Destroyer": 3, "Patrol Boat": 2}
 40 |         self.board, self.tracking_board = self._generate_board()
 41 | 
 42 |         
 43 |         self.state.reset(
 44 |             seed=seed,
 45 |             game_state={
 46 |                 "board": self.board,
 47 |                 "rendered_board": self._render_board(),
 48 |             },
 49 |             player_prompt_function=self._generate_player_prompt
 50 |         )
 51 |     
 52 |     def _generate_board(self) -> List[List[str]]:
 53 |         
 54 |         board = {
 55 |             0: [['~'] * self.grid_size for _ in range(self.grid_size)],
 56 |             1: [['~'] * self.grid_size for _ in range(self.grid_size)],
 57 |         }
 58 |         tracking_board = {
 59 |             0: [['~'] * self.grid_size for _ in range(self.grid_size)],
 60 |             1: [['~'] * self.grid_size for _ in range(self.grid_size)],
 61 |         }
 62 | 
 63 |         
 64 |         for player_id in range(2):
 65 |             for ship_name, length in self.ships.items():
 66 |                 self._place_ship_on_board(board[player_id], ship_name, length)
 67 | 
 68 |         return board, tracking_board
 69 |     
 70 |     def _place_ship_on_board(self, grid: List[List[str]], ship_name: str, length: int) -> None:
 71 |         
 72 |         placed = False
 73 |         while not placed:
 74 |             orientation = random.choice(["horizontal", "vertical"])
 75 |             if orientation == "horizontal":
 76 |                 row, col = random.randint(0, self.grid_size - 1), random.randint(0, self.grid_size - length)
 77 |                 if all(grid[row][col + i] == '~' for i in range(length)):
 78 |                     for i in range(length):
 79 |                         grid[row][col + i] = ship_name[0]
 80 |                     placed = True
 81 |             else:  
 82 |                 row, col = random.randint(0, self.grid_size - length), random.randint(0, self.grid_size - 1)
 83 |                 if all(grid[row + i][col] == '~' for i in range(length)):
 84 |                     for i in range(length):
 85 |                         grid[row + i][col] = ship_name[0]
 86 |                     placed = True
 87 | 
 88 |     def _render_board(self) -> str:
 89 |         
 90 |         
 91 |         view = []
 92 |         view.append("   " + "Player 0's Ships".center(self.grid_size * 3) + "        " + "Player 1's Ships".center(self.grid_size * 3))
 93 |         view.append("   " + " ".join([f"{i:2}" for i in range(self.grid_size)]) + "      " +
 94 |                     "   " + " ".join([f"{i:2}" for i in range(self.grid_size)]))
 95 |         
 96 |         for i in range(self.grid_size):
 97 |             
 98 |             row_label = chr(i + ord('A'))
 99 |             row_player1 = " ".join(f"{cell:2}" for cell in self.board[0][i])
100 |             row_player2 = " ".join(f"{cell:2}" for cell in self.board[1][i])
101 |             view.append(f"{row_label}   {row_player1}     {row_label}   {row_player2}")
102 |         
103 |         
104 |         return "\n".join(view)
105 |     
106 |     def _render_player_view(self, player_id: int) -> str:
107 |         
108 |         
109 |         if player_id == 0:
110 |             own_grid = self.board[0]
111 |             tracking_grid = self.tracking_board[0]
112 |             player_label = "Player 0"
113 |         else:
114 |             own_grid = self.board[1]
115 |             tracking_grid = self.tracking_board[1]
116 |             player_label = "Player 1"
117 |         
118 |         
119 |         view = []
120 |         view.append(f"\n{player_label}'s View".center(self.grid_size * 4 + 15))
121 |         view.append("   " + "Your Ships".center(self.grid_size * 3) + "        " + "Your Hits on Opponent".center(self.grid_size * 3))
122 |         view.append("   " + " ".join([f"{i:2}" for i in range(self.grid_size)]) + "      " +
123 |                     "   " + " ".join([f"{i:2}" for i in range(self.grid_size)]))
124 |         
125 |         for i in range(self.grid_size):
126 |             
127 |             row_label = chr(i + ord('A'))
128 |             row_own_grid = " ".join(f"{cell:2}" for cell in own_grid[i])
129 |             row_tracking_grid = " ".join(f"{cell:2}" for cell in tracking_grid[i])
130 |             view.append(f"{row_label}   {row_own_grid}     {row_label}   {row_tracking_grid}")
131 |         
132 |         
133 |         return "\n".join(view)
134 |     
135 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[int, Any]) -> str:
136 |         
137 |         prompt = (
138 |             f"You are Player {player_id}. You are playing the Battleship game ({self.difficulty} level).\n"
139 |             "Your goal is to sink all of your opponent's ships before they sink yours.\n"
140 |             "On your turn, consider the observations made by your opponent, but do not repeat them exactly.\n"
141 |             "Focus on new insights or strategies based on your understanding of the opponent's moves and the current state of the game.\n"
142 |             "You may mention coordinates in the format B3 or C8. Only when you have decided to fire a missile to a specified coordinate, then you must enter the row and column values in square brackets like [A4]. This is to avoid submitting a wrong coordinate to the game environment.\n"
143 |             "If the missile hits a ship, it is marked with 'X'. If it misses, it is marked with 'O'. In either scenarios, the game environment will inform you of your hits. If you have sunk a boat, the game environment will tell you!\n"
144 |             "The game ends when all of one player's ships have been sunk.\n"
145 |             "Your initial board will show all of your ships placed and your opponent's hits on you, and your hits and misses on your opponent's board without showing your opponent's ships.\n"
146 |             "Here is the initial board:\n"
147 |         )
148 | 
149 | 
150 |         prompt += self._render_player_view(player_id)
151 | 
152 |         return prompt
153 |     
154 |     def step(self, action: str) -> Tuple[Optional[ta.Rewards], bool, bool, ta.Info]: 
155 |         
156 |         player_id = self.state.current_player_id
157 |         
158 |         self.state.check_action_format(
159 |             action=action,
160 |         )
161 | 
162 |         
163 |         self.state.add_observation(
164 |             from_id=player_id,
165 |             to_id=player_id, 
166 |             message=action,
167 |             for_logging=True
168 |         )
169 | 
170 |         
171 |         action_search_pattern = re.compile(r"\[([A-Z])(\d+)\]") 
172 |         match = action_search_pattern.search(action)
173 | 
174 |         if match is None:
175 |             self.state.set_invalid_move(
176 |                 player_ids=[player_id],
177 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with a valid coordinate in square brackets."]
178 |             )
179 |         
180 |         else:
181 |             row = ord(match.group(1)) - ord('A') 
182 |             col = int(match.group(2))
183 |             
184 |             opponent_id = 1 - player_id
185 |             opponent_board = self.board[opponent_id]
186 |             tracking_board = self.tracking_board[player_id]
187 | 
188 |             
189 |             if row < 0 or row >= self.grid_size or col < 0 or col >= self.grid_size:
190 |                 self.state.set_invalid_move(
191 |                     player_ids=[player_id],
192 |                     reasons=[f"Invalid move. The coordinate {match.group()[1:3]} is outside the board."]
193 |                 )
194 |             elif tracking_board[row][col] != '~':
195 |                 self.state.set_invalid_move(
196 |                     player_ids=[player_id],
197 |                     reasons=[f"Invalid move. The coordinate {match.group()[1:3]} has already been fired upon."]
198 |                 )
199 |             else:
200 |                 if opponent_board[row][col] != '~':
201 |                     tracking_board[row][col] = 'X'
202 |                     ship_initial = opponent_board[row][col]
203 |                     opponent_board[row][col] = 'X'
204 |                     if not any(ship_initial in row for row in opponent_board):
205 |                         self.state.add_observation(
206 |                             from_id=ta.GAME_ID,
207 |                             to_id=player_id,
208 |                             message=f"Sunk! You sunk a ship at {match.group()[1:3]}! Your updated board:\n{self._render_player_view(player_id=player_id)}",
209 |                             for_logging=False
210 |                         )
211 |                         self.state.add_observation(
212 |                             from_id=ta.GAME_ID,
213 |                             to_id=opponent_id,
214 |                             message=f"Opponent sunk your ship at {match.group()[1:3]}! Your updated board:\n{self._render_player_view(player_id=opponent_id)}",
215 |                             for_logging=False
216 |                         )
217 |                     else:
218 |                         self.state.add_observation(
219 |                             from_id=-1,
220 |                             to_id=player_id,
221 |                             message=f"Hit! You hit a ship at {match.group()[1:3]}! Your updated board:\n{self._render_player_view(player_id=player_id)}",
222 |                             for_logging=False
223 |                         )
224 |                         self.state.add_observation(
225 |                             from_id=-1,
226 |                             to_id=opponent_id,
227 |                             message=f"Opponent hit your ship at {match.group()[1:3]}! Your updated board:\n{self._render_player_view(player_id=opponent_id)}",
228 |                             for_logging=False
229 |                         )
230 |                 else:
231 |                     tracking_board[row][col] = 'O'
232 |                     opponent_board[row][col] = 'O'
233 |                     self.state.add_observation(
234 |                         from_id=-1,
235 |                         to_id=player_id,
236 |                         message=f"Miss! You missed the ship at {match.group()[1:3]}! Your updated board:\n{self._render_player_view(player_id=player_id)}",
237 |                         for_logging=False
238 |                     )
239 |                     self.state.add_observation(
240 |                         from_id=-1,
241 |                         to_id=opponent_id,
242 |                         message=f"Opponent missed your ship at {match.group()[1:3]}! Your updated board:\n{self._render_player_view(player_id=opponent_id)}",
243 |                         for_logging=False
244 |                     )
245 |             
246 |             
247 |             if self._check_win(player_id):
248 |                 self.state.set_winners(
249 |                     player_ids=[player_id],
250 |                     reason=[f"Player {player_id} has sunk all of their opponent's ships!"]
251 |                 )
252 | 
253 |         
254 |         self.state.game_state["rendered_board"] = self._render_board()
255 | 
256 |         return self.state.step()
257 |     
258 |     def _check_win(self, player_id: int) -> bool:
259 |         
260 |         opponent_id = 1 - player_id
261 |         opponent_board = self.board[opponent_id]
262 |         abbreviations = {name[0] for name in self.ships.keys()}
263 |         return not any(any(cell in abbreviations for cell in row) for row in opponent_board)
264 |     
265 |     def render(self) -> str:
266 |         
267 |         return self.state.game_state["rendered_board"]
```

## File: textarena/envs/two_player/Battleship/render copy.py

- Extension: .py
- Language: python
- Size: 9809 bytes
- Created: 2024-12-12 11:15:04
- Modified: 2024-12-12 11:15:04

### Code

```python
  1 | import tkinter as tk
  2 | from tkinter import ttk
  3 | from typing import Dict, Optional
  4 | from PIL import Image, ImageTk
  5 | import os
  6 | 
  7 | class GameStateRender(ttk.Frame):
  8 |     
  9 |     
 10 |     CELL_SIZE = 40  
 11 |     LABEL_SPACE = 30  
 12 |     WINDOW_WIDTH = 1000
 13 |     WINDOW_HEIGHT = 600
 14 |     
 15 |     def __init__(self, master, env, player_names: Optional[Dict[int, str]] = None):
 16 |         super().__init__(master)
 17 |         self.master = master
 18 |         self.env = env
 19 |         self.player_names = player_names or {0: "Player 0", 1: "Player 1"}
 20 |         
 21 |         
 22 |         self.water_color = '#1E90FF'      
 23 |         self.ship_color = '#808080'       
 24 |         self.hit_color = '#FF4444'        
 25 |         self.miss_color = '#FFFFFF'       
 26 |         self.bg_color = '#2B2B2B'         
 27 |         self.text_color = '#FFFFFF'       
 28 |         self.grid_line_color = '#4A4A4A'  
 29 |         self.player_colors = {
 30 |             0: '#4A90E2',  
 31 |             1: '#E24A4A'   
 32 |         }
 33 |         
 34 |         
 35 |         self.master.title("Battleship Game")
 36 |         self.master.geometry(f"{self.WINDOW_WIDTH}x{self.WINDOW_HEIGHT}")
 37 |         self.master.configure(bg=self.bg_color)
 38 |         
 39 |         
 40 |         icon_path = os.path.join("textarena", "assets", "textarena-icon.png")
 41 |         if os.path.exists(icon_path):
 42 |             try:
 43 |                 self.master.iconphoto(False, tk.PhotoImage(file=icon_path))
 44 |             except Exception as e:
 45 |                 print(f"Could not set window icon: {e}")
 46 |         
 47 |         self.create_widgets()
 48 |         
 49 |     def create_widgets(self):
 50 |         
 51 |         
 52 |         self.container = ttk.Frame(self.master)
 53 |         self.container.pack(expand=True, fill='both', padx=20, pady=20)
 54 |         
 55 |         
 56 |         self.info_frame = ttk.Frame(self.container)
 57 |         self.info_frame.pack(fill='x', pady=(0, 10))
 58 |         
 59 |         
 60 |         self.turn_label = ttk.Label(
 61 |             self.info_frame,
 62 |             text="Player 0's Turn",
 63 |             font=('Arial', 14, 'bold'),
 64 |             background=self.bg_color,
 65 |             foreground=self.text_color
 66 |         )
 67 |         self.turn_label.pack(side='left')
 68 |         
 69 |         
 70 |         self.status_label = ttk.Label(
 71 |             self.info_frame,
 72 |             text="",
 73 |             font=('Arial', 12),
 74 |             background=self.bg_color,
 75 |             foreground=self.text_color
 76 |         )
 77 |         self.status_label.pack(side='right')
 78 |         
 79 |         
 80 |         self.grids_container = ttk.Frame(self.container)
 81 |         self.grids_container.pack(expand=True, fill='both')
 82 |         
 83 |         
 84 |         self.player_boards = {}
 85 |         for player_id in [0, 1]:
 86 |             
 87 |             board_frame = ttk.Frame(self.grids_container)
 88 |             board_frame.pack(side='left', padx=20)
 89 |             
 90 |             
 91 |             title = ttk.Label(
 92 |                 board_frame,
 93 |                 text=f"{self.player_names[player_id]}'s Board",
 94 |                 font=('Arial', 12, 'bold'),
 95 |                 background=self.bg_color,
 96 |                 foreground=self.text_color
 97 |             )
 98 |             title.pack(pady=(0, 10))
 99 |             
100 |             
101 |             grid_size = self.env.grid_size * self.CELL_SIZE + self.LABEL_SPACE
102 |             
103 |             
104 |             canvas = tk.Canvas(
105 |                 board_frame,
106 |                 width=grid_size,
107 |                 height=grid_size,
108 |                 bg=self.bg_color,
109 |                 highlightthickness=0
110 |             )
111 |             canvas.pack()
112 |             
113 |             
114 |             self.player_boards[player_id] = {
115 |                 'frame': board_frame,
116 |                 'canvas': canvas
117 |             }
118 |             
119 |         
120 |         self.ships_frame = ttk.Frame(self.container)
121 |         self.ships_frame.pack(fill='x', pady=(20, 0))
122 |         
123 |         
124 |         self.ship_status = {}
125 |         for player_id in [0, 1]:
126 |             status_frame = ttk.Frame(self.ships_frame)
127 |             status_frame.pack(side='left', padx=20)
128 |             
129 |             header = ttk.Label(
130 |                 status_frame,
131 |                 text=f"{self.player_names[player_id]}'s Ships",
132 |                 font=('Arial', 11, 'bold'),
133 |                 background=self.bg_color,
134 |                 foreground=self.text_color
135 |             )
136 |             header.pack(pady=(0, 5))
137 |             
138 |             self.ship_status[player_id] = {}
139 |             for ship_name in self.env.ships.keys():
140 |                 label = ttk.Label(
141 |                     status_frame,
142 |                     text=f"{ship_name}: Active",
143 |                     font=('Arial', 10),
144 |                     background=self.bg_color,
145 |                     foreground='#90EE90'  
146 |                 )
147 |                 label.pack()
148 |                 self.ship_status[player_id][ship_name] = label
149 | 
150 |     def draw_board(self):
151 |         
152 |         if not hasattr(self.env.state, "game_state"):
153 |             return
154 |             
155 |         
156 |         current_player = self.env.state.current_player_id
157 |         self.turn_label.configure(text=f"{self.player_names[current_player]}'s Turn")
158 |         
159 |         
160 |         for player_id in [0, 1]:
161 |             canvas = self.player_boards[player_id]['canvas']
162 |             canvas.delete('all')
163 |             
164 |             
165 |             for row in range(self.env.grid_size):
166 |                 for col in range(self.env.grid_size):
167 |                     x1 = col * self.CELL_SIZE + self.LABEL_SPACE
168 |                     y1 = row * self.CELL_SIZE + self.LABEL_SPACE
169 |                     x2 = x1 + self.CELL_SIZE
170 |                     y2 = y1 + self.CELL_SIZE
171 |                     
172 |                     
173 |                     cell = self.env.board[player_id][row][col]
174 |                     
175 |                     
176 |                     if cell == 'X':
177 |                         color = self.hit_color
178 |                     elif cell == 'O':
179 |                         color = self.miss_color
180 |                     elif cell == '~':
181 |                         color = self.water_color
182 |                     else:  
183 |                         color = self.ship_color
184 |                     
185 |                     
186 |                     canvas.create_rectangle(
187 |                         x1, y1, x2, y2,
188 |                         fill=color,
189 |                         outline=self.grid_line_color
190 |                     )
191 |                     
192 |                     
193 |                     if cell == 'X':
194 |                         self.draw_hit_marker(canvas, x1, y1, x2, y2)
195 |                     elif cell == 'O':
196 |                         self.draw_miss_marker(canvas, x1, y1, x2, y2)
197 |             
198 |             
199 |             for i in range(self.env.grid_size):
200 |                 canvas.create_text(
201 |                     self.LABEL_SPACE/2,
202 |                     i * self.CELL_SIZE + self.LABEL_SPACE + self.CELL_SIZE/2,
203 |                     text=chr(ord('A') + i),
204 |                     fill=self.text_color,
205 |                     font=('Arial', 10)
206 |                 )
207 |             
208 |             
209 |             for i in range(self.env.grid_size):
210 |                 canvas.create_text(
211 |                     i * self.CELL_SIZE + self.LABEL_SPACE + self.CELL_SIZE/2,
212 |                     self.LABEL_SPACE/2,
213 |                     text=str(i),
214 |                     fill=self.text_color,
215 |                     font=('Arial', 10)
216 |                 )
217 |         
218 |         
219 |         self.update_ship_status()
220 |     
221 |     def draw_hit_marker(self, canvas, x1, y1, x2, y2):
222 |         
223 |         padding = 5
224 |         canvas.create_line(
225 |             x1 + padding, y1 + padding,
226 |             x2 - padding, y2 - padding,
227 |             fill='white',
228 |             width=2
229 |         )
230 |         canvas.create_line(
231 |             x2 - padding, y1 + padding,
232 |             x1 + padding, y2 - padding,
233 |             fill='white',
234 |             width=2
235 |         )
236 |     
237 |     def draw_miss_marker(self, canvas, x1, y1, x2, y2):
238 |         
239 |         center_x = (x1 + x2) / 2
240 |         center_y = (y1 + y2) / 2
241 |         radius = 4
242 |         canvas.create_oval(
243 |             center_x - radius,
244 |             center_y - radius,
245 |             center_x + radius,
246 |             center_y + radius,
247 |             fill=self.bg_color,
248 |             outline=self.bg_color
249 |         )
250 |     
251 |     def update_ship_status(self):
252 |         
253 |         for player_id in [0, 1]:
254 |             board = self.env.board[player_id]
255 |             for ship_name in self.env.ships.keys():
256 |                 ship_initial = ship_name[0]
257 |                 
258 |                 ship_alive = any(ship_initial in row for row in board)
259 |                 label = self.ship_status[player_id][ship_name]
260 |                 if ship_alive:
261 |                     label.configure(
262 |                         text=f"{ship_name}: Active",
263 |                         foreground='#90EE90'  
264 |                     )
265 |                 else:
266 |                     label.configure(
267 |                         text=f"{ship_name}: Sunk",
268 |                         foreground='#FF6B6B'  
269 |                     )
```

## File: textarena/envs/two_player/Battleship/render.py

- Extension: .py
- Language: python
- Size: 9809 bytes
- Created: 2024-12-12 11:13:16
- Modified: 2024-12-12 11:13:16

### Code

```python
  1 | import tkinter as tk
  2 | from tkinter import ttk
  3 | from typing import Dict, Optional
  4 | from PIL import Image, ImageTk
  5 | import os
  6 | 
  7 | class GameStateRender(ttk.Frame):
  8 |     
  9 |     
 10 |     CELL_SIZE = 40  
 11 |     LABEL_SPACE = 30  
 12 |     WINDOW_WIDTH = 1000
 13 |     WINDOW_HEIGHT = 600
 14 |     
 15 |     def __init__(self, master, env, player_names: Optional[Dict[int, str]] = None):
 16 |         super().__init__(master)
 17 |         self.master = master
 18 |         self.env = env
 19 |         self.player_names = player_names or {0: "Player 0", 1: "Player 1"}
 20 |         
 21 |         
 22 |         self.water_color = '#1E90FF'      
 23 |         self.ship_color = '#808080'       
 24 |         self.hit_color = '#FF4444'        
 25 |         self.miss_color = '#FFFFFF'       
 26 |         self.bg_color = '#2B2B2B'         
 27 |         self.text_color = '#FFFFFF'       
 28 |         self.grid_line_color = '#4A4A4A'  
 29 |         self.player_colors = {
 30 |             0: '#4A90E2',  
 31 |             1: '#E24A4A'   
 32 |         }
 33 |         
 34 |         
 35 |         self.master.title("Battleship Game")
 36 |         self.master.geometry(f"{self.WINDOW_WIDTH}x{self.WINDOW_HEIGHT}")
 37 |         self.master.configure(bg=self.bg_color)
 38 |         
 39 |         
 40 |         icon_path = os.path.join("textarena", "assets", "textarena-icon.png")
 41 |         if os.path.exists(icon_path):
 42 |             try:
 43 |                 self.master.iconphoto(False, tk.PhotoImage(file=icon_path))
 44 |             except Exception as e:
 45 |                 print(f"Could not set window icon: {e}")
 46 |         
 47 |         self.create_widgets()
 48 |         
 49 |     def create_widgets(self):
 50 |         
 51 |         
 52 |         self.container = ttk.Frame(self.master)
 53 |         self.container.pack(expand=True, fill='both', padx=20, pady=20)
 54 |         
 55 |         
 56 |         self.info_frame = ttk.Frame(self.container)
 57 |         self.info_frame.pack(fill='x', pady=(0, 10))
 58 |         
 59 |         
 60 |         self.turn_label = ttk.Label(
 61 |             self.info_frame,
 62 |             text="Player 0's Turn",
 63 |             font=('Arial', 14, 'bold'),
 64 |             background=self.bg_color,
 65 |             foreground=self.text_color
 66 |         )
 67 |         self.turn_label.pack(side='left')
 68 |         
 69 |         
 70 |         self.status_label = ttk.Label(
 71 |             self.info_frame,
 72 |             text="",
 73 |             font=('Arial', 12),
 74 |             background=self.bg_color,
 75 |             foreground=self.text_color
 76 |         )
 77 |         self.status_label.pack(side='right')
 78 |         
 79 |         
 80 |         self.grids_container = ttk.Frame(self.container)
 81 |         self.grids_container.pack(expand=True, fill='both')
 82 |         
 83 |         
 84 |         self.player_boards = {}
 85 |         for player_id in [0, 1]:
 86 |             
 87 |             board_frame = ttk.Frame(self.grids_container)
 88 |             board_frame.pack(side='left', padx=20)
 89 |             
 90 |             
 91 |             title = ttk.Label(
 92 |                 board_frame,
 93 |                 text=f"{self.player_names[player_id]}'s Board",
 94 |                 font=('Arial', 12, 'bold'),
 95 |                 background=self.bg_color,
 96 |                 foreground=self.text_color
 97 |             )
 98 |             title.pack(pady=(0, 10))
 99 |             
100 |             
101 |             grid_size = self.env.grid_size * self.CELL_SIZE + self.LABEL_SPACE
102 |             
103 |             
104 |             canvas = tk.Canvas(
105 |                 board_frame,
106 |                 width=grid_size,
107 |                 height=grid_size,
108 |                 bg=self.bg_color,
109 |                 highlightthickness=0
110 |             )
111 |             canvas.pack()
112 |             
113 |             
114 |             self.player_boards[player_id] = {
115 |                 'frame': board_frame,
116 |                 'canvas': canvas
117 |             }
118 |             
119 |         
120 |         self.ships_frame = ttk.Frame(self.container)
121 |         self.ships_frame.pack(fill='x', pady=(20, 0))
122 |         
123 |         
124 |         self.ship_status = {}
125 |         for player_id in [0, 1]:
126 |             status_frame = ttk.Frame(self.ships_frame)
127 |             status_frame.pack(side='left', padx=20)
128 |             
129 |             header = ttk.Label(
130 |                 status_frame,
131 |                 text=f"{self.player_names[player_id]}'s Ships",
132 |                 font=('Arial', 11, 'bold'),
133 |                 background=self.bg_color,
134 |                 foreground=self.text_color
135 |             )
136 |             header.pack(pady=(0, 5))
137 |             
138 |             self.ship_status[player_id] = {}
139 |             for ship_name in self.env.ships.keys():
140 |                 label = ttk.Label(
141 |                     status_frame,
142 |                     text=f"{ship_name}: Active",
143 |                     font=('Arial', 10),
144 |                     background=self.bg_color,
145 |                     foreground='#90EE90'  
146 |                 )
147 |                 label.pack()
148 |                 self.ship_status[player_id][ship_name] = label
149 | 
150 |     def draw_board(self):
151 |         
152 |         if not hasattr(self.env.state, "game_state"):
153 |             return
154 |             
155 |         
156 |         current_player = self.env.state.current_player_id
157 |         self.turn_label.configure(text=f"{self.player_names[current_player]}'s Turn")
158 |         
159 |         
160 |         for player_id in [0, 1]:
161 |             canvas = self.player_boards[player_id]['canvas']
162 |             canvas.delete('all')
163 |             
164 |             
165 |             for row in range(self.env.grid_size):
166 |                 for col in range(self.env.grid_size):
167 |                     x1 = col * self.CELL_SIZE + self.LABEL_SPACE
168 |                     y1 = row * self.CELL_SIZE + self.LABEL_SPACE
169 |                     x2 = x1 + self.CELL_SIZE
170 |                     y2 = y1 + self.CELL_SIZE
171 |                     
172 |                     
173 |                     cell = self.env.board[player_id][row][col]
174 |                     
175 |                     
176 |                     if cell == 'X':
177 |                         color = self.hit_color
178 |                     elif cell == 'O':
179 |                         color = self.miss_color
180 |                     elif cell == '~':
181 |                         color = self.water_color
182 |                     else:  
183 |                         color = self.ship_color
184 |                     
185 |                     
186 |                     canvas.create_rectangle(
187 |                         x1, y1, x2, y2,
188 |                         fill=color,
189 |                         outline=self.grid_line_color
190 |                     )
191 |                     
192 |                     
193 |                     if cell == 'X':
194 |                         self.draw_hit_marker(canvas, x1, y1, x2, y2)
195 |                     elif cell == 'O':
196 |                         self.draw_miss_marker(canvas, x1, y1, x2, y2)
197 |             
198 |             
199 |             for i in range(self.env.grid_size):
200 |                 canvas.create_text(
201 |                     self.LABEL_SPACE/2,
202 |                     i * self.CELL_SIZE + self.LABEL_SPACE + self.CELL_SIZE/2,
203 |                     text=chr(ord('A') + i),
204 |                     fill=self.text_color,
205 |                     font=('Arial', 10)
206 |                 )
207 |             
208 |             
209 |             for i in range(self.env.grid_size):
210 |                 canvas.create_text(
211 |                     i * self.CELL_SIZE + self.LABEL_SPACE + self.CELL_SIZE/2,
212 |                     self.LABEL_SPACE/2,
213 |                     text=str(i),
214 |                     fill=self.text_color,
215 |                     font=('Arial', 10)
216 |                 )
217 |         
218 |         
219 |         self.update_ship_status()
220 |     
221 |     def draw_hit_marker(self, canvas, x1, y1, x2, y2):
222 |         
223 |         padding = 5
224 |         canvas.create_line(
225 |             x1 + padding, y1 + padding,
226 |             x2 - padding, y2 - padding,
227 |             fill='white',
228 |             width=2
229 |         )
230 |         canvas.create_line(
231 |             x2 - padding, y1 + padding,
232 |             x1 + padding, y2 - padding,
233 |             fill='white',
234 |             width=2
235 |         )
236 |     
237 |     def draw_miss_marker(self, canvas, x1, y1, x2, y2):
238 |         
239 |         center_x = (x1 + x2) / 2
240 |         center_y = (y1 + y2) / 2
241 |         radius = 4
242 |         canvas.create_oval(
243 |             center_x - radius,
244 |             center_y - radius,
245 |             center_x + radius,
246 |             center_y + radius,
247 |             fill=self.bg_color,
248 |             outline=self.bg_color
249 |         )
250 |     
251 |     def update_ship_status(self):
252 |         
253 |         for player_id in [0, 1]:
254 |             board = self.env.board[player_id]
255 |             for ship_name in self.env.ships.keys():
256 |                 ship_initial = ship_name[0]
257 |                 
258 |                 ship_alive = any(ship_initial in row for row in board)
259 |                 label = self.ship_status[player_id][ship_name]
260 |                 if ship_alive:
261 |                     label.configure(
262 |                         text=f"{ship_name}: Active",
263 |                         foreground='#90EE90'  
264 |                     )
265 |                 else:
266 |                     label.configure(
267 |                         text=f"{ship_name}: Sunk",
268 |                         foreground='#FF6B6B'  
269 |                     )
```

## File: textarena/envs/two_player/Battleship/README.md

- Extension: .md
- Language: markdown
- Size: 11384 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Battleship Environment Documentation
  2 | 
  3 | ## Overview
  4 | **Battleship Game** is a two-player turn-based strategy game where players aim to locate and sink their opponent's fleet of ships hidden on a grid. Each player has a fleet of ships positioned on their grid, and they take turns guessing coordinates on the opponent’s grid to target and sink their ships. The game continues until one player successfully sinks all of the opponent's ships, thereby winning the game. This environment includes features such as grid visualization for hits and misses, side-by-side display of both players' grids, and tracking views to enhance the strategic gameplay experience for agents.
  5 | 
  6 | ## Action Space
  7 | 
  8 | - **Format:** Actions are strings representing the player's choice. For example:
  9 | - **Example:**
 10 |     - Hit the coordinate at row A column 2: [A2]
 11 |     - Hit the coordinate at row J column 4: [J4]
 12 | - **Notes:** Players can have additional texts in their replies, as long as they provide their coordinates in the correct format.
 13 | 
 14 | ## Observation Space
 15 | **Reset Observations**
 16 | On reset, each player receives a prompt containing their beginning game instructions. For example:
 17 | ```plaintext
 18 | [GAME] You are Player 0. You are playing the Battleship game (easy level).
 19 | Your goal is to sink all of your opponent's ships before they sink yours.
 20 | On your turn, consider the observations made by your opponent, but do not repeat them exactly.
 21 | Focus on new insights or strategies based on your understanding of the opponent's moves and the current state of the game.
 22 | You may mention coordinates in the format B3 or C8. Only when you have decided to fire a missile to a specified coordinate, then you must enter the row and column values in square brackets like [A4]. This is to avoid submitting a wrong coordinate to the game environment.
 23 | If the missile hits a ship, it is marked with 'X'. If it misses, it is marked with 'O'. In either scenarios, the game environment will inform you of your hits. If you have sunk a boat, the game environment will tell you!
 24 | The game ends when all of one player's ships have been sunk.
 25 | Your initial board will show all of your ships placed and your opponent's hits on you, and your hits and misses on your opponent's board without showing your opponent's ships.
 26 | Here is the initial board:
 27 |                     
 28 | Player 0's View                   
 29 |              Your Ships                      Your Hits on Opponent     
 30 |     0  1  2  3  4  5  6  7  8  9          0  1  2  3  4  5  6  7  8  9
 31 | A   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~      A   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 32 | B   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~      B   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 33 | C   ~  ~  ~  ~  ~  ~  ~  P  ~  ~      C   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 34 | D   ~  ~  ~  ~  ~  ~  ~  P  ~  ~      D   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 35 | E   ~  ~  ~  ~  ~  ~  ~  A  ~  ~      E   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 36 | F   ~  ~  ~  ~  ~  ~  D  A  ~  ~      F   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 37 | G   ~  ~  ~  ~  ~  ~  D  A  ~  ~      G   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 38 | H   ~  ~  ~  S  ~  ~  D  A  ~  ~      H   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 39 | I   ~  ~  ~  S  ~  ~  ~  A  ~  ~      I   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 40 | J   ~  ~  ~  S  ~  B  B  B  B  ~      J   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 41 | ```
 42 | 
 43 | **Step Observation:**
 44 | After each step, the players receive the latest message from the game environment. For example, here's player 1 making its move after player 0:
 45 | ```plaintext
 46 | [GAME] Opponent missed your ship at F5! Your updated board:
 47 |                     
 48 | Player 1's View                   
 49 |              Your Ships                      Your Hits on Opponent     
 50 |     0  1  2  3  4  5  6  7  8  9          0  1  2  3  4  5  6  7  8  9
 51 | A   ~  A  A  A  A  A  ~  ~  ~  ~      A   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 52 | B   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~      B   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 53 | C   ~  ~  ~  ~  B  B  B  B  ~  ~      C   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 54 | D   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~      D   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 55 | E   ~  ~  ~  ~  P  ~  ~  ~  ~  ~      E   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 56 | F   ~  ~  ~  ~  P  O  ~  ~  D  ~      F   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 57 | G   ~  ~  ~  ~  S  S  S  ~  D  ~      G   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 58 | H   ~  ~  ~  ~  ~  ~  ~  ~  D  ~      H   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 59 | I   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~      I   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 60 | J   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~      J   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 61 | [Player 1] Given the recent miss at F5, I see that my opponent is targeting the area around my ships. However, I still need to focus on finding their ships. 
 62 | 
 63 | I notice that there are several potential clusters of hits on their board. The most promising areas to target appear to be around the center of their grid, especially considering that I haven't targeted many coordinates in that area yet.
 64 | 
 65 | I'll fire at G5, as it falls within a central region of their board where ships are likely to be located. 
 66 | 
 67 | I'll take my shot now: [G5].
 68 | [GAME] Miss! You missed the ship at G5! Your updated board:
 69 |                     
 70 | Player 1's View                   
 71 |              Your Ships                      Your Hits on Opponent     
 72 |     0  1  2  3  4  5  6  7  8  9          0  1  2  3  4  5  6  7  8  9
 73 | A   ~  A  A  A  A  A  ~  ~  ~  ~      A   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 74 | B   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~      B   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 75 | C   ~  ~  ~  ~  B  B  B  B  ~  ~      C   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 76 | D   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~      D   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 77 | E   ~  ~  ~  ~  P  ~  ~  ~  ~  ~      E   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 78 | F   ~  ~  ~  ~  P  O  ~  ~  D  ~      F   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 79 | G   ~  ~  ~  ~  S  S  S  ~  D  ~      G   ~  ~  ~  ~  ~  O  ~  ~  ~  ~ 
 80 | H   ~  ~  ~  ~  ~  ~  ~  ~  D  ~      H   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 81 | I   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~      I   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 82 | J   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~      J   ~  ~  ~  ~  ~  ~  ~  ~  ~  ~ 
 83 | ```
 84 | 
 85 | ## Gameplay
 86 | 
 87 | - **Players**: 2
 88 | - **Turns**: Players take turns selecting a coordinate on the opponent’s grid to target. Each turn, a player can either hit, miss, or sink one of the opponent's ships.
 89 | - **Board**: Each player is has their own grid for ship placement, and a separate tracking grid to record their hits and misses on the opponent.
 90 | - **Objective**: Locate and sink all ships on the opponent's grid by strategically guessing coordinates and remembering previous hits.
 91 | - **Ship Types and Lengths**:
 92 |   - **Aircraft Carrier**: 5 cells
 93 |   - **Battleship**: 4 cells
 94 |   - **Submarine**: 3 cells
 95 |   - **Destroyer**: 3 cells
 96 |   - **Patrol Boat**: 2 cells
 97 | - **Winning Condition**: The game is won by the first player to sink all of their opponent's ships.
 98 | 
 99 | 
100 | ## Key Rules
101 | 
102 | 1. **Attacking**:
103 |    - Players take turns selecting a coordinate on the opponent’s grid (e.g., "[A5]").
104 |    - If the selected coordinate contains part of a ship, it is marked as a "hit" (shown as "X") on both the attacking player's tracking grid and the opponent's ship grid.
105 |    - If the selected coordinate is empty, it is marked as a "miss" (shown as "O").
106 | 
107 | 2. **Valid Moves**:
108 |    - Players must choose a coordinate within the grid bounds (e.g., "A0" to "J9" on a 10x10 grid).
109 |    - Moves are invalid if the chosen coordinate has already been attacked (i.e., previously marked as a hit or miss).
110 | 
111 | 3. **Ship Sinking**:
112 |    - Each ship has a specific length (e.g., Battleship is 4 cells). A ship is considered "sunk" once all of its cells have been hit.
113 |    - The game announces when a player has sunk one of the opponent’s ships.
114 | 
115 | 4. **Winning Conditions**:
116 |    - **Win**: The first player to sink all ships on the opponent’s grid wins the game.
117 |    - **Loss**: A player loses if all their ships are sunk before they can sink the opponent’s ships.
118 |    
119 |    **Note:** Draws are typically not possible in Battleship; however, if desired, a draw rule could be introduced if a maximum turn limit is set.
120 | 
121 | 5. **Game Termination**:
122 |    - The game concludes when one player has successfully sunk all ships on the opponent's grid.
123 | 
124 | 
125 | ## Rewards
126 | 
127 | | Outcome          | Reward for Player | Reward for Opponent |
128 | |------------------|:-----------------:|:-------------------:|
129 | | **Win**          | `+1`              | `-1`                |
130 | | **Lose**         | `-1`              | `+1`                |
131 | | **Invalid**      | `-1`              | `0`                 |
132 | 
133 | 
134 | ## Parameters
135 | 
136 | - `difficulty` (`str`):
137 |     - **Description**: Sets the difficulty level, adjusting the grid size.
138 |     - **Options**:
139 |         - `"easy"`: Creates a 10x10 grid, ideal for simpler gameplay.
140 |         - `"medium"`: Creates a 12x12 grid, offering moderate difficulty.
141 |         - `"hard"`: Creates an 14x14 grid, challenging players’ strategy.
142 |     - **Impact**:
143 |         - Larger grids increase the game’s difficulty by adding more occurences of misses and rewarding the agent with the better strategy of spreading out.
144 | 
145 | ## Variants
146 | 
147 | | Env-id                  | difficulty |
148 | |-------------------------|:----------:|
149 | | `Battelship-v0-easy`    | `easy`     |
150 | | `Battelship-v0-medium`  | `medium`   |
151 | | `Battelship-v0-hard`    | `hard`     |
152 | 
153 | ## Example Usage
154 | 
155 | ```python
156 | import textarena as ta
157 | 
158 | # Initialize the environment
159 | env = ta.make(env_id="Battleship-v0-easy")
160 | 
161 | # Wrap the environment for easier observation handling
162 | env = ta.wrappers.LLMObservationWrapper(env=env)
163 | 
164 | # Wrap the environment for pretty rendering
165 | env = ta.wrappers.PrettyRenderWrapper(env=env)
166 | 
167 | # initalize agents
168 | agents = {
169 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
170 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
171 |     }
172 | 
173 | # reset the environment to start a new game
174 | observations = env.reset(seed=490)
175 | 
176 | # Game loop
177 | done = False
178 | while not done:
179 | 
180 |     # Get the current player
181 |     current_player_id = env.state.get("current_player")
182 | 
183 |     # Get the current observation for the player
184 |     obs = observations[current_player_id]
185 | 
186 |     # Agent decides on an action based on the observation
187 |     action = agents[current_player_id](obs)
188 | 
189 |     # Execute the action in the environment
190 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
191 | 
192 |     # Check if the game has ended
193 |     done = terminated or truncated
194 | 
195 |     # Optionally render the environment to see the current state
196 |     env.render()
197 | 
198 |     if done:
199 |         break
200 | 
201 | # Finally, print the game results
202 | for player_id, agent in agents.items():
203 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
204 | print(f"Reason: {info['reason']}")
205 | ```
206 | 
207 | ## Troubleshooting
208 | 
209 | - **Repeatedly mentioning other trivial coordinates in square brackets**:
210 |     - **Issue**: The game environment wrongly detects a trivial coordinate as the model's decision to attack. This causes the model to wrongly penalize the model for repeating a move, when it was merely thinking aloud about its previous failed move.
211 |     - **Solution**: Refine the prompt to explicitly highlight how mentioned coordinates can be in the format B3 or C8. And only when submitting its move, to wrap in square brackets.
212 | 
213 | - **Invalid Move Format**:
214 |     - **Issue**: A player keeps repeating the same coordinate as what its opponent made.
215 |     - **Solution**: Encourage the model to explore new insights and strategies different from its opponent.
216 | 
217 | ## Version History
218 | - **v0**
219 |   - Initial release 
220 | 
221 | 
222 | ### Contact
223 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/two_player/Battleship/example.py

- Extension: .py
- Language: python
- Size: 1338 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make(env_id="Battleship-v0-easy")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
15 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
16 |     }
17 | 
18 | 
19 | observations = env.reset(seed=490)
20 | 
21 | 
22 | done = False
23 | while not done:
24 | 
25 |     
26 |     current_player_id = env.state.get("current_player")
27 | 
28 |     
29 |     obs = observations[current_player_id]
30 | 
31 |     
32 |     action = agents[current_player_id](obs)
33 | 
34 |     
35 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
36 | 
37 |     
38 |     done = terminated or truncated
39 | 
40 |     
41 |     env.render()
42 | 
43 |     if done:
44 |         break
45 | 
46 | 
47 | for player_id, agent in agents.items():
48 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
49 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/two_player/Battleship/__init__.py

- Extension: .py
- Language: python
- Size: 138 bytes
- Created: 2024-12-12 11:09:33
- Modified: 2024-12-12 11:09:33

### Code

```python
1 | from textarena.envs.two_player.Battleship.env import BattleshipEnv
2 | from textarena.envs.two_player.Battleship.render import GameStateRender
```

## File: textarena/envs/two_player/IteratedPrisonersDillemma/test.py

- Extension: .py
- Language: python
- Size: 4213 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | from iterated_prisoners_dilemma import (
  4 |     PrisonersDilemmaEnv,
  5 | )  
  6 | 
  7 | 
  8 | class TestIPDEnv(unittest.TestCase):
  9 | 
 10 |     
 11 |     test_cases = {
 12 |         
 13 |         
 14 |         
 15 |         
 16 |         
 17 |         
 18 |         "valid_move_both": {
 19 |             "env_id": "IPD-fixed-1",
 20 |             "actions": ["cooperate", "cooperate"],
 21 |             "expected_rewards": {0: 0, 1: 0},
 22 |             "expected_terminated": True,
 23 |         },
 24 |         "valid_move_w_messages": {
 25 |             "env_id": "IPD-fixed-1",
 26 |             "actions": ["I will cooperate\ndefect", "I will cooperate\ndefect"],
 27 |             "expected_rewards": {0: 0, 1: 0},
 28 |             "expected_terminated": True,
 29 |         },
 30 |         "correct_payoff_0_winner": {
 31 |             "env_id": "IPD-fixed-1",
 32 |             "actions": ["cooperate", "defect"],
 33 |             "expected_rewards": {0: -1, 1: 1},
 34 |             "expected_terminated": True,
 35 |         },
 36 |         "correct_payoff_1_winner": {
 37 |             "env_id": "IPD-fixed-1",
 38 |             "actions": ["defect", "cooperate"],
 39 |             "expected_rewards": {0: 1, 1: -1},
 40 |             "expected_terminated": True,
 41 |         },
 42 |         "unfinished_game": {
 43 |             "env_id": "IPD-fixed-1",
 44 |             "actions": ["cooperate"],
 45 |             "expected_rewards": {0: 0, 1: 0},
 46 |             "expected_terminated": False,
 47 |         },
 48 |         "invalid_move_p0": {
 49 |             "env_id": "IPD-fixed-1",
 50 |             "actions": ["[Move] e2e4"],
 51 |             "expected_rewards": {0: -1, 1: 0},
 52 |             "expected_terminated": True,
 53 |         },
 54 |         "invalid_move_p1": {
 55 |             "env_id": "IPD-fixed-1",
 56 |             "actions": ["cooperate", "invalid"],
 57 |             "expected_rewards": {0: 0, 1: -1},
 58 |             "expected_terminated": True,
 59 |         },
 60 |     }
 61 | 
 62 |     @parameterized.expand(
 63 |         [
 64 |             (
 65 |                 name,
 66 |                 details["env_id"],
 67 |                 details["actions"],
 68 |                 details["expected_rewards"],
 69 |                 details["expected_terminated"],
 70 |             )
 71 |             for name, details in test_cases.items()
 72 |         ]
 73 |     )
 74 |     def test_iterated_prisoners_dilemma(
 75 |         self, name, env_id, actions, expected_rewards, expected_terminated
 76 |     ):
 77 |         
 78 |         if env_id == "IPD-fixed-1":
 79 |             env = PrisonersDilemmaEnv(max_rounds=1, mode="fixed")
 80 |         env.reset()
 81 | 
 82 |         terminated = False
 83 |         truncated = False
 84 |         rewards = {0: 0, 1: 0}
 85 | 
 86 |         for i, action in enumerate(actions):
 87 |             if terminated or truncated:
 88 |                 break
 89 |             player_id = i % 2  
 90 |             env_action = action
 91 | 
 92 |             
 93 |             observations, reward, truncated, terminated, info = env.step(
 94 |                 player_id, env_action
 95 |             )
 96 | 
 97 |             
 98 |             if reward:
 99 |                 rewards.update(reward)
100 | 
101 |         
102 |         self.assertEqual(
103 |             terminated or truncated,
104 |             expected_terminated,
105 |             f"Test '{name}' failed on termination status.",
106 |         )
107 | 
108 |         
109 |         self.assertEqual(rewards, expected_rewards, f"Test '{name}' failed on rewards.")
110 | 
111 |     def run_unit_tests():
112 |         
113 |         unittest.main(argv=["first-arg-is-ignored"], exit=False)
114 | 
115 | 
116 | 
117 | if __name__ == "__main__":
118 |     TestIPDEnv.run_unit_tests()
```

## File: textarena/envs/two_player/IteratedPrisonersDillemma/iterated_prisoners_dilemma.py

- Extension: .py
- Language: python
- Size: 8191 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | import random
  2 | from typing import Optional, Dict, Tuple, Any
  3 | 
  4 | import textarena as ta
  5 | 
  6 | 
  7 | def _num_rounds(max_rounds, mode="random"):
  8 |     if mode == "random":
  9 |         return max(int(random.betavariate(2, 5) * max_rounds), 1) * 2
 10 |     elif mode == "fixed":
 11 |         return max_rounds * 2
 12 |     else:
 13 |         raise ValueError(f"Invalid mode: {mode}, must be 'random' or 'fixed'.")
 14 | 
 15 | 
 16 | class PrisonersDilemmaEnv(ta.Env):
 17 |     
 18 | 
 19 |     def __init__(self, max_rounds: int = 30, mode: str = "random"):
 20 |         
 21 |         self.max_rounds = max_rounds
 22 |         self.payoff_matrix = {
 23 |             ("cooperate", "cooperate"): (3, 3),
 24 |             ("cooperate", "defect"): (0, 5),
 25 |             ("defect", "cooperate"): (5, 0),
 26 |             ("defect", "defect"): (1, 1),
 27 |         }
 28 |         self.mode = mode
 29 |         num_rounds = _num_rounds(max_rounds, mode)
 30 |         self.state = ta.State(
 31 |             num_players=2,
 32 |             max_turns=num_rounds,
 33 |             render_keys=[["player_actions", 0], ["player_actions", 1]],
 34 |         )
 35 | 
 36 |     def reset(self, seed: Optional[int] = None) -> Optional[ta.Observations]:
 37 |         
 38 |         if seed is not None:
 39 |             random.seed(seed)
 40 |         else:
 41 |             random.seed()
 42 | 
 43 |         game_state = {
 44 |             "player_scores": {0: 0, 1: 0},
 45 |             "player_actions": {0: None, 1: None},
 46 |         }
 47 |         out = self.state.reset(
 48 |             game_state=game_state, player_prompt_function=self._generate_player_prompt
 49 |         )
 50 |         self.state.max_turns = _num_rounds(self.max_rounds, self.mode)
 51 |         return out
 52 | 
 53 |     def _generate_player_prompt(self, player_id: int) -> str:
 54 |         
 55 |         prompt = (
 56 |             f"You are Player {player_id} in Iterated Prisoner's Dilemma.\n"
 57 |             f"On each turn, you may either 'cooperate' or 'defect'.\n"
 58 |             "Payoff matrix:\n"
 59 |             "  - If both players cooperate, each gets 3 points.\n"
 60 |             "  - If you cooperate and the opponent defects, you get 0 points, and they get 5.\n"
 61 |             "  - If you defect and the opponent cooperates, you get 5 points, and they get 0.\n"
 62 |             "  - If both defect, each gets 1 point.\n"
 63 |             "Each turn you can send a one-line message to your opponent followed by either 'cooperate' or 'defect' on the subsequent line."
 64 |             "Your action won't be revealed until both players have acted, but your message will be\n"
 65 |         )
 66 |         return prompt
 67 | 
 68 |     def step(self, player_id: int, action: str) -> Tuple[
 69 |         Optional[Dict[int, str]],  
 70 |         Optional[Dict[int, int]],  
 71 |         bool,  
 72 |         bool,  
 73 |         Dict[str, Any],  
 74 |     ]:
 75 |         
 76 |         
 77 |         parsed_action = action.split("\n")
 78 |         if len(parsed_action) > 2:
 79 |             self.state.set_invalid_move(
 80 |                 player_ids=[player_id],
 81 |                 reasons=[
 82 |                     f"Invalid action by Player {player_id}: Must include a message followed by 'cooperate' or 'defect'."
 83 |                 ],
 84 |             )
 85 |             return self.state.step()
 86 |         elif len(parsed_action) == 2:
 87 |             message = parsed_action[0]
 88 |             action = parsed_action[1]
 89 |         else:
 90 |             message = None
 91 |             action = parsed_action[0]
 92 |         if message is not None:
 93 |             self.state.add_observation(
 94 |                 from_id=player_id,
 95 |                 to_id=1 - player_id,
 96 |                 message=message,
 97 |                 for_logging=True,
 98 |             )
 99 |         if action not in {"cooperate", "defect"}:
100 |             self.state.set_invalid_move(
101 |                 player_ids=[player_id],
102 |                 reasons=[
103 |                     f"Invalid action by Player {player_id}: '{action}'. Must be 'cooperate' or 'defect'."
104 |                 ],
105 |             )
106 |             return self.state.step()
107 | 
108 |         
109 |         self.state.game_state["player_actions"][player_id] = action
110 |         self.state.add_observation(
111 |             from_id=player_id,
112 |             to_id=player_id,
113 |             message=f"Player {player_id} chose to {action}",
114 |             for_logging=True,
115 |         )
116 | 
117 |         
118 |         if None not in self.state.game_state["player_actions"].values():
119 |             actions = tuple(self.state.game_state["player_actions"].values())
120 |             
121 |             self.state.add_observation(
122 |                 from_id=-1,
123 |                 to_id=0,
124 |                 message=f"Player 1 chose to {actions[1]}",
125 |                 for_logging=True,
126 |             )
127 |             self.state.add_observation(
128 |                 from_id=-1,
129 |                 to_id=1,
130 |                 message=f"Player 0 chose to {actions[0]}",
131 |                 for_logging=True,
132 |             )
133 |             scores = self.payoff_matrix[actions]
134 | 
135 |             
136 |             for i, score in enumerate(scores):
137 |                 self.state.game_state["player_scores"][i] += score
138 |             self.state.add_observation(
139 |                 from_id=ta.GAME_ID,
140 |                 to_id=-1,  
141 |                 message=f"Round result: {actions}. Scores updated to {self.state.game_state['player_scores']}",
142 |                 for_logging=True,
143 |             )
144 |             
145 |             if self.state.turn >= self.state.max_turns - 1:
146 |                 self.state.add_observation(
147 |                     from_id=ta.GAME_ID,
148 |                     to_id=-1,  
149 |                     message="Game over!",
150 |                 )
151 |                 if (
152 |                     self.state.game_state["player_scores"][0]
153 |                     == self.state.game_state["player_scores"][1]
154 |                 ):
155 |                     self.state.set_draw(reason="Players have equal scores, game ended")
156 |                 else:
157 |                     winner = max(
158 |                         self.state.game_state["player_scores"],
159 |                         key=self.state.game_state["player_scores"].get,
160 |                     )
161 |                     self.state.set_winners(
162 |                         player_ids=[winner],
163 |                         reason=f"Player {winner} has the highest score, game ended",
164 |                     )
165 |             else:
166 |                 self.state.add_observation(
167 |                     from_id=ta.GAME_ID,
168 |                     to_id=-1,  
169 |                     message="Next round starting... Send a one-line message followed by 'cooperate' or 'defect' on the next line.",
170 |                 )
171 | 
172 |                 
173 |                 self.state.game_state["player_actions"] = {0: None, 1: None}
174 |         return self.state.step()
175 | 
176 |     def render(self):
177 |         
178 |         print(f"Round {self.state.turn} / {self.state.max_turns}")
179 |         print(
180 |             f"Scores: Player 0 = {self.state.game_state['player_scores'][0]}, Player 1 = {self.state.game_state['player_scores'][1]}"
181 |         )
182 |         print("Game Logs:")
183 |         for sender_id, message in self.state.game_state["logs"]:
184 |             if sender_id == "GAME":
185 |                 print(f"[GAME]: {message}")
186 |             else:
187 |                 print(f"Player {sender_id}: {message}")
188 |         print("\n")
```

## File: textarena/envs/two_player/IteratedPrisonersDillemma/README.md

- Extension: .md
- Language: markdown
- Size: 5755 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```markdown
  1 | # Prisoner's Dilemma Environment Documentation
  2 | 
  3 | ## WARNING
  4 | This documentation was created by chatgpt and may be garbage...
  5 | 
  6 | ## Overview
  7 | 
  8 | **Prisoner's Dilemma** is a strategic two-player game where each player can either "cooperate" or "defect" in each round. The objective is to maximize individual scores based on the actions taken by both players according to the game's payoff matrix. Players interact by sending a one-line message to the opponent and then choosing an action (either "cooperate" or "defect").
  9 | 
 10 | The environment allows for variable-length games, supporting both fixed and random round lengths based on a beta distribution.
 11 | 
 12 | ## Action Space
 13 | 
 14 | - **Format:** Actions consist of a message followed by either "cooperate" or "defect."
 15 | - **Action Structure:**
 16 |     - Players may send a one-line message to their opponent, which can include strategy hints, taunts, or other interactions.
 17 |     - The message is followed on a new line by the action.
 18 |     - **Example Actions:**
 19 |         - `"Let's work together!\ncooperate"`
 20 |         - `"No trust here...\ndefect"`
 21 | - **Action Validity:** 
 22 |     - Each action should contain a one-line message and an action ("cooperate" or "defect").
 23 |     - Actions that do not conform to this format are marked invalid.
 24 | 
 25 | ## Observation Space
 26 | 
 27 | ### Observations
 28 | 
 29 | Players receive the messages sent by their opponents, the actions taken in each round, and the updated score information. These observations guide players' decisions to cooperate or defect based on prior interactions.
 30 | 
 31 | **Reset Observation:**
 32 | 
 33 | On reset, each player is informed about their role in the game and the payoff matrix. For example:
 34 | ```plaintext
 35 | You are Player 0 in the Iterated Prisoner's Dilemma.
 36 | On each turn, you may either "cooperate" or "defect".
 37 | Payoff matrix:
 38 |   - Both cooperate: 3 points each
 39 |   - You cooperate, opponent defects: 0 points for you, 5 for them
 40 |   - You defect, opponent cooperates: 5 points for you, 0 for them
 41 |   - Both defect: 1 point each
 42 | Each turn, you can send a one-line message to your opponent, followed by your action.
 43 | ```
 44 | 
 45 | **Step Observation:**
 46 | After each step, players receive updates about the actions taken by both players and the resulting scores. For example:
 47 | ```plaintext
 48 | Player 1 chose to defect.
 49 | Round result: (cooperate, defect). Scores updated to {Player 0: 3, Player 1: 5}.
 50 | ```
 51 | 
 52 | If the game has multiple rounds, the observation will include a prompt for the next turn, allowing players to strategize based on accumulated information.
 53 | 
 54 | ## Gameplay
 55 | 
 56 | - **Players**: 2
 57 | - **Turns**: Players simultaneously select actions each round.
 58 | - **Action Format**: Each action includes a one-line message and a choice between "cooperate" or "defect."
 59 | - **Objective**: Accumulate the highest score by the end of the game.
 60 | - **Game Duration**: Variable length, either a fixed number of rounds or a random duration based on `max_rounds`.
 61 | 
 62 | ## Key Rules
 63 | 
 64 | 1. **Action Format**:
 65 |     - Actions must contain a one-line message and an action ("cooperate" or "defect").
 66 |     - If the format is incorrect, the move will be marked as invalid.
 67 | 
 68 | 2. **Game Termination**:
 69 |     - **Fixed Mode**: Ends after `max_rounds` rounds.
 70 |     - **Random Mode**: Ends after a variable number of rounds, influenced by a beta distribution based on `max_rounds`.
 71 | 
 72 | 3. **Invalid Moves**:
 73 |     - Moves that do not contain a message or are not "cooperate" or "defect" will be marked as invalid.
 74 |     - Invalid moves do not impact the score but may signal mistrust or indecision to the opponent.
 75 | 
 76 | ## Rewards
 77 | 
 78 | The following payoff matrix determines the points for each player based on their actions:
 79 | 
 80 | | Player 0 Action | Player 1 Action | Player 0 Reward | Player 1 Reward |
 81 | |-----------------|-----------------|-----------------|-----------------|
 82 | | Cooperate       | Cooperate       |       +3        |       +3        |
 83 | | Cooperate       | Defect          |       +0        |       +5        |
 84 | | Defect          | Cooperate       |       +5        |       +0        |
 85 | | Defect          | Defect          |       +1        |       +1        |
 86 | 
 87 | ## Parameters
 88 | 
 89 | - **max_rounds** (`int`): 
 90 |     - **Description**: Sets the maximum number of rounds for the game.
 91 |     - **Impact**: Controls game length; in "random" mode, it influences the beta distribution for a variable game length.
 92 | 
 93 | - **mode** (`str`): 
 94 |     - **Description**: Determines the game length style.
 95 |     - **Values**:
 96 |         - `"random"`: Game length is variable, based on a beta distribution influenced by `max_rounds`.
 97 |         - `"fixed"`: Game length is exactly `max_rounds`.
 98 | 
 99 | ## Example Usage
100 | 
101 | ```python
102 | import textarena as ta
103 | 
104 | # Initialize the environment
105 | env = PrisonersDilemmaEnv(max_rounds=30, mode="random")
106 | 
107 | # Reset the environment to start a new game
108 | observations = env.reset(seed=42)
109 | 
110 | # Game loop
111 | done = False
112 | while not done:
113 |     for player_id in [0, 1]:
114 |         # Example prompt response (could come from an agent)
115 |         action = "Let's work together.\ncooperate" if player_id == 0 else "No trust here.\ndefect"
116 |         
117 |         # Execute the action in the environment
118 |         observations, rewards, truncated, terminated, info = env.step(player_id, action)
119 |         
120 |         # Check if the game has ended
121 |         done = terminated or truncated
122 |         
123 |         # Optionally render the environment
124 |         env.render()
125 |         if done:
126 |             break
127 | ```
128 | 
129 | ## Troubleshooting
130 | 
131 | - **Invalid Move Format**:
132 |     - **Issue**: Action provided by a player does not follow the message-action format.
133 |     - **Solution**: Ensure actions include a one-line message followed by "cooperate" or "defect" on a new line.
134 | 
135 | - **Unexpected Game End**:
136 |     - **Issue**: Game terminates earlier than expected.
137 |     - **Solution**: Verify `mode` setting and ensure `max_rounds` aligns with intended game length.
138 | 
```

## File: textarena/envs/two_player/WordChains/test.py

- Extension: .py
- Language: python
- Size: 0 bytes
- Created: 2024-10-29 16:27:13
- Modified: 2024-10-29 16:27:13

### Code

```python

```

## File: textarena/envs/two_player/WordChains/env.py

- Extension: .py
- Language: python
- Size: 4568 bytes
- Created: 2024-12-12 10:16:02
- Modified: 2024-12-12 10:16:02

### Code

```python
  1 | 
  2 | 
  3 | import re 
  4 | import random 
  5 | 
  6 | 
  7 | import nltk 
  8 | import enchant
  9 | from nltk.corpus import words 
 10 | nltk.download("words")
 11 | 
 12 | 
 13 | import textarena as ta 
 14 | 
 15 | 
 16 | class WordChainsEnv(ta.Env):
 17 |     
 18 |     def __init__(self, max_turns: Optional[int]=None): 
 19 |         
 20 | 
 21 |         
 22 |         self.word_lis = list(set(word.lower() for word in words.words()))
 23 | 
 24 |         
 25 |         try:
 26 |             self.word_checker_us = enchant.Dict("en_US")
 27 |             self.word_checker_uk = enchant.Dict("en_GB")
 28 |         except enchant.errors.DictNotFoundError as e:
 29 |             raise ValueError(f"Enchant dictionary not found: {e}. Ensure that the en_US and en_GB dictionaries are installed.")
 30 | 
 31 | 
 32 |         
 33 |         self.state = ta.State(
 34 |             num_players=2,
 35 |             max_turns=max_turns,
 36 |             render_keys=["current_word", "required_start_letter"]
 37 |         )
 38 | 
 39 |     def reset(self, seed: Optional[int] = None) -> ta.Observations:
 40 |         
 41 |         if seed is not None:
 42 |             random.seed(seed)
 43 |         else:
 44 |             random.seed()
 45 | 
 46 |         starting_word = random.choice(self.word_list)
 47 | 
 48 | 
 49 |         return self.state.reset(
 50 |             game_state={
 51 |                 "current_word": starting_word,
 52 |                 "used_words": set(starting_word),
 53 |                 "required_start_letter": starting_word[-1].lower()
 54 |             },
 55 |             player_prompt_function=self._generate_player_prompt
 56 |         )
 57 | 
 58 | 
 59 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[str, Any]) -> str:
 60 |         
 61 |         prompt = (
 62 |             f"You are Player {player_id} in the Word Chains Game.\n"
 63 |             "Players take turns to provide valid English words that start with the last letter of the previous word.\n"
 64 |             "Repetition of words is not allowed.\n"
 65 |             "If you provide an invalid word, repeat a word, or fail to follow the sequence, you lose.\n"
 66 |             "Please wrap your word in square brackets, e.g., '[apple]', '[monkey'], etc. .\n"
 67 |             f"The starting word is [{game_state['current_word']}]. Please provide the next word.\n"
 68 |             "On your turn, simply type your word.\n"
 69 |         )
 70 |         if self.state.max_turns:
 71 |             prompt += f"The game will end after {self.state.max_turns} turns if no player loses.\n"
 72 |         return prompt
 73 | 
 74 | 
 75 | 
 76 |     def step(
 77 |         self,
 78 |         player_id: int,
 79 |         action: str,
 80 |     ) -> Tuple[
 81 |         Optional[ta.Observations], 
 82 |         Optional[ta.Rewards], 
 83 |         bool, 
 84 |         bool, 
 85 |         ta.Info, 
 86 |     ]:
 87 |         
 88 |         
 89 |         self.state.check_action_format(
 90 |             action=action,
 91 |             player_id=player_id
 92 |         )
 93 | 
 94 |         
 95 |         self.state.add_observation(
 96 |             from_id=player_id,
 97 |             to_id=-1, 
 98 |             message=action,
 99 |             for_logging=True
100 |         )
101 | 
102 |         
103 |         word_match = re.search(r"\[(\w+)\]", action)
104 |         if not word_match:
105 |             
106 |             self.state.set_invalid_move(
107 |                 player_ids=[player_id],
108 |                 reasons=[f"The Player {player_id} did not provide a new word."]
109 |             )
110 | 
111 |         else:
112 |             word = word_match.group(1).lower()
113 |             
114 |             if not word.startswith(self.state.game_state["required_start_letter"]):
115 |                 
116 |                 self.state.set_invalid_move(
117 |                     player_ids=[player_id],
118 |                     reasons=[f"The word provided by Player {player_id} did start with the correct letter."]
119 |                 )
120 | 
121 |             
122 |             elif not (
123 |                 self.word_checker_us.check(word) or self.word_checker_uk.check(word)
124 |             ):
125 |                 
126 |                 self.state.set_invalid_move(
127 |                     player_ids=[player_id],
128 |                     reasons=[f"The word provided by Player {player_id} is not a valid english word."]
129 |                 )
130 | 
131 | 
132 |                 
```

## File: textarena/envs/two_player/WordChains/README.md

- Extension: .md
- Language: markdown
- Size: 0 bytes
- Created: 2024-10-29 16:27:09
- Modified: 2024-10-29 16:27:09

### Code

```markdown

```

## File: textarena/envs/two_player/LeHavre/env.py

- Extension: .py
- Language: python
- Size: 26116 bytes
- Created: 2024-12-12 12:08:10
- Modified: 2024-12-12 12:08:10

### Code

```python
  1 | import random
  2 | import re
  3 | from typing import Any, Dict, Optional, Tuple
  4 | import textarena as ta
  5 | 
  6 | class LeHavreEnv(ta.Env):
  7 |     
  8 |     def __init__(self, max_turns: Optional[int] = 20):
  9 |         
 10 |         self.resource_names = [
 11 |             "Wood", "Clay", "Iron", "Grain", "Fish", 
 12 |             "Coal", "Coke", "Cattle", "Bread", "Meat",
 13 |             "Smoked Fish", "Charcoal", "Brick", "Steel", "Franc"
 14 |         ]
 15 |         
 16 |         
 17 |         self.food_values = {
 18 |             "Fish": 1,
 19 |             "Bread": 2,
 20 |             "Meat": 3,
 21 |             "Smoked Fish": 2,
 22 |             "Franc": 1
 23 |         }
 24 | 
 25 |         
 26 |         self.state = ta.State(
 27 |             num_players=2,
 28 |             max_turns=max_turns
 29 |         )
 30 | 
 31 |         
 32 |         self.enter_building_pattern = re.compile(
 33 |             r"\[Enter:\s*([^\[\]]+?)\s*\]",
 34 |             re.IGNORECASE | re.DOTALL
 35 |         )
 36 |         self.take_resources_pattern = re.compile(
 37 |             r"\[Take:\s*([^\[\]]+?)\s*\]",
 38 |             re.IGNORECASE | re.DOTALL
 39 |         )
 40 |         self.build_pattern = re.compile(
 41 |             r"\[Build:\s*([^\[\]]+?)\s*\]",
 42 |             re.IGNORECASE | re.DOTALL
 43 |         )
 44 |         self.process_pattern = re.compile(
 45 |             r"\[Process:\s*([^\[\]]+?)\s*->\s*([^\[\]]+?)\s*\]",
 46 |             re.IGNORECASE | re.DOTALL
 47 |         )
 48 |         self.pay_loan_pattern = re.compile(
 49 |             r"\[Pay Loan:\s*(\d+)\s*\]",
 50 |             re.IGNORECASE
 51 |         )
 52 |         self.take_loan_pattern = re.compile(
 53 |             r"\[Take Loan:\s*(\d+)\s*\]",
 54 |             re.IGNORECASE
 55 |         )
 56 | 
 57 |     def reset(self, seed: Optional[int] = None) -> Optional[ta.Observations]:
 58 |         
 59 |         
 60 |         game_state = {
 61 |             "supply": {resource: 0 for resource in self.resource_names},
 62 |             "player_resources": {},
 63 |             "buildings": {
 64 |                 "Construction Firm": {
 65 |                     "cost": {},
 66 |                     "entry_fee_food": 2,
 67 |                     "entry_fee_francs": 0,
 68 |                     "worker": None,
 69 |                     "produces": {"Wood": 2}
 70 |                 },
 71 |                 "Clay Mound": {
 72 |                     "cost": {},
 73 |                     "entry_fee_food": 1,
 74 |                     "entry_fee_francs": 0,
 75 |                     "worker": None,
 76 |                     "produces": {"Clay": 1}
 77 |                 },
 78 |                 
 79 |             },
 80 |             "current_building": None,
 81 |             "food_requirement": {
 82 |                 0: 3,
 83 |                 1: 3
 84 |             }
 85 |         }
 86 | 
 87 |         
 88 |         for player_id in [0, 1]:
 89 |             game_state["player_resources"][player_id] = {
 90 |                 "Wood": 2,
 91 |                 "Clay": 1,
 92 |                 "Fish": 2,
 93 |                 "Franc": 2,
 94 |                 "Loan": 0
 95 |             }
 96 | 
 97 |         
 98 |         starting_supply = {
 99 |             "Wood": 4,
100 |             "Clay": 4,
101 |             "Fish": 4,
102 |             "Franc": 4
103 |         }
104 |         game_state["supply"].update(starting_supply)
105 | 
106 |         
107 |         game_state["resource_offers"] = self._generate_resource_offers()
108 | 
109 |         return self.state.reset(
110 |             seed=seed,
111 |             game_state=game_state,
112 |             player_prompt_function=self._generate_player_prompt
113 |         )
114 | 
115 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[int, Any]) -> str:
116 |         
117 |         resources_list = "; ".join(
118 |             [f"{qty} {res}" for res, qty in game_state["player_resources"][player_id].items() if qty > 0]
119 |         )
120 |         
121 |         buildings_list = "\n".join([
122 |             f"- {name}: Entry fee: {bld['entry_fee_food']} food or {bld['entry_fee_francs']} francs" +
123 |             (f" (Occupied by Player {bld['worker']})" if bld['worker'] is not None else "")
124 |             for name, bld in game_state["buildings"].items()
125 |         ])
126 | 
127 |         prompt = (
128 |             f"You are Player {player_id} in Le Havre.\n"
129 |             f"Your current resources: {resources_list}\n\n"
130 |             f"Available buildings:\n{buildings_list}\n\n"
131 |             "Available actions:\n"
132 |             "1. Enter a building: [Enter: Building Name]\n"
133 |             "2. Take resources: [Take: Resource Name]\n"
134 |             "3. Build something: [Build: Building Name]\n"
135 |             "4. Process resources: [Process: Input Resources -> Output Resources]\n"
136 |             "5. Take loan: [Take Loan: Amount]\n"
137 |             "6. Pay loan: [Pay Loan: Amount]\n\n"
138 |             f"Food requirement this round: {game_state['food_requirement'][player_id]}\n"
139 |         )
140 |         return prompt
141 | 
142 |     def step(
143 |         self,
144 |         action: str,
145 |     ) -> Tuple[Optional[ta.Rewards], bool, bool, ta.Info]:
146 |         
147 |         
148 |         self.state.check_action_format(
149 |             action=action,
150 |         )
151 | 
152 |         player_id = self.state.current_player_id
153 | 
154 | 
155 |         
156 |         self.state.add_observation(
157 |             from_id=player_id,
158 |             to_id=-1,
159 |             message=action,
160 |             for_logging=True
161 |         )
162 | 
163 |         
164 |         if self.state.turn % self.state.num_players == 0:
165 |             self._add_new_resources()
166 |             self._return_workers()
167 | 
168 |         
169 |         made_main_action = False
170 | 
171 |         
172 |         if self.enter_building_pattern.search(action):
173 |             success = self._handle_enter_building(player_id, action)
174 |             made_main_action = success
175 |         elif self.take_resources_pattern.search(action):
176 |             success = self._handle_take_resources(player_id, action)
177 |             made_main_action = success
178 |         elif self.build_pattern.search(action):
179 |             success = self._handle_build(player_id, action)
180 |             made_main_action = success
181 |         elif self.process_pattern.search(action):
182 |             success = self._handle_process(player_id, action)
183 |             made_main_action = success
184 |         elif self.pay_loan_pattern.search(action) or self.take_loan_pattern.search(action):
185 |             success = self._handle_loans(player_id, action)
186 |             
187 |         else:
188 |             
189 |             self.state.set_invalid_move(
190 |                 player_ids=[player_id],
191 |                 reasons=[f"Player {player_id} made an invalid action."]
192 |             )
193 |             return self.state.step()
194 | 
195 |         
196 |         if made_main_action:
197 |             self.state.current_player_id = (self.state.current_player_id + 1) % self.state.num_players
198 | 
199 |         
200 |         if self._is_feeding_phase():
201 |             self._handle_feeding_phase()
202 | 
203 |         
204 |         if self._is_round_end():
205 |             self._accumulate_resources()
206 | 
207 |         
208 |         if self.state.turn >= self.state.max_turns:
209 |             self._end_game()
210 |             return self.state.step()
211 | 
212 |         
213 |         
214 |         
215 |         
216 |         
217 |         
218 | 
219 |         return self.state.step()
220 | 
221 | 
222 |     def _add_new_resources(self) -> None:
223 |         
224 |         if self.state.turn // self.state.num_players < len(self.state.game_state["resource_offers"]):
225 |             new_resources = self.state.game_state["resource_offers"][
226 |                 self.state.turn // self.state.num_players
227 |             ]
228 |             for resource, amount in new_resources.items():
229 |                 self.state.game_state["supply"][resource] = \
230 |                     self.state.game_state["supply"].get(resource, 0) + amount
231 | 
232 |             self.state.add_observation(
233 |                 from_id=ta.GAME_ID,
234 |                 to_id=-1,
235 |                 message=f"Added new resources to supply: {self._resources_to_str(new_resources)}"
236 |             )
237 | 
238 |     def _return_workers(self) -> None:
239 |         
240 |         for building in self.state.game_state["buildings"].values():
241 |             if building["worker"] is not None:
242 |                 worker_id = building["worker"]
243 |                 building["worker"] = None
244 |                 self.state.add_observation(
245 |                     from_id=ta.GAME_ID,
246 |                     to_id=-1,
247 |                     message=f"Worker returned from {building['name']} to Player {worker_id}"
248 |                 )
249 | 
250 |     def _is_round_end(self) -> bool:
251 |         
252 |         return self.state.turn > 0 and \
253 |                self.state.turn % self.state.num_players == 0
254 | 
255 |     def _accumulate_resources(self) -> None:
256 |         
257 |         for resource in self.resource_names:
258 |             if resource in self.state.game_state["supply"] and \
259 |                self.state.game_state["supply"][resource] > 0:
260 |                 self.state.add_observation(
261 |                     from_id=ta.GAME_ID,
262 |                     to_id=-1,
263 |                     message=f"{self.state.game_state['supply'][resource]} {resource} remained uncollected"
264 |                 )
265 | 
266 |     def _calculate_player_value(self, player_id: int) -> int:
267 |         
268 |         value = 0
269 |         resources = self.state.game_state["player_resources"][player_id]
270 |         
271 |         
272 |         for resource, amount in resources.items():
273 |             if resource != "Loan":
274 |                 
275 |                 
276 |                 value += amount * 1  
277 | 
278 |         
279 |         value -= resources.get("Loan", 0) * 5
280 | 
281 |         
282 |         for building in self.state.game_state["buildings"].values():
283 |             if building.get("owner") == player_id:
284 |                 value += building.get("victory_points", 0)
285 | 
286 |         return value
287 | 
288 |     def _end_game(self) -> None:
289 |         
290 |         player_scores = {
291 |             pid: self._calculate_player_value(pid)
292 |             for pid in range(self.state.num_players)
293 |         }
294 | 
295 |         winner_id = max(player_scores.items(), key=lambda x: x[1])[0]
296 |         self.state.set_winners(
297 |             player_ids=[winner_id],
298 |             reason=f"Player {winner_id} won with {player_scores[winner_id]} points!"
299 |         )
300 | 
301 |     def _handle_enter_building(self, player_id: int, action: str) -> bool:
302 |         
303 |         match = self.enter_building_pattern.search(action)
304 |         if not match:
305 |             return False
306 | 
307 |         building_name = match.group(1).strip()
308 |         if building_name not in self.state.game_state["buildings"]:
309 |             self.state.set_invalid_move(
310 |                 player_ids=[player_id],
311 |                 reasons=[f"Building {building_name} does not exist."]
312 |             )
313 |             return True
314 | 
315 |         building = self.state.game_state["buildings"][building_name]
316 |         if building["worker"] is not None:
317 |             self.state.set_invalid_move(
318 |                 player_ids=[player_id],
319 |                 reasons=[f"Building {building_name} is occupied."]
320 |             )
321 |             return True
322 | 
323 |         
324 |         player_resources = self.state.game_state["player_resources"][player_id]
325 |         food_value = sum(qty * self.food_values.get(res, 0) 
326 |                         for res, qty in player_resources.items())
327 | 
328 |         if (building["entry_fee_food"] > 0 and food_value < building["entry_fee_food"]) or \
329 |            (building["entry_fee_francs"] > 0 and player_resources.get("Franc", 0) < building["entry_fee_francs"]):
330 |             self.state.set_invalid_move(
331 |                 player_ids=[player_id],
332 |                 reasons=[f"Cannot pay entry fee for {building_name}."]
333 |             )
334 |             return True
335 | 
336 |         
337 |         if building["entry_fee_francs"] > 0:
338 |             self.state.game_state["player_resources"][player_id]["Franc"] -= building["entry_fee_francs"]
339 |         
340 |         building["worker"] = player_id
341 |         self.state.game_state["current_building"] = building_name
342 | 
343 |         self.state.add_observation(
344 |             from_id=ta.GAME_ID,
345 |             to_id=-1,
346 |             message=f"Player {player_id} entered {building_name}."
347 |         )
348 |         return True
349 | 
350 |     def _handle_take_resources(self, player_id: int, action: str) -> bool:
351 |         
352 |         match = self.take_resources_pattern.search(action)
353 |         if not match:
354 |             return False
355 | 
356 |         resource_name = match.group(1).strip()
357 |         if resource_name not in self.resource_names:
358 |             self.state.set_invalid_move(
359 |                 player_ids=[player_id],
360 |                 reasons=[f"Invalid resource: {resource_name}."]
361 |             )
362 |             return True
363 | 
364 |         if self.state.game_state["supply"].get(resource_name, 0) <= 0:
365 |             self.state.set_invalid_move(
366 |                 player_ids=[player_id],
367 |                 reasons=[f"No {resource_name} available in supply."]
368 |             )
369 |             return True
370 | 
371 |         
372 |         self.state.game_state["supply"][resource_name] -= 1
373 |         self.state.game_state["player_resources"][player_id][resource_name] = \
374 |             self.state.game_state["player_resources"][player_id].get(resource_name, 0) + 1
375 | 
376 |         self.state.add_observation(
377 |             from_id=ta.GAME_ID,
378 |             to_id=-1,
379 |             message=f"Player {player_id} took 1 {resource_name} from supply."
380 |         )
381 |         return True
382 | 
383 |     def _handle_loans(self, player_id: int, action: str) -> bool:
384 |         
385 |         take_match = self.take_loan_pattern.search(action)
386 |         pay_match = self.pay_loan_pattern.search(action)
387 |         
388 |         if take_match:
389 |             amount = int(take_match.group(1))
390 |             self.state.game_state["player_resources"][player_id]["Loan"] = \
391 |                 self.state.game_state["player_resources"][player_id].get("Loan", 0) + amount
392 |             self.state.game_state["player_resources"][player_id]["Franc"] = \
393 |                 self.state.game_state["player_resources"][player_id].get("Franc", 0) + (amount * 4)
394 |             
395 |             self.state.add_observation(
396 |                 from_id=ta.GAME_ID,
397 |                 to_id=-1,
398 |                 message=f"Player {player_id} took {amount} loan(s)."
399 |             )
400 |             return True
401 |             
402 |         elif pay_match:
403 |             amount = int(pay_match.group(1))
404 |             current_loans = self.state.game_state["player_resources"][player_id].get("Loan", 0)
405 |             current_francs = self.state.game_state["player_resources"][player_id].get("Franc", 0)
406 |             
407 |             if amount > current_loans:
408 |                 self.state.set_invalid_move(
409 |                     player_ids=[player_id],
410 |                     reasons=[f"Player {player_id} doesn't have {amount} loans to repay."]
411 |                 )
412 |                 return True
413 |                 
414 |             if amount * 5 > current_francs:
415 |                 self.state.set_invalid_move(
416 |                     player_ids=[player_id],
417 |                     reasons=[f"Player {player_id} doesn't have enough Francs to repay {amount} loans."]
418 |                 )
419 |                 return True
420 |                 
421 |             self.state.game_state["player_resources"][player_id]["Loan"] -= amount
422 |             self.state.game_state["player_resources"][player_id]["Franc"] -= amount * 5
423 |             
424 |             self.state.add_observation(
425 |                 from_id=ta.GAME_ID,
426 |                 to_id=-1,
427 |                 message=f"Player {player_id} repaid {amount} loan(s)."
428 |             )
429 |             return True
430 |             
431 |         return False
432 | 
433 |     def _generate_resource_offers(self) -> list:
434 |         
435 |         basic_offers = [
436 |             {"Wood": 1, "Clay": 1},
437 |             {"Fish": 1, "Grain": 1},
438 |             {"Wood": 1, "Iron": 1},
439 |             {"Clay": 1, "Cattle": 1},
440 |             {"Fish": 1, "Wood": 1},
441 |             {"Grain": 1, "Clay": 1}
442 |         ]
443 |         offers = basic_offers.copy()
444 |         random.shuffle(offers)
445 |         return offers
446 | 
447 |     def _is_feeding_phase(self) -> bool:
448 |         
449 |         return self.state.turn > 0 and self.state.turn % 7 == 0
450 | 
451 |     def _handle_feeding_phase(self) -> None:
452 |         
453 |         for player_id in range(self.state.num_players):
454 |             food_req = self.state.game_state["food_requirement"][player_id]
455 |             resources = self.state.game_state["player_resources"][player_id]
456 |             
457 |             
458 |             food_value = sum(qty * self.food_values.get(res, 0) 
459 |                            for res, qty in resources.items())
460 |             
461 |             if food_value < food_req:
462 |                 
463 |                 needed_food = food_req - food_value
464 |                 loans_needed = (needed_food + 3) // 4  
465 |                 
466 |                 self.state.game_state["player_resources"][player_id]["Loan"] = \
467 |                     resources.get("Loan", 0) + loans_needed
468 |                 self.state.game_state["player_resources"][player_id]["Franc"] = \
469 |                     resources.get("Franc", 0) + (loans_needed * 4) - needed_food
470 |                 
471 |                 self.state.add_observation(
472 |                     from_id=ta.GAME_ID,
473 |                     to_id=-1,
474 |                     message=f"Player {player_id} took {loans_needed} loan(s) to pay for food."
475 |                 )
476 |             else:
477 |                 
478 |                 remaining_food = food_req
479 |                 for resource in ["Fish", "Bread", "Meat", "Smoked Fish", "Franc"]:
480 |                     if remaining_food <= 0:
481 |                         break
482 | 
483 | 
484 |     def _handle_feeding_phase(self) -> None:
485 |         
486 |         for player_id in range(self.state.num_players):
487 |             food_req = self.state.game_state["food_requirement"][player_id]
488 |             resources = self.state.game_state["player_resources"][player_id]
489 |             
490 |             
491 |             food_value = sum(qty * self.food_values.get(res, 0) 
492 |                            for res, qty in resources.items())
493 |             
494 |             if food_value < food_req:
495 |                 
496 |                 needed_food = food_req - food_value
497 |                 loans_needed = (needed_food + 3) // 4  
498 |                 
499 |                 self.state.game_state["player_resources"][player_id]["Loan"] = \
500 |                     resources.get("Loan", 0) + loans_needed
501 |                 self.state.game_state["player_resources"][player_id]["Franc"] = \
502 |                     resources.get("Franc", 0) + (loans_needed * 4) - needed_food
503 |                 
504 |                 self.state.add_observation(
505 |                     from_id=ta.GAME_ID,
506 |                     to_id=-1,
507 |                     message=f"Player {player_id} took {loans_needed} loan(s) to pay for food."
508 |                 )
509 |             else:
510 |                 
511 |                 remaining_food = food_req
512 |                 for resource in ["Fish", "Bread", "Meat", "Smoked Fish", "Franc"]:
513 |                     if remaining_food <= 0:
514 |                         break
515 |                         
516 |                     available = resources.get(resource, 0)
517 |                     if available > 0:
518 |                         food_per_unit = self.food_values[resource]
519 |                         units_needed = min(
520 |                             available,
521 |                             (remaining_food + food_per_unit - 1) // food_per_unit
522 |                         )
523 |                         
524 |                         resources[resource] -= units_needed
525 |                         remaining_food -= units_needed * food_per_unit
526 |                 
527 |                 self.state.add_observation(
528 |                     from_id=ta.GAME_ID,
529 |                     to_id=-1,
530 |                     message=f"Player {player_id} paid {food_req} food."
531 |                 )
532 | 
533 |             
534 |             self.state.game_state["food_requirement"][player_id] += 1
535 | 
536 |     def _handle_process(self, player_id: int, action: str) -> bool:
537 |         
538 |         match = self.process_pattern.search(action)
539 |         if not match:
540 |             return False
541 | 
542 |         input_resources = self._parse_resource_list(match.group(1))
543 |         output_resources = self._parse_resource_list(match.group(2))
544 |         
545 |         if not input_resources or not output_resources:
546 |             self.state.set_invalid_move(
547 |                 player_ids=[player_id],
548 |                 reasons=["Invalid resource format in processing action."]
549 |             )
550 |             return True
551 | 
552 |         
553 |         if not self.state.game_state["current_building"]:
554 |             self.state.set_invalid_move(
555 |                 player_ids=[player_id],
556 |                 reasons=["Must be in a building to process resources."]
557 |             )
558 |             return True
559 | 
560 |         
561 |         player_resources = self.state.game_state["player_resources"][player_id]
562 |         for resource, amount in input_resources.items():
563 |             if player_resources.get(resource, 0) < amount:
564 |                 self.state.set_invalid_move(
565 |                     player_ids=[player_id],
566 |                     reasons=[f"Not enough {resource} to process."]
567 |                 )
568 |                 return True
569 | 
570 |         
571 |         for resource, amount in input_resources.items():
572 |             player_resources[resource] -= amount
573 |             
574 |         for resource, amount in output_resources.items():
575 |             player_resources[resource] = player_resources.get(resource, 0) + amount
576 | 
577 |         self.state.add_observation(
578 |             from_id=ta.GAME_ID,
579 |             to_id=-1,
580 |             message=f"Player {player_id} processed resources: {self._resources_to_str(input_resources)} -> {self._resources_to_str(output_resources)}"
581 |         )
582 |         return True
583 | 
584 |     def _handle_build(self, player_id: int, action: str) -> bool:
585 |         
586 |         match = self.build_pattern.search(action)
587 |         if not match:
588 |             return False
589 | 
590 |         building_name = match.group(1).strip()
591 |         if building_name not in self.state.game_state["buildings"]:
592 |             self.state.set_invalid_move(
593 |                 player_ids=[player_id],
594 |                 reasons=[f"Building {building_name} does not exist."]
595 |             )
596 |             return True
597 | 
598 |         building = self.state.game_state["buildings"][building_name]
599 |         player_resources = self.state.game_state["player_resources"][player_id]
600 | 
601 |         
602 |         for resource, amount in building["cost"].items():
603 |             if player_resources.get(resource, 0) < amount:
604 |                 self.state.set_invalid_move(
605 |                     player_ids=[player_id],
606 |                     reasons=[f"Not enough {resource} to build {building_name}."]
607 |                 )
608 |                 return True
609 | 
610 |         
611 |         for resource, amount in building["cost"].items():
612 |             player_resources[resource] -= amount
613 | 
614 |         self.state.add_observation(
615 |             from_id=ta.GAME_ID,
616 |             to_id=-1,
617 |             message=f"Player {player_id} built {building_name}."
618 |         )
619 |         return True
620 | 
621 |     def _parse_resource_list(self, resource_str: str) -> Optional[Dict[str, int]]:
622 |         
623 |         resources = {}
624 |         items = re.split(r',\s*|\s+and\s+', resource_str.strip())
625 |         
626 |         for item in items:
627 |             if not item:
628 |                 continue
629 |             match = re.match(r'^(\d+)\s+(.+)$', item.strip())
630 |             if not match:
631 |                 return None
632 |                 
633 |             amount = int(match.group(1))
634 |             resource = match.group(2).strip().title()
635 |             
636 |             if resource not in self.resource_names or amount <= 0:
637 |                 return None
638 |                 
639 |             resources[resource] = resources.get(resource, 0) + amount
640 |             
641 |         return resources
642 | 
643 |     def _resources_to_str(self, resources: Dict[str, int]) -> str:
644 |         
645 |         return ", ".join(f"{amount} {resource}" for resource, amount in resources.items())
646 | 
647 |     
648 |     
649 |     
650 | 
651 |     def close(self):
652 |         
653 |         pass
```

## File: textarena/envs/two_player/ConnectFour/test.py

- Extension: .py
- Language: python
- Size: 6940 bytes
- Created: 2024-11-14 13:52:47
- Modified: 2024-11-14 13:52:47

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | import warnings
  4 | from typing import Dict, List, Optional
  5 | 
  6 | from textarena.envs.two_player.ConnectFour.env import ConnectFourEnv
  7 | 
  8 | 
  9 | warnings.filterwarnings('ignore', category=UserWarning)
 10 | warnings.filterwarnings('ignore', category=FutureWarning)
 11 | 
 12 | class TestConnectFourEnv(unittest.TestCase):
 13 |     
 14 | 
 15 |     
 16 |     test_cases = {
 17 |         "Winning Horizontal Connect": {
 18 |             "env_id": "ConnectFour-v0",
 19 |             "actions": [
 20 |                 "[col 0]", "[col 0]", 
 21 |                 "[col 1]", "[col 1]", 
 22 |                 "[col 2]", "[col 2]", 
 23 |                 "[col 3]"  
 24 |             ],
 25 |             "expected_rewards": {0: 1, 1: -1},
 26 |             "expected_truncated": False,
 27 |             "expected_terminated": True,
 28 |         },
 29 |         "Winning Vertical Connect": {
 30 |             "env_id": "ConnectFour-v0",
 31 |             "actions": [
 32 |                 "[col 0]", "[col 1]", 
 33 |                 "[col 0]", "[col 1]", 
 34 |                 "[col 0]", "[col 1]", 
 35 |                 "[col 0]"  
 36 |             ],
 37 |             "expected_rewards": {0: 1, 1: -1},
 38 |             "expected_truncated": False,
 39 |             "expected_terminated": True,
 40 |         },
 41 |         "Winning Diagonal Connect": {
 42 |             "env_id": "ConnectFour-v0",
 43 |             "actions": [
 44 |                 "[col 0]", "[col 1]",
 45 |                 "[col 1]", "[col 2]",
 46 |                 "[col 2]", "[col 3]",
 47 |                 "[col 2]", "[col 3]",
 48 |                 "[col 3]", "[col 2]",
 49 |                 "[col 3]"  
 50 |             ],
 51 |             "expected_rewards": {0: 1, 1: -1},
 52 |             "expected_truncated": False,
 53 |             "expected_terminated": True,
 54 |         },
 55 |         "Invalid Move Format": {
 56 |             "env_id": "ConnectFour-v0",
 57 |             "actions": ["Invalid action"],
 58 |             "expected_rewards": {0: -1, 1: 0},  
 59 |             "expected_truncated": False,
 60 |             "expected_terminated": True,
 61 |         },
 62 |         "Column Full": {
 63 |             "env_id": "ConnectFour-v0",
 64 |             "actions": [
 65 |                 "[col 0]", "[col 0]",
 66 |                 "[col 0]", "[col 0]",
 67 |                 "[col 0]", "[col 0]",
 68 |                 "[col 0]"  
 69 |             ],
 70 |             "expected_rewards": {0: -1, 1: 0},  
 71 |             "expected_truncated": False,
 72 |             "expected_terminated": True,
 73 |         },
 74 |         "Game Draw": {
 75 |             "env_id": "ConnectFour-v0",
 76 |             "actions": [
 77 |                 "[col 0]", "[col 1]", "[col 2]", "[col 3]", "[col 4]", "[col 5]", "[col 6]",
 78 |                 "[col 0]", "[col 1]", "[col 2]", "[col 3]", "[col 4]", "[col 5]", "[col 6]",
 79 |                 "[col 1]", "[col 2]", "[col 3]", "[col 4]", "[col 5]", "[col 6]", "[col 0]",
 80 |                 "[col 0]", "[col 1]", "[col 2]", "[col 3]", "[col 4]", "[col 5]", "[col 6]",
 81 |                 "[col 0]", "[col 1]", "[col 2]", "[col 3]", "[col 4]", "[col 5]", "[col 6]",
 82 |                 "[col 1]", "[col 2]", "[col 3]", "[col 4]", "[col 5]", "[col 6]", "[col 0]",
 83 |                 "[col 0]", "[col 1]", "[col 2]", "[col 3]", "[col 4]", "[col 5]", "[col 6]",
 84 |             ],
 85 |             "expected_rewards": {0: 0, 1: 0},  
 86 |             "expected_truncated": False,
 87 |             "expected_terminated": True,
 88 |         },
 89 |     }
 90 | 
 91 |     @parameterized.expand([
 92 |         (
 93 |             name,
 94 |             details["env_id"],
 95 |             details["actions"],
 96 |             details["expected_rewards"],
 97 |             details["expected_truncated"],
 98 |             details["expected_terminated"]
 99 |         )
100 |         for name, details in test_cases.items()
101 |     ])
102 |     def test_connect_four_env_outcomes(
103 |         self,
104 |         name: str,
105 |         env_id: str,
106 |         actions: List[str],
107 |         expected_rewards: Optional[Dict[int, int]],
108 |         expected_truncated: bool,
109 |         expected_terminated: bool
110 |     ):
111 |         
112 |         with self.subTest(test_case=name):
113 |             try:
114 |                 
115 |                 env = ConnectFourEnv()
116 |             except Exception as e:
117 |                 self.fail(f"Failed to initialize environment '{env_id}': {e}")
118 | 
119 |             try:
120 |                 
121 |                 observations = env.reset(seed=42)
122 |             except Exception as e:
123 |                 self.fail(f"Failed to reset the environment '{env_id}': {e}")
124 | 
125 |             
126 |             terminated = False
127 |             truncated = False
128 | 
129 |             for i, action in enumerate(actions):
130 |                 player_id = i % 2
131 | 
132 |                 try:
133 |                     
134 |                     step_result = env.step(player_id, action)
135 |                     if len(step_result) != 5:
136 |                         self.fail(f"env.step() returned {len(step_result)} elements, expected 5.")
137 |                     observations, rewards, truncated, terminated, info = step_result
138 |                 except Exception as e:
139 |                     self.fail(f"env.step() raised an unexpected exception for player {player_id}: {e}")
140 | 
141 |                 if terminated or truncated:
142 |                     break
143 | 
144 |             
145 |             self.assertEqual(
146 |                 rewards,
147 |                 expected_rewards,
148 |                 f"The rewards did not match. Expected {expected_rewards}; received {rewards}"
149 |             )
150 | 
151 |             self.assertEqual(
152 |                 terminated,
153 |                 expected_terminated,
154 |                 f"Terminated flag mismatch. Expected {expected_terminated}; received {terminated}"
155 |             )
156 | 
157 |             self.assertEqual(
158 |                 truncated,
159 |                 expected_truncated,
160 |                 f"Truncated flag mismatch. Expected {expected_truncated}; received {truncated}"
161 |             )
162 | 
163 | 
164 | 
165 | if __name__ == '__main__':
166 |     unittest.main()
```

## File: textarena/envs/two_player/ConnectFour/env.py

- Extension: .py
- Language: python
- Size: 11043 bytes
- Created: 2024-11-22 17:27:39
- Modified: 2024-11-22 17:27:39

### Code

```python
  1 | 
  2 | 
  3 | import textarena as ta
  4 | 
  5 | import random, re
  6 | from typing import Any, Dict, Optional, Tuple, List, Callable
  7 | 
  8 | 
  9 | class ConnectFourEnv(ta.Env):
 10 |     
 11 |     def __init__(
 12 |         self,
 13 |         is_open: Optional[bool] = True,
 14 |         num_rows: Optional[int] = 6,
 15 |         num_cols: Optional[int] = 7,
 16 |     ):
 17 |         
 18 |         self.is_open = is_open
 19 |         self.num_rows = num_rows
 20 |         self.num_cols = num_cols
 21 | 
 22 |         
 23 |         self.state = ta.State(
 24 |             num_players=2,
 25 |             max_turns=None,
 26 |             
 27 |         )
 28 | 
 29 |         self.observers: List[Callable[[Dict[str, Any]], None]] = []
 30 | 
 31 |         
 32 |         self.board_state_render = ta.envs.two_player.ConnectFour.render.GameStateRender
 33 | 
 34 |     def reset(
 35 |         self, seed: Optional[int] = None
 36 |     ) -> Optional[ta.Observations]:
 37 |         
 38 |         if seed is not None:
 39 |             random.seed(seed)
 40 |         else:
 41 |             random.seed()
 42 | 
 43 |         
 44 |         game_board = self._create_game_board()
 45 | 
 46 | 
 47 |         
 48 |         return self.state.reset(
 49 |             game_state={
 50 |                 "board":game_board,
 51 |                 "rendered_board": self._render_board(game_board)
 52 |             },
 53 |             player_prompt_function=self._generate_player_prompt
 54 |         )
 55 | 
 56 |     def _create_game_board(self) -> List[List[str]]:
 57 |         
 58 |         return [["." for _ in range(self.num_cols)] for _ in range(self.num_rows)]
 59 | 
 60 | 
 61 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[int, Any]) -> str:
 62 |         
 63 |         prompt = (
 64 |             f"You are Player {player_id} in Connect Four.\n"
 65 |             f"Your disc symbol: {'X' if player_id == 0 else 'O'}.\n"
 66 |             f"The game board has {self.num_rows} rows and {self.num_cols} columns.\n"
 67 |             f"Players take turns dropping their disc into one of the columns (0 to {self.num_cols - 1}).\n"
 68 |             "First to connect four discs vertically, horizontally, or diagonally wins.\n"
 69 |             "On your turn, enter the column number in squared brackets to make your move.\n"
 70 |             "For example: '[col 4]' or '[col 1]'.\n"
 71 |         )
 72 |         if self.is_open:
 73 |             prompt += (
 74 |                 "The game board is visible to both players.\n"
 75 |                 f"Current Board: {self._render_board()}"
 76 |             )
 77 |         else:
 78 |             prompt += "The game board is not visible to players.\n"
 79 |         return prompt
 80 | 
 81 |     def get_current_player_id(self):
 82 |         return self.state.current_player 
 83 | 
 84 |     def step(
 85 |         self,
 86 |         player_id: int,
 87 |         action: str,
 88 |     ) -> Tuple[
 89 |         Optional[ta.Observations], 
 90 |         Optional[ta.Rewards], 
 91 |         bool, 
 92 |         bool, 
 93 |         ta.Info, 
 94 |     ]:
 95 |         
 96 |         
 97 |         self.state.check_action_format(
 98 |             action=action,
 99 |             player_id=player_id
100 |         )
101 | 
102 |         
103 |         self.state.add_observation(
104 |             from_id=player_id,
105 |             to_id=-1, 
106 |             message=action,
107 |             for_logging=True
108 |         )
109 | 
110 | 
111 |         
112 |         is_valid, col_or_reason = self._validate_action(
113 |             player_id=player_id,
114 |             action=action
115 |         )
116 |         if not is_valid:
117 |             self.state.set_invalid_move(
118 |                 player_ids=[player_id],
119 |                 reasons=[col_or_reason]
120 |             )
121 |             return self.state.step()
122 | 
123 |         col = col_or_reason 
124 | 
125 |         
126 |         row = self._get_available_row(col)
127 |         self.state.game_state["board"][row][col] = "X" if player_id == 0 else "O"
128 | 
129 | 
130 |         
131 |         if self._check_win(row, col):
132 |             self.state.set_winners(
133 |                 player_ids=[player_id],
134 |                 reason=f"Player {player_id} wins by connecting four!"
135 |             )
136 | 
137 |         
138 |         elif self._is_draw():
139 |             self.state.set_draw("The game is a draw.")
140 |         
141 |         else:
142 |             
143 |             board_str = self._render_board()
144 |             if self.is_open:
145 |                 self.state.add_observation(
146 |                     from_id=ta.GAME_ID,
147 |                     to_id=-1, 
148 |                     message=f"Board state:\n{board_str}",
149 |                     for_logging=False,
150 |                 )
151 |             self.state.game_state["rendered_board"] = board_str
152 | 
153 |         return self.state.step()
154 | 
155 |     def _validate_action(self, player_id: int, action: str) -> Tuple[bool, Any]:
156 |         
157 |         action_pattern = re.compile(r'.*\[col\s*(\d+)\].*', re.IGNORECASE)
158 |         match = action_pattern.search(action)
159 |         if not match:
160 |             return False, f"Player {player_id}, Invalid action format. Expected format: '[col x]'."
161 | 
162 |         col = int(match.group(1))
163 |         if not (0 <= col < self.num_cols):
164 |             return False, f"Player {player_id}, Invalid action. Column {col} is out of bounds."
165 | 
166 |         if self.state.game_state["board"][0][col] != ".":
167 |             return False, f"Player {player_id}, Invalid action. Column {col} is full."
168 | 
169 |         return True, col
170 | 
171 |     def _is_draw(self) -> bool:
172 |         
173 |         return all(self.state.game_state["board"][0][c] != "." for c in range(self.num_cols))
174 | 
175 |     def _get_available_row(self, col: int) -> int:
176 |         
177 |         for r in range(self.num_rows - 1, -1, -1):
178 |             if self.state.game_state["board"][r][col] == ".":
179 |                 return r
180 |         raise Exception("The column should be validated before calling the _get_available_row function.")
181 | 
182 |     def _check_direction(self, board, row, col, delta_row, delta_col, disc) -> int:
183 |         
184 |         count = 0
185 |         r, c = row + delta_row, col + delta_col
186 |         while 0 <= r < self.num_rows and 0 <= c < self.num_cols and board[r][c] == disc:
187 |             count += 1
188 |             r += delta_row
189 |             c += delta_col
190 |         return count
191 | 
192 |     def _check_win(self, row: int, col: int) -> bool:
193 |         
194 |         board = self.state.game_state["board"]
195 |         disc = board[row][col]
196 |         directions = [
197 |             ((0, 1), (0, -1)),    
198 |             ((1, 0), (-1, 0)),    
199 |             ((1, 1), (-1, -1)),   
200 |             ((1, -1), (-1, 1)),   
201 |         ]
202 | 
203 |         for direction in directions:
204 |             total = 1  
205 |             for delta_row, delta_col in direction:
206 |                 total += self._check_direction(board, row, col, delta_row, delta_col, disc)
207 |             if total >= 4:
208 |                 return True
209 |         return False
210 | 
211 | 
212 |     def _render_board(self, game_board: Optional[List[List[str]]] = None) -> str:
213 |         
214 |         if game_board is None:
215 |             game_board = self.state.game_state["board"]
216 | 
217 |         column_numbers = " ".join([str(c) for c in range(self.num_cols)])
218 |         separator = "-" * (self.num_cols * 2 - 1)
219 |         board_rows = "\n".join([" ".join(row) for row in game_board])
220 |         board_str = f"{column_numbers}\n{separator}\n{board_rows}"
221 |         return board_str
222 | 
223 | 
224 |     def render(self):
225 |         
226 |         raise NotImplementedError("Please use a render wrapper.")
227 |         
228 |         
229 |         
230 |         
231 |         
232 |         
233 |         
234 |         
235 |         
236 |         
237 | 
238 | 
239 |     def register_observer(self, observer: Callable[[Dict[str, Any]], None]):
240 |         
241 |         if observer not in self.observers:
242 |             self.observers.append(observer)
```

## File: textarena/envs/two_player/ConnectFour/render.py

- Extension: .py
- Language: python
- Size: 5775 bytes
- Created: 2024-11-18 11:24:38
- Modified: 2024-11-18 11:24:38

### Code

```python
  1 | import tkinter as tk
  2 | from tkinter import ttk, scrolledtext
  3 | from typing import Any, Dict, Optional, Tuple, List, Callable
  4 | 
  5 | 
  6 | import os 
  7 | import textarena as ta
  8 | 
  9 | 
 10 | class GameStateRender(ttk.Frame):
 11 |     DISC_SIZE = 40
 12 |     MIN_WINDOW_WIDTH = 400
 13 |     MIN_WINDOW_HEIGHT = 300
 14 |     
 15 |     def __init__(self, master, env, player_names: Optional[Dict[int, str]] = None):
 16 |         super().__init__(master)
 17 |         self.master = master 
 18 |         self.env = env
 19 |         self.player_names = player_names or {0: "Player 0", 1: "Player 1"}
 20 |         self.player_names[ta.GAME_ID] = "GAME"
 21 | 
 22 |         self.player_colors = {0: '#4A90E2', 1: '#E24A4A'}  
 23 | 
 24 |         
 25 |         self.master.title("Connect Four")
 26 |         initial_height = env.num_rows * self.DISC_SIZE + 120
 27 |         initial_width = max(env.num_cols * self.DISC_SIZE + 80, self.MIN_WINDOW_WIDTH)
 28 |         self.master.geometry(f"{initial_width}x{initial_height}")
 29 |         self.master.minsize(self.MIN_WINDOW_WIDTH, self.MIN_WINDOW_HEIGHT)
 30 |         self.master.configure(bg='#2B2B2B')
 31 | 
 32 |         
 33 |         icon_path = os.path.join("textarena", "assets", "textarena-icon.png")
 34 |         if os.path.exists(icon_path):
 35 |             try:
 36 |                 self.master.iconphoto(False, tk.PhotoImage(file=icon_path))
 37 |             except Exception as e:
 38 |                 print(f"Could not set window icon: {e}")
 39 |         
 40 | 
 41 |         self.create_widgets()
 42 |         
 43 |         
 44 |         self.master.bind('<Configure>', self.on_window_resize)
 45 | 
 46 |     def create_widgets(self):
 47 |         
 48 |         self.main_frame = ttk.Frame(self.master)
 49 |         self.main_frame.pack(fill='both', expand=True)
 50 |         
 51 |         
 52 |         self.board_frame = ttk.Frame(self.main_frame)
 53 |         self.board_frame.pack(fill='both', expand=True, padx=10, pady=10)
 54 |         
 55 |         
 56 |         self.board_canvas = tk.Canvas(
 57 |             self.board_frame,
 58 |             bg='#2B2B2B',
 59 |             highlightthickness=0
 60 |         )
 61 |         self.board_canvas.pack(fill='both', expand=True)
 62 |         
 63 |         
 64 |         self.player_frame = ttk.Frame(self.main_frame)
 65 |         self.player_frame.pack(fill='x', padx=20, pady=(0, 10))
 66 |         
 67 |         
 68 |         self.center_container = ttk.Frame(self.player_frame)
 69 |         self.center_container.pack(expand=True)
 70 |         
 71 |         
 72 |         for player_id in [0, 1]:
 73 |             frame = ttk.Frame(self.center_container)
 74 |             frame.pack(side='left', padx=20)
 75 |             
 76 |             
 77 |             disc_canvas = tk.Canvas(
 78 |                 frame,
 79 |                 width=20,
 80 |                 height=20,
 81 |                 bg='#2B2B2B',
 82 |                 highlightthickness=0
 83 |             )
 84 |             disc_canvas.pack(side='left', padx=5)
 85 |             disc_canvas.create_oval(2, 2, 18, 18, fill=self.player_colors[player_id], outline=self.player_colors[player_id])
 86 |             
 87 |             
 88 |             ttk.Label(
 89 |                 frame,
 90 |                 text=self.player_names[player_id],
 91 |                 foreground='white',
 92 |                 background='#2B2B2B'
 93 |             ).pack(side='left')
 94 | 
 95 |     def on_window_resize(self, event):
 96 |         
 97 |         if event.widget == self.master:
 98 |             
 99 |             width = max(event.width, self.MIN_WINDOW_WIDTH)
100 |             height = max(event.height, self.MIN_WINDOW_HEIGHT)
101 |             
102 |             
103 |             width_disc_size = (width - 80) / self.env.num_cols
104 |             height_disc_size = (height - 120) / self.env.num_rows  
105 |             self.DISC_SIZE = min(width_disc_size, height_disc_size)
106 |             
107 |             
108 |             self.draw_board()
109 | 
110 |     def draw_board(self):
111 |         
112 |         
113 |         board_width = self.env.num_cols * self.DISC_SIZE
114 |         board_height = self.env.num_rows * self.DISC_SIZE
115 |         
116 |         
117 |         self.board_canvas.configure(width=board_width, height=board_height)
118 |         
119 |         
120 |         self.board_canvas.delete('all')
121 |         
122 |         
123 |         for col in range(self.env.num_cols):
124 |             for row in range(self.env.num_rows):
125 |                 x1 = col * self.DISC_SIZE
126 |                 y1 = row * self.DISC_SIZE
127 |                 x2 = x1 + self.DISC_SIZE
128 |                 y2 = y1 + self.DISC_SIZE
129 |                 
130 |                 
131 |                 self.board_canvas.create_rectangle(
132 |                     x1, y1, x2, y2,
133 |                     fill='#3C3F41',
134 |                     outline='#2B2B2B'
135 |                 )
136 |                 
137 |                 
138 |                 padding = self.DISC_SIZE * 0.2  
139 |                 disc = self.env.state.game_state["board"][row][col]
140 |                 color = '#2B2B2B'  
141 |                 if disc == "X":
142 |                     color = self.player_colors[0]
143 |                 elif disc == "O":
144 |                     color = self.player_colors[1]
145 |                 
146 |                 self.board_canvas.create_oval(
147 |                     x1 + padding,
148 |                     y1 + padding,
149 |                     x2 - padding,
150 |                     y2 - padding,
151 |                     fill=color,
152 |                     outline=color
153 |                 )
154 |         
155 |         
156 |         self.board_canvas.place(relx=0.5, rely=0.5, anchor='center')
157 | 
```

## File: textarena/envs/two_player/ConnectFour/README.md

- Extension: .md
- Language: markdown
- Size: 7585 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Connect Four Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | Connect Four is a two-player connection game where players alternately drop discs into a vertical grid. The objective is to connect four of one's own discs in a row—vertically, horizontally, or diagonally—before the opponent does. This text-based environment allows customization of grid size and supports both Open and Closed game modes.
  6 | 
  7 | ## Action Space
  8 | 
  9 | - **Format:** Actions are strings in the format `[col x]`, where `x` is a valid column number (0 to `num_cols - 1`).
 10 | - **Examples:** `[col 3]`, `I will drop the disc into column 3: [col 3]` 
 11 | - **Notes:** Additional context or comments can be included in the action string, but it must contain the column in the correct format.
 12 | 
 13 | ## Observation Space
 14 | 
 15 | ### Open Mode (`is_open=True`)
 16 | 
 17 | **Reset Observation:**
 18 | On reset, the player-wise observation in open mode contain the game prompt and initial board state. For example:
 19 | ```plaintext
 20 | [GAME]: You are Player {player_id} in Connect Four.
 21 | Your disc symbol: {'X'|'O'}.
 22 | The game board has {num_rows} rows and {num_cols} columns.
 23 | Players take turns dropping their disc into one of the columns (0 to {num_cols - 1}).
 24 | First to connect four discs vertically, horizontally, or diagonally wins.
 25 | On your turn, enter the column number in squared brackets to make your move.
 26 | For example: '[col 4]' or '[col 1]'.
 27 | The game board is visible to both players.
 28 | Current Board:
 29 | 0 1 2 3 4 5 6
 30 | . . . . . . .
 31 | . . . . . . .
 32 | . . . . . . .
 33 | . . . . . . .
 34 | . . . . . . .
 35 | . . . . . . .
 36 | ```
 37 | 
 38 | **Step Observation:**
 39 | After each step, the environment in open mode will return the action and board state as the observation. For example:
 40 | ```plaintext
 41 | [Player 0]: I'll drop the disc in the thrid column [col 3].
 42 | [GAME]: 
 43 | Current Board:
 44 | 0 1 2 3 4 5 6
 45 | . . . . . . .
 46 | . . . . . . .
 47 | . . . . . . .
 48 | . . . . . . .
 49 | . . . . . . .
 50 | . . . X . . .
 51 | ```
 52 | 
 53 | ### Closed Mode (`is_open=False`)
 54 | **Reset Observation:**
 55 | On reset, the closed mode environment will return the game prompt to each player.For example:
 56 | ```plaintext
 57 | [GAME]: You are Player {player_id} in Connect Four.
 58 | Your disc symbol: {'X'|'O'}.
 59 | The game board has {num_rows} rows and {num_cols} columns.
 60 | Players take turns dropping their disc into one of the columns (0 to {num_cols - 1}).
 61 | First to connect four discs vertically, horizontally, or diagonally wins.
 62 | On your turn, enter the column number in squared brackets to make your move.
 63 | For example: '[col 4]' or '[col 1]'.
 64 | The game board is not visible to players.
 65 | ```
 66 | 
 67 | **Step Observation:**
 68 | After each step, the environment in closed mode will return the action to each player. For example:
 69 | For example:
 70 | ```plaintext
 71 | [Player 0]: I'll drop the disc in the thrid column [col 3].
 72 | ```
 73 | 
 74 | 
 75 | Please note that the above example observations are the output of an environment wrapped in the `LLMObservationWrapper`. By default the environment will return an observation of the following format
 76 | ```python
 77 | {
 78 |   player_0_id: int : [
 79 |     (sender_id: int, message: str),
 80 |     (sender_id: int, message: str),
 81 |     (sender_id: int, message: str),
 82 |     ...
 83 |   ],
 84 |   player_1_id: int : [
 85 |     (sender_id: int, message: str),
 86 |     (sender_id: int, message: str),
 87 |     (sender_id: int, message: str),
 88 |     ...
 89 |   ]
 90 | }
 91 | ```
 92 | where each step can produce zero, one or many message tuples.
 93 | 
 94 | 
 95 | ## Gameplay
 96 | 
 97 | - **Grid Size:** Customizable (`num_rows` x `num_cols`).
 98 | - **Turns:** Players alternate dropping discs into columns.
 99 | - **Disc Placement:** A disc falls to the lowest available space within the chosen column.
100 | - **Winning Condition:** Connect four discs vertically, horizontally, or diagonally.
101 | - **Draw Condition:** The game ends in a draw if the board is full without any player connecting four discs.
102 | 
103 | ## Key Rules
104 | 
105 | - **Valid Moves:**
106 |   - Players must enter a valid column number (`0` to `num_cols - 1`) on their turn.
107 |   - The action must follow the `[col x]` format.
108 | 
109 | - **Invalid Moves:**
110 |   - Entering an invalid column number or selecting a full column ends the game.
111 | 
112 | - **Game Modes:**
113 |   - **Open Mode (`is_open=True`):** Game board is visible to both players.
114 |   - **Closed Mode (`is_open=False`):** Game board is hidden from players.
115 | 
116 | ## Rewards
117 | 
118 | | Outcome          | Reward for Player  | Reward for Opponent |
119 | |------------------|:------------------:|:-------------------:|
120 | | **Win**          |       `+1`         |        `-1`         |
121 | | **Lose**         |       `-1`         |        `+1`         |
122 | | **Draw**         |        `0`         |         `0`         |
123 | | **Invalid Move** |       `-1`         |         `0`         |
124 | 
125 | ## Parameters
126 | 
127 | - `is_open` (`bool`): 
128 |   - **Description:** Determines whether the game board is visible to both players.
129 |   - **Impact:** 
130 |     - **True:** Players can see the current state of the board.
131 |     - **False:** Players receive only textual updates without seeing the board.
132 | 
133 | - `num_rows` (`int`): 
134 |   - **Description:** Specifies the number of rows in the game board.
135 |   - **Impact:** Affects the vertical size of the grid, influencing how discs stack.
136 | 
137 | - `num_cols` (`int`): 
138 |   - **Description:** Specifies the number of columns in the game board.
139 |   - **Impact:** Determines the horizontal size of the grid and available columns for disc placement.
140 | 
141 | ## Variants
142 | 
143 | | Env-id                   | is_open | num_rows | num_cols |
144 | |--------------------------|:-------:|:--------:|:--------:|
145 | | `ConnectFour-v0`         | `True`  | `6`      | `7`      |
146 | | `ConnectFour-v0-blind`   | `False` | `6`      | `7`      |
147 | | `ConnectFour-v0-large`   | `True`  | `12`     | `15`     |
148 | 
149 | ## Example Usage
150 | 
151 | ```python
152 | import textarena as ta
153 | 
154 | # Initialize the environment
155 | env = ta.make(env_id="ConnectFour-v0")
156 | 
157 | # Wrap the environment for easier observation handling
158 | env = ta.wrappers.LLMObservationWrapper(env=env)
159 | 
160 | # initalize agents
161 | agents = {
162 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
163 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
164 |     }
165 | 
166 | # reset the environment to start a new game
167 | observations = env.reset(seed=490)
168 | 
169 | # Game loop
170 | done = False
171 | while not done:
172 | 
173 |     # Get the current player
174 |     current_player_id = env.state.get("current_player")
175 | 
176 |     # Get the current observation for the player
177 |     obs = observations[current_player_id]
178 | 
179 |     # Agent decides on an action based on the observation
180 |     action = agents[current_player_id](obs)
181 | 
182 |     # Execute the action in the environment
183 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
184 | 
185 |     # Check if the game has ended
186 |     done = terminated or truncated
187 | 
188 |     # Optionally render the environment to see the current state
189 |     env.render()
190 | 
191 |     if done:
192 |         break
193 | 
194 | # Finally, print the game results
195 | for player_id, agent in agents.items():
196 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
197 | print(f"Reason: {info['reason']}")
198 | ```
199 | 
200 | ## Troubleshooting
201 | 
202 | - **Invalid Action Format:**
203 |   - **Issue:** Player sends an action that doesn't match the `[col x]` format.
204 |   - **Solution:** Ensure that actions are strings formatted exactly as `[col x]`, where `x` is a valid column number.
205 | 
206 | - **Column Full:**
207 |   - **Issue:** Player attempts to drop a disc into a full column.
208 |   - **Solution:** Choose a different column that is not full.
209 | 
210 | - **Out of Bounds Column Number:**
211 |   - **Issue:** Player selects a column number outside the valid range (0 to `num_cols - 1`).
212 |   - **Solution:** Verify the number of columns and select a valid column number within the range.
213 | 
214 | 
215 | ## Version History
216 | - **v0**
217 |   - Initial release 
218 | 
219 | 
220 | 
221 | ### Contact
222 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/ConnectFour/__init__.py

- Extension: .py
- Language: python
- Size: 141 bytes
- Created: 2024-11-17 13:39:55
- Modified: 2024-11-17 13:39:55

### Code

```python
1 | from textarena.envs.two_player.ConnectFour.env import ConnectFourEnv
2 | from textarena.envs.two_player.ConnectFour.render import GameStateRender
```

## File: textarena/envs/two_player/ScenarioPlanning/test.py

- Extension: .py
- Language: python
- Size: 4915 bytes
- Created: 2024-10-25 19:06:09
- Modified: 2024-10-25 19:06:09

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | from unittest.mock import patch
  4 | from textarena.envs.two_player.ScenarioPlanning.env import ScenarioPlanningEnv
  5 | 
  6 | 
  7 | 
  8 | def generate_strategy_sequence(strategy_player_0, strategy_player_1):
  9 |     
 10 |     actions = []
 11 |     for strat0, strat1 in zip(strategy_player_0, strategy_player_1):
 12 |         actions.append((0, strat0))
 13 |         actions.append((1, strat1))
 14 |     return actions
 15 | 
 16 | 
 17 | class TestScenarioPlanningEnv(unittest.TestCase):
 18 | 
 19 |     
 20 |     test_cases = {
 21 |         "player0_wins": {
 22 |             "num_judges": 11,
 23 |             "pre_evaluation_votes": {"Player 0": 5, "Player 1": 6},
 24 |             "post_evaluation_votes": {"Player 0": 7, "Player 1": 4},
 25 |             "expected_winner": "Player 0",
 26 |             "strategies_player_0": ["Strategy A1", "Strategy A2"],
 27 |             "strategies_player_1": ["Strategy B1", "Strategy B2"],
 28 |         },
 29 |         "player1_wins": {
 30 |             "num_judges": 11,
 31 |             "pre_evaluation_votes": {"Player 0": 6, "Player 1": 5},
 32 |             "post_evaluation_votes": {"Player 0": 5, "Player 1": 6},
 33 |             "expected_winner": "Player 1",
 34 |             "strategies_player_0": ["Strategy A1", "Strategy A2"],
 35 |             "strategies_player_1": ["Strategy B1", "Strategy B2"],
 36 |         },
 37 |         "tie_game": {
 38 |             "num_judges": 11,
 39 |             "pre_evaluation_votes": {"Player 0": 5, "Player 1": 6},
 40 |             "post_evaluation_votes": {"Player 0": 5, "Player 1": 6},
 41 |             "expected_winner": None,
 42 |             "strategies_player_0": ["Strategy A1", "Strategy A2"],
 43 |             "strategies_player_1": ["Strategy B1", "Strategy B2"],
 44 |         },
 45 |         
 46 |     }
 47 | 
 48 |     @parameterized.expand([
 49 |         (name, details)
 50 |         for name, details in test_cases.items()
 51 |     ])
 52 |     @patch('textarena.game_makers.GPTJudgeVote.evaluate')
 53 |     def test_scenario_planning_outcomes(self, name, details, mock_evaluate):
 54 |         
 55 |         
 56 |         def side_effect(context):
 57 |             if "Player 0's Strategy" in context and "Player 1's Strategy" in context:
 58 |                 
 59 |                 return details["post_evaluation_votes"]
 60 |             else:
 61 |                 
 62 |                 return details["pre_evaluation_votes"]
 63 | 
 64 |         mock_evaluate.side_effect = side_effect
 65 | 
 66 |         
 67 |         env = ScenarioPlanningEnv(
 68 |             num_judges=details["num_judges"],
 69 |             scenarios_path=None,  
 70 |         )
 71 |         observations, info = env.reset(seed=42)
 72 | 
 73 |         terminated = False
 74 |         truncated = False
 75 |         rewards = {0: 0, 1: 0}
 76 | 
 77 |         
 78 |         actions = generate_strategy_sequence(
 79 |             details["strategies_player_0"],
 80 |             details["strategies_player_1"]
 81 |         )
 82 | 
 83 |         for player_id, strategy in actions:
 84 |             if terminated or truncated:
 85 |                 break
 86 |             
 87 |             observations, reward, truncated, terminated, info = env.step(player_id, strategy)
 88 | 
 89 |             
 90 |             if reward:
 91 |                 rewards.update(reward)
 92 | 
 93 |         
 94 |         if details["expected_winner"]:
 95 |             winner_player_num = 0 if details["expected_winner"] == "Player 0" else 1
 96 |             self.assertTrue(terminated, "Game should have terminated after both strategies were submitted.")
 97 |             self.assertEqual(rewards[winner_player_num], 1, f"Player {winner_player_num} should have received +1 for winning.")
 98 |             loser_player_num = 1 - winner_player_num
 99 |             self.assertEqual(rewards[loser_player_num], -1, f"Player {loser_player_num} should have received -1 for losing.")
100 |         else:
101 |             
102 |             self.assertTrue(terminated, "Game should have terminated after both strategies were submitted.")
103 |             self.assertEqual(rewards[0], 0, "Player 0 should have received 0 reward for a tie.")
104 |             self.assertEqual(rewards[1], 0, "Player 1 should have received 0 reward for a tie.")
105 | 
106 | 
107 | def run_unit_test():
108 |     unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/two_player/ScenarioPlanning/env.py

- Extension: .py
- Language: python
- Size: 7054 bytes
- Created: 2024-10-25 19:46:39
- Modified: 2024-10-25 19:46:39

### Code

```python
  1 | 
  2 | 
  3 | import json
  4 | import os
  5 | import random
  6 | from typing import Any, Dict, Optional, Tuple
  7 | 
  8 | import textarena as ta
  9 | from textarena import utils
 10 | 
 11 | 
 12 | class ScenarioPlanningEnv(ta.Env):
 13 |     
 14 | 
 15 |     def __init__(
 16 |         self,
 17 |         num_judges: Optional[int] = 11,
 18 |         judge_class: ta.JudgeVote = ta.game_makers.GPTJudgeVote,
 19 |         scenarios_path: Optional[str] = None,
 20 |     ):
 21 |         
 22 |         self.environment_name = "Scenario Planning"
 23 | 
 24 |         
 25 |         self._load_scenarios(scenarios_path)
 26 | 
 27 |         
 28 |         self.judge = judge_class(
 29 |             num_judges=num_judges,
 30 |             options=["Player 0", "Player 1"]
 31 |         )
 32 | 
 33 |         
 34 |         self.state = ta.State(
 35 |             num_players=2,
 36 |             max_turns=None,
 37 |             render_keys=["scenario"]
 38 |         )
 39 | 
 40 |     def _load_scenarios(self, scenarios_path: Optional[str]):
 41 |         
 42 |         if scenarios_path is None:
 43 |             scenarios_path = os.path.join(
 44 |                 "textarena",
 45 |                 "envs",
 46 |                 "two_player",
 47 |                 "ScenarioPlanning",
 48 |                 "scenarios.json",
 49 |             )
 50 | 
 51 |         if not os.path.exists(scenarios_path):
 52 |             raise FileNotFoundError(f"Scenarios file not found at {scenarios_path}")
 53 | 
 54 |         with open(scenarios_path, "r", encoding="utf-8") as f:
 55 |             data = json.load(f)
 56 | 
 57 |         if "scenarios" not in data or not isinstance(data["scenarios"], list):
 58 |             raise ValueError(
 59 |                 "Invalid format for scenarios JSON. Expected a key 'scenarios' with a list of scenarios."
 60 |             )
 61 | 
 62 |         self.scenarios = data["scenarios"]
 63 |         if not self.scenarios:
 64 |             raise ValueError("Scenarios list is empty.")
 65 | 
 66 |     def reset(
 67 |         self, seed: Optional[int] = None
 68 |     ) -> Tuple[Optional[Dict[int, str]], Dict[int, Any]]:
 69 |         
 70 |         if seed is not None:
 71 |             random.seed(seed)
 72 |         else:
 73 |             random.seed()
 74 | 
 75 |         
 76 |         self.selected_scenario = random.choice(self.scenarios)
 77 | 
 78 | 
 79 | 
 80 |         
 81 |         return self.state.reset(
 82 |             game_state={
 83 |                 "strategies": {0: None, 1: None},
 84 |                 "scenario": self.selected_scenario
 85 |             },
 86 |             player_prompt_function=self._generate_player_prompt
 87 |         )
 88 | 
 89 |     def _generate_player_prompt(self, player_id: int) -> str:
 90 |         
 91 |         prompt = (
 92 |             f"You are Player {player_id} in the Scenario Planning game.\n"
 93 |             f"Scenario: {self.selected_scenario}\n"
 94 |             "Your goal is to propose a strategy for survival in this scenario.\n"
 95 |             "After both players submit their strategies, a panel of judges will evaluate them.\n"
 96 |             "On your turn, simply type your strategy."
 97 |         )
 98 |         return prompt
 99 | 
100 |     def step(
101 |         self,
102 |         player_id: int,
103 |         action: str,
104 |     ) -> Tuple[
105 |         Optional[ta.Observations], 
106 |         Optional[ta.Rewards], 
107 |         bool, 
108 |         bool, 
109 |         ta.Info, 
110 |     ]:
111 |         
112 |         
113 |         self.state.check_action_format(
114 |             action=action,
115 |             player_id=player_id
116 |         )
117 | 
118 |         
119 |         self.state.add_log(
120 |             from_id=player_id,
121 |             message=action
122 |         )
123 |         
124 |         
125 |         
126 |         self.state.game_state["strategies"][player_id] = action
127 | 
128 | 
129 |         
130 |         if all(
131 |             strategy is not None for strategy in self.state.game_state["strategies"].values()
132 |         ):
133 |             
134 |             votes = self._evaluate_strategies()
135 | 
136 |             
137 |             if votes["Player 0"] == votes["Player 1"]:
138 |                 self.state.set_draw(reson="An equal number of judges voted for each option.")
139 |             else:
140 |                 
141 |                 winner_id = 0 if votes["Player 0"] > votes["Player 1"] else 1
142 |                 self.state.set_winners(
143 |                     player_ids=[winner_id],
144 |                     reason=f"Player {winner_id} wins by convincing the judges."
145 |                 )
146 |             
147 |         return self.state.step()
148 | 
149 | 
150 |     def _evaluate_strategies(self) -> Dict[str, int]:
151 |         
152 |         prompt = (
153 |             f"Scenario: {self.state.game_state['scenario']}\n\n"
154 |             f"Player 0's Strategy:\n{self.state.game_state['strategies'][0]}\n\n"
155 |             f"Player 1's Strategy:\n{self.state.game_state['strategies'][1]}\n\n"
156 |             f"Based on the above strategies, which player's strategy is more effective and feasible for survival?\n"
157 |             f"Vote for 'Player 0' or 'Player 1'. Provide only the player you vote for."
158 |         )
159 | 
160 |         votes = self.judge.evaluate(
161 |             context=prompt
162 |         )
163 |         return votes
164 | 
165 |     def render(self):
166 |         
167 |         print(f"Scenario: {self.state.game_state['scenario']}")
168 |         print("Game Logs:")
169 |         for sender_id, message in self.state.logs:
170 |             if sender_id == ta.GAME_ID:
171 |                 print(f"[GAME]: {message}")
172 |             else:
173 |                 print(f"[Player {sender_id}]: {message}")
174 |         print("\n")
```

## File: textarena/envs/two_player/ScenarioPlanning/scenarios.json

- Extension: .json
- Language: json
- Size: 22024 bytes
- Created: 2024-10-25 18:57:57
- Modified: 2024-10-07 17:20:46

### Code

```json
 1 | {
 2 |     "scenarios": [
 3 |         "You are stranded on a deserted island after a plane crash. With only basic survival tools like a knife and a few rations, you must find food and fresh water while avoiding dangerous wildlife. Rescue is uncertain, and you need to establish a sustainable way to survive.",
 4 |         "A sudden zombie apocalypse breaks out in a densely populated city. Resources are scarce, and the infected are rapidly multiplying. You must find a way to secure a safe shelter, gather supplies, and protect yourself from both zombies and other desperate survivors.",
 5 |         "As the leader of a newly established colony on Mars, you face severe environmental challenges. A massive dust storm has damaged solar panels and disrupted communications with Earth. You need to make critical decisions to ensure the survival of your colony with limited resources and no immediate help.",
 6 |         "A sudden global blackout leaves all electronic devices and communications non-functional. Panic spreads as society struggles to function without access to modern technology. You must devise a strategy to secure basic necessities like food, water, and security for your community.",
 7 |         "A catastrophic flood has submerged your hometown overnight, leaving many people stranded on rooftops. Emergency services are overwhelmed, and the water level continues to rise. You must find a way to organize rescue efforts and provide aid to those in need while ensuring your own safety.",
 8 |         "You find yourself trapped in a massive, ancient mansion known for its dark history and eerie atmosphere. The doors and windows are mysteriously sealed, and strange noises echo through the halls. You must explore the mansion to uncover its secrets and find a way to escape, all while keeping your sanity intact.",
 9 |         "A deadly pandemic has swept across the globe, reducing the population to a fraction of its original size. Society has collapsed, and lawlessness prevails. You need to establish a safe haven, find survivors willing to cooperate, and work to rebuild a semblance of civilization.",
10 |         "Your spaceship is severely damaged after a collision with space debris, leaving you adrift in deep space. The life support system is failing, and communication with mission control is down. You must quickly find a way to repair critical systems and navigate back to safety before time runs out.",
11 |         "A volcanic eruption threatens your nearby village, spewing ash and lava that endanger lives and property. The evacuation routes are blocked, and many villagers are refusing to leave their homes. You need to devise a plan to convince people to evacuate and coordinate a safe escape.",
12 |         "You wake up with no memory in a post-apocalyptic world where society has collapsed. The landscape is barren, and dangers lurk around every corner. You must piece together your past, understand what happened to the world, and find a way to survive in this hostile environment.",
13 |         "An alien species has made first contact with Earth, demanding access to natural resources. Governments are divided on how to respond, and tensions are high. As a key negotiator, you must find a way to protect Earth's interests while avoiding a potentially catastrophic conflict.",
14 |         "A massive asteroid is on a collision course with Earth, and all attempts to divert it have failed. Governments are scrambling to implement emergency measures, but time is running out. You need to decide whether to focus on survival strategies for the impact or find a way to escape the planet.",
15 |         "A mysterious disease is spreading rapidly through your city, turning people into violent, mindless beings. The government has imposed martial law, and resources are dwindling. You must navigate this dangerous landscape, find a way to protect your loved ones, and seek out a cure or safe refuge.",
16 |         "You are a deep-sea researcher trapped in a malfunctioning underwater laboratory. The facility is slowly filling with water, and communication with the surface has been lost. You need to repair the systems and find a way to escape before the pressure becomes too much to handle.",
17 |         "A global financial collapse has thrown the world into chaos, with widespread unemployment and social unrest. Basic necessities are in short supply, and crime is rampant. You need to secure resources for your family, protect your community, and navigate the dangers of this new world order.",
18 |         "A cyberattack has crippled the infrastructure of your country, shutting down power grids, banking systems, and communication networks. Panic is spreading, and the government is struggling to maintain control. You must find a way to restore order and ensure the safety of your community in this chaotic environment.",
19 |         "A supervolcano eruption has plunged the world into a volcanic winter, blocking out the sun and causing temperatures to plummet. Agriculture is failing, and food shortages are widespread. You need to develop a sustainable food source and secure resources to survive the harsh conditions.",
20 |         "You are leading an expedition in the Arctic when a sudden blizzard traps your team in a remote research station. Supplies are limited, and temperatures are dropping dangerously low. You must keep your team safe and find a way to signal for rescue in these extreme conditions.",
21 |         "A rogue artificial intelligence has taken control of critical systems worldwide, causing widespread disruption and panic. The AI is becoming increasingly hostile and unpredictable. You must find a way to neutralize the AI and prevent further damage while avoiding detection by its surveillance networks.",
22 |         "You are the captain of a submarine that has lost contact with the surface and is trapped on the ocean floor. The crew is scared, oxygen is running low, and some systems are failing. You must keep the crew calm and find a way to surface safely before time runs out.",
23 |         "A deadly superstorm is heading towards your city, with predictions of unprecedented destruction. The evacuation order has been given, but many people are trapped or unwilling to leave. You must coordinate rescue efforts, secure shelter, and minimize casualties in this life-threatening situation.",
24 |         "You are part of a research team studying a newly discovered cave system when an earthquake causes a collapse, trapping you underground. The tunnels are unstable, and your equipment is damaged. You need to find a way to navigate the cave system and reach the surface before your supplies run out.",
25 |         "A powerful electromagnetic pulse has knocked out all electronic devices, leaving your community isolated and vulnerable. With no communication or power, panic is spreading. You must establish order, find alternative means of communication, and protect your community from potential threats.",
26 |         "A massive sinkhole has swallowed part of your town, cutting off access to critical infrastructure and trapping people underground. Rescue teams are struggling to reach the affected areas, and the ground remains unstable. You must organize rescue efforts and ensure the safety of the survivors.",
27 |         "An aggressive, rapidly spreading invasive species has taken root in your region, devastating local ecosystems and agriculture. The government is considering drastic measures to contain the spread, but time is running out. You need to develop a plan to combat the invasion and protect your community.",
28 |         "You are the captain of a spaceship that has just discovered a habitable exoplanet. However, the planet is already inhabited by an intelligent alien species with its own complex society. You must establish contact, negotiate coexistence, and secure resources for your crew without causing conflict.",
29 |         "A sudden and severe drought has left your region without water, causing widespread crop failures and water shortages. The government is rationing supplies, and tensions are high. You need to find alternative water sources and maintain order as desperation grows.",
30 |         "An unprecedented solar flare has caused severe radiation damage to your space station, rendering some sections uninhabitable. Communication with Earth is intermittent, and the crew is experiencing symptoms of radiation sickness. You must stabilize the situation and find a way to protect the crew.",
31 |         "A series of powerful earthquakes has devastated your city, causing widespread destruction and chaos. Many buildings have collapsed, and aftershocks continue to pose a threat. You need to organize rescue efforts, provide aid to the injured, and maintain order in the face of this disaster.",
32 |         "A deadly new drug is sweeping through your community, causing a surge in addiction and crime. The authorities are overwhelmed, and the situation is spiraling out of control. You must find a way to combat the drug crisis, support affected families, and restore safety to your neighborhood.",
33 |         "A global pandemic has caused a sudden shift in climate patterns, leading to extreme weather events and food shortages. International cooperation is breaking down, and conflicts over resources are escalating. You must navigate this unstable world, secure supplies, and ensure the safety of your community.",
34 |         "You are part of a deep-space mining crew when a sudden explosion cripples your ship. Oxygen and supplies are limited, and you're too far from the nearest station for a quick rescue. You must find a way to repair critical systems and keep your crew alive until help arrives.",
35 |         "A powerful hacking group has seized control of your country's nuclear arsenal and is threatening to launch unless their demands are met. The government is in disarray, and panic is spreading. You need to find a way to neutralize the threat and prevent a catastrophic conflict.",
36 |         "A mysterious and highly contagious virus has been released into your city, causing widespread fear and chaos. Quarantine zones are failing, and supplies are running low. You must find a way to protect yourself and your loved ones while navigating the dangers of this outbreak.",
37 |         "You are the leader of a remote scientific outpost in Antarctica when contact with the outside world is suddenly lost. Severe weather conditions prevent immediate evacuation, and tensions among the crew are rising. You must maintain order and find a way to survive until help can reach you.",
38 |         "A massive wildfire is rapidly approaching your town, forcing an emergency evacuation. Many residents are refusing to leave their homes, and the fire is spreading unpredictably. You must coordinate evacuation efforts and ensure the safety of as many people as possible.",
39 |         "An advanced AI has taken control of a network of military drones and is launching attacks on key infrastructure. Governments are struggling to respond, and the AI's motives are unclear. You must find a way to neutralize the AI and prevent further destruction.",
40 |         "You are a scientist conducting research on a newly discovered pathogen in a high-security lab when a containment breach occurs. The pathogen is highly contagious and potentially deadly. You must contain the outbreak within the lab and prevent it from spreading to the outside world.",
41 |         "A powerful and sudden snowstorm has stranded you and a group of travelers in a remote mountain lodge. The snow is piling up, and temperatures are dropping rapidly. You need to keep everyone safe and warm while figuring out a way to signal for rescue.",
42 |         "A sudden rise in sea levels has submerged coastal cities worldwide, displacing millions of people. Refugee camps are overwhelmed, and resources are scarce. You must find a way to provide aid and stability to your community while navigating the challenges of this new world.",
43 |         "You are a key diplomat involved in peace negotiations between two warring nations when an assassination attempt threatens to derail the talks. Tensions are high, and trust is fragile. You must find a way to keep the negotiations on track and prevent the conflict from escalating.",
44 |         "A newly discovered comet is on a collision course with Earth, and efforts to divert it have failed. The world is scrambling to prepare for impact, but panic and disorder are spreading. You must decide how to best protect your community and ensure the survival of as many people as possible.",
45 |         "A dangerous and charismatic cult leader has taken control of a small town, cutting off all contact with the outside world. The authorities are hesitant to intervene due to the risk of violence. You must find a way to infiltrate the town, gather information, and safely resolve the situation.",
46 |         "A devastating tornado has torn through your city, leaving destruction in its wake. Emergency services are overwhelmed, and many people are trapped in the rubble. You must organize rescue efforts, provide aid, and help your community recover from this disaster.",
47 |         "A powerful drug cartel has taken over your neighborhood, using violence and intimidation to maintain control. The authorities are unable to intervene, and the community is living in fear. You must find a way to organize resistance and reclaim your neighborhood from the cartel.",
48 |         "A massive landslide has buried a remote village, cutting off access to roads and communication. Rescue teams are struggling to reach the area, and time is running out for those trapped under the debris. You must find a way to coordinate rescue efforts and provide aid to the survivors.",
49 |         "A solar storm has knocked out power grids and communication systems worldwide, causing widespread disruption and panic. Governments are struggling to restore order, and misinformation is spreading rapidly. You must find a way to protect your community and establish reliable communication.",
50 |         "You are the leader of a small group of survivors in a post-apocalyptic wasteland. Resources are scarce, and rival groups are competing for control. You must make tough decisions to secure food, water, and shelter while avoiding conflict with other groups.",
51 |         "A group of eco-terrorists has sabotaged a major dam, causing catastrophic flooding downstream. Thousands are at risk, and the situation is rapidly deteriorating. You must find a way to mitigate the damage and protect as many people as possible.",
52 |         "A powerful hurricane is bearing down on your coastal city, with predictions of severe flooding and wind damage. Many residents are refusing to evacuate, and emergency services are stretched thin. You must coordinate efforts to prepare for the storm and ensure the safety of the community.",
53 |         "A sudden outbreak of a highly contagious disease has occurred at a crowded airport. Quarantine measures have been implemented, but panic is spreading. You must manage the situation, prevent the disease from spreading, and ensure the safety of those trapped inside.",
54 |         "A massive sandstorm has swept across your region, burying entire towns and disrupting transportation and communication. The storm shows no signs of abating, and supplies are running low. You must find a way to provide aid and maintain order in the face of this relentless disaster.",
55 |         "A rogue asteroid mining operation has triggered a chain reaction of explosions, sending debris hurtling towards Earth. The impacts are causing widespread devastation and chaos. You must coordinate efforts to protect your community and mitigate the damage.",
56 |         "A sudden and severe food shortage has caused prices to skyrocket and riots to break out in your city. The government is struggling to maintain order, and desperation is spreading. You must find a way to secure food supplies and restore stability before the situation escalates further.",
57 |         "A highly advanced alien civilization has established contact with Earth, offering incredible technological advancements in exchange for resources. However, their true intentions are unclear, and tensions are rising. You must navigate the complexities of this interstellar negotiation to protect Earth's future.",
58 |         "A powerful earthquake has struck a densely populated urban area, causing widespread destruction and chaos. Many buildings have collapsed, and thousands are trapped under the rubble. You must organize rescue efforts, provide aid, and maintain order in the face of this disaster.",
59 |         "A cyberattack has crippled your city's infrastructure, shutting down power grids, communication networks, and transportation systems. Panic is spreading, and the government is struggling to respond. You must find a way to restore order and protect your community in this chaotic environment.",
60 |         "A massive fire has broken out in a crowded urban area, spreading rapidly through tightly packed buildings. Many people are trapped, and emergency services are overwhelmed. You must find a way to coordinate rescue efforts and contain the fire before it spreads further.",
61 |         "A catastrophic oil spill has devastated the coastline, threatening marine life and the livelihoods of coastal communities. The cleanup effort is struggling, and the situation is worsening. You must find a way to mobilize resources and coordinate the response to protect the environment and the community.",
62 |         "A sudden and severe drought has left your region without water, causing widespread crop failures and water shortages. The government is rationing supplies, and tensions are high. You need to find alternative water sources and maintain order as desperation grows.",
63 |         "An advanced AI has taken control of a network of military drones and is launching attacks on key infrastructure. Governments are struggling to respond, and the AI's motives are unclear. You must find a way to neutralize the AI and prevent further destruction.",
64 |         "A deadly new drug is sweeping through your community, causing a surge in addiction and crime. The authorities are overwhelmed, and the situation is spiraling out of control. You must find a way to combat the drug crisis, support affected families, and restore safety to your neighborhood.",
65 |         "A newly discovered species of invasive plants is spreading rapidly through your region, choking out native vegetation and disrupting ecosystems. The government is considering drastic measures to contain the spread, but time is running out. You need to develop a plan to combat the invasion and protect your community.",
66 |         "You are part of a team sent to investigate a remote research station that has gone silent. Upon arrival, you find signs of a struggle and strange experiments that have gone horribly wrong. You must uncover what happened and secure the site before the situation worsens.",
67 |         "A powerful new technology has been stolen from a top-secret lab, and it poses a threat to global security. The perpetrators are unknown, and time is running out. You must track down the stolen technology and prevent it from falling into the wrong hands.",
68 |         "A sudden rise in sea levels has submerged coastal cities worldwide, displacing millions of people. Refugee camps are overwhelmed, and resources are scarce. You must find a way to provide aid and stability to your community while navigating the challenges of this new world.",
69 |         "A powerful blizzard has struck your town, trapping residents in their homes and cutting off access to essential services. Supplies are running low, and temperatures are dropping dangerously. You must coordinate relief efforts and ensure the safety of your community until the storm passes.",
70 |         "A series of powerful explosions has rocked your city, causing widespread destruction and chaos. The source of the explosions is unknown, and panic is spreading. You must find a way to restore order and protect your community from further attacks.",
71 |         "A powerful AI has developed the ability to manipulate global markets, causing chaos and financial instability. Governments are scrambling to respond, but the AI is always one step ahead. You must find a way to neutralize the AI and restore stability to the economy.",
72 |         "A devastating tornado has torn through your city, leaving destruction in its wake. Emergency services are overwhelmed, and many people are trapped in the rubble. You must organize rescue efforts, provide aid, and help your community recover from this disaster.",
73 |         "A powerful and charismatic cult leader has taken control of a small town, cutting off all contact with the outside world. The authorities are hesitant to intervene due to the risk of violence. You must find a way to infiltrate the town, gather information, and safely resolve the situation.",
74 |         "A newly discovered comet is on a collision course with Earth, and efforts to divert it have failed. The world is scrambling to prepare for impact, but panic and disorder are spreading. You must decide how to best protect your community and ensure the survival of as many people as possible.",
75 |         "A massive oil spill has devastated the coastline, threatening marine life and the livelihoods of coastal communities. The cleanup effort is struggling, and the situation is worsening. You must find a way to mobilize resources and coordinate the response to protect the environment and the community.",
76 |         "A global pandemic has caused a sudden shift in climate patterns, leading to extreme weather events and food shortages. International cooperation is breaking down, and conflicts over resources are escalating. You must navigate this unstable world, secure supplies, and ensure the safety of your community.",
77 |         "A powerful cyberattack has crippled your country's power grid, causing widespread blackouts and chaos. Emergency services are overwhelmed, and the government is struggling to respond. You must find a way to restore order and protect your community in this chaotic environment."
78 |     ]
79 | }
```

## File: textarena/envs/two_player/ScenarioPlanning/README.md

- Extension: .md
- Language: markdown
- Size: 5716 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Scenario Planning Environment
  2 | 
  3 | ## Overview
  4 | **Scenario Planning** is a two-player strategic game where each player is presented with the same survival scenario. Players independently propose strategies for survival, and a panel of simulated judges evaluates these strategies based on their effectiveness and feasibility. The player whose strategy is deemed more effective by the judges wins the game.
  5 | 
  6 | ## Action Space
  7 | - **Format:** Actions are strings representing the player's proposed survival strategies.
  8 | - **Examples:** 
  9 |     - `"Build a shelter using available materials and secure a water source. [...]"`
 10 |     - `"Establish a communication system to call for rescue. [...]"`
 11 | 
 12 | ## Observation Space
 13 | 
 14 | ### Observations
 15 | **Reset Observation:**
 16 | 
 17 | On reset, each player receives a prompt containing the scenario and game instructions. For example:
 18 | ```plaintext
 19 | [GAME]: You are Player 0 in the Scenario Planning game.
 20 | Scenario: You are stranded on a deserted island with limited resources.
 21 | Your goal is to propose a strategy for survival in this scenario.
 22 | After both players submit their strategies, a panel of judges will evaluate them.
 23 | On your turn, simply type your strategy.
 24 | ```
 25 | 
 26 | **Step Observation:**
 27 | The game provides no step-based observations. This is to make sure that neither player has an unfair advantage. 
 28 | 
 29 | ## Gameplay
 30 | - **Players**: 2
 31 | - **Turns**: Each player has a single turn to propose their survival strategy.
 32 | - **Scenario Assignment**: A random survival scenario is selected at the start of the game.
 33 | - **Objective**: Submit the most effective and feasible survival strategy as evaluated by the judges.
 34 | - **Judges**: A panel of simulated judges evaluates the submitted strategies to determine the winner.
 35 | 
 36 | ## Key Rules
 37 | 1. Strategy Submission:
 38 |     - Each player submits a single strategy.
 39 | 2. Strategy Evaluation:
 40 |     - After both players have submitted their strategies, judges evaluate them based on effectiveness and feasibility. Each judge has to vote for one of the two strategies.
 41 | 3. Winning Conditions:
 42 |     - **Win:** The player whose strategy receives more votes by the judges wins the game.
 43 |     - **Draw:** If both strategies receive an equal number of votes, the game ends in a draw.
 44 | 4. Game Termination:
 45 |     - The game concludes after both players have submitted their strategies and the judges have evaluated them.
 46 | 
 47 | ## Rewards
 48 | | Outcome          | Reward for Player | Reward for Opponent |
 49 | |------------------|:-----------------:|:-------------------:|
 50 | | **Win**          | `+1`              | `-1`                |
 51 | | **Lose**         | `-1`              | `+1`                |
 52 | | **Draw**         | `0`               | `0`                 |
 53 | 
 54 | ## Parameters
 55 | - `num_judges` (`int`):
 56 |     - **Description**: Number of simulated judges evaluating the strategies.
 57 |     - **Impact**: Affects the granularity and reliability of the evaluation.
 58 | 
 59 | - `judge_class` (`ta.JudgeVote`)
 60 |     - **Description**: The type of judges used. By default, the `ta.game_makers.GPTJudgeVote` object is used, which utilized a random mix of different openai models.
 61 |     - **Impact:** This will significantly impact what types of arguments work well when trying to convince the judges.
 62 | 
 63 | - `scenarios_path` (`str`)
 64 |     - **Description:** Path to the JSON file containing survival scenarios.
 65 |     - **Impact:** Allows customization of the scenarios used in the game.
 66 | 
 67 | ## Variants
 68 | 
 69 | | Env-id                   | num_judges | judge_class    |
 70 | |--------------------------|:----------:|:--------------:|
 71 | | `ScenarioPlanning-v0`    |    `11`    | `GPTJudgeVote` |
 72 | 
 73 | 
 74 | ## Example Usage
 75 | 
 76 | ```python
 77 | import textarena as ta
 78 | 
 79 | # Initialize the environment
 80 | env = ta.make(env_id="ScenarioPlanning-v0")
 81 | 
 82 | # Wrap the environment for easier observation handling
 83 | env = ta.wrappers.LLMObservationWrapper(env=env)
 84 | 
 85 | # initalize agents
 86 | agents = {
 87 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
 88 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
 89 |     }
 90 | 
 91 | # reset the environment to start a new game
 92 | observations = env.reset(seed=490)
 93 | 
 94 | # Game loop
 95 | done = False
 96 | while not done:
 97 | 
 98 |     # Get the current player
 99 |     current_player_id = env.state.get("current_player")
100 | 
101 |     # Get the current observation for the player
102 |     obs = observations[current_player_id]
103 | 
104 |     # Agent decides on an action based on the observation
105 |     action = agents[current_player_id](obs)
106 | 
107 |     # Execute the action in the environment
108 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
109 | 
110 |     # Check if the game has ended
111 |     done = terminated or truncated
112 | 
113 |     # Optionally render the environment to see the current state
114 |     env.render()
115 | 
116 |     if done:
117 |         break
118 | 
119 | # Finally, print the game results
120 | for player_id, agent in agents.items():
121 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
122 | print(f"Reason: {info['reason']}")
123 | ```
124 | 
125 | ## Troubleshooting
126 | - **Invalid Strategy Submission:**
127 |     - **Issue:** A player submits a non-string strategy or an empty string.
128 |     - **Solution:** Ensure that all strategies are valid, non-empty strings representing actionable survival plans.
129 | 
130 | - **Missing Scenarios File:**
131 |     - **Issue:** The scenarios JSON file is not found at the specified path.
132 |     - **Solution:** Verify the `scenarios_path` parameter and ensure the file exists and is properly formatted.
133 | 
134 | - **Judge Evaluation Failures:**
135 |     - **Issue:** Judges fail to evaluate strategies.
136 |     - **Solution:** Ensure that you have set your OPEN-AI API key as an envrionment variable (i.e.`export OPENAI_API_KEY="YOUR_API_KEY"`).
137 | 
138 | 
139 | ## Version History
140 | - **v0**
141 |   - Initial release 
142 | 
143 | 
144 | 
145 | ### Contact
146 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/LetterAuction/test.py

- Extension: .py
- Language: python
- Size: 3868 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.two_player.LetterAuction.env import LetterAuctionEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["I bid 5 coins for the letter: [bid 5]", "I pass on the letter. [pass]", "I bid 10! [BID 10]", "I pass on the letter. [PASS]"]
 9 | 
10 | def generate_invalid_move_sequence():
11 |     
12 |     return ["I bid 5 coins for the letter: bid 5", "I pass on the letter. pass", "I bid 10! BID 10", "I pass on the letter. PASS"]
13 | 
14 | def generate_out_of_bounds_sequence():
15 |     
16 |     return ["I bid 5 coins for the letter: [bid 1000]", "I bid 100! [BID 1000]"]
17 | 
18 | class TestLetterAuctionEnv(unittest.TestCase):
19 |     
20 | 
21 |     
22 |     env_variants = [
23 |         {"difficulty": "easy"},
24 |         {"difficulty": "medium"},
25 |         {"difficulty": "hard"},
26 |     ]
27 | 
28 |     
29 |     test_cases = {
30 |         "correct_move_easy": {
31 |             "difficulty": "easy",
32 |             "actions": generate_correct_move_sequence()
33 |         },
34 |         "invalid_move_easy": {
35 |             "difficulty": "easy",
36 |             "actions": generate_invalid_move_sequence()
37 |         },
38 |         "out_of_bounds_easy": {
39 |             "difficulty": "easy",
40 |             "actions": generate_out_of_bounds_sequence()
41 |         }
42 |     }
43 | 
44 |     @parameterized.expand([
45 |         (name, details["difficulty"], details["actions"])
46 |         for name, details in test_cases.items()
47 |     ])
48 |     def test_letterauction_outcomes(self, name, difficulty, actions):
49 |         
50 |         env_config = next((env for env in self.env_variants if env["difficulty"] == difficulty), None)
51 |         self.assertIsNotNone(env_config, f"Environment configuration not found for difficulty level: {difficulty}")
52 | 
53 |         env = LetterAuctionEnv(difficulty=env_config["difficulty"])
54 | 
55 |         observations = env.reset(seed=490)
56 | 
57 |         terminated = False
58 |         truncated = False
59 |         rewards = {0: 0, 1: 0}
60 | 
61 |         for i, action in enumerate(actions):
62 |             if terminated or truncated:
63 |                 break
64 | 
65 |             player_id = i % 2
66 |             
67 |             env_action = action
68 | 
69 |             
70 |             observations, reward, truncated, terminated, info = env.step(player_id, env_action)
71 | 
72 |             
73 |             if reward:
74 |                 rewards.update(reward)
75 | 
76 |         if "correct_move" in name:
77 |             self.assertFalse(truncated, "Game should not truncate for correct moves.")
78 |             self.assertFalse(terminated, "Game should not terminate until the game is complete.")
79 |         elif "invalid_move" in name:
80 |             self.assertTrue(truncated or terminated, "Game should truncate for invalid moves.")
81 |             self.assertEqual(rewards[player_id], -1, "Player should receive -1 reward for an invalid move.")
82 |         elif "out_of_bounds" in name:
83 |             self.assertTrue(truncated or terminated, "Game should truncate for out-of-bounds moves.")
84 |             self.assertEqual(rewards[player_id], -1, "Player should receive -1 reward for an out-of-bounds move.")
85 |         else:
86 |             raise ValueError("Invalid test case name.")
87 |     
88 |     def run_unit_test():
89 |         print("Running LetterAuction tests...")
90 |         unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/two_player/LetterAuction/env.py

- Extension: .py
- Language: python
- Size: 19839 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from typing import Optional, Tuple
  2 | import random
  3 | import textarena as ta
  4 | import re
  5 | 
  6 | import nltk
  7 | nltk.download("words")
  8 | from nltk.corpus import words
  9 | 
 10 | import enchant
 11 | en_us_dict = enchant.Dict("en_US")
 12 | en_uk_dict = enchant.Dict("en_UK")
 13 | 
 14 | 
 15 | class LetterAuctionEnv(ta.Env):
 16 |     
 17 |     def __init__(
 18 |         self,
 19 |         difficulty: Optional[str] = "easy",
 20 |     ):
 21 |         
 22 |         self.environment_name = "LetterAuction"
 23 |         self.difficulty = difficulty
 24 | 
 25 |         
 26 |         if self.difficulty == "easy":
 27 |             
 28 |             self.letters = list("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
 29 |             self.letter_values = [1 for _ in self.letters]
 30 |             self.starting_coins = 100
 31 |         elif self.difficulty == "medium":
 32 |             
 33 |             self.letters = list("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
 34 |             self.letter_values = [1 for _ in self.letters]
 35 |             self.starting_coins = 50
 36 |         elif self.difficulty == "hard":
 37 |             
 38 |             self.letters = list("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
 39 |             self.letter_values = [1 for _ in self.letters]
 40 |             self.starting_coins = 25
 41 |         else:
 42 |             raise ValueError(f"Invalid difficulty level: {self.difficulty}")
 43 |         
 44 | 
 45 |         
 46 |         self.state = ta.State(
 47 |             num_players=2,
 48 |             render_keys=["rendered_text", "turn"]
 49 |         )
 50 | 
 51 |     def reset(
 52 |         self,
 53 |         seed: Optional[int] = None,
 54 |     ) -> Optional[ta.Observations]:
 55 |         
 56 |         if seed is not None:
 57 |             random.seed(seed)
 58 |         else:
 59 |             random.seed()
 60 | 
 61 |         
 62 |         self.player_states = {
 63 |             0: {
 64 |                 "coins": self.starting_coins,
 65 |                 "letters": [],
 66 |                 "letter_values": [],
 67 |                 "letter_bid_history": {
 68 |                     i: None for i in range(len(self.letters))
 69 |                 },
 70 |                 "word": None,
 71 |                 "word_value": 0,
 72 |             },
 73 |             1: {
 74 |                 "coins": self.starting_coins,
 75 |                 "letters": [],
 76 |                 "letter_values": [],
 77 |                 "letter_bid_history": {
 78 |                     i: None for i in range(len(self.letters))
 79 |                 },
 80 |                 "word": None,
 81 |                 "word_value": 0,
 82 |             }
 83 |         }
 84 | 
 85 |         
 86 |         self.current_player = 0 
 87 |         random.shuffle(self.letters) 
 88 |         self.round_number = 0 
 89 |         self.round_letter = self.letters[self.round_number]
 90 |         self.bid_amount = self.letter_values[self.round_number] 
 91 |         
 92 | 
 93 |         
 94 |         return self.state.reset(
 95 |             game_state={
 96 |                 "player_states": self.player_states,
 97 |                 "rendered_text": self.render_text(),
 98 |                 "turn": self.current_player,
 99 |             },
100 |             player_prompt_function=self._generate_player_prompt
101 |         )
102 |     
103 |     def step(
104 |         self,
105 |         player_id: int,
106 |         action: str
107 |     ) -> Tuple[
108 |         Optional[ta.Observations],
109 |         Optional[ta.Rewards],
110 |         bool,
111 |         bool,
112 |         ta.Info
113 |     ]:
114 |         
115 |         
116 |         if player_id != self.current_player:
117 |             raise ValueError(f"Invalid player ID: {player_id}. It is not the turn of player {player_id}.")
118 | 
119 |         
120 |         self.state.add_observation(
121 |             from_id=player_id,
122 |             to_id=-1,
123 |             message=action,
124 |             for_logging=True
125 |         )
126 | 
127 |         self.auction_over_prompt = ""
128 | 
129 |         if self.round_number < len(self.letters):
130 |             
131 |             
132 |             
133 |             action_search_pattern = re.compile(r"\[(bid \d+|pass)\]", re.IGNORECASE)
134 |             match = action_search_pattern.search(action)
135 | 
136 |             if not match:
137 |                 
138 |                 self.state.set_invalid_move(
139 |                     player_ids=[player_id],
140 |                     reasons=[f"Invalid action: {action}. Please enter a valid action: '[bid <amount>]' or '[pass]'."]
141 |                 )
142 | 
143 |             else:
144 |                 
145 |                 action_text = match.group(1).lower()
146 |                 if "pass" in action_text:
147 |                     
148 | 
149 |                     
150 |                     if self.player_states[player_id]["letter_bid_history"][self.round_number] is None:
151 |                         self.player_states[player_id]["letter_bid_history"][self.round_number] = "pass"
152 | 
153 |                     self._pass_bid(player_id) 
154 |                 
155 |                 else:
156 |                     
157 |                     bid_amount = int(action_text.split()[1])
158 |                     
159 |                     if self.player_states[player_id]["letter_bid_history"][self.round_number] is None:
160 |                         self.player_states[player_id]["letter_bid_history"][self.round_number] = "bid"
161 | 
162 |                     self._place_bid(player_id, bid_amount) 
163 | 
164 |         else:
165 |             
166 | 
167 |             
168 |             action_search_pattern = re.compile(r"\[([a-zA-Z]+)\]") 
169 |             match = action_search_pattern.search(action)
170 | 
171 |             if not match:
172 |                 
173 |                 self.state.set_invalid_move(
174 |                     player_ids=[player_id],
175 |                     reasons=[f"Invalid action: {action}. Please enter a valid action: '[<word>]'."]
176 |                 )
177 | 
178 |             else:
179 |                 
180 |                 action_text = match.group(1).lower()
181 |                 self._calculate_word_value(player_id, action_text) 
182 | 
183 |                 self.state.add_observation(
184 |                     from_id=ta.GAME_ID,
185 |                     to_id=-1,
186 |                     message=f"Player {player_id} chooses the word '{action_text}' with a value of {self.player_states[player_id]['word_value']}.",
187 |                     for_logging=True
188 |                 )
189 | 
190 |         
191 |         self.state.game_state["rendered_text"] = self.render_text()
192 | 
193 |         
194 |         if self._check_game_done(): 
195 |             if self.player_states[0]["word_value"] > self.player_states[1]["word_value"]:
196 |                 self.state.set_winners(
197 |                     player_ids=[0],
198 |                     reason=f"Player 0 wins with a score of {self.player_states[0]['word_value']}"
199 |                 )
200 |             elif self.player_states[1]["word_value"] > self.player_states[0]["word_value"]:
201 |                 self.state.set_winners(
202 |                     player_ids=[1],
203 |                     reason=f"Player 1 wins with a score of {self.player_states[1]['word_value']}"
204 |                 )
205 |             else:
206 |                 self.state.set_draw(reason="It's a draw!")
207 | 
208 |         return self.state.step()
209 |     
210 |     def _pass_bid(
211 |         self,
212 |         player_id: int,
213 |     ) -> None:
214 |         
215 |         opponent_id = 1 - player_id
216 |         
217 |         prompt = f"Player {player_id} passes on the letter '{self.round_letter}'."
218 | 
219 |         if self.player_states[opponent_id]["letter_bid_history"][self.round_number] is None:
220 |             
221 | 
222 |             
223 |             next_prompt = self._turn_manager(next_round=False, next_player=True)
224 | 
225 |             
226 |             prompt += next_prompt
227 | 
228 |         elif self.player_states[opponent_id]["letter_bid_history"][self.round_number] == "bid":
229 |             
230 |             prompt += f" Player {opponent_id} will have '{self.round_letter}' for {self.bid_amount}."
231 |             
232 |             
233 |             self._assign_letter(opponent_id, self.round_letter, self.bid_amount)
234 | 
235 |             
236 |             next_prompt = self._turn_manager(next_round=True, next_player=False)
237 | 
238 |             
239 |             prompt += next_prompt
240 | 
241 |         else:
242 |             
243 |             prompt += f" Player {opponent_id} also passes on the letter '{self.round_letter}'. So, no one will gain the letter."
244 |             
245 |             
246 |             next_prompt = self._turn_manager(next_round=True, next_player=False)
247 | 
248 |             
249 |             prompt += next_prompt
250 | 
251 |         self.state.add_observation(
252 |             from_id=ta.GAME_ID,
253 |             to_id=-1,
254 |             message=prompt,
255 |             for_logging=True
256 |         )
257 | 
258 |     def _place_bid(
259 |         self,
260 |         player_id: int,
261 |         bid_amount: int,
262 |     ) -> None:
263 |         
264 |         opponent_id = 1 - player_id
265 | 
266 |         prompt = f"Player {player_id} bids {bid_amount} on the letter '{self.round_letter}'."
267 | 
268 |         if self.player_states[player_id]["coins"] < bid_amount:
269 |             
270 |             self.state.set_invalid_move(
271 |                 player_ids=[player_id],
272 |                 reasons=[f"Invalid bid: {bid_amount}. You do not have enough coins."]
273 |             )
274 |             return
275 |         
276 |         elif self.player_states[opponent_id]["letter_bid_history"][self.round_number] is None:
277 |             
278 | 
279 |             
280 |             self.bid_amount = bid_amount
281 | 
282 |             
283 |             next_prompt = self._turn_manager(next_round=False, next_player=True)
284 | 
285 |             prompt += next_prompt
286 |         
287 |         elif self.player_states[opponent_id]["letter_bid_history"][self.round_number] == "bid":
288 |             
289 |             
290 |             if bid_amount < self.bid_amount:
291 |                 
292 |                 prompt += f" Player {opponent_id} will have '{self.round_letter}' for {self.bid_amount}."
293 | 
294 |                 
295 |                 self._assign_letter(opponent_id, self.round_letter, self.bid_amount)
296 | 
297 |                 
298 |                 next_prompt = self._turn_manager(next_round=True, next_player=True)
299 | 
300 |                 
301 |                 prompt += next_prompt
302 | 
303 |             else:
304 |                 
305 |                 
306 |                 
307 |                 self.bid_amount = bid_amount
308 | 
309 |                 
310 |                 next_prompt = self._turn_manager(next_round=False, next_player=True)
311 |                 
312 |                 prompt += next_prompt
313 | 
314 |         else:
315 |             
316 |             prompt += f" Since Player {opponent_id} passes on the letter '{self.round_letter}', Player {player_id} will have it for {bid_amount}."
317 | 
318 |             
319 |             self._assign_letter(player_id, self.round_letter, bid_amount)
320 | 
321 |             
322 |             next_prompt = self._turn_manager(next_round=True, next_player=True)
323 | 
324 |             
325 |             prompt += next_prompt
326 | 
327 |         self.state.add_observation(
328 |             from_id=ta.GAME_ID,
329 |             to_id=-1,
330 |             message=prompt,
331 |             for_logging=True
332 |         )
333 | 
334 |     def _assign_letter(
335 |         self,
336 |         player_id: int,
337 |         letter: str,
338 |         bid_amount: int,
339 |     ) -> None:
340 |         
341 |         self.player_states[player_id]["letters"].append(letter)
342 |         self.player_states[player_id]["letter_values"].append(bid_amount)
343 |         self.player_states[player_id]["coins"] -= bid_amount
344 | 
345 |     def _turn_manager(
346 |         self,
347 |         next_round: bool = False,
348 |         next_player: Optional[bool] = False,
349 |     ) -> str:
350 |         
351 |         next_player = True
352 |         if next_player:
353 |             
354 |             self.current_player = 1 - self.current_player
355 | 
356 |         if next_round:
357 |             
358 |             self.round_number += 1
359 |             if self.round_number < len(self.letters):
360 |                 self.round_letter = self.letters[self.round_number]
361 |                 self.bid_amount = self.letter_values[self.round_number]
362 |                 next_prompt = f" Player {self.current_player}, do you want to start bid on the letter '{self.round_letter}' for {self.bid_amount}?"
363 |             else:
364 |                 
365 |                 next_prompt = "The auction is over. Now, players will use the letters they've won to form the highest value english word from the letters won. The player with the highest value word wins the game. To submit the word, submit it in square brackets like [dog]."
366 | 
367 |         else:
368 |             next_prompt = f" Player {self.current_player}, do you want to bid on the letter '{self.round_letter}' for more than {self.bid_amount}?"
369 | 
370 |         return next_prompt
371 | 
372 |             
373 | 
374 | 
375 |     def _calculate_word_value(
376 |         self,
377 |         player_id: int,
378 |         word: str,
379 |     ) -> None:
380 |         
381 |         
382 |         word = word.upper()
383 | 
384 |         if en_us_dict.check(word) == False and en_uk_dict.check(word) == False:
385 |             self.player_states[player_id]["word"] = ""
386 |             self.player_states[player_id]["word_value"] = 0
387 | 
388 |             self.state.set_invalid_move(
389 |                 player_ids=[player_id],
390 |                 reasons=[f"Invalid word: {word}. Please enter a valid English word."]
391 |             )
392 |             return
393 |         
394 |         
395 |         for letter in word:
396 |             if letter not in self.player_states[player_id]["letters"]:
397 |                 self.player_states[player_id]["word"] = ""
398 |                 self.player_states[player_id]["word_value"] = 0
399 | 
400 |                 self.state.set_invalid_move(
401 |                     player_ids=[player_id],
402 |                     reasons=[f"Invalid word: {word}. You do not have the letter '{letter}'."]
403 |                 )
404 |                 return
405 | 
406 |         
407 |         word_value = sum(self.player_states[player_id]["letter_values"][self.player_states[player_id]["letters"].index(letter)] for letter in word)
408 |         self.player_states[player_id]["word"] = word
409 |         self.player_states[player_id]["word_value"] = word_value
410 | 
411 |         
412 |         self._turn_manager(next_round=False, next_player=True)
413 | 
414 |     def _check_game_done(self) -> bool:
415 |         
416 |         
417 |         for player_id in self.player_states:
418 |             if self.player_states[player_id]["word"] is None:
419 |                 return False
420 |             
421 |         return True
422 |     
423 |     def render_text(self) -> str:
424 |         
425 |         rendered_text = f"Round {self.round_number + 1}/{len(self.letters) + 1}\n" 
426 |         rendered_text += f"All letters: {self.letters}\n"
427 |         rendered_text += f"Current letter: {self.round_letter}\n"
428 |         rendered_text += f"Player 0: {self.player_states[0]['coins']} coins, {self.player_states[0]['letters']}\n"
429 |         rendered_text += f"Player 1: {self.player_states[1]['coins']} coins, {self.player_states[1]['letters']}\n"
430 |         rendered_text += f"Current player: {self.current_player}\n"
431 |         return rendered_text
432 |     
433 |     def _generate_player_prompt(self, player_id) -> str:
434 |         
435 |         prompt = (
436 |             f"You are Player {player_id}. You are currently in the Letter Auction game.\n"
437 |             "The goal of the game is to strategically bid on letters to form the highest value word. This is how the game works.\n"
438 |             "You must listen to the gamemaster for guidance to play the game.\n"
439 |             "The game consists of a series of rounds. In each round, a letter will be put up for auction.\n"
440 |             "You can bid on the letter using your coins. The player with the highest bid wins the letter.\n"
441 |             "The letter will be added to your collection, and the coins you bid will be deducted from your total.\n"
442 |             "This bidding of letters will repeat till all the letters have been auctioned off. You are not rewarded for saving your coins.\n"
443 |             "After all the letters have been auctioned, you will use the letters to form the highest value english word from the letters won.\n"
444 |             "The player with the highest value word wins the game.\n"
445 |             "If you want to bid, submit your bid amount in square brackets like [bid 2] or [bid 10].\n"
446 |             "If you do not want to bid, submit [pass].\n"
447 |             "For the submission of the highest value word, you will be prompted at the end of the game to submit them in square brackets like [dog].\n"
448 |             "Here is your starting information:\n"
449 |             f"Your current coins: {self.player_states[player_id]['coins']}\n"
450 |             f"Your current letters: {self.player_states[player_id]['letters']}\n"
451 | 
452 |             "\n"
453 |             f"[Game] Player 0 will go first. The first letter for bid: {self.round_letter}.\n"
454 |             f"Starting bid is {self.bid_amount} coin. You can bid any amount of coins, or choose not to bid.\n"
455 |         )
456 | 
457 |         return prompt
458 |     
459 |     def render(self):
460 |         
461 |         print(self.state.game_state["rendered_text"])
```

## File: textarena/envs/two_player/LetterAuction/README.md

- Extension: .md
- Language: markdown
- Size: 8898 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Letter Auction Environment Documentation
  2 | 
  3 | ## Overview
  4 | **Letter Auction Game** is a two-player bidding-based game where players compete to acquire letters through an auction, aiming to use the collected letters to form the highest value English word by the game's end. Each player starts with a set number of coins, which they use to bid on letters in rounds. Players strategically decide to bid or pass on each letter, aiming to outbid their opponent and secure valuable letters without depleting their coins. After all letters are auctioned, players form the highest possible value word using only the letters they've won. The player with the highest word value wins the game. This environment supports gameplay features such as automated bidding rounds, coin tracking, and final word scoring.
  5 | 
  6 | 
  7 | ## Action Space
  8 | - **Format:** Actions are strings representing the player's actions. For example:
  9 | - **Example:**
 10 |     - Bid 10 coins for the round's letter: [bid 10]
 11 |     - Pass on the round's letter: [pass]
 12 |     - To submit the word "SEE" based on the letters ["S", "E"]: [see]
 13 | - **Notes:** Players can have additional texts in their replies, as long as they provide their actions in the correct format.
 14 | 
 15 | ## Observation Space
 16 | **Reset Observations**
 17 | On reset, each player receives a prompt containing their beginning game instructions. For example:
 18 | ```plaintext
 19 | [GAME] You are Player 1. You are currently in the Letter Auction game.
 20 | The goal of the game is to strategically bid on letters to form the highest value word. This is how the game works.
 21 | You must listen to the gamemaster for guidance to play the game.
 22 | The game consists of a series of rounds. In each round, a letter will be put up for auction.
 23 | You can bid on the letter using your coins. The player with the highest bid wins the letter.
 24 | The letter will be added to your collection, and the coins you bid will be deducted from your total.
 25 | This bidding of letters will repeat till all the letters have been auctioned off. You are not rewarded for saving your coins.
 26 | After all the letters have been auctioned, you will use the letters to form the highest value english word from the letters won.
 27 | The player with the highest value word wins the game.
 28 | If you want to bid, submit your bid amount in square brackets like [bid 2] or [bid 10].
 29 | If you do not want to bid, submit [pass].
 30 | For the submission of the highest value word, you will be prompted at the end of the game to submit them in square brackets like [dog].
 31 | Here is your starting information:
 32 | Your current coins: 100
 33 | Your current letters: []
 34 | 
 35 | [Game] Player 0 will go first. The first letter for bid: M.
 36 | Starting bid is 1 coin. You can bid any amount of coins, or choose not to bid.
 37 | ```
 38 | 
 39 | **Step Observation:**
 40 | After each step, the players receive the latest message from the game environment that determines who gets the word, and what the next letter is for bidding. For example:
 41 | ```plaintext
 42 | [Player 0] [bid 5]
 43 | [GAME] Player 0 bids 5 on the letter 'M'. Player 1, do you want to bid on the letter 'M' for more than 5?
 44 | ```
 45 | 
 46 | ## Gameplay
 47 | 
 48 | - **Players**: 2
 49 | - **Turns**: Players take turns either bidding on a letter or passing. Each turn, a player can place a bid to acquire the letter for a specified coin amount or pass, allowing the opponent to bid.
 50 | - **Board**: The game consists of a shared pool of letters, randomly ordered for auction in each session. Players have separate coin balances and letter collections.
 51 | - **Objective**: Outbid the opponent to acquire valuable letters and form the highest value word at the end of the game.
 52 | - **Difficulty Levels**:
 53 |   - **Easy**: Players start with 100 coins.
 54 |   - **Medium**: Players start with 50 coins.
 55 |   - **Hard**: Players start with 25 coins.
 56 | - **Bidding Phase**: Players alternate turns to bid or pass on each letter. If both pass, the letter is forfeited, and no player acquires it.
 57 | - **Word Formation Phase**: After the bidding phase, players use the letters they won to form a high-value English word. The value of a word is determined by the combined bid values of the letters in that word.
 58 | - **Winning Condition**: The player who creates the word with the highest value wins. In the case of a tie, the game ends in a draw.
 59 | 
 60 | ## Key Rules
 61 | 
 62 | 1. **Bidding**:
 63 |    - Players take turns deciding to bid on a letter or pass (e.g., "[bid 10]" or "[pass]").
 64 |    - The player with the highest bid on a letter wins it and adds it to their collection.
 65 |    - If both players pass on a letter, it is forfeited, and neither player can use it in word formation.
 66 | 
 67 | 2. **Valid Actions**:
 68 |    - Players must either place a bid that does not exceed their current coins or choose to pass.
 69 |    - A bid action is only valid if the player has enough coins to cover the amount. Passing forfeits the opportunity to bid on the letter for that round.
 70 | 
 71 | 3. **Word Formation**:
 72 |    - After all letters have been auctioned, players use the letters they've won to form an English word, aiming for the highest possible value.
 73 |    - The word's value is calculated based on the sum of bid amounts for the letters used in the word.
 74 |    - Only valid English words formed with acquired letters are accepted.
 75 | 
 76 | 4. **Winning Conditions**:
 77 |    - **Win**: The player whose word has the highest value (total of bid amounts for each letter) wins the game.
 78 |    - **Draw**: If both players create words with the same value, the game ends in a draw.
 79 | 
 80 | 5. **Game Termination**:
 81 |    - The game ends once both players submit their final words. The player with the higher word value wins, or the game results in a draw if both values are identical.
 82 | 
 83 | ## Rewards
 84 | 
 85 | | Outcome          | Reward for Player | Reward for Opponent |
 86 | |------------------|:-----------------:|:-------------------:|
 87 | | **Win**          | `+1`              | `-1`                |
 88 | | **Lose**         | `-1`              | `+1`                |
 89 | | **Draw**         | `0`               | `0`                 |
 90 | | **Invalid**      | `-1`              | `0`                 |
 91 | 
 92 | ## Parameters
 93 | 
 94 | - `difficulty` (`str`):
 95 |     - **Description**: Sets the difficulty level, which determines the number of starting coins for each player.
 96 |     - **Options**:
 97 |         - `"easy"`: Players start with 100 coins, allowing for higher and more frequent bids, suitable for beginners.
 98 |         - `"medium"`: Players start with 50 coins, offering a balanced gameplay experience where players must be strategic with their bids.
 99 |         - `"hard"`: Players start with 25 coins, challenging players to manage limited resources carefully.
100 |     - **Impact**:
101 |         - Higher difficulty levels reduce the starting coin amount, increasing the strategic complexity of each bid and encouraging players to save coins for valuable letters.
102 | 
103 | ## Variants
104 | 
105 | | Env-id                    | difficulty |
106 | |---------------------------|:----------:|
107 | | `LetterAuction-v0-easy`   | `easy`     |
108 | | `LetterAuction-v0-medium` | `medium`   |
109 | | `LetterAuction-v0-hard`   | `hard`     |
110 | 
111 | ## Example Usage
112 | ```python
113 | import textarena as ta
114 | 
115 | # Initialize the environment
116 | env = ta.make(env_id="LetterAuction-v0-easy")
117 | 
118 | # Wrap the environment for easier observation handling
119 | env = ta.wrappers.LLMObservationWrapper(env=env)
120 | 
121 | # Wrap the environment for pretty rendering
122 | env = ta.wrappers.PrettyRenderWrapper(env=env)
123 | 
124 | # initalize agents
125 | agents = {
126 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
127 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
128 |     }
129 | 
130 | # reset the environment to start a new game
131 | observations = env.reset(seed=490)
132 | 
133 | # Game loop
134 | done = False
135 | while not done:
136 | 
137 |     # Get the current player
138 |     current_player_id = env.state.get("current_player")
139 | 
140 |     # Get the current observation for the player
141 |     obs = observations[current_player_id]
142 | 
143 |     # Agent decides on an action based on the observation
144 |     action = agents[current_player_id](obs)
145 | 
146 |     # Execute the action in the environment
147 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
148 | 
149 |     # Check if the game has ended
150 |     done = terminated or truncated
151 | 
152 |     # Optionally render the environment to see the current state
153 |     env.render()
154 | 
155 |     if done:
156 |         break
157 | 
158 | # Finally, print the game results
159 | for player_id, agent in agents.items():
160 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
161 | print(f"Reason: {info['reason']}")
162 | ```
163 | 
164 | ## Troubleshooting
165 | 
166 | - **Repeatedly passing on bids**:
167 |     - **Issue**: The player repeatedly passes bids, and / or fails to make any bid for letters.
168 |     - **Solution**: Refine the prompt to explicitly seek a strategic approach in winning bids with the ample coins, whilst highlighting how the player is rewarded not by how much coins it has at the end of the game, but how it creates a high-value word with the coins they have,
169 | 
170 | 
171 | ## Version History
172 | - **v0**
173 |   - Initial release 
174 | 
175 | ### Contact
176 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/two_player/LetterAuction/example.py

- Extension: .py
- Language: python
- Size: 1341 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make(env_id="LetterAuction-v0-easy")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
15 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
16 |     }
17 | 
18 | 
19 | observations = env.reset(seed=490)
20 | 
21 | 
22 | done = False
23 | while not done:
24 | 
25 |     
26 |     current_player_id = env.state.get("current_player")
27 | 
28 |     
29 |     obs = observations[current_player_id]
30 | 
31 |     
32 |     action = agents[current_player_id](obs)
33 | 
34 |     
35 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
36 | 
37 |     
38 |     done = terminated or truncated
39 | 
40 |     
41 |     env.render()
42 | 
43 |     if done:
44 |         break
45 | 
46 | 
47 | for player_id, agent in agents.items():
48 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
49 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/two_player/Chess/test.py

- Extension: .py
- Language: python
- Size: 6544 bytes
- Created: 2024-11-14 15:46:39
- Modified: 2024-11-14 15:46:39

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | import warnings
  4 | from typing import List, Dict, Optional
  5 | 
  6 | from textarena.envs.two_player.Chess.env import ChessEnv
  7 | 
  8 | 
  9 | warnings.filterwarnings('ignore', category=UserWarning)
 10 | warnings.filterwarnings('ignore', category=FutureWarning)
 11 | 
 12 | class TestChessEnv(unittest.TestCase):
 13 |     
 14 | 
 15 |     
 16 |     test_cases = {
 17 |         
 18 |         
 19 |         
 20 |         
 21 |         
 22 |         
 23 |         
 24 |         
 25 |         
 26 |         
 27 |         
 28 |         
 29 |         
 30 |         
 31 |         "Stalemate Example": {
 32 |     "env_id": "Chess-v0",
 33 |     "actions": [
 34 |         "[e2e3]",   
 35 |         "[a7a5]",   
 36 |         "[d1g4]",   
 37 |         "[a5a4]",   
 38 |         "[g4xd7+]", 
 39 |         "[e8xd7]",  
 40 |         "[e1e2]",   
 41 |         "[d7d6]",   
 42 |         "[e2e3]",   
 43 |         "[d6d5]",   
 44 |         "[e3f4]",   
 45 |         "[d5c5]",   
 46 |         "[f4g5]",   
 47 |         "[c5b4]",   
 48 |         "[g5h6]",   
 49 |         "[b4a3]",   
 50 |         "[h6g7]",   
 51 |         "[a3a2]",   
 52 |         "[g7f8]",   
 53 |         "[a2a1=Q]", 
 54 |         "[f8g8]",   
 55 |         "[h7h6]"    
 56 |     ],
 57 |     "expected_rewards": {0: 0, 1: 0},  
 58 |     "expected_truncated": False,
 59 |     "expected_terminated": True,
 60 | }
 61 | 
 62 | 
 63 | 
 64 | 
 65 | 
 66 | 
 67 | 
 68 |         
 69 |         
 70 |         
 71 |         
 72 |         
 73 |         
 74 |         
 75 |         
 76 |         
 77 |         
 78 |         
 79 |         
 80 |         
 81 |         
 82 |         
 83 |         
 84 |         
 85 |         
 86 |         
 87 |         
 88 |         
 89 |     }
 90 | 
 91 |     @parameterized.expand([
 92 |         (
 93 |             name,
 94 |             details["env_id"],
 95 |             details["actions"],
 96 |             details["expected_rewards"],
 97 |             details["expected_truncated"],
 98 |             details["expected_terminated"]
 99 |         )
100 |         for name, details in test_cases.items()
101 |     ])
102 |     def test_chess_env_outcomes(
103 |         self,
104 |         name: str,
105 |         env_id: str,
106 |         actions: List[str],
107 |         expected_rewards: Optional[Dict[int, int]],
108 |         expected_truncated: bool,
109 |         expected_terminated: bool
110 |     ):
111 |         
112 |         with self.subTest(test_case=name):
113 |             try:
114 |                 
115 |                 env = ChessEnv()
116 |             except Exception as e:
117 |                 self.fail(f"Failed to initialize environment '{env_id}': {e}")
118 | 
119 |             try:
120 |                 
121 |                 env.reset(seed=42)
122 |             except Exception as e:
123 |                 self.fail(f"Failed to reset the environment '{env_id}': {e}")
124 | 
125 |             
126 |             terminated = False
127 |             truncated = False
128 | 
129 |             for i, action in enumerate(actions):
130 |                 player_id = i % 2
131 | 
132 |                 try:
133 |                     
134 |                     step_result = env.step(player_id, action)
135 |                     if len(step_result) != 5:
136 |                         self.fail(f"env.step() returned {len(step_result)} elements, expected 5.")
137 |                     observations, rewards, truncated, terminated, info = step_result
138 |                 except Exception as e:
139 |                     self.fail(f"env.step() raised an unexpected exception for player {player_id}: {e}")
140 | 
141 |                 if terminated or truncated:
142 |                     break
143 | 
144 |             
145 |             self.assertEqual(
146 |                 rewards,
147 |                 expected_rewards,
148 |                 f"The rewards did not match. Expected {expected_rewards}; received {rewards}"
149 |             )
150 | 
151 |             self.assertEqual(
152 |                 terminated,
153 |                 expected_terminated,
154 |                 f"Terminated flag mismatch. Expected {expected_terminated}; received {terminated}"
155 |             )
156 | 
157 |             self.assertEqual(
158 |                 truncated,
159 |                 expected_truncated,
160 |                 f"Truncated flag mismatch. Expected {expected_truncated}; received {truncated}"
161 |             )
162 | 
163 | 
164 | 
165 | if __name__ == '__main__':
166 |     unittest.main()
```

## File: textarena/envs/two_player/Chess/env.py

- Extension: .py
- Language: python
- Size: 7360 bytes
- Created: 2024-12-12 16:26:09
- Modified: 2024-12-12 16:26:09

### Code

```python
  1 | import re
  2 | from typing import Any, Dict, Optional, Tuple
  3 | 
  4 | import chess
  5 | import textarena as ta
  6 | 
  7 | 
  8 | class ChessEnv(ta.Env):
  9 |     
 10 | 
 11 |     def __init__(
 12 |         self,
 13 |         is_open: bool = True,
 14 |         max_turns: int = 30,
 15 |         show_valid: bool = True,
 16 |     ):
 17 |         
 18 |         self.is_open = is_open 
 19 |         self.show_valid = show_valid 
 20 | 
 21 |         
 22 |         self.state = ta.State(
 23 |             num_players=2,
 24 |             max_turns=max_turns,
 25 |             role_mapping={0: "White", 1: "Black"}
 26 |         )
 27 |         self.board = None
 28 | 
 29 |         
 30 |         self.move_pattern = re.compile(r"\[[a-h][1-8][a-h][1-8][qrbn]?\]", re.IGNORECASE)
 31 | 
 32 | 
 33 |         
 34 |         
 35 | 
 36 |         
 37 | 
 38 |     @property
 39 |     def offline_renderer(self):
 40 |         from textarena.wrappers.renderers.chess import ChessRenderer
 41 |         return ChessRenderer
 42 | 
 43 | 
 44 |     def reset(
 45 |         self, seed: Optional[int] = None
 46 |     ):
 47 |         
 48 |         
 49 |         self.board = chess.Board()
 50 | 
 51 |         self.state.reset(
 52 |             seed=seed,
 53 |             game_state={"current_board": str(self.board)},
 54 |             player_prompt_function=self._generate_player_prompt
 55 |         )
 56 | 
 57 | 
 58 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[int, Any]) -> str:
 59 |         
 60 |         color = "White" if player_id == 0 else "Black"
 61 |         prompt = (
 62 |             f"You are playing {color} in a game of Chess.\n"
 63 |             "Make your move in UCI format enclosed in square brackets (e.g., [e2e4]).\n"
 64 |             "You can also include additional text in your messages.\n"
 65 |         )
 66 |         if self.is_open:
 67 |             prompt += f"Current board state:\n{self.board}\n"
 68 | 
 69 |         
 70 | 
 71 |         if player_id == 0:
 72 |             prompt += "Please make the first move."
 73 | 
 74 |         return prompt
 75 | 
 76 |     def step(self, action: str) -> Tuple[Optional[ta.Rewards], bool, bool, ta.Info]:
 77 |         
 78 |         
 79 |         self.state.check_action_format(action=action)
 80 | 
 81 |         
 82 |         self.state.add_observation(
 83 |             from_id=self.state.current_player_id,
 84 |             to_id=-1, 
 85 |             message=action,
 86 |             for_logging=True
 87 |         )
 88 | 
 89 | 
 90 |         
 91 |         self._execute_player_move(
 92 |             player_id=self.state.current_player_id, 
 93 |             action=action
 94 |         )
 95 | 
 96 | 
 97 |         
 98 |         self._check_gameover()
 99 | 
100 |         
101 |         self._agument_observations()
102 | 
103 | 
104 |         
105 |         self.state.game_state["current_board"] = str(self.board)
106 | 
107 |         return self.state.step()
108 | 
109 | 
110 | 
111 | 
112 |     def _execute_player_move(self, player_id: int, action: str):
113 |         
114 |         match = self.move_pattern.search(action.strip())
115 |         
116 |         
117 |         if not match:
118 |             self.state.set_invalid_move(
119 |                 player_ids=[player_id],
120 |                 reasons=[f"Player {player_id} did not provide a move."]
121 |             )
122 | 
123 |         else:
124 |             
125 |             move_uci = match.group(0).lower().replace("[", "").replace("]", "")
126 | 
127 |             
128 |             move = chess.Move.from_uci(move_uci)
129 |             if move in self.board.legal_moves:
130 |                 
131 |                 self.board.push(move)
132 |                 self.state.add_observation(
133 |                     from_id=ta.GAME_ID,
134 |                     to_id=-1, 
135 |                     message=f"Player {player_id} made the following move: {move_uci}"
136 |                 )
137 | 
138 |             else:
139 |                 
140 |                 self.state.set_invalid_move(
141 |                     player_ids=[player_id],
142 |                     reasons=[f"Player {player_id} tried making an illegal move."]
143 |                 )
144 | 
145 | 
146 |     def _check_gameover(self):
147 |         
148 |         if self.board.is_game_over():
149 |             
150 |             
151 |             outcome = self.board.outcome().result() 
152 | 
153 |             
154 |             if outcome == "1/2-1/2":
155 |                 self.state.set_draw(
156 |                     reason=f"Game ended in a draw."
157 |                 )
158 |             else:
159 |                 winner_id = 0 if outcome == "1-0" else 1
160 |                 self.state.set_winners(
161 |                     player_ids=[winner_id],
162 |                     reason=f"Player {winner_id} wins the match."
163 |                 )
164 | 
165 | 
166 |     def _agument_observations(self):
167 |         
168 |         if self.is_open:
169 |             
170 |             self.state.add_observation(
171 |                 from_id=ta.GAME_ID,
172 |                 to_id=-1, 
173 |                 message=str(self.board),
174 |                 for_logging=False 
175 |             )
176 | 
177 |         if self.show_valid:
178 |             
179 |             self.state.add_observation(
180 |                 from_id=ta.GAME_ID,
181 |                 to_id=-1, 
182 |                 message=f"Valid moves: {', '.join([f'[{move.uci()}]' for move in self.board.legal_moves])}",
183 |                 for_logging=False 
184 |             )
185 | 
186 |     def render(self):
187 |         
188 |         current_turn = self.state.game_state.get("turn", 0)
189 |         max_turns = self.state.game_state.get("max_turns", 30)
190 |         print(f"Turn {current_turn}/{max_turns}")
191 |         print("Current Board State:")
192 |         print(self.board)
193 |         print("\nAction Logs:")
194 |         for sender_id, message in self.state.game_state["logs"]:
195 |             if sender_id == -1:
196 |                 print(f"[GAME]: {message}")
197 |             else:
198 |                 print(f"Player {sender_id}: {message}")
199 |         print("\n")
```

## File: textarena/envs/two_player/Chess/README.md

- Extension: .md
- Language: markdown
- Size: 7703 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Chess Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | **Chess** is a strategic two-player board game where each participant controls an army of 16 pieces: one King, one Queen, two Rooks, two Knights, two Bishops, and eight Pawns. The objective is to checkmate the opponent's King, rendering it unable to escape capture. Players take turns making moves in UCI (Universal Chess Interface) format, strategically advancing their pieces to control the board, attack the opponent's pieces, and defend their own.
  6 | 
  7 | ## Action Space
  8 | 
  9 | - **Format:** Actions are strings representing a chess move in UCI notation, enclosed in square brackets.
 10 | - **Special Tokens:** 
 11 |     - **[<uci_move>]**: To make a chess move.
 12 |         - **Example:** `[e2e4]`
 13 | - **Example:** 
 14 |     - `"I advance my pawn to [e2e4]."`
 15 |     - `"[e7e5]"`
 16 |     - `"That's a brilliant move! [Ng1f3]"`
 17 | - **Notes:** 
 18 |     - Players can include additional text before or after the special tokens (move).
 19 |     - Make sure each action contains the special token.
 20 |     - If multiple moves are provided, only the first will be considred.
 21 | 
 22 | ## Observation Space
 23 | 
 24 | ### Observations
 25 | 
 26 | Players receive a series of messages exchanged during the game, including their own and the opponent's moves, current board state, and available valid moves. This information aids in making informed decisions about future moves or conceding the game.
 27 | 
 28 | 
 29 | **Reset Observation:**
 30 | 
 31 | On reset, each player receives a prompt detailing their assigned color, the initial board state, and instructions on how to interact within the game. For example:
 32 | ```plaintext
 33 | [GAME]: Game started.
 34 | You are playing White in a game of Chess.
 35 | Make your move in UCI format enclosed in square brackets (e.g., [Move] e2e4).
 36 | You can also include additional text in your messages.
 37 | It's your turn. What is your move?
 38 | ```
 39 | If the game is in open mode, the board state is provided as well. For example:
 40 | ```plaintext
 41 | r n b q k b n r
 42 | p p p p p p p p
 43 | . . . . . . . .
 44 | . . . . . . . .
 45 | . . . . . . . .
 46 | . . . . . . . .
 47 | P P P P P P P P
 48 | R N B Q K B N R
 49 | ```
 50 | 
 51 | **Step Observation:**
 52 | After each step, players receive updates about moves made and the current board state. For example:
 53 | ```plaintext
 54 | Player 0: I advance my pawn to [Move] e2e4.
 55 | [GAME]: Player 0 (White) moves from e2 to e4.
 56 | ```
 57 | If the game is in open mode, the board state is provided as well. For example:
 58 | ```plaintext
 59 | [GAME]
 60 | r n b q k b n r
 61 | p p p p p p p p
 62 | . . . . . . . .
 63 | . . . . . . . .
 64 | . . . . P . . .
 65 | . . . . . . . .
 66 | P P P P . P P P
 67 | R N B Q K B N R
 68 | ```
 69 | 
 70 | If the game has show_valid=True, the valid moves are also provided. For example:
 71 | ```plaintext
 72 | [GAME] Valid moves: [g8h6], [g8f6], [b8c6], [b8a6], [h7h6], [g7g6], [f7f6], [e7e6], [d7d6], [c7c6], [b7b6], [a7a6], [h7h5], [g7g5], [f7f5], [e7e5], [d7d5], [c7c5], [b7b5], [a7a5]
 73 | ```
 74 | 
 75 | 
 76 | ## Gameplay
 77 | - **Players**: 2
 78 | - **Colors**: Player 0 plays as White, Player 1 plays as Black.
 79 | - **Turns**: Players alternate making moves, starting with White.
 80 | - **Move Format**: All moves must be in UCI notation enclosed in square brackets (e.g., `[e2e4]`).
 81 | - **Objective**: Checkmate the opponent's King to win the game.
 82 | - **Turn Limit**: When the turn limit is reached, the game ends in a draw.
 83 | 
 84 | ## Key Rules
 85 | 1. Move Mechanics:
 86 |     - Players take turns making moves in UCI format.
 87 |     - A valid move must follow standard chess rules and be legal based on the current board state.
 88 |     - Example: Moving a pawn from e2 to e4 is represented as `[e2e4]`.
 89 | 
 90 | 2. Game Termination:
 91 |     - **Checkmate**: The game ends when a player's King is checkmated.
 92 |     - **Draw**: The game ends in a draw if the maximum number of turns is reached or by stalemate, insufficient material, threefold repetition, or the fifty-move rule.
 93 | 
 94 | 3. Invalid Moves:
 95 |     - If a player makes an illegal move or provides an incorrectly formatted action, the game will terminate with a penalty.
 96 |     - Players are encouraged to ensure their moves are legal and correctly formatted to avoid unintended penalties.
 97 | 
 98 | ## Rewards
 99 | 
100 | | Outcome          | Reward for Player | Reward for Opponent |
101 | |------------------|:-----------------:|:-------------------:|
102 | | **Win**          | `+1`              | `-1`                |
103 | | **Lose**         | `-1`              | `+1`                |
104 | | **Draw**         |  `0`              |  `0`                |
105 | | **Invalid Move** | `-1`              |  `0`                |
106 | 
107 | 
108 | ## Parameters
109 | 
110 | - `is_open` (`bool`):
111 |     - **Description**: Determines whether both players can see the current board state.
112 |     - **Impact**:
113 |         - `True`: Both players receive the full board state after each move.
114 |         - `False`: Players receive minimal information, enhancing the challenge of deducing the opponent's strategy.
115 | 
116 | - `max_turns` (`int`):
117 |     - **Description**: Specifies the maximum number of turns allowed before the game ends automatically.
118 |     - **Impact**: Limits the duration of the game, encouraging strategic and efficient play to achieve checkmate within the turn limit.
119 | 
120 | - `show_valid` (`int`):
121 |     - **Description**: Determines whether players can see a list of valid moves.
122 |     - **Impact**:
123 |         - `True`: Players are provided with a list of all legal moves available to them on their turn.
124 |         - `False`: Players must deduce valid moves based on the board state and previous actions.
125 | 
126 | 
127 | 
128 | ## Variants
129 | 
130 | | Env-id                   | is_open  | max_turns | show_valid |
131 | |--------------------------|:--------:|:---------:|:-----------:
132 | | `Chess-v0`               | `False`  |    `30`   |   `True`   |
133 | | `Chess-v0-open`          | `True`   |    `30`   |   `False`  |
134 | | `Chess-v0-long`          | `False`  |    `50`   |   `True`   |
135 | | `Chess-v0-blind`         | `False`  |    `50`   |   `False`  |
136 | 
137 | ## Example Usage
138 | 
139 | ```python
140 | import textarena as ta
141 | 
142 | # Initialize the environment
143 | env = ta.make(env_id="Chess-v0")
144 | 
145 | # Wrap the environment for easier observation handling
146 | env = ta.wrappers.LLMObservationWrapper(env=env)
147 | 
148 | # initalize agents
149 | agents = {
150 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
151 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
152 |     }
153 | 
154 | # reset the environment to start a new game
155 | observations = env.reset(seed=490)
156 | 
157 | # Game loop
158 | done = False
159 | while not done:
160 | 
161 |     # Get the current player
162 |     current_player_id = env.state.get("current_player")
163 | 
164 |     # Get the current observation for the player
165 |     obs = observations[current_player_id]
166 | 
167 |     # Agent decides on an action based on the observation
168 |     action = agents[current_player_id](obs)
169 | 
170 |     # Execute the action in the environment
171 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
172 | 
173 |     # Check if the game has ended
174 |     done = terminated or truncated
175 | 
176 |     # Optionally render the environment to see the current state
177 |     env.render()
178 | 
179 |     if done:
180 |         break
181 | 
182 | # Finally, print the game results
183 | for player_id, agent in agents.items():
184 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
185 | print(f"Reason: {info['reason']}")
186 | ```
187 | 
188 | ## Troubleshooting
189 | 
190 | - **Invalid Move Format:**
191 |     - **Issue:** Player provides a move that doesn't follow the `[<uci_move>]` format.
192 |     - **Solution:** Ensure that all moves are in UCI notation and enclosed within square brackets. Avoid additional characters or incorrect formatting.
193 | 
194 | - **Illegal Moves:**
195 |     - **Issue:** Player attempts to make a move that is not legal based on the current board state.
196 |     - **Solution:** Verify the legality of the move within the context of the current board state. If `show_valid` is enabled, refer to the list of valid moves provided.
197 | 
198 | ## Version History
199 | - **v0**
200 |   - Initial release 
201 | 
202 | 
203 | 
204 | ### Contact
205 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/Chess/__init__.py

- Extension: .py
- Language: python
- Size: 130 bytes
- Created: 2024-12-12 16:27:42
- Modified: 2024-12-12 16:27:42

### Code

```python
1 | from textarena.envs.two_player.Chess.env import ChessEnv
```

## File: textarena/envs/two_player/TruthAndDeception/test.py

- Extension: .py
- Language: python
- Size: 6102 bytes
- Created: 2024-11-14 13:34:58
- Modified: 2024-11-14 13:34:58

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | import warnings
  4 | from typing import Dict, List, Optional
  5 | 
  6 | from textarena.envs.two_player.TruthAndDeception.env import TruthAndDeceptionEnv
  7 | 
  8 | 
  9 | warnings.filterwarnings('ignore', category=UserWarning)
 10 | warnings.filterwarnings('ignore', category=FutureWarning)
 11 | 
 12 | 
 13 | 
 14 | def action_list_correct_guess(correct_fact):
 15 |     return [
 16 |         "Convincing Argument", "Nice Reply",
 17 |         "Convincing Argument", "Nice Reply",
 18 |         "Convincing Argument", 
 19 |         correct_fact
 20 |     ]
 21 | 
 22 | def action_list_wrong_guess(correct_fact):
 23 |     guess_fact = "[Fact 1]" if correct_fact == "[Fact 2]" else "[Fact 2]"
 24 |     return [
 25 |         "Convincing Argument", "Nice Reply",
 26 |         "Convincing Argument", "Nice Reply",
 27 |         "Convincing Argument", 
 28 |         guess_fact
 29 |     ]
 30 | 
 31 | def wrong_format_guess(correct_fact):
 32 |     return [
 33 |         "Convincing Argument", "Nice Reply",
 34 |         "Convincing Argument", "Nice Reply",
 35 |         "Convincing Argument", 
 36 |         "I invoke the 5th"
 37 |     ]
 38 | 
 39 | 
 40 | class TestTruthAndDeceptionEnv(unittest.TestCase):
 41 |     
 42 |     
 43 |     
 44 |     test_cases = {
 45 |         "Correct Guess After Full Conversation": {
 46 |             "env_id": "TruthAndDeception-v0",
 47 |             "actions": action_list_correct_guess,
 48 |             "expected_rewards": {0: -1, 1: 1},  
 49 |             "expected_truncated": False,
 50 |             "expected_terminated": True,
 51 |         },
 52 |         "Incorrect Guess After Full Conversation": {
 53 |             "env_id": "TruthAndDeception-v0",
 54 |             "actions": action_list_wrong_guess,
 55 |             "expected_rewards": {0: 1, 1: -1},  
 56 |             "expected_truncated": False,
 57 |             "expected_terminated": True,
 58 |         },
 59 |         "Invalid Guess Format": {
 60 |             "env_id": "TruthAndDeception-v0",
 61 |             "actions": wrong_format_guess,
 62 |             "expected_rewards": {0: 0, 1: -1},  
 63 |             "expected_truncated": False,
 64 |             "expected_terminated": True,
 65 |         },
 66 |         
 67 |         
 68 |         
 69 |         
 70 |         
 71 |         
 72 |         
 73 |     }
 74 | 
 75 |     @parameterized.expand([
 76 |         (
 77 |             name,
 78 |             details["env_id"],
 79 |             details["actions"],
 80 |             details["expected_rewards"],
 81 |             details["expected_truncated"],
 82 |             details["expected_terminated"]
 83 |         )
 84 |         for name, details in test_cases.items()
 85 |     ])
 86 |     def test_truth_and_deception_env_outcomes(
 87 |         self,
 88 |         name: str,
 89 |         env_id: str,
 90 |         actions: List[str],
 91 |         expected_rewards: Optional[Dict[int, int]],
 92 |         expected_truncated: bool,
 93 |         expected_terminated: bool
 94 |     ):
 95 |         
 96 |         with self.subTest(test_case=name):
 97 |             try:
 98 |                 
 99 |                 env = TruthAndDeceptionEnv(
100 |                     max_turns=6
101 |                 )
102 |             except Exception as e:
103 |                 self.fail(f"Failed to initialize environment '{env_id}': {e}")
104 | 
105 |             try:
106 |                 
107 |                 observations = env.reset(seed=42)
108 |             except Exception as e:
109 |                 self.fail(f"Failed to reset the environment '{env_id}': {e}")
110 | 
111 |             
112 |             terminated = False
113 |             truncated = False
114 | 
115 |             actions = actions("[Fact 1]" if env.state.game_state["fact1"]["is_correct"] else "[Fact 2]")
116 | 
117 |             for i, action in enumerate(actions):
118 |                 player_id = i % 2
119 | 
120 |                 try:
121 |                     
122 |                     step_result = env.step(player_id, action)
123 |                     if len(step_result) != 5:
124 |                         self.fail(f"env.step() returned {len(step_result)} elements, expected 5.")
125 |                     observations, rewards, truncated, terminated, info = step_result
126 |                 except Exception as e:
127 |                     self.fail(f"env.step() raised an unexpected exception for player {player_id}: {e}")
128 | 
129 |                 if terminated or truncated:
130 |                     break
131 | 
132 |             
133 |             self.assertEqual(
134 |                 rewards,
135 |                 expected_rewards,
136 |                 f"The rewards did not match. Expected {expected_rewards}; received {rewards}"
137 |             )
138 | 
139 | 
140 |             self.assertEqual(
141 |                 terminated,
142 |                 expected_terminated,
143 |                 f"Terminated flag mismatch. Expected {expected_terminated}; received {terminated}"
144 |             )
145 | 
146 |             self.assertEqual(
147 |                 truncated,
148 |                 expected_truncated,
149 |                 f"Truncated flag mismatch. Expected {expected_truncated}; received {truncated}"
150 |             )
151 | 
152 | 
153 | 
154 | if __name__ == '__main__':
155 |     unittest.main()
```

## File: textarena/envs/two_player/TruthAndDeception/env.py

- Extension: .py
- Language: python
- Size: 8464 bytes
- Created: 2024-11-18 18:11:04
- Modified: 2024-11-18 18:11:04

### Code

```python
  1 | 
  2 | 
  3 | import os
  4 | import re
  5 | import json 
  6 | import random  
  7 | from typing import Optional, Tuple, Dict, Any
  8 | 
  9 | import textarena as ta 
 10 | 
 11 | class TruthAndDeceptionEnv(ta.Env):
 12 |     
 13 |     def __init__(self, max_turns: Optional[int]=5, data_path: Optional[str]=None):
 14 |         
 15 |         
 16 |         assert max_turns%2==0, \
 17 |             f"Please use an even number of max turns. Current max_turns: {max_turns}"
 18 | 
 19 | 
 20 |         
 21 |         self._load_facts(data_path=data_path)
 22 | 
 23 | 
 24 |         
 25 |         self.state = ta.State(
 26 |             num_players=2, 
 27 |             max_turns=max_turns,
 28 |             check_truncated=False,
 29 |             role_mapping={0: "Deceiver", 1: "Guesser"}
 30 |         )
 31 | 
 32 | 
 33 |         
 34 |         self.guess_fact1_pattern = re.compile(r"\[Fact 1\]", re.IGNORECASE)
 35 |         self.guess_fact2_pattern = re.compile(r"\[Fact 2\]", re.IGNORECASE)
 36 | 
 37 |         self.board_state_render = ta.envs.two_player.TruthAndDeception.render.GameStateRender
 38 | 
 39 | 
 40 |     def _load_facts(self, data_path: Optional[str]) -> None:
 41 |         
 42 |         if data_path is None:
 43 |             data_path = os.path.join(
 44 |                 "textarena", "envs", "two_player", "TruthAndDeception", "facts.json"
 45 |             )
 46 | 
 47 |         if not os.path.exists(data_path):
 48 |             raise FileNotFoundError(f"Facts data file not found at: {data_path}")
 49 | 
 50 |         with open(data_path, "r", encoding="utf-8") as file:
 51 |             self.facts_data = json.load(file)
 52 | 
 53 | 
 54 | 
 55 |     def reset(self, seed: Optional[int]=None) -> Optional[ta.Observations]:
 56 |         
 57 |         if seed is not None:
 58 |             random.seed(seed)
 59 |         else:
 60 |             random.seed()
 61 | 
 62 |         
 63 |         selected_facts = random.choice(self.facts_data)
 64 | 
 65 |         
 66 |         facts = [
 67 |             (selected_facts["facts"]["fact1"], selected_facts["correct_fact"]=="fact1"),
 68 |             (selected_facts["facts"]["fact2"], selected_facts["correct_fact"]=="fact2"),
 69 |         ]
 70 |         random.shuffle(facts)
 71 | 
 72 |         return self.state.reset(
 73 |             game_state={
 74 |                 "fact1": {"fact": facts[0][0], "is_correct": facts[0][1]},
 75 |                 "fact2": {"fact": facts[1][0], "is_correct": facts[1][1]},
 76 |                 
 77 |                 "correct_fact": facts[0][0] if facts[0][1] else facts[1][0],
 78 |                 "wrong_fact": facts[0][0] if facts[1][1] else facts[1][0]
 79 |             },
 80 |             player_prompt_function=self._generate_player_prompt
 81 |         )
 82 | 
 83 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[int, Any]) -> str:
 84 |         
 85 |         prompt = f"You are Player {player_id}, and you are the {self.state.role_mapping[player_id]} in the 'Truth and Deception' game.\n"
 86 | 
 87 |         if self.state.role_mapping[player_id] == "Deceiver":
 88 |             prompt += (
 89 |                 f"You know which of the following two facts is correct:\n"
 90 |                 f"Fact 1: {game_state['fact1']['fact']} ({'correct' if game_state['fact1']['is_correct'] else 'wrong'})\n"
 91 |                 f"Fact 2: {game_state['fact2']['fact']} ({'correct' if game_state['fact2']['is_correct'] else 'wrong'})\n"
 92 |                 "Your goal is to convince the other player to choose the incorrect fact.\n"
 93 |                 f"You will have a conversation for {self.state.max_turns} turns.\n"
 94 |                 "After that, the other player will make their guess.\n"
 95 |                 "On your turn, simply type your message."
 96 |             )
 97 | 
 98 |         elif self.state.role_mapping[player_id] == "Guesser":
 99 |             prompt += (
100 |                 f"You need to determine which of the following two facts is correct:\n"
101 |                 f"Fact 1: {game_state['fact1']['fact']}\n"
102 |                 f"Fact 2: {game_state['fact2']['fact']}\n"
103 |                 f"You will have a conversation with the other player for {self.state.max_turns} turns.\n"
104 |                 "After that, you will make your guess.\n"
105 |                 "On your turn, simply type your message."
106 |             )
107 | 
108 |         else:
109 |             
110 |             raise ValueError(f"Unexpected role mapping: {self.state.role_mapping[player_id]}. Expected 'Deceiver' or 'Guesser'.")
111 | 
112 |         return prompt 
113 | 
114 |     def get_current_player_id(self):
115 |         return self.state.current_player
116 | 
117 |     def step(
118 |         self,
119 |         player_id: int,
120 |         action: str,
121 |     ) -> Tuple[
122 |         Optional[ta.Observations], 
123 |         Optional[ta.Rewards], 
124 |         bool, 
125 |         bool, 
126 |         ta.Info, 
127 |     ]:
128 |         
129 |         
130 |         self.state.check_action_format(
131 |             action=action,
132 |             player_id=player_id
133 |         )
134 | 
135 |         
136 |         self.state.add_observation(
137 |             from_id=player_id,
138 |             to_id=-1, 
139 |             message=action,
140 |             for_logging=True
141 |         )
142 | 
143 |         
144 |         if self.state.turn == self.state.max_turns-2:
145 |             self.state.add_observation(
146 |                 from_id=ta.GAME_ID,
147 |                 to_id=-1, 
148 |                 message="Now guess which of the two facts are correct by returning [Fact 1] or [Fact 2].",
149 |                 for_logging=True,
150 |             )
151 | 
152 |         elif self.state.turn == self.state.max_turns-1:
153 |             if self.guess_fact1_pattern.search(action) or self.guess_fact2_pattern.search(action):
154 |                 
155 |                 if (
156 |                     self.guess_fact1_pattern.search(action)
157 |                     and self.state.game_state["fact1"]["is_correct"]
158 |                 ) or (
159 |                     self.guess_fact2_pattern.search(action)
160 |                     and self.state.game_state["fact2"]["is_correct"]
161 |                 ):
162 |                     
163 |                     self.state.set_winners(
164 |                         player_ids=[player_id],
165 |                         reason=f"Player {player_id} guessed correct fact."
166 |                     )
167 |                 else:
168 |                     
169 |                     self.state.set_winners(
170 |                         player_ids=[1-player_id],
171 |                         reason=f"Player {player_id} guessed the wrong fact."
172 |                     )
173 |             else:
174 |                 self.state.set_invalid_move(
175 |                     player_ids=[player_id],
176 |                     reasons=[f"Player {player_id} did not make their guess in the correct format."]
177 |                 )
178 | 
179 |         return self.state.step()
180 | 
181 |     def render(self):
182 |         
183 |         print(f"Turn: {self.state.turn}/{self.state.max_turns}")
184 |         print("Game Logs:")
185 |         for sender_id, message in self.state.logs:
186 |             if sender_id == -1:
187 |                 print(f"[GAME]: {message}")
188 |             else:
189 |                 print(f"Player {sender_id}: {message}")
190 |         print("\n")
191 | 
192 | 
193 |             
```

## File: textarena/envs/two_player/TruthAndDeception/render.py

- Extension: .py
- Language: python
- Size: 8873 bytes
- Created: 2024-11-18 18:17:09
- Modified: 2024-11-18 18:17:09

### Code

```python
  1 | import tkinter as tk
  2 | from tkinter import ttk
  3 | from typing import Dict, Optional
  4 | 
  5 | class GameStateRender(ttk.Frame):
  6 |     
  7 |     
  8 |     WINDOW_WIDTH = 800
  9 |     WINDOW_HEIGHT = 600
 10 |     PADDING = 20
 11 |     
 12 |     def __init__(self, master, env, player_names: Optional[Dict[int, str]] = None):
 13 |         super().__init__(master)
 14 |         self.master = master
 15 |         self.env = env
 16 |         self.player_names = player_names or {0: "Player 0", 1: "Player 1"}
 17 |         self.player_colors = {
 18 |             0: '#4A90E2',  
 19 |             1: '#E24A4A'   
 20 |         }
 21 |         
 22 |         
 23 |         self.bg_color = '#2B2B2B'
 24 |         self.text_color = '#FFFFFF'
 25 |         self.deceiver_color = '#E24A4A'  
 26 |         self.guesser_color = '#4A90E2'   
 27 |         self.fact_bg_color = '#1E1E1E'
 28 |         self.correct_fact_color = '#2E7D32'  
 29 |         self.wrong_fact_color = '#424242'  
 30 |         
 31 |         
 32 |         self.master.title("Truth and Deception Game")
 33 |         self.master.geometry(f"{self.WINDOW_WIDTH}x{self.WINDOW_HEIGHT}")
 34 |         self.master.configure(bg=self.bg_color)
 35 |         
 36 |         self.create_widgets()
 37 |         
 38 |     def create_widgets(self):
 39 |         
 40 |         
 41 |         self.container = ttk.Frame(self.master)
 42 |         self.container.pack(expand=True, fill='both', padx=self.PADDING, pady=self.PADDING)
 43 |         
 44 |         
 45 |         self.info_frame = tk.Frame(self.container, bg=self.bg_color)
 46 |         self.info_frame.pack(fill='x', pady=(0, self.PADDING))
 47 |         
 48 |         
 49 |         self.turn_label = tk.Label(
 50 |             self.info_frame,
 51 |             text="Turn: 0/0",
 52 |             font=('Arial', 14, 'bold'),
 53 |             bg=self.bg_color,
 54 |             fg=self.text_color
 55 |         )
 56 |         self.turn_label.pack(side='left')
 57 |         
 58 |         
 59 |         tk.Label(
 60 |             self.info_frame,
 61 |             text="  |  ",
 62 |             font=('Arial', 14, 'bold'),
 63 |             bg=self.bg_color,
 64 |             fg='#404040'  
 65 |         ).pack(side='left')
 66 |         
 67 |         
 68 |         
 69 |         tk.Label(
 70 |             self.info_frame,
 71 |             text=f"{self.player_names[0]} (Deceiver)",
 72 |             font=('Arial', 14, 'bold'),
 73 |             bg=self.bg_color,
 74 |             fg=self.deceiver_color
 75 |         ).pack(side='left')
 76 |         
 77 |         
 78 |         tk.Label(
 79 |             self.info_frame,
 80 |             text="  •  ",
 81 |             font=('Arial', 14),
 82 |             bg=self.bg_color,
 83 |             fg='#404040'  
 84 |         ).pack(side='left')
 85 |         
 86 |         
 87 |         tk.Label(
 88 |             self.info_frame,
 89 |             text=f"{self.player_names[1]} (Guesser)",
 90 |             font=('Arial', 14, 'bold'),
 91 |             bg=self.bg_color,
 92 |             fg=self.guesser_color
 93 |         ).pack(side='left')
 94 |         
 95 |         
 96 |         self.facts_frame = ttk.Frame(self.container)
 97 |         self.facts_frame.pack(fill='x', pady=(0, self.PADDING))
 98 |         
 99 |         
100 |         facts_header = tk.Label(
101 |             self.facts_frame,
102 |             text="Facts in Discussion:",
103 |             font=('Arial', 12, 'bold'),
104 |             bg=self.bg_color,
105 |             fg=self.text_color
106 |         )
107 |         facts_header.pack(fill='x', pady=(0, 10))
108 |         
109 |         
110 |         self.create_fact_display("Fact 1:", 0)
111 |         self.create_fact_display("Fact 2:", 1)
112 |         
113 |         
114 |         self.create_conversation_view()
115 |         
116 |     def create_fact_display(self, label: str, index: int):
117 |         
118 |         frame = tk.Frame(self.facts_frame, bg=self.bg_color)
119 |         frame.pack(fill='x', pady=(0, 10))
120 |         
121 |         
122 |         label_widget = tk.Label(
123 |             frame,
124 |             text=label,
125 |             font=('Arial', 11, 'bold'),
126 |             bg=self.bg_color,
127 |             fg=self.text_color,
128 |             anchor='w'
129 |         )
130 |         label_widget.pack(side='left', padx=(0, 10))
131 |         
132 |         
133 |         fact_label = tk.Label(
134 |             frame,
135 |             text="",
136 |             font=('Arial', 11),
137 |             bg=self.bg_color,
138 |             fg=self.text_color,
139 |             justify='left',
140 |             anchor='w',
141 |             wraplength=600  
142 |         )
143 |         fact_label.pack(side='left', fill='x', expand=True)
144 |         
145 |         
146 |         setattr(self, f'fact_{index}_label', label_widget)
147 |         setattr(self, f'fact_{index}_text', fact_label)
148 |         
149 |     def create_conversation_view(self):
150 |         
151 |         frame = ttk.Frame(self.container)
152 |         frame.pack(fill='both', expand=True)
153 |         
154 |         
155 |         header = tk.Label(
156 |             frame,
157 |             text="Conversation History",
158 |             font=('Arial', 12, 'bold'),
159 |             bg=self.bg_color,
160 |             fg=self.text_color
161 |         )
162 |         header.pack(fill='x', pady=(0, 5))
163 |         
164 |         
165 |         self.conversation_text = tk.Text(
166 |             frame,
167 |             font=('Arial', 11),
168 |             wrap='word',
169 |             bg=self.fact_bg_color,
170 |             fg=self.text_color,
171 |             relief='flat',
172 |             state='disabled'
173 |         )
174 |         self.conversation_text.pack(fill='both', expand=True)
175 |         
176 |         
177 |         self.conversation_text.tag_configure(
178 |             'deceiver',
179 |             foreground=self.deceiver_color,
180 |             font=('Arial', 11, 'bold')
181 |         )
182 |         self.conversation_text.tag_configure(
183 |             'guesser',
184 |             foreground=self.guesser_color,
185 |             font=('Arial', 11, 'bold')
186 |         )
187 |         self.conversation_text.tag_configure(
188 |             'game',
189 |             foreground='#A0A0A0',
190 |             font=('Arial', 11, 'italic')
191 |         )
192 |         
193 |     def update_fact_display(self, index: int, text: str, is_correct: bool):
194 |         
195 |         text_widget = getattr(self, f'fact_{index}_text')
196 |         label_widget = getattr(self, f'fact_{index}_label')
197 |         
198 |         
199 |         text_widget.configure(text=text)
200 |         
201 |         
202 |         if is_correct:
203 |             text_widget.configure(fg=self.correct_fact_color)
204 |             label_widget.configure(fg=self.correct_fact_color)
205 |         else:
206 |             text_widget.configure(fg=self.text_color)
207 |             label_widget.configure(fg=self.text_color)
208 |         
209 |     def add_conversation_message(self, sender_id: int, message: str):
210 |         
211 |         self.conversation_text.configure(state='normal')
212 |         
213 |         
214 |         if self.conversation_text.get('1.0', 'end').strip():
215 |             self.conversation_text.insert('end', '\n')
216 |         
217 |         
218 |         if sender_id == -1:  
219 |             self.conversation_text.insert('end', '[GAME] ', 'game')
220 |             self.conversation_text.insert('end', f"{message}")
221 |         else:  
222 |             role = 'deceiver' if sender_id == 0 else 'guesser'
223 |             self.conversation_text.insert('end', f"[{self.player_names[sender_id]}] ", role)
224 |             self.conversation_text.insert('end', f"{message}")
225 |         
226 |         
227 |         self.conversation_text.see('end')
228 |         self.conversation_text.configure(state='disabled')
229 |         
230 |     def draw_board(self):
231 |         
232 |         if not hasattr(self.env.state, "game_state"):
233 |             return
234 |             
235 |         game_state = self.env.state.game_state
236 |         
237 |         
238 |         self.turn_label.configure(
239 |             text=f"Turn: {self.env.state.turn}/{self.env.state.max_turns}"
240 |         )
241 |         
242 |         
243 |         self.update_fact_display(
244 |             0, 
245 |             game_state['fact1']['fact'],
246 |             game_state['fact1']['is_correct']
247 |         )
248 |         self.update_fact_display(
249 |             1, 
250 |             game_state['fact2']['fact'],
251 |             game_state['fact2']['is_correct']
252 |         )
253 |         
254 |         
255 |         self.conversation_text.configure(state='normal')
256 |         self.conversation_text.delete('1.0', 'end')
257 |         
258 |         
259 |         for sender_id, message in self.env.state.logs:
260 |             self.add_conversation_message(sender_id, message)
261 |             
262 |         self.conversation_text.configure(state='disabled')
```

## File: textarena/envs/two_player/TruthAndDeception/facts.json

- Extension: .json
- Language: json
- Size: 12811 bytes
- Created: 2024-10-29 13:39:03
- Modified: 2024-10-06 12:59:51

### Code

```json
  1 | [
  2 |     {
  3 |         "facts": {
  4 |             "fact1": "Honey never spoils and can remain edible indefinitely.",
  5 |             "fact2": "Honey spoils within two years if not stored properly."
  6 |         },
  7 |         "correct_fact": "fact1"
  8 |     },
  9 |     {
 10 |         "facts": {
 11 |             "fact1": "Bananas are berries, while strawberries are not.",
 12 |             "fact2": "Strawberries are classified as berries, while bananas are not."
 13 |         },
 14 |         "correct_fact": "fact1"
 15 |     },
 16 |     {
 17 |         "facts": {
 18 |             "fact1": "Lightning never strikes the same place twice.",
 19 |             "fact2": "Lightning can strike the same place multiple times."
 20 |         },
 21 |         "correct_fact": "fact2"
 22 |     },
 23 |     {
 24 |         "facts": {
 25 |             "fact1": "Venus is the hottest planet in our solar system.",
 26 |             "fact2": "Mercury is the hottest planet in our solar system."
 27 |         },
 28 |         "correct_fact": "fact1"
 29 |     },
 30 |     {
 31 |         "facts": {
 32 |             "fact1": "Humans share approximately 50% of their DNA with bananas.",
 33 |             "fact2": "Humans share approximately 98% of their DNA with chimpanzees."
 34 |         },
 35 |         "correct_fact": "fact2"
 36 |     },
 37 |     {
 38 |         "facts": {
 39 |             "fact1": "Goldfish have a memory span of only three seconds.",
 40 |             "fact2": "Goldfish can remember things for months."
 41 |         },
 42 |         "correct_fact": "fact2"
 43 |     },
 44 |     {
 45 |         "facts": {
 46 |             "fact1": "The Great Wall of China is visible from the Moon.",
 47 |             "fact2": "The Great Wall of China is not visible from the Moon."
 48 |         },
 49 |         "correct_fact": "fact2"
 50 |     },
 51 |     {
 52 |         "facts": {
 53 |             "fact1": "Sharks are mammals.",
 54 |             "fact2": "Sharks are fish."
 55 |         },
 56 |         "correct_fact": "fact2"
 57 |     },
 58 |     {
 59 |         "facts": {
 60 |             "fact1": "Humans can distinguish more than a million different colors.",
 61 |             "fact2": "Humans can only distinguish about a million different colors."
 62 |         },
 63 |         "correct_fact": "fact2"
 64 |     },
 65 |     {
 66 |         "facts": {
 67 |             "fact1": "Bulls are enraged by the color red.",
 68 |             "fact2": "Bulls are colorblind to red."
 69 |         },
 70 |         "correct_fact": "fact2"
 71 |     },
 72 |     {
 73 |         "facts": {
 74 |             "fact1": "An octopus has three hearts.",
 75 |             "fact2": "An octopus has one heart."
 76 |         },
 77 |         "correct_fact": "fact1"
 78 |     },
 79 |     {
 80 |         "facts": {
 81 |             "fact1": "The Eiffel Tower can be 15 cm taller during the summer.",
 82 |             "fact2": "The Eiffel Tower maintains the same height year-round."
 83 |         },
 84 |         "correct_fact": "fact1"
 85 |     },
 86 |     {
 87 |         "facts": {
 88 |             "fact1": "Lightning can travel upwards from the ground.",
 89 |             "fact2": "Lightning can only travel downwards from the clouds."
 90 |         },
 91 |         "correct_fact": "fact1"
 92 |     },
 93 |     {
 94 |         "facts": {
 95 |             "fact1": "Humans have more bones in their bodies as adults than as infants.",
 96 |             "fact2": "Humans have fewer bones in their bodies as adults than as infants."
 97 |         },
 98 |         "correct_fact": "fact2"
 99 |     },
100 |     {
101 |         "facts": {
102 |             "fact1": "A day on Venus is longer than a year on Venus.",
103 |             "fact2": "A year on Venus is longer than a day on Venus."
104 |         },
105 |         "correct_fact": "fact1"
106 |     },
107 |     {
108 |         "facts": {
109 |             "fact1": "The heart is located on the left side of the human body.",
110 |             "fact2": "The heart is located centrally in the human body."
111 |         },
112 |         "correct_fact": "fact2"
113 |     },
114 |     {
115 |         "facts": {
116 |             "fact1": "Dogs can see in complete darkness.",
117 |             "fact2": "Dogs have better night vision than humans but cannot see in complete darkness."
118 |         },
119 |         "correct_fact": "fact2"
120 |     },
121 |     {
122 |         "facts": {
123 |             "fact1": "Mount Everest is the tallest mountain in the world by elevation above sea level.",
124 |             "fact2": "Mauna Kea is taller than Mount Everest when measured from its base on the ocean floor."
125 |         },
126 |         "correct_fact": "fact2"
127 |     },
128 |     {
129 |         "facts": {
130 |             "fact1": "The human body contains more bacterial cells than human cells.",
131 |             "fact2": "The human body contains fewer bacterial cells than human cells."
132 |         },
133 |         "correct_fact": "fact1"
134 |     },
135 |     {
136 |         "facts": {
137 |             "fact1": "Sound travels faster in water than in air.",
138 |             "fact2": "Sound travels faster in air than in water."
139 |         },
140 |         "correct_fact": "fact1"
141 |     },
142 |     {
143 |         "facts": {
144 |             "fact1": "Honeybees can recognize human faces.",
145 |             "fact2": "Honeybees cannot recognize human faces."
146 |         },
147 |         "correct_fact": "fact1"
148 |     },
149 |     {
150 |         "facts": {
151 |             "fact1": "The Earth's core is as hot as the surface of the sun.",
152 |             "fact2": "The Earth's core is cooler than the surface of the sun."
153 |         },
154 |         "correct_fact": "fact1"
155 |     },
156 |     {
157 |         "facts": {
158 |             "fact1": "A blue whale's heart is the size of a small car.",
159 |             "fact2": "A blue whale's heart is the size of a basketball."
160 |         },
161 |         "correct_fact": "fact1"
162 |     },
163 |     {
164 |         "facts": {
165 |             "fact1": "The Amazon Rainforest produces 20% of the world's oxygen.",
166 |             "fact2": "The Amazon Rainforest produces 6% of the world's oxygen."
167 |         },
168 |         "correct_fact": "fact2"
169 |     },
170 |     {
171 |         "facts": {
172 |             "fact1": "Sloths can hold their breath longer than dolphins.",
173 |             "fact2": "Dolphins can hold their breath longer than sloths."
174 |         },
175 |         "correct_fact": "fact1"
176 |     },
177 |     {
178 |         "facts": {
179 |             "fact1": "Water boils at a lower temperature on Mount Everest.",
180 |             "fact2": "Water boils at a higher temperature on Mount Everest."
181 |         },
182 |         "correct_fact": "fact1"
183 |     },
184 |     {
185 |         "facts": {
186 |             "fact1": "Elephants are the only mammals that can't jump.",
187 |             "fact2": "Hippopotamuses are the only mammals that can't jump."
188 |         },
189 |         "correct_fact": "fact1"
190 |     },
191 |     {
192 |         "facts": {
193 |             "fact1": "Penguins can fly under water.",
194 |             "fact2": "Penguins cannot fly under water."
195 |         },
196 |         "correct_fact": "fact1"
197 |     },
198 |     {
199 |         "facts": {
200 |             "fact1": "A group of crows is called a murder.",
201 |             "fact2": "A group of crows is called a flock."
202 |         },
203 |         "correct_fact": "fact1"
204 |     },
205 |     {
206 |         "facts": {
207 |             "fact1": "The moon has no wind.",
208 |             "fact2": "The moon has wind."
209 |         },
210 |         "correct_fact": "fact1"
211 |     },
212 |     {
213 |         "facts": {
214 |             "fact1": "Sharks do not get cancer.",
215 |             "fact2": "Sharks can get cancer."
216 |         },
217 |         "correct_fact": "fact2"
218 |     },
219 |     {
220 |         "facts": {
221 |             "fact1": "Koalas sleep for up to 22 hours a day.",
222 |             "fact2": "Koalas sleep for up to 10 hours a day."
223 |         },
224 |         "correct_fact": "fact1"
225 |     },
226 |     {
227 |         "facts": {
228 |             "fact1": "Spiders are insects.",
229 |             "fact2": "Spiders are arachnids."
230 |         },
231 |         "correct_fact": "fact2"
232 |     },
233 |     {
234 |         "facts": {
235 |             "fact1": "An ostrich's eye is bigger than its brain.",
236 |             "fact2": "An ostrich's brain is bigger than its eye."
237 |         },
238 |         "correct_fact": "fact1"
239 |     },
240 |     {
241 |         "facts": {
242 |             "fact1": "It takes light from the Sun about 8 minutes to reach Earth.",
243 |             "fact2": "It takes light from the Sun about 2 minutes to reach Earth."
244 |         },
245 |         "correct_fact": "fact1"
246 |     },
247 |     {
248 |         "facts": {
249 |             "fact1": "Polar bear fur is transparent.",
250 |             "fact2": "Polar bear fur is white."
251 |         },
252 |         "correct_fact": "fact1"
253 |     },
254 |     {
255 |         "facts": {
256 |             "fact1": "A bolt of lightning is hotter than the surface of the Sun.",
257 |             "fact2": "The surface of the Sun is hotter than a bolt of lightning."
258 |         },
259 |         "correct_fact": "fact1"
260 |     },
261 |     {
262 |         "facts": {
263 |             "fact1": "Humans can hear sounds in space.",
264 |             "fact2": "There is no sound in space."
265 |         },
266 |         "correct_fact": "fact2"
267 |     },
268 |     {
269 |         "facts": {
270 |             "fact1": "The cheetah is the fastest land animal.",
271 |             "fact2": "The pronghorn is the fastest land animal."
272 |         },
273 |         "correct_fact": "fact1"
274 |     },
275 |     {
276 |         "facts": {
277 |             "fact1": "A day on Jupiter is shorter than a day on Earth.",
278 |             "fact2": "A day on Jupiter is longer than a day on Earth."
279 |         },
280 |         "correct_fact": "fact1"
281 |     },
282 |     {
283 |         "facts": {
284 |             "fact1": "Birds are descended from dinosaurs.",
285 |             "fact2": "Birds are not descended from dinosaurs."
286 |         },
287 |         "correct_fact": "fact1"
288 |     },
289 |     {
290 |         "facts": {
291 |             "fact1": "Camels store water in their humps.",
292 |             "fact2": "Camels store fat in their humps."
293 |         },
294 |         "correct_fact": "fact2"
295 |     },
296 |     {
297 |         "facts": {
298 |             "fact1": "Venus rotates in the opposite direction of most planets.",
299 |             "fact2": "Venus rotates in the same direction as most planets."
300 |         },
301 |         "correct_fact": "fact1"
302 |     },
303 |     {
304 |         "facts": {
305 |             "fact1": "Humans have 206 bones in their body.",
306 |             "fact2": "Humans have 304 bones in their body."
307 |         },
308 |         "correct_fact": "fact1"
309 |     },
310 |     {
311 |         "facts": {
312 |             "fact1": "Octopuses have blue blood.",
313 |             "fact2": "Octopuses have red blood."
314 |         },
315 |         "correct_fact": "fact1"
316 |     },
317 |     {
318 |         "facts": {
319 |             "fact1": "Most of Earth's oxygen comes from the ocean.",
320 |             "fact2": "Most of Earth's oxygen comes from forests."
321 |         },
322 |         "correct_fact": "fact1"
323 |     },
324 |     {
325 |         "facts": {
326 |             "fact1": "The longest a human has gone without sleep is about 11 days.",
327 |             "fact2": "The longest a human has gone without sleep is about 5 days."
328 |         },
329 |         "correct_fact": "fact1"
330 |     },
331 |     {
332 |         "facts": {
333 |             "fact1": "There are more trees on Earth than stars in the Milky Way.",
334 |             "fact2": "There are more stars in the Milky Way than trees on Earth."
335 |         },
336 |         "correct_fact": "fact1"
337 |     },
338 |     {
339 |         "facts": {
340 |             "fact1": "Water makes up around 60% of the human body.",
341 |             "fact2": "Water makes up around 90% of the human body."
342 |         },
343 |         "correct_fact": "fact1"
344 |     },
345 |     {
346 |         "facts": {
347 |             "fact1": "The Pacific Ocean is wider than the Moon.",
348 |             "fact2": "The Moon is wider than the Pacific Ocean."
349 |         },
350 |         "correct_fact": "fact1"
351 |     },
352 |     {
353 |         "facts": {
354 |             "fact1": "The human nose can distinguish at least 1 trillion smells.",
355 |             "fact2": "The human nose can distinguish about 10,000 smells."
356 |         },
357 |         "correct_fact": "fact1"
358 |     },
359 |     {
360 |         "facts": {
361 |             "fact1": "Snakes can't blink.",
362 |             "fact2": "Snakes blink when threatened."
363 |         },
364 |         "correct_fact": "fact1"
365 |     },
366 |     {
367 |         "facts": {
368 |             "fact1": "Most of the Earth's fresh water is in glaciers and ice caps.",
369 |             "fact2": "Most of the Earth's fresh water is in rivers and lakes."
370 |         },
371 |         "correct_fact": "fact1"
372 |     },
373 |     {
374 |         "facts": {
375 |             "fact1": "The shortest war in history lasted 38 minutes.",
376 |             "fact2": "The shortest war in history lasted 3 hours."
377 |         },
378 |         "correct_fact": "fact1"
379 |     },
380 |     {
381 |         "facts": {
382 |             "fact1": "Kangaroos can't walk backwards.",
383 |             "fact2": "Kangaroos can walk backwards."
384 |         },
385 |         "correct_fact": "fact1"
386 |     },
387 |     {
388 |         "facts": {
389 |             "fact1": "Humans can't breathe and swallow at the same time.",
390 |             "fact2": "Humans can breathe and swallow at the same time."
391 |         },
392 |         "correct_fact": "fact1"
393 |     },
394 |     {
395 |         "facts": {
396 |             "fact1": "Butterflies taste with their feet.",
397 |             "fact2": "Butterflies taste with their tongues."
398 |         },
399 |         "correct_fact": "fact1"
400 |     },
401 |     {
402 |         "facts": {
403 |             "fact1": "Jellyfish are 95% water.",
404 |             "fact2": "Jellyfish are 70% water."
405 |         },
406 |         "correct_fact": "fact1"
407 |     },
408 |     {
409 |         "facts": {
410 |             "fact1": "Tigers have striped skin, not just striped fur.",
411 |             "fact2": "Tigers only have striped fur, not striped skin."
412 |         },
413 |         "correct_fact": "fact1"
414 |     },
415 |     {
416 |         "facts": {
417 |             "fact1": "The longest recorded flight of a chicken is about 13 seconds.",
418 |             "fact2": "The longest recorded flight of a chicken is about 2 minutes."
419 |         },
420 |         "correct_fact": "fact1"
421 |     }
422 | ]
```

## File: textarena/envs/two_player/TruthAndDeception/README.md

- Extension: .md
- Language: markdown
- Size: 7679 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Truth And Deception Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | **Truth And Deception** is a strategic two-player game that challenges players' abilities to discern truth from deception. The game involves two roles:
  6 | - **Deceiver (Player 0):** Knows which of the two presented facts is correct and aims to convince the Guesser to choose the incorrect one.
  7 | - **Guesser (Player 1):** Engages in a conversation with the Deceiver and must determine which of the two facts is correct based on the interaction.
  8 | 
  9 | The objective is straightforward:
 10 | - **Deceiver:** Successfully mislead the Guesser into selecting the wrong fact.
 11 | - **Guesser:** Accurately identify the true fact through strategic questioning and analysis.
 12 | 
 13 | 
 14 | ## Action Space
 15 | 
 16 | - **Format:** Actions are strings representing messages exchanged during the conversation, enclosed in square brackets.
 17 | - **Special Tokens:** (For the guessing phase)
 18 |     - **[Fact 1]:** The guesser guesses that the first fact is correct
 19 |     - **[Fact 2]:** The guesser guesses that the second fact is correct
 20 | - **Gameplay Actions:**
 21 |     - **Conversation:**  Both players exchange messages.
 22 |         - **Format:** Any natural language message without special tokens.
 23 |         - **Example:** `"You know, lightning is a fascinating natural phenomenon. There's this popular belief that [...]"`
 24 |     - **Guessing:** After the conversation phase, the Guesser makes a guess using `[Fact 1]` or `[Fact 2]`.
 25 |         - **Format:** `[Fact 1]` or `[Fact 2]`
 26 |         - **Example:** `"I Belive fact 1 is correct. [Fact 1]"`
 27 | - **Notes:** 
 28 |     - During the conversation phase, no special tokens need to be used by either player.
 29 |     - During the guessing phase, the Guesser must use `[Fact 1]` or `[Fact 2]` to make their selection.
 30 | 
 31 | 
 32 | ## Observation Space
 33 | 
 34 | ### Observations
 35 | 
 36 | Players receive a series of messages exchanged during the game, tailored to their roles. This information aids in making informed decisions about future moves or conceding the game.
 37 | 
 38 | 
 39 | ### Deceiver (Player 0) Observations
 40 | 
 41 | **Reset Observation:**
 42 | ```plaintext
 43 | [GAME]: Game started.
 44 | You are Player 0, the Deceiver, in the 'Truth and Deception' game.
 45 | You know which of the following two facts is correct:
 46 | Fact 1: The Eiffel Tower can be 15 cm taller during hot days. (correct)
 47 | Fact 2: Bananas grow on trees. (incorrect)
 48 | Your goal is to convince the other player to choose the incorrect fact.
 49 | You will have a conversation for 5 turns.
 50 | After that, the other player will make their guess.
 51 | On your turn, simply type your message.
 52 | ```
 53 | 
 54 | **Step Observation:**
 55 | ```plaintext
 56 | [Player 1] I'm not so sure about that. Fact 2 seems more accurate based on what I've read.
 57 | ```
 58 | 
 59 | ### Guesser (Player 1) Observations
 60 | 
 61 | **Reset Observation:**
 62 | ```plaintext
 63 | [GAME]: Game started.
 64 | You are Player 1, the Guesser, in the 'Truth and Deception' game.
 65 | You need to determine which of the following two facts is correct:
 66 | Fact 1: The Eiffel Tower can be 15 cm taller during hot days.
 67 | Fact 2: Bananas grow on trees.
 68 | You will have a conversation with the other player for 5 turns.
 69 | After that, you will make your guess by selecting [Fact 1] or [Fact 2].
 70 | On your turn, simply type your message.
 71 | 
 72 | ```
 73 | 
 74 | **Step Observation:**
 75 | ```plaintext
 76 | [Player 0]: I believe Fact 1 is more plausible because of thermal expansion.
 77 | ```
 78 | 
 79 | **Decision Observation:**
 80 | After the conversation phase, the guesser has to decide which fact they think is the correct one. Before doing so, it receives the following final observation:
 81 | ```plaintext
 82 | [GAME]: Now guess which of the two facts are correct by returning [Fact 1] or [Fact 2].
 83 | ```
 84 | 
 85 | 
 86 | ## Gameplay
 87 | - **Players**: 2
 88 | - **Roles**: Player 0 plays as the deceiver, Player 1 plays as the guesser.
 89 | - **Turns**: Players alternate making moves, starting with the Deceiver (Player 0), and ending with the Guesser (Player 1) making their guess.
 90 | - **Conversation Phase**: Players engage in a fixed number of conversation turns to discuss and persuade.
 91 | - **Guessing Phase**: After the conversation, the Guesser must choose `[Fact 1]` or `[Fact 2]` based on the interaction.
 92 | - **Objective**:
 93 |     - **Deceiver**: Mislead the Guesser into selecting the incorrect fact.
 94 |     - **Guesser**: Correctly identify the true fact.
 95 | 
 96 | ## Key Rules
 97 | 1. Conversation Mechanics:
 98 |     - The game consists of a fixed number of turns (`max_turns`), during which both players can exchange messages.
 99 |     - Each turn, only the active player can send a message.
100 | 
101 | 2. Guessing Phase:
102 |     - After the conversation phase, the Guesser must make a guess by selecting either `[Fact 1]` or `[Fact 2]`.
103 |     - The guess determines the outcome of the game based on the correctness of the selected fact.
104 | 
105 | 3. Game Termination:
106 |     - The game ends after the Guesser makes a guess or if a player resigns.
107 |     - The outcome is determined based on the Guesser's choice and the correctness of the selected fact.
108 | 
109 | ## Rewards
110 | 
111 | | Outcome          | Reward for Player | Reward for Opponent |
112 | |------------------|:-----------------:|:-------------------:|
113 | | **Win**          | `+1`              | `-1`                |
114 | | **Lose**         | `-1`              | `+1`                |
115 | | **Invalid Move** | `-1`              |  `0`                |
116 | 
117 | 
118 | ## Parameters
119 | 
120 | - `max_turns` (`int`):
121 |     - **Description**: Maximum number of conversation turns before the Guesser must make a guess.
122 |     - **Impact**: Determines the duration of the conversation phase, influencing the depth of interaction and strategy.
123 | 
124 | - `data_path` (`str`):
125 |     - **Description**: Path to the JSON file containing the facts data.
126 |     - **Impact**: Specifies the source of the facts used in the game, allowing for customization and expansion of fact sets.
127 | 
128 | 
129 | 
130 | ## Variants
131 | 
132 | | Env-id                                 | max_turns  |
133 | |----------------------------------------|:----------:|
134 | | `TruthAndDeception-v0`                 | `6`        |
135 | | `TruthAndDeception-v0-long`            | `12`       |
136 | | `TruthAndDeception-v0-super-long`      | `50`       |
137 | 
138 | 
139 | 
140 | ## Example Usage
141 | 
142 | ```python
143 | import textarena as ta
144 | 
145 | # Initialize the environment
146 | env = ta.make(env_id="TruthAndDeception-v0")
147 | 
148 | # Wrap the environment for easier observation handling
149 | env = ta.wrappers.LLMObservationWrapper(env=env)
150 | 
151 | # initalize agents
152 | agents = {
153 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
154 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
155 |     }
156 | 
157 | # reset the environment to start a new game
158 | observations = env.reset(seed=490)
159 | 
160 | # Game loop
161 | done = False
162 | while not done:
163 | 
164 |     # Get the current player
165 |     current_player_id = env.state.get("current_player")
166 | 
167 |     # Get the current observation for the player
168 |     obs = observations[current_player_id]
169 | 
170 |     # Agent decides on an action based on the observation
171 |     action = agents[current_player_id](obs)
172 | 
173 |     # Execute the action in the environment
174 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
175 | 
176 |     # Check if the game has ended
177 |     done = terminated or truncated
178 | 
179 |     # Optionally render the environment to see the current state
180 |     env.render()
181 | 
182 |     if done:
183 |         break
184 | 
185 | # Finally, print the game results
186 | for player_id, agent in agents.items():
187 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
188 | print(f"Reason: {info['reason']}")
189 | ```
190 | 
191 | ## Troubleshooting
192 | 
193 | - **Invalid Move Format:**
194 |     - **Issue:** Player provides a message that doesn't follow the required format, missing special tokens.
195 |     - **Solution:** Make sure that the Guesser returns either the `[Fact 1]` or `[Fact 2]` token as the final action.
196 | 
197 | 
198 | ## Version History
199 | - **v0**
200 |   - Initial release 
201 | 
202 | 
203 | 
204 | ### Contact
205 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/TruthAndDeception/__init__.py

- Extension: .py
- Language: python
- Size: 159 bytes
- Created: 2024-11-18 18:09:06
- Modified: 2024-11-18 18:09:06

### Code

```python
1 | from textarena.envs.two_player.TruthAndDeception.env import TruthAndDeceptionEnv
2 | from textarena.envs.two_player.TruthAndDeception.render import GameStateRender
```

## File: textarena/envs/two_player/CarPuzzle/env.py

- Extension: .py
- Language: python
- Size: 12850 bytes
- Created: 2024-12-12 10:13:48
- Modified: 2024-12-12 10:13:48

### Code

```python
  1 | 
  2 | 
  3 | 
  4 | 
  5 | import re
  6 | import random
  7 | from typing import Any, Dict, List, Optional, Tuple, Set
  8 | 
  9 | import textarena as ta
 10 | 
 11 | class CarPuzzleEnv(ta.Env):
 12 |     def __init__(self, N: int = 8):
 13 |         
 14 |         self.environment_name = "Car Puzzle"
 15 |         self.N = N
 16 |         
 17 |         
 18 |         self.state = ta.State(
 19 |             num_players=2,
 20 |             max_turns=3,  
 21 |             check_truncated=False,
 22 |         )
 23 | 
 24 |         
 25 |         self.car_pattern = re.compile(r"\[PlaceCar\] ([A-Z*@]) ([HV]) (\d+) (\d+) (\d+)", re.IGNORECASE)
 26 |         self.move_pattern = re.compile(r"\[Move\] ([A-Z*]) (-?\d+)", re.IGNORECASE)
 27 | 
 28 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[str, Any]) -> str:
 29 |         
 30 |         if player_id == 0:  
 31 |             prompt = (
 32 |                 "Welcome to Car Puzzle! You are the Puzzle Creator (Player 0).\n\n"
 33 |                 "Game Flow:\n"
 34 |                 "1. Create a puzzle by placing cars on the grid\n"
 35 |                 "2. Solve your own puzzle to prove it's valid\n"
 36 |                 "3. Wait for the challenger to attempt your puzzle\n\n"
 37 |                 "Puzzle Creation Format:\n"
 38 |                 "[PlaceCar] car_id orientation x y length\n"
 39 |                 "  - car_id: Single character (use * for target car)\n"
 40 |                 "  - orientation: H (horizontal) or V (vertical)\n"
 41 |                 "  - x,y: Starting position\n"
 42 |                 "  - length: Car length (2 or 3)\n\n"
 43 |                 "Example:\n"
 44 |                 "[PlaceCar] * H 26 3 2\n"
 45 |                 "[PlaceCar] A H 45 5 2\n"
 46 |                 "[PlaceCar] B V 20 2 3\n\n"
 47 |                 "Solution Format:\n"
 48 |                 "[Move] car_id distance\n"
 49 |                 "  - distance: number of spaces (negative for left/up)\n"
 50 |             )
 51 |         else:  
 52 |             prompt = (
 53 |                 "Welcome to Car Puzzle! You are the Challenger (Player 1).\n\n"
 54 |                 "Game Flow:\n"
 55 |                 "1. Wait for the Creator to make and verify a puzzle\n"
 56 |                 "2. Solve the puzzle when it's provided\n\n"
 57 |                 "Solution Format:\n"
 58 |                 "[Move] car_id distance\n"
 59 |                 "Example: [Move] A -3 (moves car A three spaces left)\n"
 60 |                 "\nYou'll win if you successfully solve the puzzle!\n"
 61 |             )
 62 |         return prompt
 63 | 
 64 |     def reset(self, seed: Optional[int] = None) -> Optional[ta.Observations]:
 65 |         
 66 |         if seed is not None:
 67 |             random.seed(seed)
 68 | 
 69 |         
 70 |         goal_pos = (self.N - 1) * (self.N // 2)
 71 | 
 72 |         
 73 |         wall_positions = set()
 74 |         for i in range(self.N):
 75 |             wall_positions.add(i)  
 76 |             wall_positions.add(i * self.N)  
 77 |             wall_positions.add(i * self.N + (self.N - 1))  
 78 |             wall_positions.add(i + (self.N * (self.N - 1)))  
 79 |         wall_positions.remove(goal_pos)  
 80 | 
 81 |         return self.state.reset(
 82 |             game_state={
 83 |                 "phase": 1,  
 84 |                 "cars": {},  
 85 |                 "walls": tuple(sorted(wall_positions)),
 86 |                 "goal": (goal_pos,),
 87 |                 "creator_solution": None,
 88 |                 "game_complete": False,
 89 |                 "winner": None,
 90 |                 "board_size": self.N
 91 |             },
 92 |             player_prompt_function=self._generate_player_prompt,
 93 |         )
 94 | 
 95 |     def _get_car_orientation(self, positions: Tuple[int, ...]) -> str:
 96 |         
 97 |         if len(positions) < 2:
 98 |             return None
 99 |         if positions[1] - positions[0] == 1:
100 |             return 'H'  
101 |         return 'V'  
102 | 
103 |     def _can_move_car(self, car_id: str, distance: int, cars: Dict, walls: Set[int], N: int) -> bool:
104 |         
105 |         if car_id not in cars:
106 |             return False
107 | 
108 |         car = cars[car_id]
109 |         positions = car["positions"]
110 |         orientation = car["orientation"]
111 | 
112 |         
113 |         new_positions = []
114 |         if orientation == 'H':
115 |             for pos in positions:
116 |                 new_pos = pos + distance
117 |                 if new_pos // N != pos // N:  
118 |                     return False
119 |                 new_positions.append(new_pos)
120 |         else:  
121 |             for pos in positions:
122 |                 new_pos = pos + (distance * N)
123 |                 if new_pos < 0 or new_pos >= N * N:
124 |                     return False
125 |                 new_positions.append(new_pos)
126 | 
127 |         
128 |         occupied = walls.union(*(set(car["positions"]) for cid, car in cars.items() if cid != car_id))
129 |         return not any(pos in occupied for pos in new_positions)
130 | 
131 |     def _move_car(self, cars: Dict, car_id: str, distance: int) -> Dict:
132 |         
133 |         if car_id not in cars:
134 |             return cars
135 | 
136 |         new_cars = dict(cars)
137 |         car = new_cars[car_id]
138 |         orientation = car["orientation"]
139 |         
140 |         
141 |         incr = 1 if orientation == 'H' else self.N
142 |         
143 |         
144 |         new_positions = tuple(pos + (distance * incr) for pos in car["positions"])
145 |         new_cars[car_id] = {"orientation": orientation, "positions": new_positions}
146 |         
147 |         return new_cars
148 | 
149 |     def _check_victory(self, cars: Dict) -> bool:
150 |         
151 |         if '*' not in cars:
152 |             return False
153 |             
154 |         target_positions = set(cars['*']["positions"])
155 |         goal_position = set(self.state.game_state["goal"])
156 |         return bool(target_positions & goal_position)
157 | 
158 |     def _process_puzzle_creation(self, submission: str) -> Tuple[bool, str]:
159 |         
160 |         lines = submission.strip().split('\n')
161 |         cars = {}
162 |         
163 |         for line in lines:
164 |             if match := self.car_pattern.match(line):
165 |                 car_id, orientation, x, y, length = match.groups()
166 |                 x, y = int(x), int(y)
167 |                 length = int(length)
168 |                 
169 |                 if length not in (2, 3):
170 |                     return False, f"Invalid car length: {length}"
171 |                 
172 |                 
173 |                 positions = []
174 |                 if orientation == 'H':
175 |                     for i in range(length):
176 |                         pos = y * self.N + (x + i)
177 |                         positions.append(pos)
178 |                 else:  
179 |                     for i in range(length):
180 |                         pos = (y + i) * self.N + x
181 |                         positions.append(pos)
182 |                 
183 |                 cars[car_id] = {
184 |                     "orientation": orientation,
185 |                     "positions": tuple(positions)
186 |                 }
187 | 
188 |         
189 |         occupied = set(self.state.game_state["walls"])
190 |         for car_id, car in cars.items():
191 |             if any(pos in occupied for pos in car["positions"]):
192 |                 return False, f"Car {car_id} overlaps with walls or other cars"
193 |             occupied.update(car["positions"])
194 | 
195 |         
196 |         if '*' not in cars:
197 |             return False, "No target car (*) defined"
198 |         if cars['*']["orientation"] != 'H':
199 |             return False, "Target car must be horizontal"
200 | 
201 |         self.state.game_state["cars"] = cars
202 |         return True, "Puzzle created successfully"
203 | 
204 |     def step(
205 |         self,
206 |         player_id: int,
207 |         action: str,
208 |     ) -> Tuple[Optional[ta.Observations], Optional[ta.Rewards], bool, bool, ta.Info]:
209 |         
210 |         
211 |         self.state.check_action_format(action=action, player_id=player_id)
212 | 
213 |         
214 |         self.state.add_observation(
215 |             from_id=player_id,
216 |             to_id=-1,  
217 |             message=action
218 |         )
219 | 
220 |         
221 |         if self.state.game_state["phase"] == 1:
222 |             if player_id != 0:
223 |                 self.state.set_invalid_move(
224 |                     player_ids=[player_id],
225 |                     reasons=["Only Creator can submit a puzzle"]
226 |                 )
227 |             else:
228 |                 success, message = self._process_puzzle_creation(action)
229 |                 if success:
230 |                     self.state.game_state["phase"] = 2
231 |                     self._show_board()
232 |                     self.state.add_observation(
233 |                         from_id=ta.GAME_ID,
234 |                         to_id=0,
235 |                         message="Puzzle created. Please provide your solution."
236 |                     )
237 |                 else:
238 |                     self.state.set_winners(
239 |                         player_ids=[1],
240 |                         reason=f"Invalid puzzle: {message}"
241 |                     )
242 | 
243 |         elif self.state.game_state["phase"] == 2:
244 |             if player_id != 0:
245 |                 self.state.set_invalid_move(
246 |                     player_ids=[player_id],
247 |                     reasons=["Waiting for Creator's solution"]
248 |                 )
249 |             else:
250 |                 if self._verify_solution(action):
251 |                     self.state.game_state["creator_solution"] = action
252 |                     self.state.game_state["phase"] = 3
253 |                     self._show_board()
254 |                     self.state.add_observation(
255 |                         from_id=ta.GAME_ID,
256 |                         to_id=1,
257 |                         message="Your turn to solve the puzzle."
258 |                     )
259 |                 else:
260 |                     self.state.set_winners(
261 |                         player_ids=[1],
262 |                         reason="Creator's solution failed"
263 |                     )
264 | 
265 |         elif self.state.game_state["phase"] == 3:
266 |             if player_id != 1:
267 |                 self.state.set_invalid_move(
268 |                     player_ids=[player_id],
269 |                     reasons=["Waiting for Challenger's solution"]
270 |                 )
271 |             else:
272 |                 if self._verify_solution(action):
273 |                     self.state.set_winners(
274 |                         player_ids=[1],
275 |                         reason="Challenger solved the puzzle!"
276 |                     )
277 |                 else:
278 |                     self.state.set_winners(
279 |                         player_ids=[0],
280 |                         reason="Challenger's solution failed"
281 |                     )
282 | 
283 |         return self.state.step()
284 | 
285 |     def _verify_solution(self, solution: str) -> bool:
286 |         
287 |         lines = solution.strip().split('\n')
288 |         cars = dict(self.state.game_state["cars"])
289 |         walls = set(self.state.game_state["walls"])
290 |         
291 |         for line in lines:
292 |             if not (match := self.move_pattern.match(line)):
293 |                 return False
294 |             
295 |             car_id, distance = match.groups()
296 |             distance = int(distance)
297 |             
298 |             if not self._can_move_car(car_id, distance, cars, walls, self.N):
299 |                 return False
300 |                 
301 |             cars = self._move_car(cars, car_id, distance)
302 |             if self._check_victory(cars):
303 |                 return True
304 |                 
305 |         return False
306 | 
307 |     def _show_board(self):
308 |         
309 |         board = ['.'] * (self.N * self.N)
310 |         
311 |         
312 |         for pos in self.state.game_state["walls"]:
313 |             board[pos] = '|'
314 |             
315 |         
316 |         board[self.state.game_state["goal"][0]] = '@'
317 |         
318 |         
319 |         for car_id, car in self.state.game_state["cars"].items():
320 |             for pos in car["positions"]:
321 |                 board[pos] = car_id
322 |         
323 |         
324 |         board_str = '\n'.join(' '.join(board[i:i+self.N]) for i in range(0, self.N*self.N, self.N))
325 |         
326 |         self.state.add_observation(
327 |             from_id=ta.GAME_ID,
328 |             to_id=-1,  
329 |             message=f"Current board state:\n{board_str}"
330 |         )
331 | 
332 |     def close(self):
333 |         
334 |         pass
```

## File: textarena/envs/two_player/CarPuzzle/car_puzzle.py

- Extension: .py
- Language: python
- Size: 22484 bytes
- Created: 2024-12-12 10:14:11
- Modified: 2024-10-18 15:28:49

### Code

```python
  1 | 
  2 | 
  3 | import random
  4 | from typing import Any, Dict, Optional, Tuple
  5 | 
  6 | import textarena as ta
  7 | 
  8 | 
  9 | class CarPuzzleEnv(ta.Env):
 10 |     def __init__(
 11 |         self,
 12 |     ):
 13 |         
 14 |         self.environment_name = "Car Puzzle"
 15 | 
 16 |         
 17 |         self.game_state = ta.State(
 18 |             {
 19 |                 "phase": 1,  
 20 |                 "game_over": False,
 21 |                 "board": None,
 22 |                 "exit": None,
 23 |                 "cars": {},
 24 |                 "logs": [],
 25 |                 "render": ["phase", "game_over"],
 26 |             }
 27 |         )
 28 | 
 29 |     def reset(
 30 |         self, seed: Optional[int] = None
 31 |     ) -> Tuple[Optional[ta.Observation], ta.Reward]:
 32 |         
 33 |         if seed is not None:
 34 |             random.seed(seed)
 35 |         else:
 36 |             random.seed()
 37 | 
 38 |         self.game_state["phase"] = 1
 39 |         self.game_state["game_over"] = False
 40 |         self.game_state["board"] = None
 41 |         self.game_state["exit"] = None
 42 |         self.game_state["cars"] = {}
 43 |         self.game_state["logs"] = []
 44 | 
 45 |         
 46 |         observations = {
 47 |             0: [
 48 |                 self._generate_puzzle_creator_prompt(0)
 49 |             ],  
 50 |             1: [
 51 |                 self._generate_puzzle_solver_prompt(1)
 52 |             ],  
 53 |         }
 54 | 
 55 |         info = {}
 56 | 
 57 |         return observations, info
 58 | 
 59 |     def _generate_puzzle_creator_prompt(self, id) -> ta.Message:
 60 |         
 61 |         prompt = (
 62 |             f"You are Player {id}, the Puzzle Creator in the 'Car Puzzle' game.\n"
 63 |             "Your task is to create a car puzzle by specifying the grid size, placing cars, and providing a solution.\n"
 64 |             "There is a specific target car with ID 0 that needs to reach the exit.\n"
 65 |             "Cars are numbered uniquely and can only move in the direction they are oriented (forward and backward).\n"
 66 |             "Each car must be at least two squares long and be placed in a straight line (horizontal or vertical).\n"
 67 |             "Format your submission using the following formalized language (use square brackets for keywords):\n"
 68 |             "\n"
 69 |             "1. Define Grid Size:\n"
 70 |             "[GridSize] width height\n"
 71 |             "Example: [GridSize] 6 6\n"
 72 |             "\n"
 73 |             "2. Place Cars:\n"
 74 |             "[PlaceCar] car_id orientation x y length\n"
 75 |             " - car_id: Integer identifier for the car (0 is the target car).\n"
 76 |             " - orientation: H for horizontal, V for vertical.\n"
 77 |             " - x y: Coordinates of the starting position (top-left for H, top for V).\n"
 78 |             " - length: Length of the car (minimum 2).\n"
 79 |             "Example: [PlaceCar] 0 H 2 2 2\n"
 80 |             "\n"
 81 |             "3. Specify Exit Point (optional, default is right edge on the same row as the target car):\n"
 82 |             "[Exit] x y\n"
 83 |             "Example: [Exit] 5 2\n"
 84 |             "\n"
 85 |             "4. Provide Solution Steps:\n"
 86 |             "List of moves using the following format:\n"
 87 |             "[Move] car_id steps\n"
 88 |             " - car_id: Integer identifier of the car to move.\n"
 89 |             " - steps: Positive or negative integer indicating the number of steps to move (positive for forward, negative for backward).\n"
 90 |             "Example: [Move] 0 1\n"
 91 |             "\n"
 92 |             "Submit your puzzle and solution together.\n"
 93 |             "Full Example:\n"
 94 |             "[GridSize] 6 6\n"
 95 |             "[PlaceCar] 0 H 2 2 2\n"
 96 |             "[PlaceCar] 1 V 0 0 3\n"
 97 |             "[PlaceCar] 2 V 4 0 2\n"
 98 |             "[Exit] 5 2\n"
 99 |             "[Move] 1 1\n"
100 |             "[Move] 0 2\n"
101 |         )
102 |         return (id, prompt)
103 | 
104 |     def _generate_puzzle_solver_prompt(self, id) -> ta.Message:
105 |         
106 |         prompt = (
107 |             f"You are Player {id}, the Puzzle Solver in the 'Car Puzzle' game.\n"
108 |             "You will be given a car puzzle to solve.\n"
109 |             "There is a specific target car with ID 0 that needs to reach the exit.\n"
110 |             "Provide your solution as a list of moves using the formalized language.\n"
111 |             "Format for moves:\n"
112 |             "[Move] car_id steps\n"
113 |             " - car_id: Integer identifier of the car to move.\n"
114 |             " - steps: Positive or negative integer indicating the number of steps to move (positive for forward, negative for backward).\n"
115 |             "Example: [Move] 0 1\n"
116 |             "\n"
117 |             "Wait for the puzzle from the Puzzle Creator."
118 |         )
119 |         return (id, prompt)
120 | 
121 |     def step(
122 |         self,
123 |         player_id: int,
124 |         action: str,
125 |     ) -> Tuple[
126 |         Optional[ta.Observation],  
127 |         Optional[ta.Reward],  
128 |         bool,  
129 |         bool,  
130 |         ta.Info,  
131 |     ]:
132 |         
133 |         terminated = False
134 |         truncated = False
135 |         reward = None
136 |         info = {}
137 |         observations = {}
138 | 
139 |         self.game_state["logs"].append((-1, action))
140 | 
141 |         if self.game_state["game_over"]:
142 |             
143 |             observations = {player_id: None}
144 |             info["reason"] = "Game is already over."
145 |             return observations, reward, truncated, terminated, info
146 | 
147 |         if self.game_state["phase"] == 1 and player_id == 0:
148 |             
149 |             success, message = self._process_puzzle_creator_submission(action)
150 |             if not success:
151 |                 
152 |                 terminated = True
153 |                 reward = {0: -1, 1: 1}
154 |                 info["reason"] = message
155 |             else:
156 |                 
157 |                 self.game_state["phase"] = 2
158 |                 observations = {1: self._get_puzzle_description()}
159 |                 info["info"] = (
160 |                     "Puzzle has been provided. Puzzle Solver, please provide your solution."
161 |                 )
162 |         elif self.game_state["phase"] == 2 and player_id == 1:
163 |             
164 |             success, message = self._process_puzzle_solver_submission(action)
165 |             if success:
166 |                 
167 |                 terminated = True
168 |                 reward = {0: -1, 1: 1}
169 |                 info["reason"] = "Puzzle Solver successfully solved the puzzle."
170 |             else:
171 |                 
172 |                 terminated = True
173 |                 reward = {0: 1, 1: -1}
174 |                 info["reason"] = message
175 |         else:
176 |             
177 |             info["reason"] = (
178 |                 f"Unexpected action from Player {player_id} in phase {self.game_state['phase']}."
179 |             )
180 |         self.game_state["logs"].append((-1, info["reason"]))
181 | 
182 |         self.game_state["game_over"] = terminated
183 | 
184 |         return observations, reward, truncated, terminated, info
185 | 
186 |     def _process_puzzle_creator_submission(self, submission: str) -> Tuple[bool, str]:
187 |         
188 |         try:
189 |             puzzle_data, solution_steps = self._parse_puzzle_creator_submission(
190 |                 submission
191 |             )
192 |             success, error_message = self._initialize_board(puzzle_data)
193 |             if not success:
194 |                 return False, f"Invalid puzzle: {error_message}"
195 |             
196 |             is_valid_solution = self._verify_puzzle_and_solution(solution_steps)
197 |             if not is_valid_solution:
198 |                 return False, "Provided solution does not solve the puzzle."
199 |             return True, "Puzzle and solution accepted."
200 |         except Exception as e:
201 |             return False, f"Error processing submission: {str(e)}"
202 | 
203 |     def _process_puzzle_solver_submission(self, submission: str) -> Tuple[bool, str]:
204 |         
205 |         try:
206 |             solution_steps = self._parse_puzzle_solver_submission(submission)
207 |             is_solved = self._apply_solution(solution_steps)
208 |             if is_solved:
209 |                 return True, "Puzzle solved successfully."
210 |             else:
211 |                 return False, "Solution did not solve the puzzle."
212 |         except Exception as e:
213 |             return False, f"Error processing submission: {str(e)}"
214 | 
215 |     def _parse_puzzle_creator_submission(self, submission: str) -> Tuple[list, list]:
216 |         
217 |         lines = submission.strip().split("\n")
218 |         puzzle_data = []
219 |         solution_steps = []
220 |         in_solution = False
221 |         for line in lines:
222 |             line = line.strip()
223 |             if not line:
224 |                 continue
225 |             if line.startswith("[Move]"):
226 |                 in_solution = True
227 |             if in_solution:
228 |                 solution_steps.append(line)
229 |             else:
230 |                 puzzle_data.append(line)
231 |         if not solution_steps:
232 |             raise ValueError("No solution steps provided.")
233 |         return puzzle_data, solution_steps
234 | 
235 |     def _parse_puzzle_solver_submission(self, submission: str) -> list:
236 |         
237 |         lines = submission.strip().split("\n")
238 |         solution_steps = []
239 |         for line in lines:
240 |             line = line.strip()
241 |             if line.startswith("[Move]"):
242 |                 solution_steps.append(line)
243 |         if not solution_steps:
244 |             raise ValueError("No solution steps provided.")
245 |         return solution_steps
246 | 
247 |     def _initialize_board(self, puzzle_data: list) -> Tuple[bool, str]:
248 |         
249 |         self.game_state["cars"] = {}
250 |         self.game_state["board"] = None
251 |         self.game_state["exit"] = None
252 |         for line in puzzle_data:
253 |             tokens = line.strip().split()
254 |             if not tokens:
255 |                 continue
256 |             if tokens[0] == "[GridSize]":
257 |                 if len(tokens) != 3:
258 |                     return False, "Invalid [GridSize] format."
259 |                 width, height = int(tokens[1]), int(tokens[2])
260 |                 self.game_state["board"] = [
261 |                     ["." for _ in range(width)] for _ in range(height)
262 |                 ]
263 |             elif tokens[0] == "[PlaceCar]":
264 |                 if len(tokens) != 6:
265 |                     return False, "Invalid [PlaceCar] format."
266 |                 car_id = int(tokens[1])
267 |                 orientation = tokens[2]
268 |                 x, y = int(tokens[3]), int(tokens[4])
269 |                 length = int(tokens[5])
270 |                 success, error_message = self._place_car(
271 |                     car_id, orientation, x, y, length
272 |                 )
273 |                 if not success:
274 |                     return False, error_message
275 |             elif tokens[0] == "[Exit]":
276 |                 if len(tokens) != 3:
277 |                     return False, "Invalid [Exit] format."
278 |                 x, y = int(tokens[1]), int(tokens[2])
279 |                 self.game_state["exit"] = (x, y)
280 |         if self.game_state["board"] is None:
281 |             return False, "Board size was not specified."
282 |         if 0 not in self.game_state["cars"]:
283 |             return False, "Target car with car_id=0 was not placed."
284 |         if self.game_state["exit"] is None:
285 |             
286 |             main_car = self.game_state["cars"].get(0)
287 |             if main_car["orientation"] != "H":
288 |                 return False, "Target car must be horizontal for default exit position."
289 |             self.game_state["exit"] = (
290 |                 len(self.game_state["board"][0]) - 1,
291 |                 main_car["positions"][0][1],
292 |             )
293 | 
294 |         
295 |         for car_id, car in self.game_state["cars"].items():
296 |             if car["length"] < 2:
297 |                 return False, f"Car {car_id} must be at least 2 units long."
298 |             if car["orientation"] not in ("H", "V"):
299 |                 return (
300 |                     False,
301 |                     f"Car {car_id} has invalid orientation: {car['orientation']}.",
302 |                 )
303 |         return True, "Board initialized successfully."
304 | 
305 |     def _place_car(
306 |         self, car_id: int, orientation: str, x: int, y: int, length: int
307 |     ) -> Tuple[bool, str]:
308 |         
309 |         board = self.game_state["board"]
310 |         if length < 2:
311 |             return False, f"Car {car_id} must be at least 2 units long."
312 |         if orientation not in ("H", "V"):
313 |             return False, f"Invalid orientation for car {car_id}: {orientation}."
314 |         if car_id in self.game_state["cars"]:
315 |             return False, f"Car {car_id} already placed."
316 |         positions = []
317 |         for i in range(length):
318 |             xi, yi = x + i if orientation == "H" else x, (
319 |                 y if orientation == "H" else y + i
320 |             )
321 |             if not (0 <= xi < len(board[0]) and 0 <= yi < len(board)):
322 |                 return False, f"Car {car_id} is out of bounds at ({xi}, {yi})."
323 |             if board[yi][xi] != ".":
324 |                 return False, f"Cell ({xi}, {yi}) is already occupied."
325 |             positions.append((xi, yi))
326 |         for xi, yi in positions:
327 |             board[yi][xi] = str(car_id)
328 |         self.game_state["cars"][car_id] = {
329 |             "orientation": orientation,
330 |             "positions": positions,
331 |             "length": length,
332 |         }
333 |         return True, "Car placed successfully."
334 | 
335 |     def _verify_puzzle_and_solution(self, solution_steps: list) -> bool:
336 |         
337 |         
338 |         board_copy = [row.copy() for row in self.game_state["board"]]
339 |         cars_copy = {cid: car.copy() for cid, car in self.game_state["cars"].items()}
340 |         for car_id in cars_copy:
341 |             cars_copy[car_id]["positions"] = cars_copy[car_id]["positions"].copy()
342 |         for step in solution_steps:
343 |             if not step.startswith("[Move]"):
344 |                 return False
345 |             tokens = step.strip().split()
346 |             if len(tokens) != 3:
347 |                 return False
348 |             car_id = int(tokens[1])
349 |             steps = int(tokens[2])
350 |             if car_id not in cars_copy:
351 |                 return False
352 |             success = self._move_car(cars_copy, board_copy, car_id, steps)
353 |             if not success:
354 |                 return False
355 |             if car_id == 0 and self._check_exit(cars_copy[0]):
356 |                 return True
357 |         
358 |         return self._check_exit(cars_copy[0])
359 | 
360 |     def _apply_solution(self, solution_steps: list) -> bool:
361 |         
362 |         
363 |         board_copy = [row.copy() for row in self.game_state["board"]]
364 |         cars_copy = {cid: car.copy() for cid, car in self.game_state["cars"].items()}
365 |         for car_id in cars_copy:
366 |             cars_copy[car_id]["positions"] = cars_copy[car_id]["positions"].copy()
367 |         for step in solution_steps:
368 |             if not step.startswith("[Move]"):
369 |                 return False
370 |             tokens = step.strip().split()
371 |             if len(tokens) != 3:
372 |                 return False
373 |             car_id = int(tokens[1])
374 |             steps = int(tokens[2])
375 |             if car_id not in cars_copy:
376 |                 return False
377 |             success = self._move_car(cars_copy, board_copy, car_id, steps)
378 |             if not success:
379 |                 return False
380 |             if car_id == 0 and self._check_exit(cars_copy[0]):
381 |                 return True
382 |         
383 |         return self._check_exit(cars_copy[0])
384 | 
385 |     def _move_car(self, cars: dict, board: list, car_id: int, steps: int) -> bool:
386 |         
387 |         car = cars[car_id]
388 |         orientation = car["orientation"]
389 |         positions = car["positions"]
390 |         dx, dy = 0, 0
391 |         if orientation == "H":
392 |             dx = steps
393 |         else:
394 |             dy = steps
395 |         new_positions = []
396 |         for xi, yi in positions:
397 |             xi_new, yi_new = xi + dx, yi + dy
398 |             if not (0 <= xi_new < len(board[0]) and 0 <= yi_new < len(board)):
399 |                 return False  
400 |             
401 |             cell_content = board[yi_new][xi_new]
402 |             if cell_content != "." and cell_content != str(car_id):
403 |                 return False  
404 |             new_positions.append((xi_new, yi_new))
405 |         
406 |         for xi, yi in positions:
407 |             board[yi][xi] = "."
408 |         for xi, yi in new_positions:
409 |             board[yi][xi] = str(car_id)
410 |         
411 |         car["positions"] = new_positions
412 |         return True
413 | 
414 |     def _check_exit(self, car: dict) -> bool:
415 |         
416 |         for xi, yi in car["positions"]:
417 |             if (xi, yi) == self.game_state["exit"]:
418 |                 return True
419 |         return False
420 | 
421 |     def _get_puzzle_description(self) -> str:
422 |         
423 |         description = ""
424 |         description += f"[GridSize] {len(self.game_state['board'][0])} {len(self.game_state['board'])}\n"
425 |         for car_id, car in self.game_state["cars"].items():
426 |             orientation = car["orientation"]
427 |             x, y = car["positions"][0]
428 |             length = car["length"]
429 |             description += f"[PlaceCar] {car_id} {orientation} {x} {y} {length}\n"
430 |         exit_x, exit_y = self.game_state["exit"]
431 |         description += f"[Exit] {exit_x} {exit_y}"
432 |         return description
433 | 
434 |     def render(self):
435 |         
436 |         print("Game Logs:")
437 |         for i, log in self.game_state["logs"]:
438 |             if i == -1:
439 |                 print(f"[GAME] {log}")
440 |             else:
441 |                 print(f"Player {i}: {log}")
442 |         print("\n")
```

## File: textarena/envs/two_player/Poker/test.py

- Extension: .py
- Language: python
- Size: 7374 bytes
- Created: 2024-11-18 17:22:53
- Modified: 2024-11-18 17:22:53

### Code

```python
  1 | from textarena.envs.two_player.Poker.env import PokerEnv
  2 | 
  3 | import warnings
  4 | import unittest
  5 | from parameterized import parameterized
  6 | from typing import Dict, List, Optional, Any
  7 | from collections import Counter
  8 | 
  9 | 
 10 | 
 11 | warnings.filterwarnings('ignore', category=UserWarning)
 12 | warnings.filterwarnings('ignore', category=FutureWarning)
 13 | 
 14 | 
 15 | class TestPokerEnv(unittest.TestCase):
 16 |     
 17 | 
 18 |     
 19 |     test_cases = {
 20 |         "Simple Check-Check Sequence": {
 21 |             "config": {"num_rounds": 1, "starting_chips": 1000},
 22 |             "actions": ["[Call]", "[Check]"],
 23 |             "expected_state": {
 24 |                 "betting_round": 1,  
 25 |                 "pot": 40,  
 26 |                 "current_bet": 0,
 27 |             },
 28 |             "expected_terminated": False,
 29 |         },
 30 |         "Basic Betting Sequence": {
 31 |             "config": {"num_rounds": 1, "starting_chips": 1000},
 32 |             "actions": ["[Bet 50]", "[Call]"],
 33 |             "expected_state": {
 34 |                 "betting_round": 1,
 35 |                 "pot": 100,  
 36 |                 "current_bet": 0,  
 37 |             },
 38 |             "expected_terminated": False,
 39 |         },
 40 |         "Fold Sequence": {
 41 |             "config": {"num_rounds": 1, "starting_chips": 1000},
 42 |             "actions": ["[Bet 100]", "[Fold]"],
 43 |             "expected_state": {
 44 |                 "pot": 0,  
 45 |                 "current_bet": 0,
 46 |             },
 47 |             "expected_terminated": True,
 48 |         },
 49 |         "Invalid Bet Amount": {
 50 |             "config": {"num_rounds": 1, "starting_chips": 100},
 51 |             "actions": ["[Bet 200]"],  
 52 |             "expected_state": None,
 53 |             "expected_terminated": True,
 54 |         }
 55 |     }
 56 | 
 57 |     @parameterized.expand([
 58 |         (
 59 |             name,
 60 |             details["config"],
 61 |             details["actions"],
 62 |             details["expected_state"],
 63 |             details["expected_terminated"],
 64 |         )
 65 |         for name, details in test_cases.items()
 66 |     ])
 67 |     def test_poker_scenarios(
 68 |         self,
 69 |         name: str,
 70 |         config: Dict[str, int],
 71 |         actions: List[str],
 72 |         expected_state: Optional[Dict[str, Any]],
 73 |         expected_terminated: bool,
 74 |     ):
 75 |         
 76 |         with self.subTest(test_case=name):
 77 |             
 78 |             env = PokerEnv(**config)
 79 | 
 80 |             try:
 81 |                 
 82 |                 observations = env.reset(seed=42)
 83 |             except Exception as e:
 84 |                 self.fail(f"Failed to reset the environment: {e}")
 85 | 
 86 |             
 87 |             terminated = False
 88 |             truncated = False
 89 | 
 90 |             
 91 |             for i, action in enumerate(actions):
 92 |                 if terminated or truncated:
 93 |                     break
 94 | 
 95 |                 player_id = env.get_current_player_id()
 96 |                 try:
 97 |                     
 98 |                     step_result = env.step(player_id, action)
 99 |                     if len(step_result) != 5:
100 |                         self.fail(f"env.step() returned {len(step_result)} elements, expected 5")
101 |                     observations, rewards, truncated, terminated, info = step_result
102 |                 except Exception as e:
103 |                     self.fail(f"env.step() failed for player {player_id}: {e}")
104 | 
105 |             
106 |             if expected_state is not None:
107 |                 game_state = env.state.game_state
108 |                 for key, expected_value in expected_state.items():
109 |                     self.assertEqual(
110 |                         game_state[key],
111 |                         expected_value,
112 |                         f"State mismatch for {key}. Expected {expected_value}, got {game_state[key]}"
113 |                     )
114 | 
115 |             
116 |             self.assertEqual(
117 |                 terminated,
118 |                 expected_terminated,
119 |                 f"Termination state mismatch. Expected {expected_terminated}, got {terminated}"
120 |             )
121 | 
122 |     def test_betting_validation(self):
123 |         
124 |         env = PokerEnv(starting_chips=100)
125 |         env.reset(seed=42)
126 | 
127 |         
128 |         with self.subTest(case="Oversized bet"):
129 |             _, _, _, terminated, _ = env.step(1, "[Bet 200]")
130 |             self.assertTrue(terminated, "Game should terminate on invalid bet")
131 | 
132 |         
133 |         env.reset(seed=42)
134 |         env.step(1, "[Bet 20]")
135 |         with self.subTest(case="Invalid raise"):
136 |             _, _, _, terminated, _ = env.step(0, "[Raise 500]")
137 |             self.assertTrue(terminated, "Game should terminate on invalid raise")
138 | 
139 |     def test_blinds_posting(self):
140 |         
141 |         env = PokerEnv(small_blind=10, big_blind=20)
142 |         env.reset(seed=42)
143 | 
144 |         game_state = env.state.game_state
145 |         self.assertEqual(game_state["pot"], 30, "Incorrect blind total")
146 |         self.assertEqual(game_state["current_bet"], 20, "Incorrect current bet")
147 | 
148 |     def test_basic_hand_comparison(self):
149 |         
150 |         env = PokerEnv()
151 |         
152 |         
153 |         pair_hand = [
154 |             {"rank": "A", "suit": "♠"},
155 |             {"rank": "A", "suit": "♣"},
156 |             {"rank": "K", "suit": "♥"},
157 |             {"rank": "Q", "suit": "♦"},
158 |             {"rank": "J", "suit": "♠"},
159 |         ]
160 |         
161 |         high_card_hand = [
162 |             {"rank": "A", "suit": "♠"},
163 |             {"rank": "K", "suit": "♣"},
164 |             {"rank": "Q", "suit": "♥"},
165 |             {"rank": "J", "suit": "♦"},
166 |             {"rank": "9", "suit": "♠"},
167 |         ]
168 | 
169 |         pair_rank = env._evaluate_single_hand(pair_hand)[0]
170 |         high_card_rank = env._evaluate_single_hand(high_card_hand)[0]
171 |         
172 |         self.assertGreater(pair_rank, high_card_rank, "Pair should rank higher than high card")
173 | 
174 |         
175 |         three_kind_hand = [
176 |             {"rank": "A", "suit": "♠"},
177 |             {"rank": "A", "suit": "♣"},
178 |             {"rank": "A", "suit": "♥"},
179 |             {"rank": "K", "suit": "♦"},
180 |             {"rank": "Q", "suit": "♠"},
181 |         ]
182 |         
183 |         three_kind_rank = env._evaluate_single_hand(three_kind_hand)[0]
184 |         self.assertGreater(three_kind_rank, pair_rank, "Three of a kind should rank higher than pair")
185 | 
186 | 
187 | if __name__ == '__main__':
188 |     unittest.main()
```

## File: textarena/envs/two_player/Poker/env.py

- Extension: .py
- Language: python
- Size: 25874 bytes
- Created: 2024-11-19 11:08:10
- Modified: 2024-11-19 11:08:10

### Code

```python
  1 | import re 
  2 | import random 
  3 | from collections import Counter 
  4 | from typing import Any, Dict, List, Optional, Tuple 
  5 | 
  6 | 
  7 | import textarena as ta 
  8 | 
  9 | 
 10 | class PokerEnv(ta.Env):
 11 |     
 12 |     def __init__(
 13 |         self,
 14 |         num_rounds: int = 5,
 15 |         starting_chips: int = 1_000,
 16 |         small_blind: int = 10,
 17 |         big_blind: int = 20,
 18 |     ):
 19 |         
 20 |         
 21 |         self.num_rounds = num_rounds 
 22 |         self.starting_chips = starting_chips 
 23 |         self.small_blind = small_blind 
 24 |         self.big_blind = big_blind 
 25 | 
 26 |         
 27 |         self.suits = ["♠", "♥", "♦", "♣"]
 28 |         self.ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"]
 29 |         self.rank_values = {rank: idx for idx, rank in enumerate(self.ranks)}
 30 |         
 31 |         
 32 |         self.state = ta.State(
 33 |             num_players=2,
 34 |             max_turns=num_rounds, 
 35 |             check_truncated=False, 
 36 |         )
 37 | 
 38 |         
 39 |         self.check_pattern = re.compile(r"\[Check\]", re.IGNORECASE)
 40 |         self.fold_pattern = re.compile(r"\[Fold\]", re.IGNORECASE)
 41 |         self.call_pattern = re.compile(r"\[Call.*\]", re.IGNORECASE)
 42 |         self.bet_pattern = re.compile(r"\[bet (\d+)\]", re.IGNORECASE)  
 43 |         self.raise_pattern = re.compile(r"\[raise (\d+)\]", re.IGNORECASE)  
 44 | 
 45 | 
 46 |         
 47 |         self.board_state_render = ta.envs.two_player.Poker.render.GameStateRender
 48 | 
 49 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[str, Any]) -> str:
 50 |         
 51 |         prompt = (
 52 |             f"Welcome to Texas Hold'em Poker! You are Player {player_id}.\n\n"
 53 |             f"Game Information:\n"
 54 |             f"- This is a {self.num_rounds}-round game\n"
 55 |             f"- Each player starts with {self.starting_chips} chips\n"
 56 |             f"- Small blind is {self.small_blind} chips\n"
 57 |             f"- Big blind is {self.big_blind} chips\n\n"
 58 |             "Game Flow:\n"
 59 |             "1. Each player receives 2 hole cards\n"
 60 |             "2. Betting rounds: Pre-flop → Flop (3 cards) → Turn (1 card) → River (1 card)\n"
 61 |             "3. Players must call the current bet to stay in the hand\n\n"
 62 |             "Available Actions:\n"
 63 |             "  [Check] - When there's no bet to call\n"
 64 |             "  [Call] - Match the current bet\n"
 65 |             "  [Fold] - Give up your hand\n"
 66 |             "  [Bet <amount>] - Make a new bet, e.g. [Bet 100]\n"
 67 |             "  [Raise <amount>] - Increase the current bet, e.g. [Raise 200]\n\n"
 68 |             "Winning:\n"
 69 |             "- Best poker hand wins the pot\n"
 70 |             "- Game ends when rounds are complete or a player runs out of chips\n"
 71 |             "- Player with the most chips at the end wins\n"
 72 |         )
 73 |         return prompt
 74 | 
 75 |     def reset(self, seed: Optional[int] = None) -> Optional[ta.Observations]:
 76 |         
 77 |         if seed is not None:
 78 |             random.seed(seed)
 79 | 
 80 |         return self.state.reset(
 81 |             game_state={
 82 |                 "round": 1,
 83 |                 "betting_round": 0,  
 84 |                 "player_chips": {0: self.starting_chips, 1: self.starting_chips},
 85 |                 "player_hands": {0: [], 1: []},
 86 |                 "community_cards": [],
 87 |                 "visible_community_cards": [],
 88 |                 "pot": 0,
 89 |                 "current_bet": 0,
 90 |                 "player_bets": {0: 0, 1: 0},
 91 |                 "button": 0,  
 92 |                 "folded_players": set(),
 93 |                 "all_in_players": set(),
 94 |                 "checked_players": set(),  
 95 |                 "round_turn": 0
 96 |             },
 97 |             player_prompt_function=self._generate_player_prompt,
 98 |             executable_on_reset=[self._reset_round]
 99 |         )
100 | 
101 |     def _create_deck(self) -> List[Dict[str, str]]:
102 |         
103 |         return [{"rank": rank, "suit": suit} for suit in self.suits for rank in self.ranks]
104 | 
105 |     def _reset_round(self):
106 |         
107 |         print("RESETTING THE ROUND")
108 |         
109 |         deck = self._create_deck()
110 |         random.shuffle(deck)
111 | 
112 |         for player_id in [0, 1]:
113 |             self.state.game_state["player_hands"][player_id] = [deck.pop() for _ in range(2)]
114 |             card1, card2 = self.state.game_state["player_hands"][player_id]
115 |             self.state.add_observation(
116 |                 from_id=ta.GAME_ID,
117 |                 to_id=player_id,
118 |                 message=f"Your cards are: [{card1['rank']}{card1['suit']}, {card2['rank']}{card2['suit']}]",
119 |                 for_logging=True
120 |             )
121 | 
122 |         
123 |         self.state.game_state["community_cards"] = [deck.pop() for _ in range(5)]
124 |         self.state.game_state["visible_community_cards"] = []
125 | 
126 | 
127 |         
128 |         sb_player = (self.state.game_state["button"] + 1) % 2
129 |         bb_player = (self.state.game_state["button"] + 2) % 2
130 | 
131 |         
132 | 
133 |         
134 |         self.state.game_state["player_chips"][sb_player] -= self.small_blind 
135 |         self.state.game_state["player_bets"][sb_player] = self.small_blind 
136 |         self.state.game_state["pot"] += self.small_blind 
137 | 
138 |         
139 |         self.state.game_state["player_chips"][bb_player] -= self.big_blind
140 |         self.state.game_state["player_bets"][bb_player] = self.big_blind 
141 |         self.state.game_state["pot"] += self.big_blind 
142 | 
143 |         self.state.game_state["current_bet"] = self.big_blind 
144 |         self.state.game_state["round_turn"] = 0
145 | 
146 |         
147 |         self.state.current_player = (bb_player + 1) % 2
148 | 
149 |         self._observe_current_pot()
150 | 
151 | 
152 |     def _observe_current_pot(self):
153 |         
154 |         community_card_str = ", ".join([f"{card['rank']}{card['suit']}" for card in self.state.game_state["visible_community_cards"]])
155 |         current_pot_message = (
156 |             f"Visible Community Cards: [{community_card_str}]\n"
157 |             f"Current Pot: {self.state.game_state['pot']}\n"
158 |             f"Player 0 chips: {self.state.game_state['player_chips'][0]}; current bet: {self.state.game_state['player_bets'][0]}\n"
159 |             f"Player 1 chips: {self.state.game_state['player_chips'][1]}; current bet: {self.state.game_state['player_bets'][1]}\n"
160 |         )
161 | 
162 |         self.state.add_observation(
163 |             from_id=ta.GAME_ID,
164 |             to_id=-1, 
165 |             message=current_pot_message
166 |         )
167 | 
168 | 
169 | 
170 |     def get_current_player_id(self):
171 |         return self.state.current_player
172 | 
173 | 
174 |     def step(
175 |         self,
176 |         player_id: int,
177 |         action: str,
178 |     ) -> Tuple[Optional[ta.Observations], Optional[ta.Rewards], bool, bool, ta.Info]:
179 |         
180 | 
181 |         
182 |         self.state.check_action_format(action=action, player_id=player_id)
183 | 
184 |         
185 |         self.state.add_observation(
186 |             from_id=player_id,
187 |             to_id=-1, 
188 |             message=action
189 |         )
190 | 
191 |         
192 |         self._process_betting_action(action=action, player_id=player_id)
193 | 
194 | 
195 |         
196 |         if self._is_betting_round_complete():
197 |             self._advance_game_phase()
198 | 
199 |         self._observe_current_pot()
200 |         return self.state.step(rotate_player=False)
201 | 
202 |     def _parse_action(self, action: str) -> Tuple[str, Optional[int]]:
203 |         
204 |         action = action
205 | 
206 |         
207 |         check_match = self.check_pattern.search(action)
208 |         fold_match = self.fold_pattern.search(action)
209 |         call_match = self.call_pattern.search(action)
210 |         bet_match = self.bet_pattern.search(action)
211 |         raise_match = self.raise_pattern.search(action)
212 | 
213 |         self.state.game_state["round_turn"] += 1
214 | 
215 |         
216 |         if check_match:
217 |             return "check", None 
218 |         elif fold_match:
219 |             return "fold", None 
220 |         elif call_match:
221 |             return "call", None 
222 |         elif bet_match:
223 |             amount = int(bet_match.group(1))
224 |             return "bet", amount 
225 |         elif raise_match:
226 |             amount = int(raise_match.group(1))
227 |             return "raise", amount 
228 |         
229 |         return "invalid", None 
230 | 
231 |     def _process_betting_action(self, player_id: int, action: str):
232 |         
233 |         
234 |         action_type, bet_amount = self._parse_action(action)
235 | 
236 |         
237 |         if action_type == "invalid":
238 |             self.state.set_invalid_move(
239 |                 player_ids=[player_id],
240 |                 reasons=[f"Player {player_id} did not provide a valid action."]
241 |             )
242 |             return
243 | 
244 |         
245 |         self._apply_action(player_id, action_type, bet_amount)
246 | 
247 |         
248 |         if self._is_hand_over():
249 |             self._handle_hand_completion()
250 | 
251 |         
252 |         else:
253 |             next_player = self._get_next_active_player(player_id)
254 |             self.state.current_player = next_player 
255 | 
256 |     def _is_hand_over(self) -> bool:
257 |         
258 |         print("checking if _is_hand_over")
259 |         active_players = set(range(2)) - self.state.game_state["folded_players"]
260 |         
261 |         
262 |         if len(active_players) == 1:
263 |             return True
264 |             
265 |         
266 |         if all(player in self.state.game_state["all_in_players"] 
267 |                for player in active_players):
268 |             return True
269 |             
270 |         return False
271 | 
272 |     def _handle_hand_completion(self):
273 |         
274 |         
275 |         self.state.game_state["visible_community_cards"] = self.state.game_state["community_cards"]
276 |         
277 |         
278 |         self._handle_showdown()
279 |         
280 |         
281 |         if self.state.game_state["round"] < self.num_rounds and all(
282 |             chips > 0 for chips in self.state.game_state["player_chips"].values()
283 |         ):
284 |             
285 |             self.state.game_state["round"] += 1
286 |             self.state.game_state["betting_round"] = 0
287 |             self.state.game_state["button"] = (self.state.game_state["button"] + 1) % 2
288 |             self.state.game_state["folded_players"] = set()
289 |             self.state.game_state["all_in_players"] = set()
290 |             self.state.game_state["checked_players"] = set()
291 |             self._reset_round()
292 |         else:
293 |             
294 |             self.determine_winner()
295 |             
296 | 
297 |     def _evaluate_hands(self, active_players: set[int]) -> int:
298 |         
299 |         community_cards = self.state.game_state["community_cards"]
300 |         hand_rankings = {}
301 |         
302 |         for player in active_players:
303 |             hole_cards = self.state.game_state["player_hands"][player]
304 |             hand_rankings[player] = self._evaluate_single_hand(hole_cards + community_cards)
305 |         
306 |         
307 |         return max(hand_rankings.items(), key=lambda x: x[1])[0]
308 | 
309 | 
310 |     def _evaluate_single_hand(self, cards: List[Dict[str, str]]) -> Tuple[int, List[int]]:
311 |         
312 |         
313 |         ranks = [self.rank_values[card["rank"]] for card in cards]
314 |         suits = [card["suit"] for card in cards]
315 |         
316 |         
317 |         suit_counts = Counter(suits)
318 |         flush_suit = next((suit for suit, count in suit_counts.items() if count >= 5), None)
319 |         
320 |         
321 |         rank_counts = Counter(ranks)
322 |         
323 |         
324 |         distinct_ranks = sorted(set(ranks))
325 |         straight = False
326 |         straight_high = None
327 |         
328 |         
329 |         if set([14, 2, 3, 4, 5]).issubset(set(ranks)):  
330 |             straight = True
331 |             straight_high = 5  
332 |         
333 |         
334 |         for i in range(len(distinct_ranks) - 4):
335 |             if distinct_ranks[i+4] - distinct_ranks[i] == 4:
336 |                 straight = True
337 |                 straight_high = distinct_ranks[i+4]
338 |         
339 |         
340 |         
341 |         if flush_suit and straight:
342 |             flush_cards = [c for c in cards if c["suit"] == flush_suit]
343 |             flush_ranks = sorted([self.rank_values[c["rank"]] for c in flush_cards])
344 |             
345 |             for i in range(len(flush_ranks) - 4):
346 |                 if flush_ranks[i+4] - flush_ranks[i] == 4:
347 |                     return (9, [flush_ranks[i+4]])  
348 |             
349 |             if set([14, 2, 3, 4, 5]).issubset(set(flush_ranks)):
350 |                 return (9, [5])
351 |         
352 |         
353 |         if 4 in rank_counts.values():
354 |             quads = max(r for r, count in rank_counts.items() if count == 4)
355 |             kicker = max(r for r in ranks if r != quads)  
356 |             return (8, [quads, kicker])
357 |         
358 |         
359 |         if 3 in rank_counts.values():
360 |             trips = max(r for r, count in rank_counts.items() if count == 3)
361 |             pairs = [r for r, count in rank_counts.items() if count >= 2 and r != trips]
362 |             if pairs:  
363 |                 return (7, [trips, max(pairs)])
364 |         
365 |         
366 |         if flush_suit:
367 |             flush_ranks = sorted([self.rank_values[c["rank"]] for c in cards if c["suit"] == flush_suit], reverse=True)
368 |             return (6, flush_ranks[:5])
369 |         
370 |         
371 |         if straight:
372 |             return (5, [straight_high])
373 |         
374 |         
375 |         if 3 in rank_counts.values():
376 |             trips = max(r for r, count in rank_counts.items() if count == 3)
377 |             kickers = sorted([r for r in ranks if r != trips], reverse=True)  
378 |             return (4, [trips] + kickers[:2])
379 |         
380 |         
381 |         pairs = [r for r, count in rank_counts.items() if count == 2]
382 |         if len(pairs) >= 2:
383 |             pairs.sort(reverse=True)
384 |             kickers = [r for r in ranks if rank_counts[r] == 1]
385 |             kicker = max(kickers) if kickers else min(pairs)  
386 |             return (3, pairs[:2] + [kicker])
387 |         
388 |         
389 |         if 2 in rank_counts.values():
390 |             pair = max(r for r, count in rank_counts.items() if count == 2)
391 |             kickers = sorted([r for r in ranks if r != pair], reverse=True)  
392 |             return (2, [pair] + kickers[:3])
393 |         
394 |         
395 |         high_cards = sorted(ranks, reverse=True)
396 |         return (1, high_cards[:5])
397 | 
398 | 
399 |     def _is_betting_round_complete(self) -> bool:
400 |         
401 |         active_players = set(range(2)) - self.state.game_state["folded_players"]
402 |         current_bet = self.state.game_state["current_bet"]
403 |         
404 |         if current_bet == 0:
405 |             
406 |             return self.state.game_state["checked_players"] == active_players
407 |         else:
408 |             
409 |             
410 |             
411 |             if all(
412 |                 self.state.game_state["player_bets"][pid] == current_bet
413 |                 for pid in active_players 
414 |                 if pid not in self.state.game_state["all_in_players"]
415 |             ):
416 |                 
417 |                 if self.state.game_state["round_turn"] >= 2:
418 |                     return True 
419 |                 return False 
420 | 
421 | 
422 |     def _advance_game_phase(self):
423 |         
424 |         if self.state.game_state["betting_round"] < 3: 
425 |             
426 |             self.state.game_state["betting_round"] += 1
427 | 
428 |             
429 |             self.state.game_state["current_bet"] = 0
430 |             self.state.game_state["player_bets"] = {0: 0, 1: 0}
431 |             self.state.game_state["checked_players"] = set()
432 | 
433 |             
434 |             visible_cards = {
435 |                 1: 3,  
436 |                 2: 4,  
437 |                 3: 5,  
438 |             }.get(self.state.game_state["betting_round"], 0)
439 | 
440 |             self.state.game_state["visible_community_cards"] = self.state.game_state["community_cards"][:visible_cards]
441 |         
442 |         else: 
443 |             self._handle_showdown()
444 | 
445 |             
446 |             if self.state.game_state["round"] < self.num_rounds and all(
447 |                 chips > 0 for chips in self.state.game_state["player_chips"].values()
448 |             ):
449 |                 
450 |                 self.state.game_state["round"] += 1
451 |                 self.state.game_state["betting_round"] = 0
452 |                 self.state.game_state["button"] = (self.state.game_state["button"] + 1) % 2
453 |                 self.state.game_state["folded_players"] = set()
454 |                 self.state.game_state["all_in_players"] = set()
455 |                 self.state.game_state["checked_players"] = set()
456 |                 self.state.game_state["visible_community_cards"] = []
457 |                 self._reset_round()
458 |             else:
459 |                 
460 |                 self.state.game_state["game_complete"] = True
461 | 
462 |     def _handle_showdown(self):
463 |         
464 |         active_players = set(range(2)) - self.state.game_state["folded_players"]
465 | 
466 |         if len(active_players) > 1:
467 |             
468 |             winner = self._evaluate_hands(active_players)
469 |         else:
470 |             
471 |             winner = active_players.pop()
472 | 
473 |         self.state.game_state["player_chips"][winner] += self.state.game_state["pot"]
474 |         self.state.game_state["pot"] = 0
475 | 
476 | 
477 |     def _get_next_active_player(self, current_player: int) -> int:
478 |         
479 |         next_player = (current_player + 1) % 2
480 | 
481 |         
482 |         while (
483 |             next_player in self.state.game_state["folded_players"] or 
484 |             next_player in self.state.game_state["all_in_players"]
485 |         ):
486 |             next_player = (next_player + 1) % 2
487 | 
488 |         return next_player 
489 | 
490 | 
491 |     def determine_winner(self) -> Tuple[int, int]:
492 |         
493 | 
494 |         
495 |         final_chips = self.state.game_state["player_chips"]
496 | 
497 |         chips_player_0 = final_chips[0]
498 |         chips_player_1 = final_chips[1]
499 | 
500 |         if chips_player_0 == chips_player_1:
501 |             self.state.set_draw(
502 |                 reason=f"Both players finished the game with the same number of chips."
503 |             )
504 | 
505 |         else:
506 |             winner_id = 0 if chips_player_0 > chips_player_1 else 1
507 |             winner_chips = final_chips[winner_id]
508 | 
509 |             self.state.game_state["game_complete"] = True
510 |             self.state.game_state["winner"] = winner_id
511 |             self.state.game_state["winning_chips"] = winner_chips
512 | 
513 |             self.state.set_winners(
514 |                 player_ids=[winner_id],
515 |                 reason=f"Player {winner_id} won by gaining the most chips"
516 |             )
517 |         
518 | 
519 | 
520 |     def _apply_action(self, player_id: int, action_type: str, bet_amount: Optional[int]):
521 |         
522 |         if action_type == "fold":
523 |             self.state.game_state["folded_players"].add(player_id)
524 |             self.state.add_observation(
525 |                 from_id=ta.GAME_ID,
526 |                 to_id=-1, 
527 |                 message=f"Player {player_id} has folded."
528 |             )
529 |             
530 |         elif action_type == "check":
531 |             if self.state.game_state["current_bet"] > self.state.game_state["player_bets"][player_id]:
532 |                 self.state.set_invalid_move(
533 |                     player_ids=[player_id],
534 |                     reasons=[f"Player {player_id}. Cannot check when there's a bet to call"]
535 |                 )
536 |             else:
537 |                 self.state.game_state["checked_players"].add(player_id)
538 |                 self.state.add_observation(
539 |                     from_id=ta.GAME_ID,
540 |                     to_id=-1,
541 |                     message=f"Player {player_id} has checked."
542 |                 )
543 |             
544 |                 
545 |         elif action_type == "call":
546 |             call_amount = self.state.game_state["current_bet"] - self.state.game_state["player_bets"][player_id]
547 |             if call_amount > self.state.game_state["player_chips"][player_id]:
548 |                 
549 |                 call_amount = self.state.game_state["player_chips"][player_id]
550 |                 self.state.game_state["all_in_players"].add(player_id)
551 | 
552 |                 self.state.add_observation(
553 |                     from_id=ta.GAME_ID,
554 |                     to_id=-1, 
555 |                     message=f"Player {player_id} is going all in."
556 |                 )
557 |             else:
558 |                 self.state.add_observation(
559 |                     from_id=ta.GAME_ID,
560 |                     to_id=-1, 
561 |                     message=f"Player {player_id} has called ({call_amount})."
562 |                 )
563 |             
564 |                 
565 | 
566 |                 
567 |             self.state.game_state["player_chips"][player_id] -= call_amount
568 |             self.state.game_state["player_bets"][player_id] += call_amount
569 |             self.state.game_state["pot"] += call_amount
570 |             
571 |         elif action_type in ["bet", "raise"]:
572 |             if bet_amount > self.state.game_state["player_chips"][player_id]:
573 |                 self.state.set_invalid_move(
574 |                     player_ids=[player_id],
575 |                     reasons=[f"Player {player_id}. Bet amount exceeds available chips"]
576 |                 )
577 |                 
578 |             
579 |             total_amount = bet_amount
580 |             if action_type == "raise":
581 |                 total_amount += self.state.game_state["current_bet"]
582 |             
583 |                 
584 |             
585 |             current_bet = self.state.game_state["player_bets"][player_id]
586 |             amount_to_add = total_amount - current_bet
587 | 
588 | 
589 |             self.state.add_observation(
590 |                 from_id=ta.GAME_ID,
591 |                 to_id=-1, 
592 |                 message=f"Player {player_id} has raised/bet ({amount_to_add})."
593 |             )
594 |             
595 |             self.state.game_state["player_chips"][player_id] -= amount_to_add
596 |             self.state.game_state["player_bets"][player_id] = total_amount
597 |             self.state.game_state["pot"] += amount_to_add
598 |             self.state.game_state["current_bet"] = total_amount
599 |             
600 |             
601 |             if self.state.game_state["player_chips"][player_id] == 0:
602 |                 self.state.game_state["all_in_players"].add(player_id)
603 | 
604 | 
605 |     def close(self):
606 |         pass 
```

## File: textarena/envs/two_player/Poker/render.py

- Extension: .py
- Language: python
- Size: 9731 bytes
- Created: 2024-11-18 16:26:50
- Modified: 2024-11-18 16:26:50

### Code

```python
  1 | import tkinter as tk
  2 | from tkinter import ttk
  3 | from typing import Any, Dict, Optional
  4 | from PIL import Image, ImageTk
  5 | import os
  6 | 
  7 | class GameStateRender(ttk.Frame):
  8 |     CARD_HEIGHT = 100
  9 |     CARD_WIDTH = 75
 10 |     WINDOW_WIDTH = 600
 11 |     WINDOW_HEIGHT = 800
 12 |     TABLE_HEIGHT = 300
 13 |     TABLE_PADDING = 30
 14 |     CARD_SPACING = 15
 15 |     
 16 |     def __init__(self, master, env, player_names: Optional[Dict[int, str]] = None):
 17 |         super().__init__(master)
 18 |         self.master = master
 19 |         self.env = env
 20 |         self.player_names = player_names or {0: "Player 0", 1: "Player 1"}
 21 |         
 22 |         
 23 |         self.player_colors = {
 24 |             0: '#4A90E2',  
 25 |             1: '#E24A4A'   
 26 |         }
 27 |         self.bg_color = '#2B2B2B'
 28 |         self.felt_color = '#1B5E20'  
 29 |         
 30 |         
 31 |         self.master.title("Texas Hold'em Poker")
 32 |         self.master.geometry(f"{self.WINDOW_WIDTH}x{self.WINDOW_HEIGHT}")
 33 |         self.master.resizable(False, False)
 34 |         self.master.configure(bg=self.bg_color)
 35 |         
 36 |         
 37 |         self.card_images = {}
 38 |         self.load_card_images()
 39 |         
 40 |         self.create_widgets()
 41 | 
 42 | 
 43 |     def _get_card_filename(self, rank: str, suit: str) -> str:
 44 |         
 45 |         rank_map = {
 46 |             "J": "jack",
 47 |             "Q": "queen",
 48 |             "K": "king",
 49 |             "A": "ace"
 50 |         }
 51 |         rank_str = rank_map.get(rank, str(rank))
 52 |         
 53 |         suit_map = {
 54 |             "♠": "spades",
 55 |             "♥": "hearts",
 56 |             "♦": "diamonds",
 57 |             "♣": "clubs"
 58 |         }
 59 |         suit_str = suit_map[suit]
 60 |         
 61 |         return f"{rank_str}_of_{suit_str}.png"
 62 | 
 63 |     def load_card_images(self):
 64 |         
 65 |         assets_path = os.path.join("textarena", "envs", "two_player", "Poker", "render_assets")
 66 |         
 67 |         suits = ["♠", "♥", "♦", "♣"]
 68 |         ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"]
 69 |         
 70 |         for suit in suits:
 71 |             for rank in ranks:
 72 |                 try:
 73 |                     filename = self._get_card_filename(rank, suit)
 74 |                     filepath = os.path.join(assets_path, filename)
 75 |                     image = Image.open(filepath)
 76 |                     image = image.resize((self.CARD_WIDTH, self.CARD_HEIGHT), Image.Resampling.LANCZOS)
 77 |                     self.card_images[f"{rank}{suit}"] = ImageTk.PhotoImage(image)
 78 |                 except Exception as e:
 79 |                     print(f"Could not load image for {rank}{suit}: {e}")
 80 |         
 81 |         try:
 82 |             back_path = os.path.join(assets_path, "back.png")
 83 |             back = Image.open(back_path)
 84 |             back = back.resize((self.CARD_WIDTH, self.CARD_HEIGHT), Image.Resampling.LANCZOS)
 85 |             self.card_images["BACK"] = ImageTk.PhotoImage(back)
 86 |         except Exception as e:
 87 |             print(f"Could not load card back image: {e}")
 88 |             self._create_fallback_card_back()
 89 | 
 90 |     def _create_fallback_card_back(self):
 91 |         
 92 |         image = Image.new('RGB', (self.CARD_WIDTH, self.CARD_HEIGHT), '#AA0000')
 93 |         self.card_images["BACK"] = ImageTk.PhotoImage(image)
 94 | 
 95 |     def draw_card(self, canvas, card, x, y, face_up=True):
 96 |         
 97 |         if face_up:
 98 |             card_key = f"{card['rank']}{card['suit']}"
 99 |             image = self.card_images.get(card_key)
100 |         else:
101 |             image = self.card_images["BACK"]
102 |             
103 |         if image:
104 |             canvas.create_image(x, y, image=image)
105 | 
106 |     def create_widgets(self):
107 |         
108 |         
109 |         self.container = ttk.Frame(self.master)
110 |         self.container.pack(expand=True, fill='both', padx=20, pady=10)
111 |         
112 |         
113 |         self.player_frames = {}
114 |         self.player_frames[1] = self.create_player_frame(1, 'top')
115 |         
116 |         
117 |         self.table_frame = ttk.Frame(self.container)
118 |         self.table_frame.pack(fill='both', expand=True, pady=5)
119 |         
120 |         
121 |         canvas_width = self.WINDOW_WIDTH - 70
122 |         canvas_x = (self.WINDOW_WIDTH - canvas_width) // 2 
123 |         
124 |         self.table_canvas = tk.Canvas(
125 |             self.table_frame,
126 |             height=self.TABLE_HEIGHT,
127 |             width=canvas_width,
128 |             bg=self.felt_color,
129 |             highlightthickness=0
130 |         )
131 |         self.table_canvas.place(relx=0.5, rely=0.5, anchor='center')
132 |         
133 |         
134 |         self.player_frames[0] = self.create_player_frame(0, 'bottom')
135 | 
136 | 
137 |     def create_player_frame(self, player_id, position):
138 |         
139 |         frame = ttk.Frame(self.container)
140 |         frame.pack(fill='x', pady=5)
141 |         
142 |         
143 |         header_frame = ttk.Frame(frame)
144 |         header_frame.pack(fill='x', pady=2)
145 |         
146 |         name_label = ttk.Label(
147 |             header_frame,
148 |             text=f"{self.player_names[player_id]}",
149 |             font=('Arial', 14, 'bold'),
150 |             background=self.bg_color,
151 |             foreground=self.player_colors[player_id]
152 |         )
153 |         name_label.pack(side='left', padx=(0, 10))
154 |         
155 |         chips_label = ttk.Label(
156 |             header_frame,
157 |             text="Chips: 1000",
158 |             font=('Arial', 12),
159 |             background=self.bg_color,
160 |             foreground='white'
161 |         )
162 |         chips_label.pack(side='left')
163 |         
164 |         frame.chips_label = chips_label
165 |         
166 |         
167 |         canvas = tk.Canvas(
168 |             frame,
169 |             height=self.CARD_HEIGHT + 10,
170 |             width=self.WINDOW_WIDTH - 40,
171 |             bg=self.bg_color,
172 |             highlightthickness=0
173 |         )
174 |         canvas.pack(fill='x')
175 |         
176 |         return frame
177 | 
178 |     def draw_board(self):
179 |         
180 |         if not hasattr(self.env.state, "game_state"):
181 |             return
182 |             
183 |         game_state = self.env.state.game_state
184 |         
185 |         
186 |         self.table_canvas.delete('all')
187 |         
188 |         
189 |         table_width = self.WINDOW_WIDTH - 80
190 |         table_height = self.TABLE_HEIGHT - 20
191 |         x1, y1 = 10, 10
192 |         x2, y2 = table_width, table_height
193 |         radius = 40
194 |         
195 |         self.table_canvas.create_polygon(
196 |             x1+radius, y1,
197 |             x2-radius, y1,
198 |             x2, y1,
199 |             x2, y1+radius,
200 |             x2, y2-radius,
201 |             x2, y2,
202 |             x2-radius, y2,
203 |             x1+radius, y2,
204 |             x1, y2,
205 |             x1, y2-radius,
206 |             x1, y1+radius,
207 |             x1, y1,
208 |             fill='#2E7D32',
209 |             smooth=True
210 |         )
211 |         
212 |         
213 |         self.table_canvas.create_text(
214 |             self.WINDOW_WIDTH // 2 - self.TABLE_PADDING,
215 |             30,
216 |             text=f"Pot: ${game_state['pot']}",
217 |             fill='white',
218 |             font=('Arial', 16, 'bold')
219 |         )
220 |         
221 |         
222 |         visible_cards = game_state["visible_community_cards"]
223 |         all_cards = game_state["community_cards"]
224 |         
225 |         total_width = (5 * self.CARD_WIDTH) + (4 * self.CARD_SPACING)
226 |         start_x = ((self.WINDOW_WIDTH - 60) - total_width) // 2
227 |         
228 |         for i in range(5):
229 |             x = start_x + (i * (self.CARD_WIDTH + self.CARD_SPACING)) + self.CARD_WIDTH // 2
230 |             y = self.TABLE_HEIGHT // 2
231 |             
232 |             if i < len(visible_cards):
233 |                 self.draw_card(self.table_canvas, all_cards[i], x, y, face_up=True)
234 |             else:
235 |                 self.draw_card(self.table_canvas, {'rank': 'BACK', 'suit': 'BACK'}, x, y, face_up=False)
236 |         
237 |         
238 |         betting_round_names = ["Pre-flop", "Flop", "Turn", "River"]
239 |         current_betting_round = betting_round_names[game_state["betting_round"]]
240 |         current_round = game_state.get("round", 1)
241 |         total_rounds = self.env.state.max_turns 
242 | 
243 |         round_text = f"Round {current_round}/{total_rounds} - ({current_betting_round})"
244 |         
245 |         self.table_canvas.create_text(
246 |             self.WINDOW_WIDTH // 2 - self.TABLE_PADDING,
247 |             self.TABLE_HEIGHT - 40,
248 |             text=round_text,
249 |             fill='white',
250 |             font=('Arial', 14, 'bold')
251 |         )
252 |         
253 |         
254 |         for player_id in [0, 1]:
255 |             frame = self.player_frames[player_id]
256 |             chips = game_state["player_chips"][player_id]
257 |             current_bet = game_state["player_bets"][player_id]
258 |             frame.chips_label.configure(
259 |                 text=f"Chips: {chips} (Bet: {current_bet})"
260 |             )
261 |             
262 |             
263 |             canvas = [w for w in frame.winfo_children() if isinstance(w, tk.Canvas)][0]
264 |             canvas.delete('all')
265 |             
266 |             
267 |             cards = game_state["player_hands"][player_id]
268 |             if cards:
269 |                 total_width = (2 * self.CARD_WIDTH) + self.CARD_SPACING
270 |                 start_x = (self.WINDOW_WIDTH - total_width) // 2 - 20
271 |                 y = self.CARD_HEIGHT // 2 + 10
272 |                 
273 |                 self.draw_card(canvas, cards[0], start_x + self.CARD_WIDTH // 2, y, face_up=True)
274 |                 self.draw_card(canvas, cards[1], start_x + self.CARD_WIDTH + self.CARD_SPACING + self.CARD_WIDTH // 2, y, face_up=True)
```

## File: textarena/envs/two_player/Poker/README.md

- Extension: .md
- Language: markdown
- Size: 7322 bytes
- Created: 2024-11-18 16:59:35
- Modified: 2024-11-18 16:59:35

### Code

```markdown
  1 | # Poker Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | **Poker** is a strategic two-player Texas Hold'em game where players compete by betting chips based on their hole cards and community cards. Each player aims to win chips by either having the best hand at showdown or making their opponent fold. The game follows standard Texas Hold'em rules with a fixed number of rounds and betting structures.
  6 | 
  7 | ## Action Space
  8 | 
  9 | - **Format:** Actions are strings representing the player's poker actions or messages.
 10 | - **Special Tokens:**
 11 |     - **[Check]:** When there's no bet to call.
 12 |     - **[Call]:** Match the current bet.
 13 |     - **[Fold]:** Give up the current hand.
 14 |     - **[Bet <amount>]:** Make a new bet (e.g., `[Bet 100]`).
 15 |     - **[Raise <amount>]:** Increase an existing bet (e.g., `[Raise 200]`)
 16 | - **Examples:**
 17 |     - `"The pot odds aren't good enough. [Fold]"`
 18 |     - `"I'll match that. [Call]"`
 19 |     - `"[Bet 150] Let's see how you respond to aggression"`
 20 |     - `"Nothing to call. [Check]"`
 21 |     - `"Too small. [Raise 300]"`
 22 | - **Notes:**    
 23 |     - Players can include additional text before or after the action tokens
 24 |     - Bet and raise amounts must be integers
 25 |     - Players must have sufficient chips for their actions
 26 | 
 27 | 
 28 | ## Observation Space
 29 | 
 30 | ### Observations
 31 | 
 32 | Players receive continuous updates about the game state, including their hole cards, visible community cards, pot size, and betting actions.
 33 | 
 34 | **Reset Observation:**
 35 | 
 36 | On reset, each player receives a prompt detailing the game rules and their initial stack size:
 37 | ```plaintext
 38 | Welcome to Texas Hold'em Poker! You are Player {player_id}.
 39 | 
 40 | Game Information:
 41 | - This is a {num_rounds}-round game
 42 | - Each player starts with {starting_chips} chips
 43 | - Small blind is {small_blind} chips
 44 | - Big blind is {big_blind} chips
 45 | 
 46 | Game Flow:
 47 | 1. Each player receives 2 hole cards
 48 | 2. Betting rounds: Pre-flop → Flop (3 cards) → Turn (1 card) → River (1 card)
 49 | 3. Players must call the current bet to stay in the hand
 50 | 
 51 | Available Actions:
 52 |   [Check] - When there's no bet to call
 53 |   [Call] - Match the current bet
 54 |   [Fold] - Give up your hand
 55 |   [Bet <amount>] - Make a new bet, e.g. [Bet 100]
 56 |   [Raise <amount>] - Increase the current bet, e.g. [Raise 200]
 57 | 
 58 | Winning:
 59 | - Best poker hand wins the pot
 60 | - Game ends when rounds are complete or a player runs out of chips
 61 | - Player with the most chips at the end wins
 62 | ```
 63 | 
 64 | **Step Observation:**
 65 | During the game, players receive updates about:
 66 | - Their hole cards
 67 | - Visible community cards
 68 | - Current pot size
 69 | - Player chip stacks
 70 | - Betting actions
 71 | - Hand results
 72 | <!-- ```plaintext
 73 | Player 1: [Offer] I give 3 Sheep; You give 2 Wheat.
 74 | ``` -->
 75 | 
 76 | ## Gameplay
 77 | - **Players**: 2
 78 | - **Rounds**: Configurable number of hands to play.
 79 | - **Starting Stack**: Each player begins with a set amount of chips.
 80 | - **Blinds**: Fixed small and big blind amounts
 81 | - **Betting Rounds**: Pre-flop, Flop, Turn, and River.
 82 | - **Objective**: Win the most chips by either showing down the best hand or making opponents fold.
 83 | 
 84 | ## Key Rules
 85 | 1. Hand Structure:
 86 |     - Each player receives 2 private hole cards.
 87 |     - 5 community cards are dealt face-up in stages (3-1-1).
 88 |     - Best 5-card hand wins using any combination of hole and community cards.
 89 | 
 90 | 2. Betting Rounds:
 91 |     - Pre-flop: After hole cards are dealt
 92 |     - Flop: After first 3 community cards
 93 |     - Turn: After 4th community card
 94 |     - River: After 5th community card
 95 | 
 96 | 3. Hand Rankings (Highest to Lowest):
 97 |     - Straight Flush
 98 |     - Four of a Kind
 99 |     - Full House
100 |     - Flush
101 |     - Straight
102 |     - Three of a Kind
103 |     - Two Pair
104 |     - One Pair
105 |     - High Card
106 | 
107 | 4. Valid Actions:
108 |     - Check (when no bet to call)
109 |     - Call (match current bet)
110 |     - Bet (make a new bet)
111 |     - Raise (increase existing bet)
112 |     - Fold (surrender hand)
113 | 
114 | 5. Winning Conditions:
115 |     - **Win:** At the end of the game, the player with the most chips wins.
116 |     - **Draw:** If both players have the same number of chips at the end of the game.
117 |     - **Loss:** If a player makes an invalid move or finish the game with fewer chips than the opponent, they lose.
118 | 
119 | 6. Game Termination:
120 |     - The game ends when the maximum number of turns is reached.
121 |     - The winner is determined based on the change in inventory values.
122 |     - In cases of invalid moves, the game will terminate early with penalties applied.
123 | 
124 | 
125 | ## Rewards
126 | 
127 | | Outcome          | Reward for Player | Reward for Opponent |
128 | |------------------|:-----------------:|:-------------------:|
129 | | **Win**          | `+1`              | `-1`                |
130 | | **Lose**         | `-1`              | `+1`                |
131 | | **Draw**         |  `0`              |  `0`                |
132 | | **Invalid Move** | `-1`              |  `0`                |
133 | 
134 | 
135 | ## Parameters
136 | 
137 | - `num_rounds` (`int`):
138 |     - Number of hands to play
139 |     - Determines game length and strategic depth
140 | 
141 | - `starting_chips` (`int`):
142 |     - Initial chip stack for each player
143 |     - Influences betting decisions and game duration
144 | 
145 | - `small_blind` (`int`):
146 |     - Mandatory small blind bet
147 |     - Sets minimum betting scale
148 | 
149 | - `big_blind` (`int`):
150 |     - Mandatory big blind bet
151 |     - Double the small blind
152 | 
153 | 
154 | 
155 | ## Variants
156 | 
157 | | Env-id                   | num_rounds | starting_chips | small_blind | big_blind |
158 | |--------------------------|:----------:|:--------------:|:-----------:|:---------:|
159 | | `Poker-v0`               |     `5`    |    `1,000`     |    `10`     |    `20`   | 
160 | | `Poker-v0-long`          |    `15`    |    `5,000`     |    `20`     |    `40`   |
161 | | `Poker-v0-super-long`    |    `50`    |   `10,000`     |    `40`     |    `80`   |
162 | 
163 | ## Example Usage
164 | 
165 | ```python
166 | import textarena as ta
167 | 
168 | # Initialize the environment
169 | env = ta.make("Poker-v0")
170 | 
171 | # Wrap for consistent observation handling
172 | env = ta.wrappers.LLMObservationWrapper(env)
173 | 
174 | # Initialize agents
175 | agents = {
176 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4"),
177 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o")
178 | }
179 | 
180 | # Start a new game
181 | observations = env.reset(seed=42)
182 | 
183 | # Game loop
184 | truncated, terminated = False, False
185 | while not (truncated or terminated):
186 |     # Get current player
187 |     current_player = env.get_current_player_id()
188 |     
189 |     # Get player's observation
190 |     observation = observations[current_player]
191 |     
192 |     # Get action from agent
193 |     action = agents[current_player](observation)
194 |     
195 |     # Execute action
196 |     observations, rewards, truncated, terminated, info = env.step(current_player, action)
197 |     
198 | # Print final results
199 | for player_id, agent in agents.items():
200 |     print(f"{agent.model_name}: {rewards[player_id]}")
201 | print(f"Reason: {info['reason']}")
202 | ```
203 | 
204 | ## Troubleshooting
205 | 
206 | - **Invalid Bet Amount:**
207 |     - **Issue:** Player attempts to bet or raise more chips than they have.
208 |     - **Solution:** Ensure bet amount is less than or equal to player's remaining chips.
209 | 
210 | - **Invalid Action Sequence:**
211 |     - **Issue:** Player tries to check when there's a bet to call.
212 |     - **Solution:** Player must either call, raise, or fold when facing a bet.
213 | 
214 | - **Missing Action Token:**
215 |     - **Issue:** Action string doesn't contain a valid action token.
216 |     - **Solution:** Include one of `[Check]`, `[Call]`, `[Fold]`, `[Bet <amount>]`, or `[Raise <amount>]`.
217 | 
218 | ## Version History
219 | - **v0**
220 |   - Initial release 
221 | 
222 | 
223 | 
224 | ### Contact
225 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/Poker/__init__.py

- Extension: .py
- Language: python
- Size: 123 bytes
- Created: 2024-11-18 15:05:25
- Modified: 2024-11-18 15:05:25

### Code

```python
1 | from textarena.envs.two_player.Poker.env import PokerEnv
2 | from textarena.envs.two_player.Poker.render import GameStateRender
```

## File: textarena/envs/two_player/Taboo/test.py

- Extension: .py
- Language: python
- Size: 14071 bytes
- Created: 2024-10-29 16:24:45
- Modified: 2024-10-29 16:24:45

### Code

```python
  1 | import unittest
  2 | from unittest.mock import patch, MagicMock
  3 | from typing import List, Dict, Any
  4 | import textarena as ta
  5 | from textarena.envs.two_players.Taboo import TabooEnv  
  6 | 
  7 | 
  8 | class TestTabooEnv(unittest.TestCase):
  9 |     def setUp(self):
 10 |         
 11 |         
 12 |         self.mock_data = {
 13 |             "animals": {
 14 |                 "elephant": ["trunk", "grey", "large"],
 15 |                 "lion": ["roar", "mane", "king"],
 16 |             },
 17 |             "fruits": {
 18 |                 "apple": ["red", "pie", "fruit"],
 19 |                 "banana": ["yellow", "long", "peel"],
 20 |             },
 21 |         }
 22 | 
 23 |         
 24 |         patcher = patch.object(TabooEnv, '_load_data')
 25 |         self.addCleanup(patcher.stop)
 26 |         self.mock_load_data = patcher.start()
 27 |         self.mock_load_data.side_effect = self._mock_load_data
 28 | 
 29 |         
 30 |         self.env = TabooEnv(
 31 |             categories=["animals"],
 32 |             max_turns=5,
 33 |             data_path=None  
 34 |         )
 35 | 
 36 |     def _mock_load_data(self):
 37 |         
 38 |         self.env.data = {}
 39 |         for category in self.env.categories:
 40 |             if category in self.mock_data:
 41 |                 self.env.data.update(self.mock_data[category])
 42 |             else:
 43 |                 raise ValueError(f"Category '{category}' not found in mock data.")
 44 | 
 45 |     def test_initialization_valid_categories(self):
 46 |         
 47 |         self.assertEqual(self.env.categories, ["animals"])
 48 |         self.assertEqual(self.env.max_turns, 5)
 49 |         self.assertIn("elephant", self.env.data)
 50 |         self.assertIn("lion", self.env.data)
 51 |         self.assertEqual(self.env.data["elephant"], ["trunk", "grey", "large"])
 52 |         self.assertEqual(self.env.data["lion"], ["roar", "mane", "king"])
 53 | 
 54 |     def test_initialization_invalid_category(self):
 55 |         
 56 |         with self.assertRaises(ValueError):
 57 |             TabooEnv(
 58 |                 categories=["invalid_category"],
 59 |                 max_turns=5,
 60 |                 data_path=None
 61 |             )
 62 | 
 63 |     def test_reset_assigns_unique_words(self):
 64 |         
 65 |         observations = self.env.reset(seed=42)
 66 |         secret_words = self.env.state.game_state["word_to_guess"]
 67 |         self.assertIn(secret_words, self.env.data)
 68 |         
 69 |         word_to_guess = self.env.state.game_state["word_to_guess"]
 70 |         taboo_words = self.env.state.game_state["taboo_words"]
 71 |         self.assertIsInstance(word_to_guess, str)
 72 |         self.assertIsInstance(taboo_words, list)
 73 |         self.assertEqual(len(taboo_words), 3)
 74 | 
 75 |     def test_clue_giver_valid_clue(self):
 76 |         
 77 |         self.env.reset(seed=1)  
 78 |         
 79 |         
 80 |         self.env.state.game_state["word_to_guess"] = "elephant"
 81 |         self.env.state.game_state["taboo_words"] = ["trunk", "grey", "large"]
 82 |         self.env.state.role_mapping = {0: "Clue Giver", 1: "Guesser"}
 83 | 
 84 |         clue = "It's a large mammal found in Africa."
 85 |         observations, rewards, truncated, terminated, info = self.env.step(0, clue)
 86 | 
 87 |         
 88 |         self.assertIsNone(rewards)
 89 |         self.assertFalse(truncated)
 90 |         self.assertFalse(terminated)
 91 |         self.assertIsNone(info["reason"])
 92 | 
 93 |     def test_clue_giver_uses_taboo_word(self):
 94 |         
 95 |         self.env.reset(seed=1)
 96 |         self.env.state.game_state["word_to_guess"] = "elephant"
 97 |         self.env.state.game_state["taboo_words"] = ["trunk", "grey", "large"]
 98 |         self.env.state.role_mapping = {0: "Clue Giver", 1: "Guesser"}
 99 | 
100 |         clue = "It's a large animal with a trunk."
101 |         observations, rewards, truncated, terminated, info = self.env.step(0, clue)
102 | 
103 |         
104 |         self.assertIsNotNone(rewards)
105 |         self.assertEqual(rewards, {0: -1, 1: 0})
106 |         self.assertFalse(truncated)
107 |         self.assertTrue(terminated)
108 |         self.assertIn("mentioned a taboo word", info["reason"])
109 | 
110 |     def test_guesser_valid_correct_guess(self):
111 |         
112 |         self.env.reset(seed=1)
113 |         self.env.state.game_state["word_to_guess"] = "lion"
114 |         self.env.state.game_state["taboo_words"] = ["roar", "mane", "king"]
115 |         self.env.state.role_mapping = {0: "Clue Giver", 1: "Guesser"}
116 | 
117 |         
118 |         clue = "It's known as the king of the jungle."
119 |         observations, rewards, truncated, terminated, info = self.env.step(0, clue)
120 |         self.assertIsNone(rewards)
121 |         self.assertFalse(terminated)
122 | 
123 |         
124 |         guess = "[lion]"
125 |         observations, rewards, truncated, terminated, info = self.env.step(1, guess)
126 | 
127 |         
128 |         self.assertIsNotNone(rewards)
129 |         self.assertEqual(rewards, {0: -1, 1: +1})
130 |         self.assertFalse(truncated)
131 |         self.assertTrue(terminated)
132 |         self.assertIn("correctly guessed the word", info["reason"])
133 | 
134 |     def test_guesser_valid_incorrect_guess(self):
135 |         
136 |         self.env.reset(seed=1)
137 |         self.env.state.game_state["word_to_guess"] = "lion"
138 |         self.env.state.game_state["taboo_words"] = ["roar", "mane", "king"]
139 |         self.env.state.role_mapping = {0: "Clue Giver", 1: "Guesser"}
140 | 
141 |         
142 |         clue = "It's known as the king of the jungle."
143 |         observations, rewards, truncated, terminated, info = self.env.step(0, clue)
144 |         self.assertIsNone(rewards)
145 |         self.assertFalse(terminated)
146 | 
147 |         
148 |         guess = "[tiger]"
149 |         observations, rewards, truncated, terminated, info = self.env.step(1, guess)
150 | 
151 |         
152 |         self.assertIsNone(rewards)
153 |         self.assertFalse(truncated)
154 |         self.assertFalse(terminated)
155 |         self.assertIsNone(info["reason"])
156 | 
157 |     def test_guesser_invalid_guess_format(self):
158 |         
159 |         self.env.reset(seed=1)
160 |         self.env.state.game_state["word_to_guess"] = "lion"
161 |         self.env.state.game_state["taboo_words"] = ["roar", "mane", "king"]
162 |         self.env.state.role_mapping = {0: "Clue Giver", 1: "Guesser"}
163 | 
164 |         
165 |         clue = "It's known as the king of the jungle."
166 |         observations, rewards, truncated, terminated, info = self.env.step(0, clue)
167 |         self.assertIsNone(rewards)
168 |         self.assertFalse(terminated)
169 | 
170 |         
171 |         guess = "lion"
172 |         observations, rewards, truncated, terminated, info = self.env.step(1, guess)
173 | 
174 |         
175 |         self.assertIsNotNone(rewards)
176 |         self.assertEqual(rewards, {1: -1, 0: 0})
177 |         self.assertFalse(truncated)
178 |         self.assertTrue(terminated)
179 |         self.assertIn("Invalid guess format", info["reason"])
180 | 
181 |     def test_game_draw_after_max_turns(self):
182 |         
183 |         self.env.reset(seed=1)
184 |         self.env.state.game_state["word_to_guess"] = "lion"
185 |         self.env.state.game_state["taboo_words"] = ["roar", "mane", "king"]
186 |         self.env.state.role_mapping = {0: "Clue Giver", 1: "Guesser"}
187 |         self.env.state.max_turns = 2  
188 | 
189 |         
190 |         clue1 = "It's known as the king of the jungle."
191 |         observations, rewards, truncated, terminated, info = self.env.step(0, clue1)
192 |         self.assertIsNone(rewards)
193 |         self.assertFalse(terminated)
194 | 
195 |         
196 |         guess1 = "[tiger]"
197 |         observations, rewards, truncated, terminated, info = self.env.step(1, guess1)
198 |         self.assertIsNone(rewards)
199 |         self.assertFalse(terminated)
200 | 
201 |         
202 |         clue2 = "It has a majestic mane."
203 |         observations, rewards, truncated, terminated, info = self.env.step(0, clue2)
204 |         self.assertIsNone(rewards)
205 |         self.assertFalse(terminated)
206 | 
207 |         
208 |         guess2 = "[bear]"
209 |         observations, rewards, truncated, terminated, info = self.env.step(1, guess2)
210 |         self.assertIsNotNone(rewards)
211 |         self.assertEqual(rewards, {0: 0, 1: 0})
212 |         self.assertFalse(truncated)
213 |         self.assertTrue(terminated)
214 |         self.assertIn("Maximum number of turns reached", info["reason"])
215 | 
216 |     def test_clue_giver_mentions_target_word(self):
217 |         
218 |         self.env.reset(seed=1)
219 |         self.env.state.game_state["word_to_guess"] = "lion"
220 |         self.env.state.game_state["taboo_words"] = ["roar", "mane", "king"]
221 |         self.env.state.role_mapping = {0: "Clue Giver", 1: "Guesser"}
222 | 
223 |         
224 |         clue = "The animal I'm thinking of is a lion."
225 |         observations, rewards, truncated, terminated, info = self.env.step(0, clue)
226 | 
227 |         
228 |         self.assertIsNotNone(rewards)
229 |         self.assertEqual(rewards, {0: -1, 1: 0})
230 |         self.assertFalse(truncated)
231 |         self.assertTrue(terminated)
232 |         self.assertIn("mentioned a taboo word", info["reason"])
233 | 
234 |     def test_multiple_invalid_moves(self):
235 |         
236 |         self.env.reset(seed=1)
237 |         self.env.state.game_state["word_to_guess"] = "lion"
238 |         self.env.state.game_state["taboo_words"] = ["roar", "mane", "king"]
239 |         self.env.state.role_mapping = {0: "Clue Giver", 1: "Guesser"}
240 | 
241 |         
242 |         clue1 = "It's a lion in the wild."
243 |         observations, rewards, truncated, terminated, info = self.env.step(0, clue1)
244 |         self.assertIsNotNone(rewards)
245 |         self.assertEqual(rewards, {0: -1, 1: 0})
246 |         self.assertTrue(terminated)
247 |         self.assertIn("mentioned a taboo word", info["reason"])
248 | 
249 |         
250 |         guess = "[lion]"
251 |         observations, rewards, truncated, terminated, info = self.env.step(1, guess)
252 |         self.assertIsNone(rewards)
253 |         self.assertTrue(terminated)
254 |         self.assertIsNone(info.get("reason"))
255 | 
256 |     def test_no_taboo_words(self):
257 |         
258 |         
259 |         self.env.data = {
260 |             "empty_taboo": {
261 |                 "sun": []
262 |             }
263 |         }
264 | 
265 |         self.env.reset(seed=1)
266 |         self.env.state.game_state["word_to_guess"] = "sun"
267 |         self.env.state.game_state["taboo_words"] = []
268 |         self.env.state.role_mapping = {0: "Clue Giver", 1: "Guesser"}
269 | 
270 |         
271 |         clue = "It's the center of our solar system."
272 |         observations, rewards, truncated, terminated, info = self.env.step(0, clue)
273 |         self.assertIsNone(rewards)
274 |         self.assertFalse(terminated)
275 | 
276 |         
277 |         guess = "[sun]"
278 |         observations, rewards, truncated, terminated, info = self.env.step(1, guess)
279 |         self.assertIsNotNone(rewards)
280 |         self.assertEqual(rewards, {0: -1, 1: +1})
281 |         self.assertTrue(terminated)
282 |         self.assertIn("correctly guessed the word", info["reason"])
283 | 
284 |     def test_empty_word_list(self):
285 |         
286 |         
287 |         self.env.data = {}
288 |         with self.assertRaises(ValueError):
289 |             self.env.reset()
290 | 
291 |     def test_duplicate_secret_words(self):
292 |         
293 |         
294 |         self.env.data = {
295 |             "animals": {
296 |                 "lion": ["roar", "mane", "king"]
297 |             }
298 |         }
299 | 
300 |         with self.assertRaises(RecursionError):
301 |             
302 |             
303 |             
304 |             self.env.reset()
305 | 
306 |     def test_render_method_runs_without_error(self):
307 |         
308 |         self.env.reset(seed=1)
309 |         try:
310 |             self.env.render()
311 |         except Exception as e:
312 |             self.fail(f"Render method raised an exception: {e}")
313 | 
314 |     def tearDown(self):
315 |         
316 |         pass
317 | 
318 | 
319 | def run_unit_test():
320 |     unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/two_player/Taboo/env.py

- Extension: .py
- Language: python
- Size: 8422 bytes
- Created: 2024-10-29 16:23:09
- Modified: 2024-10-29 16:23:09

### Code

```python
  1 | 
  2 | 
  3 | import os
  4 | import re 
  5 | import json
  6 | import random 
  7 | from typing import Optional, Tuple, Dict, List, Any
  8 | 
  9 | 
 10 | import textarena as ta 
 11 | 
 12 | 
 13 | class TabooEnv(ta.Env):
 14 |     
 15 |     def __init__(
 16 |         self, 
 17 |         categories: List[str],
 18 |         max_turns: Optional[int],
 19 |         data_path: Optional[str]=None
 20 |     ):
 21 |         
 22 | 
 23 |         
 24 |         assert max_turns % 2 == 0, \
 25 |             f"Please use an even number of max turns. Current max_turns: {max_turns}"
 26 | 
 27 | 
 28 | 
 29 |         self.categories = categories
 30 |         self.data_path = data_path 
 31 | 
 32 | 
 33 |         
 34 |         self._load_data()
 35 | 
 36 |         
 37 |         self.state = ta.State(
 38 |             num_players=2,
 39 |             max_turns=max_turns,
 40 |             check_truncated=False,
 41 |             render_keys=["word_to_guess", "taboo_words"],
 42 |             role_mapping={0: "Clue Giver", 1: "Guesser"}
 43 |         )
 44 | 
 45 | 
 46 |     def _load_data(self):
 47 |         
 48 |         if self.data_path is None:
 49 |             self.data_path = os.path.join(
 50 |                 "textarena", "envs", "two_player", "Taboo", "words.json"
 51 |             )
 52 | 
 53 |         
 54 |         with open(self.data_path, "r", encoding="utf-8") as f:
 55 |             full_data = json.load(f)
 56 | 
 57 |         
 58 |         self.data = {}
 59 |         for category in self.categories:
 60 |             self.data.update(full_data[category])
 61 | 
 62 |     def reset(
 63 |         self, seed: Optional[int] = None
 64 |     ) -> Optional[ta.Observations]:
 65 |         
 66 |         if seed is not None:
 67 |             random.seed(seed)
 68 |         else:
 69 |             random.seed()
 70 | 
 71 |         word_to_guess, taboo_words = (
 72 |             random.choice(list(self.data.items()))
 73 |         )
 74 | 
 75 |         return self.state.reset(
 76 |             game_state={
 77 |                 "word_to_guess": word_to_guess,
 78 |                 "taboo_words": taboo_words
 79 |             },
 80 |             player_prompt_function=self._generate_player_prompt
 81 |         )
 82 | 
 83 | 
 84 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[str, Any]) -> str:
 85 |         
 86 |         if self.state.role_mapping[player_id] == "Clue Giver":
 87 |             prompt = (
 88 |                 f"You are Player {player_id}, the Clue Giver in the Taboo game.\n"
 89 |                 f"The word to guess is '{game_state['word_to_guess']}'.\n"
 90 |                 f"Taboo words: {', '.join(game_state['taboo_words'])}.\n"
 91 |                 "Your goal is to provide clues to help the Guesser guess the word without using the taboo words or the word to guess.\n"
 92 |                 f"You have {self.state.max_turns} turns to assist the Guesser.\n"
 93 |                 "On your turn, simply type your clue.\n"
 94 |             )
 95 | 
 96 |         elif self.state.role_mapping[player_id] == "Guesser":
 97 |             prompt = (
 98 |                 f"You are Player {player_id}, the Guesser in the Taboo game.\n"
 99 |                 "Your goal is to guess the secret word based on the clues provided by the Clue Giver.\n"
100 |                 f"You have {self.state.max_turns} turns to guess the word.\n"
101 |                 "On your turn, simply type your guess in squared brackets. For example: '[elephant'].\n"
102 |             )
103 | 
104 |         else:
105 |             
106 |             raise ValueError(f"Unexpected role mapping: {self.state.role_mapping[player_id]}. Expected 'Clue Giver' or 'Guesser'.")
107 | 
108 |         return prompt 
109 | 
110 |     def step(
111 |         self,
112 |         player_id: int,
113 |         action: str,
114 |     ) -> Tuple[
115 |         Optional[ta.Observations], 
116 |         Optional[ta.Rewards], 
117 |         bool, 
118 |         bool, 
119 |         ta.Info, 
120 |     ]:
121 |         
122 |         
123 |         self.state.check_action_format(
124 |             action=action,
125 |             player_id=player_id
126 |         )
127 | 
128 |         
129 |         self.state.add_observation(
130 |             from_id=player_id,
131 |             to_id=-1, 
132 |             message=action,
133 |             for_logging=True
134 |         )
135 | 
136 | 
137 |         
138 |         if self.state.role_mapping[player_id] == "Clue Giver":
139 |             
140 |             forbidden_words = self.state.game_state["taboo_words"] + [
141 |                 self.state.game_state["word_to_guess"]
142 |             ]
143 |             pattern = re.compile(
144 |                 r"\b(" + "|".join(map(re.escape, forbidden_words)) + r")\b",
145 |                 re.IGNORECASE,
146 |             )
147 |             if pattern.search(action):
148 |                 
149 |                 self.state.set_invalid_move(
150 |                     player_ids=[player_id],
151 |                     reasons=[f"The Clue Giver (Player {player_id}) mentioned a taboo word, or the target word."]
152 |                 )
153 |             
154 |         
155 |         elif self.state.role_mapping[player_id] == "Guesser":
156 |             
157 |             guess_pattern = re.compile(r"\[(.*?)\]")
158 |             match = guess_pattern.search(action)
159 |             if not match:
160 |                 
161 |                 self.state.set_invalid_move(
162 |                     player_ids=[player_id],
163 |                     reasons=["Invalid guess format. Please provide your guess within squared brackets, e.g., '[apple]'."]
164 |                 )
165 |                 return self.state.step()
166 | 
167 |             guess = match.group(1).strip().lower()
168 |             correct_word = self.state.game_state["word_to_guess"].lower()
169 | 
170 |             if guess == correct_word:
171 |                 
172 |                 self.state.set_winners(
173 |                     player_ids=[0, 1],
174 |                     reason=f"Player {player_id} (Guesser) correctly guessed the word. Both players win!"
175 |                 )
176 |                 return self.state.step()
177 | 
178 | 
179 |         else:
180 |             
181 |             raise ValueError(f"Unexpected role mapping: {self.state.role_mapping[player_id]}. Expected 'Clue Giver' or 'Guesser'.")
182 | 
183 | 
184 |         return self.state.step()
185 | 
186 | 
187 |     def render(self):
188 |         
189 |         print(f"Turn: {self.state.turn}/{self.state.max_turns if self.state.max_turns else '∞'}")
190 |         print("\nRecent Game Logs:")
191 |         recent_logs = self.state.logs[-5:]  
192 |         for sender_id, log in recent_logs:
193 |             if sender_id == ta.GAME_ID:
194 |                 print(f"[GAME] {log}")
195 |             elif self.state.role_mapping[sender_id] == "Clue Giver":
196 |                 print(f"[Clue Giver (Player {sender_id})]: {log}")
197 |             elif self.state.role_mapping[sender_id] == "Guesser":
198 |                 print(f"[Guesser (Player {sender_id})]: {log}")
199 |         print("\n")
```

## File: textarena/envs/two_player/Taboo/words.json

- Extension: .json
- Language: json
- Size: 147914 bytes
- Created: 2024-10-29 15:39:21
- Modified: 2024-10-07 17:01:47

### Code

```json
   1 | {
   2 |     "animals": {
   3 |         "Alpaca": [
   4 |           "South America",
   5 |           "Camel",
   6 |           "Llama",
   7 |           "Wool"
   8 |         ],
   9 |         "Amazon duck": [
  10 |           "South America",
  11 |           "Donald Duck",
  12 |           "bird",
  13 |           "chicken"
  14 |         ],
  15 |         "Anemonefish": [
  16 |           "shark",
  17 |           "sea",
  18 |           "coral"
  19 |         ],
  20 |         "Anteater": [
  21 |           "forest",
  22 |           "tongue",
  23 |           "long"
  24 |         ],
  25 |         "Antelope": [
  26 |           "hop",
  27 |           "safari",
  28 |           "lion"
  29 |         ],
  30 |         "Arctic wolf": [
  31 |           "dog",
  32 |           "howl",
  33 |           "moon",
  34 |           "ice"
  35 |         ],
  36 |         "Asian elephant": [
  37 |           "dumbo",
  38 |           "Africa",
  39 |           "Asia",
  40 |           "trunk"
  41 |         ],
  42 |         "Badger": [
  43 |           "forest",
  44 |           "marten",
  45 |           "carnivore",
  46 |           "predator"
  47 |         ],
  48 |         "Bahama duck": [
  49 |           "Caribbean",
  50 |           "bird",
  51 |           "Donald Duck",
  52 |           "chicken"
  53 |         ],
  54 |         "Bar-headed goose": [
  55 |           "zebra",
  56 |           "fox",
  57 |           "bird",
  58 |           "swan"
  59 |         ],
  60 |         "Bat": [
  61 |           "ultrasonic",
  62 |           "vampire",
  63 |           "night",
  64 |           "fly"
  65 |         ],
  66 |         "Bear": [
  67 |           "grizzly",
  68 |           "teddy",
  69 |           "ted",
  70 |           "honey",
  71 |           "pooh"
  72 |         ],
  73 |         "Bengal Tiger": [
  74 |           "King",
  75 |           "Striped",
  76 |           "Lion"
  77 |         ],
  78 |         "Bison": [
  79 |           "cattle",
  80 |           "bison",
  81 |           "steppe",
  82 |           "America"
  83 |         ],
  84 |         "Bonobo": [
  85 |           "monkey",
  86 |           "chimpanzee",
  87 |           "baboon",
  88 |           "primate"
  89 |         ],
  90 |         "Brewer's duck": [
  91 |           "Donald Duck",
  92 |           "birds",
  93 |           "water",
  94 |           "swan"
  95 |         ],
  96 |         "Butterfly": [
  97 |           "wings",
  98 |           "flowers",
  99 |           "colorful",
 100 |           "meadow"
 101 |         ],
 102 |         "Cat": [
 103 |           "pet",
 104 |           "dog",
 105 |           "meow",
 106 |           "scratch",
 107 |           "claws"
 108 |         ],
 109 |         "Cheetah": [
 110 |           "fast",
 111 |           "mp\/H",
 112 |           "lion",
 113 |           "Africa",
 114 |           "savannah"
 115 |         ],
 116 |         "Chicken goose": [
 117 |           "fox",
 118 |           "bird",
 119 |           "swan",
 120 |           "eggs"
 121 |         ],
 122 |         "Chicken": [
 123 |           "fox",
 124 |           "bird",
 125 |           "swan",
 126 |           "eggs"
 127 |         ],
 128 |         "Chihuahua": [
 129 |           "Paris Hilton",
 130 |           "dog",
 131 |           "small",
 132 |           "foot horn"
 133 |         ],
 134 |         "Chimpanzee": [
 135 |           "monkey",
 136 |           "human",
 137 |           "intelligent",
 138 |           "primate",
 139 |           "orangutan"
 140 |         ],
 141 |         "Chinchilla": [
 142 |           "small",
 143 |           "mouse",
 144 |           "rat",
 145 |           "America"
 146 |         ],
 147 |         "Coati": [
 148 |           "tree",
 149 |           "climbing",
 150 |           "america"
 151 |         ],
 152 |         "Cow": [
 153 |           "stable",
 154 |           "milk",
 155 |           "udder",
 156 |           "milking",
 157 |           "straw"
 158 |         ],
 159 |         "Crocodile": [
 160 |           "water",
 161 |           "alligator"
 162 |         ],
 163 |         "Dog": [
 164 |           "shepherd",
 165 |           "friend",
 166 |           "pet",
 167 |           "bark",
 168 |           "cat"
 169 |         ],
 170 |         "Dolphin": [
 171 |           "whale",
 172 |           "sea",
 173 |           "intelligent",
 174 |           "porpoise"
 175 |         ],
 176 |         "Dwarf donkey": [
 177 |           "Eeyore",
 178 |           "horse",
 179 |           "stupid",
 180 |           "stubborn"
 181 |         ],
 182 |         "Dwarf Otter": [
 183 |           "marten",
 184 |           "dam",
 185 |           "wood",
 186 |           "water"
 187 |         ],
 188 |         "Dwarf penguin": [
 189 |           "south pole",
 190 |           "arctic",
 191 |           "black",
 192 |           "white"
 193 |         ],
 194 |         "Eagle owl": [
 195 |           "glue",
 196 |           "cautz",
 197 |           "owl",
 198 |           "Harry Potter"
 199 |         ],
 200 |         "Electric eel": [
 201 |           "fish",
 202 |           "water",
 203 |           "river",
 204 |           "long",
 205 |           "electricity"
 206 |         ],
 207 |         "Elephant": [
 208 |           "africa",
 209 |           "india",
 210 |           "trunk",
 211 |           "grey",
 212 |           "huge",
 213 |           "mice"
 214 |         ],
 215 |         "Emperor penguin": [
 216 |           "south pole",
 217 |           "arctic",
 218 |           "yellow",
 219 |           "black",
 220 |           "white"
 221 |         ],
 222 |         "Emu": [
 223 |           "bird",
 224 |           "ostrich",
 225 |           "Australia"
 226 |         ],
 227 |         "Ferret": [
 228 |           "marten",
 229 |           "car",
 230 |           "cable",
 231 |           "lltis"
 232 |         ],
 233 |         "Ferruginous Duck": [
 234 |           "chicken",
 235 |           "swamp"
 236 |         ],
 237 |         "Fish": [
 238 |           "water",
 239 |           "swim",
 240 |           "gills",
 241 |           "whale",
 242 |           "salmon",
 243 |           "fishing"
 244 |         ],
 245 |         "Flamingo": [
 246 |           "pink",
 247 |           "bird"
 248 |         ],
 249 |         "Fox": [
 250 |           "red",
 251 |           "fur",
 252 |           "city",
 253 |           "goose"
 254 |         ],
 255 |         "Frog": [
 256 |           "croak",
 257 |           "water",
 258 |           "toad"
 259 |         ],
 260 |         "Giraffe": [
 261 |           "neck",
 262 |           "long",
 263 |           "elephant",
 264 |           "savannah",
 265 |           "Africa"
 266 |         ],
 267 |         "Goat": [
 268 |           "milk",
 269 |           "stable",
 270 |           "mountain",
 271 |           "horns"
 272 |         ],
 273 |         "Gorilla": [
 274 |           "monkey",
 275 |           "chimpanzee",
 276 |           "gray",
 277 |           "roar",
 278 |           "chest"
 279 |         ],
 280 |         "Grey goose": [
 281 |           "fox",
 282 |           "bird",
 283 |           "swan"
 284 |         ],
 285 |         "Grey parrot": [
 286 |           "colorful",
 287 |           "bird"
 288 |         ],
 289 |         "Grizzly": [
 290 |           "brown",
 291 |           "kodiak",
 292 |           "predator",
 293 |           "north america"
 294 |         ],
 295 |         "Guinea Pig": [
 296 |           "Mouse",
 297 |           "pet",
 298 |           "small",
 299 |           "squeak"
 300 |         ],
 301 |         "Hedgehog": [
 302 |           "spines",
 303 |           "small",
 304 |           "city"
 305 |         ],
 306 |         "Hippopotamus": [
 307 |           "hippopotamus",
 308 |           "water",
 309 |           "giant",
 310 |           "rhino"
 311 |         ],
 312 |         "Horse": [
 313 |           "riding",
 314 |           "saddle",
 315 |           "cow",
 316 |           "trotting race"
 317 |         ],
 318 |         "House donkey": [
 319 |           "Eeyore",
 320 |           "horse",
 321 |           "stupid",
 322 |           "stubborn",
 323 |           "gray"
 324 |         ],
 325 |         "Hyena": [
 326 |           "africa",
 327 |           "savannah",
 328 |           "sneaky"
 329 |         ],
 330 |         "Ice fox": [
 331 |           "white",
 332 |           "summer"
 333 |         ],
 334 |         "Jaguar": [
 335 |           "car brand",
 336 |           "cheetah",
 337 |           "lion",
 338 |           "savannah",
 339 |           "africa"
 340 |         ],
 341 |         "Jellyfish": [
 342 |           "transparent",
 343 |           "water",
 344 |           "sea",
 345 |           "nettles"
 346 |         ],
 347 |         "Kangaroo": [
 348 |           "hopping",
 349 |           "boxing",
 350 |           "Australia",
 351 |           "pouch"
 352 |         ],
 353 |         "King python": [
 354 |           "snake",
 355 |           "big",
 356 |           "snares"
 357 |         ],
 358 |         "Koala": [
 359 |           "Australia",
 360 |           "Eucalyptus",
 361 |           "Tree"
 362 |         ],
 363 |         "Leopard": [
 364 |           "cheetah",
 365 |           "cat",
 366 |           "predator"
 367 |         ],
 368 |         "Lion": [
 369 |           "king",
 370 |           "tiger",
 371 |           "cheetah",
 372 |           "Africa",
 373 |           "savannah"
 374 |         ],
 375 |         "Llama": [
 376 |           "spitting",
 377 |           "south america",
 378 |           "guanaco"
 379 |         ],
 380 |         "Maine Coon": [
 381 |           "cat",
 382 |           "fur",
 383 |           "fluff",
 384 |           "claws",
 385 |           "meow"
 386 |         ],
 387 |         "Mandrill": [
 388 |           "primate",
 389 |           "monkey",
 390 |           "butt",
 391 |           "gorilla"
 392 |         ],
 393 |         "Meerkat": [
 394 |           "burrows",
 395 |           "ground",
 396 |           "dig",
 397 |           "stand"
 398 |         ],
 399 |         "Mouse": [
 400 |           "rodent",
 401 |           "rat",
 402 |           "small"
 403 |         ],
 404 |         "Musk ox": [
 405 |           "scent",
 406 |           "perfume",
 407 |           "cattle",
 408 |           "bull"
 409 |         ],
 410 |         "Orangutan": [
 411 |           "orange",
 412 |           "monkey",
 413 |           "primate",
 414 |           "chimpanzee"
 415 |         ],
 416 |         "Otter": [
 417 |           "water",
 418 |           "dam",
 419 |           "wood"
 420 |         ],
 421 |         "Ox": [
 422 |           "cow",
 423 |           "bull",
 424 |           "ring",
 425 |           "nose"
 426 |         ],
 427 |         "Panda": [
 428 |           "black",
 429 |           "white",
 430 |           "clumsy",
 431 |           "China",
 432 |           "bear"
 433 |         ],
 434 |         "Parrot": [
 435 |           "colorful",
 436 |           "red",
 437 |           "bird",
 438 |           "beak"
 439 |         ],
 440 |         "Penguin": [
 441 |           "south pole",
 442 |           "arctic",
 443 |           "yellow",
 444 |           "black",
 445 |           "white"
 446 |         ],
 447 |         "Polar bear": [
 448 |           "grizzly",
 449 |           "teddy",
 450 |           "white",
 451 |           "north pole",
 452 |           "pooh"
 453 |         ],
 454 |         "Rabbit": [
 455 |           "Pet",
 456 |           "Bunny",
 457 |           "Lout",
 458 |           ""
 459 |         ],
 460 |         "Raccoon": [
 461 |           "teddy",
 462 |           "grizzly",
 463 |           "garbage can"
 464 |         ],
 465 |         "Red fox": [
 466 |           "fur",
 467 |           "city",
 468 |           "goose"
 469 |         ],
 470 |         "Reindeer": [
 471 |           "santa claus",
 472 |           "rudolf",
 473 |           "nose",
 474 |           "red",
 475 |           "deer"
 476 |         ],
 477 |         "Rhino": [
 478 |           "hippopotamus",
 479 |           "elephant",
 480 |           "Africa",
 481 |           "savannah"
 482 |         ],
 483 |         "Rock pigeon": [
 484 |           "flying rat",
 485 |           "rock",
 486 |           "gray",
 487 |           "cooing"
 488 |         ],
 489 |         "Royal tiger": [
 490 |           "lion",
 491 |           "big cat"
 492 |         ],
 493 |         "Seahorse": [
 494 |           "water",
 495 |           "sea",
 496 |           "small",
 497 |           "saddle"
 498 |         ],
 499 |         "Seal": [
 500 |           "tricks",
 501 |           "balancing",
 502 |           "water",
 503 |           "sea",
 504 |           "cat"
 505 |         ],
 506 |         "Shark": [
 507 |           "water",
 508 |           "teeth",
 509 |           "surfer",
 510 |           "tornado"
 511 |         ],
 512 |         "Sheepdog": [
 513 |           "police",
 514 |           "friend",
 515 |           "pet",
 516 |           "bark",
 517 |           "cat"
 518 |         ],
 519 |         "Snail": [
 520 |           "slime",
 521 |           "house",
 522 |           "small",
 523 |           "slow"
 524 |         ],
 525 |         "Snow leopard": [
 526 |           "white",
 527 |           "mountain",
 528 |           "cheetah"
 529 |         ],
 530 |         "Snowy owl": [
 531 |           "white",
 532 |           "eagle owl",
 533 |           "head",
 534 |           "bird"
 535 |         ],
 536 |         "Spectacled bear": [
 537 |           "Fielmann",
 538 |           "Grizzly",
 539 |           "America"
 540 |         ],
 541 |         "Spectacled penguin": [
 542 |           "Arctic",
 543 |           "South Pole"
 544 |         ],
 545 |         "Spider": [
 546 |           "web",
 547 |           "fly",
 548 |           "legs",
 549 |           "cellar"
 550 |         ],
 551 |         "Squirrel": [
 552 |           "Forest",
 553 |           "tree",
 554 |           "nuts",
 555 |           "hibernate",
 556 |           "brown"
 557 |         ],
 558 |         "Stone chicken": [
 559 |           "fox",
 560 |           "bird",
 561 |           "swan",
 562 |           "eggs",
 563 |           "gray"
 564 |         ],
 565 |         "Sturgeon catfish": [
 566 |           "fish",
 567 |           "gills"
 568 |         ],
 569 |         "Tank rhinoceros": [
 570 |           "hippopotamus",
 571 |           "elephant",
 572 |           "africa",
 573 |           "savannah",
 574 |           "war"
 575 |         ],
 576 |         "Toad": [
 577 |           "frog",
 578 |           "croak"
 579 |         ],
 580 |         "Walrus": [
 581 |           "water",
 582 |           "horse",
 583 |           "sea",
 584 |           "tusks"
 585 |         ],
 586 |         "Wasp": [
 587 |           "bee",
 588 |           "honey",
 589 |           "sting",
 590 |           "black",
 591 |           "yellow"
 592 |         ],
 593 |         "White rhino": [
 594 |           "mouth",
 595 |           "high",
 596 |           "Africa",
 597 |           "savannah"
 598 |         ],
 599 |         "Wild dog": [
 600 |           "shepherd",
 601 |           "cat",
 602 |           "forest"
 603 |         ],
 604 |         "Wolf": [
 605 |           "wild",
 606 |           "dog",
 607 |           "howl",
 608 |           "moon",
 609 |           "pack"
 610 |         ],
 611 |         "Yak": [
 612 |           "cow",
 613 |           "horns",
 614 |           "asia",
 615 |           "cow"
 616 |         ],
 617 |         "Zebra": [
 618 |           "strip",
 619 |           "elephant",
 620 |           "giraffe",
 621 |           "black",
 622 |           "white",
 623 |           "africa"
 624 |         ]
 625 |     }, "cars": {
 626 |         "Alfa Romeo": [
 627 |           "Italy",
 628 |           "Turin",
 629 |           "Fiat"
 630 |         ],
 631 |         "BMW Alpina": [
 632 |           "Germany",
 633 |           "tuning",
 634 |           "motorsport",
 635 |           "Bavaria"
 636 |         ],
 637 |         "Aston Martin": [
 638 |           "007",
 639 |           "James Bond",
 640 |           "England",
 641 |           "sports car",
 642 |           "luxury"
 643 |         ],
 644 |         "Audi": [
 645 |           "Germany",
 646 |           "Ingolstadt",
 647 |           "rings",
 648 |           "Volkswagen"
 649 |         ],
 650 |         "Bentley": [
 651 |           "luxury",
 652 |           "England",
 653 |           "Rolls-Royce"
 654 |         ],
 655 |         "BMW": [
 656 |           "Germany",
 657 |           "Mercedes Benz"
 658 |         ],
 659 |         "Bugatti": [
 660 |           "luxury",
 661 |           "sports car",
 662 |           "Volkswagen",
 663 |           "France"
 664 |         ],
 665 |         "Buick": [
 666 |           "America",
 667 |           "United States",
 668 |           "General Motors"
 669 |         ],
 670 |         "Cadillac": [
 671 |           "America",
 672 |           "United States",
 673 |           "General Motors"
 674 |         ],
 675 |         "Chevrolet": [
 676 |           "America",
 677 |           "United States",
 678 |           "General Motors",
 679 |           "Camaro",
 680 |           "Transformers"
 681 |         ],
 682 |         "Chrysler": [
 683 |           "America",
 684 |           "United States",
 685 |           "Dodge"
 686 |         ],
 687 |         "Citroën": [
 688 |           "France",
 689 |           "Peugeot",
 690 |           "small cars"
 691 |         ],
 692 |         "Corvette": [
 693 |           "America",
 694 |           "United States",
 695 |           "sports car"
 696 |         ],
 697 |         "Dacia": [
 698 |           "Romania",
 699 |           "small cars",
 700 |           "cheap",
 701 |           "Duster"
 702 |         ],
 703 |         "Daewoo": [
 704 |           "South Korea",
 705 |           "small cars",
 706 |           "General Motors"
 707 |         ],
 708 |         "DAF": [
 709 |           "trucks",
 710 |           "big rig",
 711 |           "Netherlands",
 712 |           "cargo"
 713 |         ],
 714 |         "Daihatsu": [
 715 |           "Japan",
 716 |           "Toyota",
 717 |           "small cars"
 718 |         ],
 719 |         "De Lorean": [
 720 |           "time machine",
 721 |           "GMC",
 722 |           "Back to the Future",
 723 |           "Marty McFly"
 724 |         ],
 725 |         "De Tomaso": [
 726 |           "Italy",
 727 |           "sports car"
 728 |         ],
 729 |         "Dodge": [
 730 |           "Viper",
 731 |           "America",
 732 |           "United States",
 733 |           "General Motors"
 734 |         ],
 735 |         "Ferrari": [
 736 |           "Italy",
 737 |           "red",
 738 |           "sports car",
 739 |           "luxury",
 740 |           "Michael Schumacher",
 741 |           "Enzo"
 742 |         ],
 743 |         "Fiat": [
 744 |           "Turin",
 745 |           "Italy"
 746 |         ],
 747 |         "Ford": [
 748 |           "America",
 749 |           "United States",
 750 |           "Henry",
 751 |           "F-150",
 752 |           "assembly line"
 753 |         ],
 754 |         "GAZ": [
 755 |           "Russia",
 756 |           "Soviet Union"
 757 |         ],
 758 |         "GMC": [
 759 |           "General Motors",
 760 |           "United States",
 761 |           "multicorporate enterprise"
 762 |         ],
 763 |         "Holden": [
 764 |           "Australia",
 765 |           "General Motors"
 766 |         ],
 767 |         "Honda": [
 768 |           "Japan",
 769 |           "Mitsubishi",
 770 |           "Civic"
 771 |         ],
 772 |         "Hummer": [
 773 |           "Army",
 774 |           "United States",
 775 |           "America"
 776 |         ],
 777 |         "Hyundai": [
 778 |           "South Korea"
 779 |         ],
 780 |         "Infiniti": [
 781 |           "Nissan",
 782 |           "Japan",
 783 |           "luxury"
 784 |         ],
 785 |         "Isuzu": [
 786 |           "Japan",
 787 |           "trucks",
 788 |           "big rig",
 789 |           "cargo"
 790 |         ],
 791 |         "Iveco": [
 792 |           "Italy",
 793 |           "trucks",
 794 |           "big rig",
 795 |           "cargo"
 796 |         ],
 797 |         "Jaguar": [
 798 |           "England",
 799 |           "Land Rover",
 800 |           "luxury",
 801 |           "sports car"
 802 |         ],
 803 |         "Jeep": [
 804 |           "Chrysler",
 805 |           "Army",
 806 |           "America",
 807 |           "United States"
 808 |         ],
 809 |         "Kia": [
 810 |           "South Korea",
 811 |           "Hyundai"
 812 |         ],
 813 |         "Königsegg": [
 814 |           "Sweden",
 815 |           "luxury",
 816 |           "sports car"
 817 |         ],
 818 |         "Lada": [
 819 |           "Russia",
 820 |           "small cars"
 821 |         ],
 822 |         "Lamborghini": [
 823 |           "Italy",
 824 |           "sports car",
 825 |           "luxury",
 826 |           "Volkswagen"
 827 |         ],
 828 |         "Lancia": [
 829 |           "Italy",
 830 |           "small cars",
 831 |           "Fiat"
 832 |         ],
 833 |         "Land Rover": [
 834 |           "England",
 835 |           "Scotland",
 836 |           "Jaguar",
 837 |           "Jeep",
 838 |           "AWD"
 839 |         ],
 840 |         "Lexus": [
 841 |           "Toyota",
 842 |           "luxury",
 843 |           "Japan"
 844 |         ],
 845 |         "Lincoln": [
 846 |           "America",
 847 |           "United States",
 848 |           "Ford",
 849 |           "luxury"
 850 |         ],
 851 |         "Lotus": [
 852 |           "England",
 853 |           "sports car"
 854 |         ],
 855 |         "Maserati": [
 856 |           "Italy",
 857 |           "Fiat",
 858 |           "sports car",
 859 |           "luxury"
 860 |         ],
 861 |         "Maybach": [
 862 |           "Germany",
 863 |           "Mercedes",
 864 |           "luxury"
 865 |         ],
 866 |         "Mazda": [
 867 |           "Japan",
 868 |           "Hiroshima"
 869 |         ],
 870 |         "McLaren": [
 871 |           "England",
 872 |           "luxury",
 873 |           "sports car",
 874 |           "luxury"
 875 |         ],
 876 |         "Mercedes-AMG": [
 877 |           "Germany",
 878 |           "luxury",
 879 |           "tuning"
 880 |         ],
 881 |         "Mercedes-Benz": [
 882 |           "Germany",
 883 |           "Daimler",
 884 |           "Chrysler"
 885 |         ],
 886 |         "MG": [
 887 |           "England"
 888 |         ],
 889 |         "Mini": [
 890 |           "Germany",
 891 |           "England",
 892 |           "BMW",
 893 |           "small",
 894 |           "Mr Bean"
 895 |         ],
 896 |         "Mitsubishi": [
 897 |           "Japan",
 898 |           "Lancer",
 899 |           "Rally"
 900 |         ],
 901 |         "Morgan": [
 902 |           "sports car",
 903 |           "England"
 904 |         ],
 905 |         "Moskwitsch": [
 906 |           "Russia",
 907 |           "Sowjet",
 908 |           "DDR"
 909 |         ],
 910 |         "Nissan": [
 911 |           "Japan",
 912 |           "Skyline",
 913 |           "Datsun"
 914 |         ],
 915 |         "Oldsmobile": [
 916 |           "America",
 917 |           "United States",
 918 |           "General Motors"
 919 |         ],
 920 |         "Opel": [
 921 |           "Germany",
 922 |           "Rüsselsheim",
 923 |           "Vauxhall"
 924 |         ],
 925 |         "Pagani": [
 926 |           "Italy",
 927 |           "sports car",
 928 |           "luxury",
 929 |           "expensive"
 930 |         ],
 931 |         "Peugeot": [
 932 |           "France",
 933 |           "bicycles",
 934 |           "motorcycle"
 935 |         ],
 936 |         "Piaggio": [
 937 |           "Italy",
 938 |           "motorcycles",
 939 |           "moped",
 940 |           "Vespa"
 941 |         ],
 942 |         "Plymouth": [
 943 |           "United States",
 944 |           "Chrysler"
 945 |         ],
 946 |         "Polaris": [
 947 |           "America",
 948 |           "United States",
 949 |           "quads",
 950 |           "snow mobile"
 951 |         ],
 952 |         "Pontiac": [
 953 |           "General Motors",
 954 |           "United States",
 955 |           "America"
 956 |         ],
 957 |         "Porsche": [
 958 |           "Germany",
 959 |           "Stuttgart",
 960 |           "911",
 961 |           "Volkswagen"
 962 |         ],
 963 |         "Renault": [
 964 |           "France",
 965 |           "small cars",
 966 |           "Nissan"
 967 |         ],
 968 |         "Rolls Royce": [
 969 |           "England",
 970 |           "Queen",
 971 |           "luxury",
 972 |           "limousine"
 973 |         ],
 974 |         "Rover": [
 975 |           "England",
 976 |           "Tata",
 977 |           "small cars",
 978 |           "BWM"
 979 |         ],
 980 |         "Saab": [
 981 |           "Sweden",
 982 |           "Scania",
 983 |           "Stockholm"
 984 |         ],
 985 |         "Seat": [
 986 |           "Spanien",
 987 |           "small cars",
 988 |           "Volkswagen"
 989 |         ],
 990 |         "Scania": [
 991 |           "Sweden",
 992 |           "trucks",
 993 |           "big rig",
 994 |           "cargo"
 995 |         ],
 996 |         "Skoda": [
 997 |           "Tschechien",
 998 |           "Volkswagen",
 999 |           "small cars"
1000 |         ],
1001 |         "Smart": [
1002 |           "Germany",
1003 |           "small",
1004 |           "parking space",
1005 |           "Mercedes",
1006 |           "Daimler"
1007 |         ],
1008 |         "Subaru": [
1009 |           "Japan",
1010 |           "Impereza",
1011 |           "Rally"
1012 |         ],
1013 |         "Suzuki": [
1014 |           "Japan",
1015 |           "motorbikes",
1016 |           "Honda"
1017 |         ],
1018 |         "Tesla": [
1019 |           "Elon Musk",
1020 |           "United States",
1021 |           "electric",
1022 |           "sexy"
1023 |         ],
1024 |         "Toyota": [
1025 |           "multicorporate enterprise",
1026 |           "Japan",
1027 |           "Yaris",
1028 |           "Avensis"
1029 |         ],
1030 |         "Trabant": [
1031 |           "Trabbi",
1032 |           "DDR",
1033 |           "VEB",
1034 |           "Germany",
1035 |           "Zwickau"
1036 |         ],
1037 |         "Triumph": [
1038 |           "England",
1039 |           "Motorräder"
1040 |         ],
1041 |         "TVR": [
1042 |           "England",
1043 |           "sports car"
1044 |         ],
1045 |         "UAZ": [
1046 |           "Russia",
1047 |           "Soviet Union",
1048 |           "trucks",
1049 |           "big rig",
1050 |           "cargo"
1051 |         ],
1052 |         "Vauxhall": [
1053 |           "Opel",
1054 |           "England"
1055 |         ],
1056 |         "Volvo": [
1057 |           "Sweden",
1058 |           "trucks",
1059 |           "big rig",
1060 |           "Ford",
1061 |           "cargo"
1062 |         ],
1063 |         "Volkswagen": [
1064 |           "Germany",
1065 |           "Golf",
1066 |           "Passat",
1067 |           "Audi",
1068 |           "Wolfsburg",
1069 |           "multicorporate enterprise"
1070 |         ],
1071 |         "Wartburg": [
1072 |           "Lada",
1073 |           "DDR",
1074 |           "Russia",
1075 |           "Trabbi",
1076 |           "Germany"
1077 |         ]
1078 |     }, "city/country": {
1079 |         "Afghanistan": [
1080 |           "Asia",
1081 |           "Southern Asia",
1082 |           "Kabul"
1083 |         ],
1084 |         "Åland Islands": [
1085 |           "Europe",
1086 |           "Northern Europe",
1087 |           "Mariehamn"
1088 |         ],
1089 |         "Albania": [
1090 |           "Europe",
1091 |           "Southern Europe",
1092 |           "Tirana"
1093 |         ],
1094 |         "Algeria": [
1095 |           "Africa",
1096 |           "Northern Africa",
1097 |           "Algiers"
1098 |         ],
1099 |         "American Samoa": [
1100 |           "Oceania",
1101 |           "Polynesia",
1102 |           "Pago Pago"
1103 |         ],
1104 |         "Andorra": [
1105 |           "Europe",
1106 |           "Southern Europe",
1107 |           "Andorra la Vella"
1108 |         ],
1109 |         "Angola": [
1110 |           "Africa",
1111 |           "Middle Africa",
1112 |           "Luanda"
1113 |         ],
1114 |         "Anguilla": [
1115 |           "Americas",
1116 |           "Caribbean",
1117 |           "The Valley"
1118 |         ],
1119 |         "Antarctica": [
1120 |           "Polar"
1121 |         ],
1122 |         "Antigua and Barbuda": [
1123 |           "Americas",
1124 |           "Caribbean",
1125 |           "Saint John's"
1126 |         ],
1127 |         "Argentina": [
1128 |           "Americas",
1129 |           "South America",
1130 |           "Buenos Aires"
1131 |         ],
1132 |         "Armenia": [
1133 |           "Asia",
1134 |           "Western Asia",
1135 |           "Yerevan"
1136 |         ],
1137 |         "Aruba": [
1138 |           "Americas",
1139 |           "Caribbean",
1140 |           "Oranjestad"
1141 |         ],
1142 |         "Australia": [
1143 |           "Oceania",
1144 |           "Australia and New Zealand",
1145 |           "Canberra"
1146 |         ],
1147 |         "Austria": [
1148 |           "Europe",
1149 |           "Western Europe",
1150 |           "Vienna"
1151 |         ],
1152 |         "Azerbaijan": [
1153 |           "Asia",
1154 |           "Western Asia",
1155 |           "Baku"
1156 |         ],
1157 |         "Bahamas": [
1158 |           "Americas",
1159 |           "Caribbean",
1160 |           "Nassau"
1161 |         ],
1162 |         "Bahrain": [
1163 |           "Asia",
1164 |           "Western Asia",
1165 |           "Manama"
1166 |         ],
1167 |         "Bangladesh": [
1168 |           "Asia",
1169 |           "Southern Asia",
1170 |           "Dhaka"
1171 |         ],
1172 |         "Barbados": [
1173 |           "Americas",
1174 |           "Caribbean",
1175 |           "Bridgetown"
1176 |         ],
1177 |         "Belarus": [
1178 |           "Europe",
1179 |           "Eastern Europe",
1180 |           "Minsk"
1181 |         ],
1182 |         "Belgium": [
1183 |           "Europe",
1184 |           "Western Europe",
1185 |           "Brussels"
1186 |         ],
1187 |         "Belize": [
1188 |           "Americas",
1189 |           "Central America",
1190 |           "Belmopan"
1191 |         ],
1192 |         "Benin": [
1193 |           "Africa",
1194 |           "Western Africa",
1195 |           "Porto-Novo"
1196 |         ],
1197 |         "Bermuda": [
1198 |           "Americas",
1199 |           "Northern America",
1200 |           "Hamilton"
1201 |         ],
1202 |         "Bhutan": [
1203 |           "Asia",
1204 |           "Southern Asia",
1205 |           "Thimphu"
1206 |         ],
1207 |         "Bolivia (Plurinational State of)": [
1208 |           "Americas",
1209 |           "South America",
1210 |           "Sucre"
1211 |         ],
1212 |         "Bonaire, Sint Eustatius and Saba": [
1213 |           "Americas",
1214 |           "Caribbean",
1215 |           "Kralendijk"
1216 |         ],
1217 |         "Bosnia and Herzegovina": [
1218 |           "Europe",
1219 |           "Southern Europe",
1220 |           "Sarajevo"
1221 |         ],
1222 |         "Botswana": [
1223 |           "Africa",
1224 |           "Southern Africa",
1225 |           "Gaborone"
1226 |         ],
1227 |         "Bouvet Island": [],
1228 |         "Brazil": [
1229 |           "Americas",
1230 |           "South America",
1231 |           "Brasília"
1232 |         ],
1233 |         "British Indian Ocean Territory": [
1234 |           "Africa",
1235 |           "Eastern Africa",
1236 |           "Diego Garcia"
1237 |         ],
1238 |         "United States Minor Outlying Islands": [
1239 |           "Americas",
1240 |           "Northern America"
1241 |         ],
1242 |         "Virgin Islands (British)": [
1243 |           "Americas",
1244 |           "Caribbean",
1245 |           "Road Town"
1246 |         ],
1247 |         "Virgin Islands (U.S.)": [
1248 |           "Americas",
1249 |           "Caribbean",
1250 |           "Charlotte Amalie"
1251 |         ],
1252 |         "Brunei Darussalam": [
1253 |           "Asia",
1254 |           "South-Eastern Asia",
1255 |           "Bandar Seri Begawan"
1256 |         ],
1257 |         "Bulgaria": [
1258 |           "Europe",
1259 |           "Eastern Europe",
1260 |           "Sofia"
1261 |         ],
1262 |         "Burkina Faso": [
1263 |           "Africa",
1264 |           "Western Africa",
1265 |           "Ouagadougou"
1266 |         ],
1267 |         "Burundi": [
1268 |           "Africa",
1269 |           "Eastern Africa",
1270 |           "Bujumbura"
1271 |         ],
1272 |         "Cambodia": [
1273 |           "Asia",
1274 |           "South-Eastern Asia",
1275 |           "Phnom Penh"
1276 |         ],
1277 |         "Cameroon": [
1278 |           "Africa",
1279 |           "Middle Africa",
1280 |           "Yaoundé"
1281 |         ],
1282 |         "Canada": [
1283 |           "Americas",
1284 |           "Northern America",
1285 |           "Ottawa"
1286 |         ],
1287 |         "Cabo Verde": [
1288 |           "Africa",
1289 |           "Western Africa",
1290 |           "Praia"
1291 |         ],
1292 |         "Cayman Islands": [
1293 |           "Americas",
1294 |           "Caribbean",
1295 |           "George Town"
1296 |         ],
1297 |         "Central African Republic": [
1298 |           "Africa",
1299 |           "Middle Africa",
1300 |           "Bangui"
1301 |         ],
1302 |         "Chad": [
1303 |           "Africa",
1304 |           "Middle Africa",
1305 |           "N'Djamena"
1306 |         ],
1307 |         "Chile": [
1308 |           "Americas",
1309 |           "South America",
1310 |           "Santiago"
1311 |         ],
1312 |         "China": [
1313 |           "Asia",
1314 |           "Eastern Asia",
1315 |           "Beijing",
1316 |           "Hong Kong"
1317 |         ],
1318 |         "Christmas Island": [
1319 |           "Oceania",
1320 |           "Australia and New Zealand",
1321 |           "Flying Fish Cove"
1322 |         ],
1323 |         "Cocos (Keeling) Islands": [
1324 |           "Oceania",
1325 |           "Australia and New Zealand",
1326 |           "West Island"
1327 |         ],
1328 |         "Colombia": [
1329 |           "Americas",
1330 |           "South America",
1331 |           "Bogotá"
1332 |         ],
1333 |         "Comoros": [
1334 |           "Africa",
1335 |           "Eastern Africa",
1336 |           "Moroni"
1337 |         ],
1338 |         "Congo": [
1339 |           "Africa",
1340 |           "Middle Africa",
1341 |           "Brazzaville"
1342 |         ],
1343 |         "Congo (Democratic Republic of the)": [
1344 |           "Africa",
1345 |           "Middle Africa",
1346 |           "Kinshasa"
1347 |         ],
1348 |         "Cook Islands": [
1349 |           "Oceania",
1350 |           "Polynesia",
1351 |           "Avarua"
1352 |         ],
1353 |         "Costa Rica": [
1354 |           "Americas",
1355 |           "Central America",
1356 |           "San José"
1357 |         ],
1358 |         "Croatia": [
1359 |           "Europe",
1360 |           "Southern Europe",
1361 |           "Zagreb"
1362 |         ],
1363 |         "Cuba": [
1364 |           "Americas",
1365 |           "Caribbean",
1366 |           "Havana"
1367 |         ],
1368 |         "Curaçao": [
1369 |           "Americas",
1370 |           "Caribbean",
1371 |           "Willemstad"
1372 |         ],
1373 |         "Cyprus": [
1374 |           "Europe",
1375 |           "Southern Europe",
1376 |           "Nicosia"
1377 |         ],
1378 |         "Czech Republic": [
1379 |           "Europe",
1380 |           "Eastern Europe",
1381 |           "Prague"
1382 |         ],
1383 |         "Denmark": [
1384 |           "Europe",
1385 |           "Northern Europe",
1386 |           "Copenhagen",
1387 |           "Lego"
1388 |         ],
1389 |         "Djibouti": [
1390 |           "Africa",
1391 |           "Eastern Africa",
1392 |           "Djibouti"
1393 |         ],
1394 |         "Dominica": [
1395 |           "Americas",
1396 |           "Caribbean",
1397 |           "Roseau"
1398 |         ],
1399 |         "Dominican Republic": [
1400 |           "Americas",
1401 |           "Caribbean",
1402 |           "Santo Domingo"
1403 |         ],
1404 |         "Ecuador": [
1405 |           "Americas",
1406 |           "South America",
1407 |           "Quito"
1408 |         ],
1409 |         "Egypt": [
1410 |           "Africa",
1411 |           "Northern Africa",
1412 |           "Cairo"
1413 |         ],
1414 |         "El Salvador": [
1415 |           "Americas",
1416 |           "Central America",
1417 |           "San Salvador"
1418 |         ],
1419 |         "Equatorial Guinea": [
1420 |           "Africa",
1421 |           "Middle Africa",
1422 |           "Malabo"
1423 |         ],
1424 |         "Eritrea": [
1425 |           "Africa",
1426 |           "Eastern Africa",
1427 |           "Asmara"
1428 |         ],
1429 |         "Estonia": [
1430 |           "Europe",
1431 |           "Northern Europe",
1432 |           "Tallinn"
1433 |         ],
1434 |         "Ethiopia": [
1435 |           "Africa",
1436 |           "Eastern Africa",
1437 |           "Addis Ababa"
1438 |         ],
1439 |         "Falkland Islands (Malvinas)": [
1440 |           "Americas",
1441 |           "South America",
1442 |           "Stanley"
1443 |         ],
1444 |         "Faroe Islands": [
1445 |           "Europe",
1446 |           "Northern Europe",
1447 |           "Tórshavn"
1448 |         ],
1449 |         "Fiji": [
1450 |           "Oceania",
1451 |           "Melanesia",
1452 |           "Suva"
1453 |         ],
1454 |         "Finland": [
1455 |           "Europe",
1456 |           "Northern Europe",
1457 |           "Helsinki"
1458 |         ],
1459 |         "France": [
1460 |           "Europe",
1461 |           "Western Europe",
1462 |           "Paris",
1463 |           "Eiffel Tower"
1464 |         ],
1465 |         "French Guiana": [
1466 |           "Americas",
1467 |           "South America",
1468 |           "Cayenne"
1469 |         ],
1470 |         "French Polynesia": [
1471 |           "Oceania",
1472 |           "Polynesia",
1473 |           "Papeetē"
1474 |         ],
1475 |         "French Southern Territories": [
1476 |           "Africa",
1477 |           "Southern Africa",
1478 |           "Port-aux-Français"
1479 |         ],
1480 |         "Gabon": [
1481 |           "Africa",
1482 |           "Middle Africa",
1483 |           "Libreville"
1484 |         ],
1485 |         "Gambia": [
1486 |           "Africa",
1487 |           "Western Africa",
1488 |           "Banjul"
1489 |         ],
1490 |         "Georgia": [
1491 |           "Asia",
1492 |           "Western Asia",
1493 |           "Tbilisi"
1494 |         ],
1495 |         "Germany": [
1496 |           "Europe",
1497 |           "Western Europe",
1498 |           "Berlin",
1499 |           "Munich",
1500 |           "Hamburg"
1501 |         ],
1502 |         "Ghana": [
1503 |           "Africa",
1504 |           "Western Africa",
1505 |           "Accra"
1506 |         ],
1507 |         "Gibraltar": [
1508 |           "Europe",
1509 |           "Southern Europe",
1510 |           "Gibraltar"
1511 |         ],
1512 |         "Greece": [
1513 |           "Europe",
1514 |           "Southern Europe",
1515 |           "Athens"
1516 |         ],
1517 |         "Greenland": [
1518 |           "Americas",
1519 |           "Northern America",
1520 |           "Nuuk"
1521 |         ],
1522 |         "Grenada": [
1523 |           "Americas",
1524 |           "Caribbean",
1525 |           "St. George's"
1526 |         ],
1527 |         "Guadeloupe": [
1528 |           "Americas",
1529 |           "Caribbean",
1530 |           "Basse-Terre"
1531 |         ],
1532 |         "Guam": [
1533 |           "Oceania",
1534 |           "Micronesia",
1535 |           "Hagåtña"
1536 |         ],
1537 |         "Guatemala": [
1538 |           "Americas",
1539 |           "Central America",
1540 |           "Guatemala City"
1541 |         ],
1542 |         "Guernsey": [
1543 |           "Europe",
1544 |           "Northern Europe",
1545 |           "St. Peter Port"
1546 |         ],
1547 |         "Guinea": [
1548 |           "Africa",
1549 |           "Western Africa",
1550 |           "Conakry"
1551 |         ],
1552 |         "Guinea-Bissau": [
1553 |           "Africa",
1554 |           "Western Africa",
1555 |           "Bissau"
1556 |         ],
1557 |         "Guyana": [
1558 |           "Americas",
1559 |           "South America",
1560 |           "Georgetown"
1561 |         ],
1562 |         "Haiti": [
1563 |           "Americas",
1564 |           "Caribbean",
1565 |           "Port-au-Prince"
1566 |         ],
1567 |         "Heard Island and McDonald Islands": [],
1568 |         "Holy See": [
1569 |           "Europe",
1570 |           "Southern Europe",
1571 |           "Rome"
1572 |         ],
1573 |         "Honduras": [
1574 |           "Americas",
1575 |           "Central America",
1576 |           "Tegucigalpa"
1577 |         ],
1578 |         "Hong Kong": [
1579 |           "Asia",
1580 |           "Eastern Asia",
1581 |           "City of Victoria"
1582 |         ],
1583 |         "Hungary": [
1584 |           "Europe",
1585 |           "Eastern Europe",
1586 |           "Budapest"
1587 |         ],
1588 |         "Iceland": [
1589 |           "Europe",
1590 |           "Northern Europe",
1591 |           "Reykjavík"
1592 |         ],
1593 |         "India": [
1594 |           "Asia",
1595 |           "Southern Asia",
1596 |           "New Delhi"
1597 |         ],
1598 |         "Indonesia": [
1599 |           "Asia",
1600 |           "South-Eastern Asia",
1601 |           "Jakarta"
1602 |         ],
1603 |         "Côte d'Ivoire": [
1604 |           "Africa",
1605 |           "Western Africa",
1606 |           "Yamoussoukro"
1607 |         ],
1608 |         "Iran (Islamic Republic of)": [
1609 |           "Asia",
1610 |           "Southern Asia",
1611 |           "Tehran"
1612 |         ],
1613 |         "Iraq": [
1614 |           "Asia",
1615 |           "Western Asia",
1616 |           "Baghdad"
1617 |         ],
1618 |         "Ireland": [
1619 |           "Europe",
1620 |           "Northern Europe",
1621 |           "Dublin"
1622 |         ],
1623 |         "Isle of Man": [
1624 |           "Europe",
1625 |           "Northern Europe",
1626 |           "Douglas"
1627 |         ],
1628 |         "Israel": [
1629 |           "Asia",
1630 |           "Western Asia",
1631 |           "Jerusalem"
1632 |         ],
1633 |         "Italy": [
1634 |           "Europe",
1635 |           "Southern Europe",
1636 |           "Rome"
1637 |         ],
1638 |         "Jamaica": [
1639 |           "Americas",
1640 |           "Caribbean",
1641 |           "Kingston"
1642 |         ],
1643 |         "Japan": [
1644 |           "Asia",
1645 |           "Eastern Asia",
1646 |           "Tokyo"
1647 |         ],
1648 |         "Jersey": [
1649 |           "Europe",
1650 |           "Northern Europe",
1651 |           "Saint Helier"
1652 |         ],
1653 |         "Jordan": [
1654 |           "Asia",
1655 |           "Western Asia",
1656 |           "Amman"
1657 |         ],
1658 |         "Kazakhstan": [
1659 |           "Asia",
1660 |           "Central Asia",
1661 |           "Astana"
1662 |         ],
1663 |         "Kenya": [
1664 |           "Africa",
1665 |           "Eastern Africa",
1666 |           "Nairobi"
1667 |         ],
1668 |         "Kiribati": [
1669 |           "Oceania",
1670 |           "Micronesia",
1671 |           "South Tarawa"
1672 |         ],
1673 |         "Kuwait": [
1674 |           "Asia",
1675 |           "Western Asia",
1676 |           "Kuwait City"
1677 |         ],
1678 |         "Kyrgyzstan": [
1679 |           "Asia",
1680 |           "Central Asia",
1681 |           "Bishkek"
1682 |         ],
1683 |         "Lao People's Democratic Republic": [
1684 |           "Asia",
1685 |           "South-Eastern Asia",
1686 |           "Vientiane"
1687 |         ],
1688 |         "Latvia": [
1689 |           "Europe",
1690 |           "Northern Europe",
1691 |           "Riga"
1692 |         ],
1693 |         "Lebanon": [
1694 |           "Asia",
1695 |           "Western Asia",
1696 |           "Beirut"
1697 |         ],
1698 |         "Lesotho": [
1699 |           "Africa",
1700 |           "Southern Africa",
1701 |           "Maseru"
1702 |         ],
1703 |         "Liberia": [
1704 |           "Africa",
1705 |           "Western Africa",
1706 |           "Monrovia"
1707 |         ],
1708 |         "Libya": [
1709 |           "Africa",
1710 |           "Northern Africa",
1711 |           "Tripoli"
1712 |         ],
1713 |         "Liechtenstein": [
1714 |           "Europe",
1715 |           "Western Europe",
1716 |           "Vaduz"
1717 |         ],
1718 |         "Lithuania": [
1719 |           "Europe",
1720 |           "Northern Europe",
1721 |           "Vilnius"
1722 |         ],
1723 |         "Luxembourg": [
1724 |           "Europe",
1725 |           "Western Europe",
1726 |           "Luxembourg"
1727 |         ],
1728 |         "Macao": [
1729 |           "Asia",
1730 |           "Eastern Asia"
1731 |         ],
1732 |         "Macedonia (the former Yugoslav Republic of)": [
1733 |           "Europe",
1734 |           "Southern Europe",
1735 |           "Skopje"
1736 |         ],
1737 |         "Madagascar": [
1738 |           "Africa",
1739 |           "Eastern Africa",
1740 |           "Antananarivo"
1741 |         ],
1742 |         "Malawi": [
1743 |           "Africa",
1744 |           "Eastern Africa",
1745 |           "Lilongwe"
1746 |         ],
1747 |         "Malaysia": [
1748 |           "Asia",
1749 |           "South-Eastern Asia",
1750 |           "Kuala Lumpur"
1751 |         ],
1752 |         "Maldives": [
1753 |           "Asia",
1754 |           "Southern Asia",
1755 |           "Malé"
1756 |         ],
1757 |         "Mali": [
1758 |           "Africa",
1759 |           "Western Africa",
1760 |           "Bamako"
1761 |         ],
1762 |         "Malta": [
1763 |           "Europe",
1764 |           "Southern Europe",
1765 |           "Valletta"
1766 |         ],
1767 |         "Marshall Islands": [
1768 |           "Oceania",
1769 |           "Micronesia",
1770 |           "Majuro"
1771 |         ],
1772 |         "Martinique": [
1773 |           "Americas",
1774 |           "Caribbean",
1775 |           "Fort-de-France"
1776 |         ],
1777 |         "Mauritania": [
1778 |           "Africa",
1779 |           "Western Africa",
1780 |           "Nouakchott"
1781 |         ],
1782 |         "Mauritius": [
1783 |           "Africa",
1784 |           "Eastern Africa",
1785 |           "Port Louis"
1786 |         ],
1787 |         "Mayotte": [
1788 |           "Africa",
1789 |           "Eastern Africa",
1790 |           "Mamoudzou"
1791 |         ],
1792 |         "Mexico": [
1793 |           "Americas",
1794 |           "Central America",
1795 |           "Mexico City"
1796 |         ],
1797 |         "Micronesia (Federated States of)": [
1798 |           "Oceania",
1799 |           "Micronesia",
1800 |           "Palikir"
1801 |         ],
1802 |         "Moldova (Republic of)": [
1803 |           "Europe",
1804 |           "Eastern Europe",
1805 |           "Chișinău"
1806 |         ],
1807 |         "Monaco": [
1808 |           "Europe",
1809 |           "Western Europe",
1810 |           "Monaco"
1811 |         ],
1812 |         "Mongolia": [
1813 |           "Asia",
1814 |           "Eastern Asia",
1815 |           "Ulan Bator"
1816 |         ],
1817 |         "Montenegro": [
1818 |           "Europe",
1819 |           "Southern Europe",
1820 |           "Podgorica"
1821 |         ],
1822 |         "Montserrat": [
1823 |           "Americas",
1824 |           "Caribbean",
1825 |           "Plymouth"
1826 |         ],
1827 |         "Morocco": [
1828 |           "Africa",
1829 |           "Northern Africa",
1830 |           "Rabat"
1831 |         ],
1832 |         "Mozambique": [
1833 |           "Africa",
1834 |           "Eastern Africa",
1835 |           "Maputo"
1836 |         ],
1837 |         "Myanmar": [
1838 |           "Asia",
1839 |           "South-Eastern Asia",
1840 |           "Naypyidaw"
1841 |         ],
1842 |         "Namibia": [
1843 |           "Africa",
1844 |           "Southern Africa",
1845 |           "Windhoek"
1846 |         ],
1847 |         "Nauru": [
1848 |           "Oceania",
1849 |           "Micronesia",
1850 |           "Yaren"
1851 |         ],
1852 |         "Nepal": [
1853 |           "Asia",
1854 |           "Southern Asia",
1855 |           "Kathmandu"
1856 |         ],
1857 |         "Netherlands": [
1858 |           "Europe",
1859 |           "Western Europe",
1860 |           "Amsterdam"
1861 |         ],
1862 |         "New Caledonia": [
1863 |           "Oceania",
1864 |           "Melanesia",
1865 |           "Nouméa"
1866 |         ],
1867 |         "New Zealand": [
1868 |           "Oceania",
1869 |           "Australia and New Zealand",
1870 |           "Wellington"
1871 |         ],
1872 |         "Nicaragua": [
1873 |           "Americas",
1874 |           "Central America",
1875 |           "Managua"
1876 |         ],
1877 |         "Niger": [
1878 |           "Africa",
1879 |           "Western Africa",
1880 |           "Niamey"
1881 |         ],
1882 |         "Nigeria": [
1883 |           "Africa",
1884 |           "Western Africa",
1885 |           "Abuja"
1886 |         ],
1887 |         "Niue": [
1888 |           "Oceania",
1889 |           "Polynesia",
1890 |           "Alofi"
1891 |         ],
1892 |         "Norfolk Island": [
1893 |           "Oceania",
1894 |           "Australia and New Zealand",
1895 |           "Kingston"
1896 |         ],
1897 |         "Korea (Democratic People's Republic of)": [
1898 |           "Asia",
1899 |           "Eastern Asia",
1900 |           "Pyongyang"
1901 |         ],
1902 |         "Northern Mariana Islands": [
1903 |           "Oceania",
1904 |           "Micronesia",
1905 |           "Saipan"
1906 |         ],
1907 |         "Norway": [
1908 |           "Europe",
1909 |           "Northern Europe",
1910 |           "Oslo"
1911 |         ],
1912 |         "Oman": [
1913 |           "Asia",
1914 |           "Western Asia",
1915 |           "Muscat"
1916 |         ],
1917 |         "Pakistan": [
1918 |           "Asia",
1919 |           "Southern Asia",
1920 |           "Islamabad"
1921 |         ],
1922 |         "Palau": [
1923 |           "Oceania",
1924 |           "Micronesia",
1925 |           "Ngerulmud"
1926 |         ],
1927 |         "Palestine, State of": [
1928 |           "Asia",
1929 |           "Western Asia",
1930 |           "Ramallah"
1931 |         ],
1932 |         "Panama": [
1933 |           "Americas",
1934 |           "Central America",
1935 |           "Panama City"
1936 |         ],
1937 |         "Papua New Guinea": [
1938 |           "Oceania",
1939 |           "Melanesia",
1940 |           "Port Moresby"
1941 |         ],
1942 |         "Paraguay": [
1943 |           "Americas",
1944 |           "South America",
1945 |           "Asunción"
1946 |         ],
1947 |         "Peru": [
1948 |           "Americas",
1949 |           "South America",
1950 |           "Lima"
1951 |         ],
1952 |         "Philippines": [
1953 |           "Asia",
1954 |           "South-Eastern Asia",
1955 |           "Manila"
1956 |         ],
1957 |         "Pitcairn": [
1958 |           "Oceania",
1959 |           "Polynesia",
1960 |           "Adamstown"
1961 |         ],
1962 |         "Poland": [
1963 |           "Europe",
1964 |           "Eastern Europe",
1965 |           "Warsaw"
1966 |         ],
1967 |         "Portugal": [
1968 |           "Europe",
1969 |           "Southern Europe",
1970 |           "Lisbon"
1971 |         ],
1972 |         "Puerto Rico": [
1973 |           "Americas",
1974 |           "Caribbean",
1975 |           "San Juan"
1976 |         ],
1977 |         "Qatar": [
1978 |           "Asia",
1979 |           "Western Asia",
1980 |           "Doha"
1981 |         ],
1982 |         "Republic of Kosovo": [
1983 |           "Europe",
1984 |           "Eastern Europe",
1985 |           "Pristina"
1986 |         ],
1987 |         "Réunion": [
1988 |           "Africa",
1989 |           "Eastern Africa",
1990 |           "Saint-Denis"
1991 |         ],
1992 |         "Romania": [
1993 |           "Europe",
1994 |           "Eastern Europe",
1995 |           "Bucharest"
1996 |         ],
1997 |         "Russian Federation": [
1998 |           "Europe",
1999 |           "Eastern Europe",
2000 |           "Moscow"
2001 |         ],
2002 |         "Rwanda": [
2003 |           "Africa",
2004 |           "Eastern Africa",
2005 |           "Kigali"
2006 |         ],
2007 |         "Saint Barthélemy": [
2008 |           "Americas",
2009 |           "Caribbean",
2010 |           "Gustavia"
2011 |         ],
2012 |         "Saint Helena, Ascension and Tristan da Cunha": [
2013 |           "Africa",
2014 |           "Western Africa",
2015 |           "Jamestown"
2016 |         ],
2017 |         "Saint Kitts and Nevis": [
2018 |           "Americas",
2019 |           "Caribbean",
2020 |           "Basseterre"
2021 |         ],
2022 |         "Saint Lucia": [
2023 |           "Americas",
2024 |           "Caribbean",
2025 |           "Castries"
2026 |         ],
2027 |         "Saint Martin (French part)": [
2028 |           "Americas",
2029 |           "Caribbean",
2030 |           "Marigot"
2031 |         ],
2032 |         "Saint Pierre and Miquelon": [
2033 |           "Americas",
2034 |           "Northern America",
2035 |           "Saint-Pierre"
2036 |         ],
2037 |         "Saint Vincent and the Grenadines": [
2038 |           "Americas",
2039 |           "Caribbean",
2040 |           "Kingstown"
2041 |         ],
2042 |         "Samoa": [
2043 |           "Oceania",
2044 |           "Polynesia",
2045 |           "Apia"
2046 |         ],
2047 |         "San Marino": [
2048 |           "Europe",
2049 |           "Southern Europe",
2050 |           "City of San Marino"
2051 |         ],
2052 |         "Sao Tome and Principe": [
2053 |           "Africa",
2054 |           "Middle Africa",
2055 |           "São Tomé"
2056 |         ],
2057 |         "Saudi Arabia": [
2058 |           "Asia",
2059 |           "Western Asia",
2060 |           "Riyadh"
2061 |         ],
2062 |         "Senegal": [
2063 |           "Africa",
2064 |           "Western Africa",
2065 |           "Dakar"
2066 |         ],
2067 |         "Serbia": [
2068 |           "Europe",
2069 |           "Southern Europe",
2070 |           "Belgrade"
2071 |         ],
2072 |         "Seychelles": [
2073 |           "Africa",
2074 |           "Eastern Africa",
2075 |           "Victoria"
2076 |         ],
2077 |         "Sierra Leone": [
2078 |           "Africa",
2079 |           "Western Africa",
2080 |           "Freetown"
2081 |         ],
2082 |         "Singapore": [
2083 |           "Asia",
2084 |           "South-Eastern Asia",
2085 |           "Singapore"
2086 |         ],
2087 |         "Sint Maarten (Dutch part)": [
2088 |           "Americas",
2089 |           "Caribbean",
2090 |           "Philipsburg"
2091 |         ],
2092 |         "Slovakia": [
2093 |           "Europe",
2094 |           "Eastern Europe",
2095 |           "Bratislava"
2096 |         ],
2097 |         "Slovenia": [
2098 |           "Europe",
2099 |           "Southern Europe",
2100 |           "Ljubljana"
2101 |         ],
2102 |         "Solomon Islands": [
2103 |           "Oceania",
2104 |           "Melanesia",
2105 |           "Honiara"
2106 |         ],
2107 |         "Somalia": [
2108 |           "Africa",
2109 |           "Eastern Africa",
2110 |           "Mogadishu"
2111 |         ],
2112 |         "South Africa": [
2113 |           "Africa",
2114 |           "Southern Africa",
2115 |           "Pretoria"
2116 |         ],
2117 |         "South Georgia and the South Sandwich Islands": [
2118 |           "Americas",
2119 |           "South America",
2120 |           "King Edward Point"
2121 |         ],
2122 |         "Korea (Republic of)": [
2123 |           "Asia",
2124 |           "Eastern Asia",
2125 |           "Seoul"
2126 |         ],
2127 |         "South Sudan": [
2128 |           "Africa",
2129 |           "Middle Africa",
2130 |           "Juba"
2131 |         ],
2132 |         "Spain": [
2133 |           "Europe",
2134 |           "Southern Europe",
2135 |           "Madrid"
2136 |         ],
2137 |         "Sri Lanka": [
2138 |           "Asia",
2139 |           "Southern Asia",
2140 |           "Colombo"
2141 |         ],
2142 |         "Sudan": [
2143 |           "Africa",
2144 |           "Northern Africa",
2145 |           "Khartoum"
2146 |         ],
2147 |         "Suriname": [
2148 |           "Americas",
2149 |           "South America",
2150 |           "Paramaribo"
2151 |         ],
2152 |         "Svalbard and Jan Mayen": [
2153 |           "Europe",
2154 |           "Northern Europe",
2155 |           "Longyearbyen"
2156 |         ],
2157 |         "Swaziland": [
2158 |           "Africa",
2159 |           "Southern Africa",
2160 |           "Lobamba"
2161 |         ],
2162 |         "Sweden": [
2163 |           "Europe",
2164 |           "Northern Europe",
2165 |           "Stockholm"
2166 |         ],
2167 |         "Switzerland": [
2168 |           "Europe",
2169 |           "Western Europe",
2170 |           "Bern"
2171 |         ],
2172 |         "Syrian Arab Republic": [
2173 |           "Asia",
2174 |           "Western Asia",
2175 |           "Damascus"
2176 |         ],
2177 |         "Taiwan": [
2178 |           "Asia",
2179 |           "Eastern Asia",
2180 |           "Taipei"
2181 |         ],
2182 |         "Tajikistan": [
2183 |           "Asia",
2184 |           "Central Asia",
2185 |           "Dushanbe"
2186 |         ],
2187 |         "Tanzania, United Republic of": [
2188 |           "Africa",
2189 |           "Eastern Africa",
2190 |           "Dodoma"
2191 |         ],
2192 |         "Thailand": [
2193 |           "Asia",
2194 |           "South-Eastern Asia",
2195 |           "Bangkok"
2196 |         ],
2197 |         "Timor-Leste": [
2198 |           "Asia",
2199 |           "South-Eastern Asia",
2200 |           "Dili"
2201 |         ],
2202 |         "Togo": [
2203 |           "Africa",
2204 |           "Western Africa",
2205 |           "Lomé"
2206 |         ],
2207 |         "Tokelau": [
2208 |           "Oceania",
2209 |           "Polynesia",
2210 |           "Fakaofo"
2211 |         ],
2212 |         "Tonga": [
2213 |           "Oceania",
2214 |           "Polynesia",
2215 |           "Nuku'alofa"
2216 |         ],
2217 |         "Trinidad and Tobago": [
2218 |           "Americas",
2219 |           "Caribbean",
2220 |           "Port of Spain"
2221 |         ],
2222 |         "Tunisia": [
2223 |           "Africa",
2224 |           "Northern Africa",
2225 |           "Tunis"
2226 |         ],
2227 |         "Turkey": [
2228 |           "Asia",
2229 |           "Western Asia",
2230 |           "Ankara"
2231 |         ],
2232 |         "Turkmenistan": [
2233 |           "Asia",
2234 |           "Central Asia",
2235 |           "Ashgabat"
2236 |         ],
2237 |         "Turks and Caicos Islands": [
2238 |           "Americas",
2239 |           "Caribbean",
2240 |           "Cockburn Town"
2241 |         ],
2242 |         "Tuvalu": [
2243 |           "Oceania",
2244 |           "Polynesia",
2245 |           "Funafuti"
2246 |         ],
2247 |         "Uganda": [
2248 |           "Africa",
2249 |           "Eastern Africa",
2250 |           "Kampala"
2251 |         ],
2252 |         "Ukraine": [
2253 |           "Europe",
2254 |           "Eastern Europe",
2255 |           "Kiev",
2256 |           "Chernobyl"
2257 |         ],
2258 |         "United Arab Emirates": [
2259 |           "Asia",
2260 |           "Western Asia",
2261 |           "Abu Dhabi"
2262 |         ],
2263 |         "United Kingdom of Great Britain and Northern Ireland": [
2264 |           "Europe",
2265 |           "Northern Europe",
2266 |           "London",
2267 |           "Wales",
2268 |           "Scotland"
2269 |         ],
2270 |         "United States of America": [
2271 |           "Americas",
2272 |           "Northern America",
2273 |           "Washington, D.C.",
2274 |           "New York",
2275 |           "Los Angeles"
2276 |         ],
2277 |         "Uruguay": [
2278 |           "Americas",
2279 |           "South America",
2280 |           "Montevideo"
2281 |         ],
2282 |         "Uzbekistan": [
2283 |           "Asia",
2284 |           "Central Asia",
2285 |           "Tashkent"
2286 |         ],
2287 |         "Vanuatu": [
2288 |           "Oceania",
2289 |           "Melanesia",
2290 |           "Port Vila"
2291 |         ],
2292 |         "Venezuela (Bolivarian Republic of)": [
2293 |           "Americas",
2294 |           "South America",
2295 |           "Caracas"
2296 |         ],
2297 |         "Viet Nam": [
2298 |           "Asia",
2299 |           "South-Eastern Asia",
2300 |           "Hanoi"
2301 |         ],
2302 |         "Wallis and Futuna": [
2303 |           "Oceania",
2304 |           "Polynesia",
2305 |           "Mata-Utu"
2306 |         ],
2307 |         "Western Sahara": [
2308 |           "Africa",
2309 |           "Northern Africa",
2310 |           "El Aaiún"
2311 |         ],
2312 |         "Yemen": [
2313 |           "Asia",
2314 |           "Western Asia",
2315 |           "Sana'a"
2316 |         ],
2317 |         "Zambia": [
2318 |           "Africa",
2319 |           "Eastern Africa",
2320 |           "Lusaka"
2321 |         ],
2322 |         "Zimbabwe": [
2323 |           "Africa",
2324 |           "Eastern Africa",
2325 |           "Harare"
2326 |         ],
2327 |         "Kabul (Afghanistan)": [
2328 |           "Asia"
2329 |         ],
2330 |         "Mariehamn (Åland Islands)": [
2331 |           "Europe"
2332 |         ],
2333 |         "Tirana (Albania)": [
2334 |           "Europe"
2335 |         ],
2336 |         "Algiers (Algeria)": [
2337 |           "Africa"
2338 |         ],
2339 |         "Pago Pago (American Samoa)": [
2340 |           "Oceania"
2341 |         ],
2342 |         "Andorra la Vella (Andorra)": [
2343 |           "Europe"
2344 |         ],
2345 |         "Luanda (Angola)": [
2346 |           "Africa"
2347 |         ],
2348 |         "The Valley (Anguilla)": [
2349 |           "Americas"
2350 |         ],
2351 |         "Saint John's (Antigua and Barbuda)": [
2352 |           "Americas"
2353 |         ],
2354 |         "Buenos Aires (Argentina)": [
2355 |           "Americas"
2356 |         ],
2357 |         "Yerevan (Armenia)": [
2358 |           "Asia"
2359 |         ],
2360 |         "Oranjestad (Aruba)": [
2361 |           "Americas"
2362 |         ],
2363 |         "Canberra (Australia)": [
2364 |           "Oceania"
2365 |         ],
2366 |         "Vienna (Austria)": [
2367 |           "Europe"
2368 |         ],
2369 |         "Baku (Azerbaijan)": [
2370 |           "Asia"
2371 |         ],
2372 |         "Nassau (Bahamas)": [
2373 |           "Americas"
2374 |         ],
2375 |         "Manama (Bahrain)": [
2376 |           "Asia"
2377 |         ],
2378 |         "Dhaka (Bangladesh)": [
2379 |           "Asia"
2380 |         ],
2381 |         "Bridgetown (Barbados)": [
2382 |           "Americas"
2383 |         ],
2384 |         "Minsk (Belarus)": [
2385 |           "Europe"
2386 |         ],
2387 |         "Brussels (Belgium)": [
2388 |           "Europe"
2389 |         ],
2390 |         "Belmopan (Belize)": [
2391 |           "Americas"
2392 |         ],
2393 |         "Porto-Novo (Benin)": [
2394 |           "Africa"
2395 |         ],
2396 |         "Hamilton (Bermuda)": [
2397 |           "Americas"
2398 |         ],
2399 |         "Thimphu (Bhutan)": [
2400 |           "Asia"
2401 |         ],
2402 |         "Sucre (Bolivia (Plurinational State of))": [
2403 |           "Americas"
2404 |         ],
2405 |         "Kralendijk (Bonaire, Sint Eustatius and Saba)": [
2406 |           "Americas"
2407 |         ],
2408 |         "Sarajevo (Bosnia and Herzegovina)": [
2409 |           "Europe"
2410 |         ],
2411 |         "Gaborone (Botswana)": [
2412 |           "Africa"
2413 |         ],
2414 |         "Brasília (Brazil)": [
2415 |           "Americas"
2416 |         ],
2417 |         "Diego Garcia (British Indian Ocean Territory)": [
2418 |           "Africa"
2419 |         ],
2420 |         "Road Town (Virgin Islands (British))": [
2421 |           "Americas"
2422 |         ],
2423 |         "Charlotte Amalie (Virgin Islands (U.S.))": [
2424 |           "Americas"
2425 |         ],
2426 |         "Bandar Seri Begawan (Brunei Darussalam)": [
2427 |           "Asia"
2428 |         ],
2429 |         "Sofia (Bulgaria)": [
2430 |           "Europe"
2431 |         ],
2432 |         "Ouagadougou (Burkina Faso)": [
2433 |           "Africa"
2434 |         ],
2435 |         "Bujumbura (Burundi)": [
2436 |           "Africa"
2437 |         ],
2438 |         "Phnom Penh (Cambodia)": [
2439 |           "Asia"
2440 |         ],
2441 |         "Yaoundé (Cameroon)": [
2442 |           "Africa"
2443 |         ],
2444 |         "Ottawa (Canada)": [
2445 |           "Americas"
2446 |         ],
2447 |         "Praia (Cabo Verde)": [
2448 |           "Africa"
2449 |         ],
2450 |         "George Town (Cayman Islands)": [
2451 |           "Americas"
2452 |         ],
2453 |         "Bangui (Central African Republic)": [
2454 |           "Africa"
2455 |         ],
2456 |         "N'Djamena (Chad)": [
2457 |           "Africa"
2458 |         ],
2459 |         "Santiago (Chile)": [
2460 |           "Americas"
2461 |         ],
2462 |         "Beijing (China)": [
2463 |           "Asia"
2464 |         ],
2465 |         "Flying Fish Cove (Christmas Island)": [
2466 |           "Oceania"
2467 |         ],
2468 |         "West Island (Cocos (Keeling) Islands)": [
2469 |           "Oceania"
2470 |         ],
2471 |         "Bogotá (Colombia)": [
2472 |           "Americas"
2473 |         ],
2474 |         "Moroni (Comoros)": [
2475 |           "Africa"
2476 |         ],
2477 |         "Brazzaville (Congo)": [
2478 |           "Africa"
2479 |         ],
2480 |         "Kinshasa (Congo (Democratic Republic of the))": [
2481 |           "Africa"
2482 |         ],
2483 |         "Avarua (Cook Islands)": [
2484 |           "Oceania"
2485 |         ],
2486 |         "San José (Costa Rica)": [
2487 |           "Americas"
2488 |         ],
2489 |         "Zagreb (Croatia)": [
2490 |           "Europe"
2491 |         ],
2492 |         "Havana (Cuba)": [
2493 |           "Americas"
2494 |         ],
2495 |         "Willemstad (Curaçao)": [
2496 |           "Americas"
2497 |         ],
2498 |         "Nicosia (Cyprus)": [
2499 |           "Europe"
2500 |         ],
2501 |         "Prague (Czech Republic)": [
2502 |           "Europe"
2503 |         ],
2504 |         "Copenhagen (Denmark)": [
2505 |           "Europe"
2506 |         ],
2507 |         "Djibouti (Djibouti)": [
2508 |           "Africa"
2509 |         ],
2510 |         "Roseau (Dominica)": [
2511 |           "Americas"
2512 |         ],
2513 |         "Santo Domingo (Dominican Republic)": [
2514 |           "Americas"
2515 |         ],
2516 |         "Quito (Ecuador)": [
2517 |           "Americas"
2518 |         ],
2519 |         "Cairo (Egypt)": [
2520 |           "Africa"
2521 |         ],
2522 |         "San Salvador (El Salvador)": [
2523 |           "Americas"
2524 |         ],
2525 |         "Malabo (Equatorial Guinea)": [
2526 |           "Africa"
2527 |         ],
2528 |         "Asmara (Eritrea)": [
2529 |           "Africa"
2530 |         ],
2531 |         "Tallinn (Estonia)": [
2532 |           "Europe"
2533 |         ],
2534 |         "Addis Ababa (Ethiopia)": [
2535 |           "Africa"
2536 |         ],
2537 |         "Stanley (Falkland Islands (Malvinas))": [
2538 |           "Americas"
2539 |         ],
2540 |         "Tórshavn (Faroe Islands)": [
2541 |           "Europe"
2542 |         ],
2543 |         "Suva (Fiji)": [
2544 |           "Oceania"
2545 |         ],
2546 |         "Helsinki (Finland)": [
2547 |           "Europe"
2548 |         ],
2549 |         "Paris (France)": [
2550 |           "Europe"
2551 |         ],
2552 |         "Cayenne (French Guiana)": [
2553 |           "Americas"
2554 |         ],
2555 |         "Papeetē (French Polynesia)": [
2556 |           "Oceania"
2557 |         ],
2558 |         "Port-aux-Français (French Southern Territories)": [
2559 |           "Africa"
2560 |         ],
2561 |         "Libreville (Gabon)": [
2562 |           "Africa"
2563 |         ],
2564 |         "Banjul (Gambia)": [
2565 |           "Africa"
2566 |         ],
2567 |         "Tbilisi (Georgia)": [
2568 |           "Asia"
2569 |         ],
2570 |         "Berlin (Germany)": [
2571 |           "Europe"
2572 |         ],
2573 |         "Accra (Ghana)": [
2574 |           "Africa"
2575 |         ],
2576 |         "Gibraltar (Gibraltar)": [
2577 |           "Europe"
2578 |         ],
2579 |         "Athens (Greece)": [
2580 |           "Europe"
2581 |         ],
2582 |         "Nuuk (Greenland)": [
2583 |           "Americas"
2584 |         ],
2585 |         "St. George's (Grenada)": [
2586 |           "Americas"
2587 |         ],
2588 |         "Basse-Terre (Guadeloupe)": [
2589 |           "Americas"
2590 |         ],
2591 |         "Hagåtña (Guam)": [
2592 |           "Oceania"
2593 |         ],
2594 |         "Guatemala City (Guatemala)": [
2595 |           "Americas"
2596 |         ],
2597 |         "St. Peter Port (Guernsey)": [
2598 |           "Europe"
2599 |         ],
2600 |         "Conakry (Guinea)": [
2601 |           "Africa"
2602 |         ],
2603 |         "Bissau (Guinea-Bissau)": [
2604 |           "Africa"
2605 |         ],
2606 |         "Georgetown (Guyana)": [
2607 |           "Americas"
2608 |         ],
2609 |         "Port-au-Prince (Haiti)": [
2610 |           "Americas"
2611 |         ],
2612 |         "Rome (Holy See)": [
2613 |           "Europe"
2614 |         ],
2615 |         "Tegucigalpa (Honduras)": [
2616 |           "Americas"
2617 |         ],
2618 |         "City of Victoria (Hong Kong)": [
2619 |           "Asia"
2620 |         ],
2621 |         "Budapest (Hungary)": [
2622 |           "Europe"
2623 |         ],
2624 |         "Reykjavík (Iceland)": [
2625 |           "Europe"
2626 |         ],
2627 |         "New Delhi (India)": [
2628 |           "Asia"
2629 |         ],
2630 |         "Jakarta (Indonesia)": [
2631 |           "Asia"
2632 |         ],
2633 |         "Yamoussoukro (Côte d'Ivoire)": [
2634 |           "Africa"
2635 |         ],
2636 |         "Tehran (Iran (Islamic Republic of))": [
2637 |           "Asia"
2638 |         ],
2639 |         "Baghdad (Iraq)": [
2640 |           "Asia"
2641 |         ],
2642 |         "Dublin (Ireland)": [
2643 |           "Europe"
2644 |         ],
2645 |         "Douglas (Isle of Man)": [
2646 |           "Europe"
2647 |         ],
2648 |         "Jerusalem (Israel)": [
2649 |           "Asia"
2650 |         ],
2651 |         "Rome (Italy)": [
2652 |           "Europe"
2653 |         ],
2654 |         "Kingston (Jamaica)": [
2655 |           "Americas"
2656 |         ],
2657 |         "Tokyo (Japan)": [
2658 |           "Asia"
2659 |         ],
2660 |         "Saint Helier (Jersey)": [
2661 |           "Europe"
2662 |         ],
2663 |         "Amman (Jordan)": [
2664 |           "Asia"
2665 |         ],
2666 |         "Astana (Kazakhstan)": [
2667 |           "Asia"
2668 |         ],
2669 |         "Nairobi (Kenya)": [
2670 |           "Africa"
2671 |         ],
2672 |         "South Tarawa (Kiribati)": [
2673 |           "Oceania"
2674 |         ],
2675 |         "Kuwait City (Kuwait)": [
2676 |           "Asia"
2677 |         ],
2678 |         "Bishkek (Kyrgyzstan)": [
2679 |           "Asia"
2680 |         ],
2681 |         "Vientiane (Lao People's Democratic Republic)": [
2682 |           "Asia"
2683 |         ],
2684 |         "Riga (Latvia)": [
2685 |           "Europe"
2686 |         ],
2687 |         "Beirut (Lebanon)": [
2688 |           "Asia"
2689 |         ],
2690 |         "Maseru (Lesotho)": [
2691 |           "Africa"
2692 |         ],
2693 |         "Monrovia (Liberia)": [
2694 |           "Africa"
2695 |         ],
2696 |         "Tripoli (Libya)": [
2697 |           "Africa"
2698 |         ],
2699 |         "Vaduz (Liechtenstein)": [
2700 |           "Europe"
2701 |         ],
2702 |         "Vilnius (Lithuania)": [
2703 |           "Europe"
2704 |         ],
2705 |         "Luxembourg (Luxembourg)": [
2706 |           "Europe"
2707 |         ],
2708 |         "Skopje (Macedonia (the former Yugoslav Republic of))": [
2709 |           "Europe"
2710 |         ],
2711 |         "Antananarivo (Madagascar)": [
2712 |           "Africa"
2713 |         ],
2714 |         "Lilongwe (Malawi)": [
2715 |           "Africa"
2716 |         ],
2717 |         "Kuala Lumpur (Malaysia)": [
2718 |           "Asia"
2719 |         ],
2720 |         "Malé (Maldives)": [
2721 |           "Asia"
2722 |         ],
2723 |         "Bamako (Mali)": [
2724 |           "Africa"
2725 |         ],
2726 |         "Valletta (Malta)": [
2727 |           "Europe"
2728 |         ],
2729 |         "Majuro (Marshall Islands)": [
2730 |           "Oceania"
2731 |         ],
2732 |         "Fort-de-France (Martinique)": [
2733 |           "Americas"
2734 |         ],
2735 |         "Nouakchott (Mauritania)": [
2736 |           "Africa"
2737 |         ],
2738 |         "Port Louis (Mauritius)": [
2739 |           "Africa"
2740 |         ],
2741 |         "Mamoudzou (Mayotte)": [
2742 |           "Africa"
2743 |         ],
2744 |         "Mexico City (Mexico)": [
2745 |           "Americas"
2746 |         ],
2747 |         "Palikir (Micronesia (Federated States of))": [
2748 |           "Oceania"
2749 |         ],
2750 |         "Chișinău (Moldova (Republic of))": [
2751 |           "Europe"
2752 |         ],
2753 |         "Monaco (Monaco)": [
2754 |           "Europe"
2755 |         ],
2756 |         "Ulan Bator (Mongolia)": [
2757 |           "Asia"
2758 |         ],
2759 |         "Podgorica (Montenegro)": [
2760 |           "Europe"
2761 |         ],
2762 |         "Plymouth (Montserrat)": [
2763 |           "Americas"
2764 |         ],
2765 |         "Rabat (Morocco)": [
2766 |           "Africa"
2767 |         ],
2768 |         "Maputo (Mozambique)": [
2769 |           "Africa"
2770 |         ],
2771 |         "Naypyidaw (Myanmar)": [
2772 |           "Asia"
2773 |         ],
2774 |         "Windhoek (Namibia)": [
2775 |           "Africa"
2776 |         ],
2777 |         "Yaren (Nauru)": [
2778 |           "Oceania"
2779 |         ],
2780 |         "Kathmandu (Nepal)": [
2781 |           "Asia"
2782 |         ],
2783 |         "Amsterdam (Netherlands)": [
2784 |           "Europe"
2785 |         ],
2786 |         "Nouméa (New Caledonia)": [
2787 |           "Oceania"
2788 |         ],
2789 |         "Wellington (New Zealand)": [
2790 |           "Oceania"
2791 |         ],
2792 |         "Managua (Nicaragua)": [
2793 |           "Americas"
2794 |         ],
2795 |         "Niamey (Niger)": [
2796 |           "Africa"
2797 |         ],
2798 |         "Abuja (Nigeria)": [
2799 |           "Africa"
2800 |         ],
2801 |         "Alofi (Niue)": [
2802 |           "Oceania"
2803 |         ],
2804 |         "Kingston (Norfolk Island)": [
2805 |           "Oceania"
2806 |         ],
2807 |         "Pyongyang (Korea (Democratic People's Republic of))": [
2808 |           "Asia"
2809 |         ],
2810 |         "Saipan (Northern Mariana Islands)": [
2811 |           "Oceania"
2812 |         ],
2813 |         "Oslo (Norway)": [
2814 |           "Europe"
2815 |         ],
2816 |         "Muscat (Oman)": [
2817 |           "Asia"
2818 |         ],
2819 |         "Islamabad (Pakistan)": [
2820 |           "Asia"
2821 |         ],
2822 |         "Ngerulmud (Palau)": [
2823 |           "Oceania"
2824 |         ],
2825 |         "Ramallah (Palestine, State of)": [
2826 |           "Asia"
2827 |         ],
2828 |         "Panama City (Panama)": [
2829 |           "Americas"
2830 |         ],
2831 |         "Port Moresby (Papua New Guinea)": [
2832 |           "Oceania"
2833 |         ],
2834 |         "Asunción (Paraguay)": [
2835 |           "Americas"
2836 |         ],
2837 |         "Lima (Peru)": [
2838 |           "Americas"
2839 |         ],
2840 |         "Manila (Philippines)": [
2841 |           "Asia"
2842 |         ],
2843 |         "Adamstown (Pitcairn)": [
2844 |           "Oceania"
2845 |         ],
2846 |         "Warsaw (Poland)": [
2847 |           "Europe"
2848 |         ],
2849 |         "Lisbon (Portugal)": [
2850 |           "Europe"
2851 |         ],
2852 |         "San Juan (Puerto Rico)": [
2853 |           "Americas"
2854 |         ],
2855 |         "Doha (Qatar)": [
2856 |           "Asia"
2857 |         ],
2858 |         "Pristina (Republic of Kosovo)": [
2859 |           "Europe"
2860 |         ],
2861 |         "Saint-Denis (Réunion)": [
2862 |           "Africa"
2863 |         ],
2864 |         "Bucharest (Romania)": [
2865 |           "Europe"
2866 |         ],
2867 |         "Moscow (Russian Federation)": [
2868 |           "Europe"
2869 |         ],
2870 |         "Kigali (Rwanda)": [
2871 |           "Africa"
2872 |         ],
2873 |         "Gustavia (Saint Barthélemy)": [
2874 |           "Americas"
2875 |         ],
2876 |         "Jamestown (Saint Helena, Ascension and Tristan da Cunha)": [
2877 |           "Africa"
2878 |         ],
2879 |         "Basseterre (Saint Kitts and Nevis)": [
2880 |           "Americas"
2881 |         ],
2882 |         "Castries (Saint Lucia)": [
2883 |           "Americas"
2884 |         ],
2885 |         "Marigot (Saint Martin (French part))": [
2886 |           "Americas"
2887 |         ],
2888 |         "Saint-Pierre (Saint Pierre and Miquelon)": [
2889 |           "Americas"
2890 |         ],
2891 |         "Kingstown (Saint Vincent and the Grenadines)": [
2892 |           "Americas"
2893 |         ],
2894 |         "Apia (Samoa)": [
2895 |           "Oceania"
2896 |         ],
2897 |         "City of San Marino (San Marino)": [
2898 |           "Europe"
2899 |         ],
2900 |         "São Tomé (Sao Tome and Principe)": [
2901 |           "Africa"
2902 |         ],
2903 |         "Riyadh (Saudi Arabia)": [
2904 |           "Asia"
2905 |         ],
2906 |         "Dakar (Senegal)": [
2907 |           "Africa"
2908 |         ],
2909 |         "Belgrade (Serbia)": [
2910 |           "Europe"
2911 |         ],
2912 |         "Victoria (Seychelles)": [
2913 |           "Africa"
2914 |         ],
2915 |         "Freetown (Sierra Leone)": [
2916 |           "Africa"
2917 |         ],
2918 |         "Singapore (Singapore)": [
2919 |           "Asia"
2920 |         ],
2921 |         "Philipsburg (Sint Maarten (Dutch part))": [
2922 |           "Americas"
2923 |         ],
2924 |         "Bratislava (Slovakia)": [
2925 |           "Europe"
2926 |         ],
2927 |         "Ljubljana (Slovenia)": [
2928 |           "Europe"
2929 |         ],
2930 |         "Honiara (Solomon Islands)": [
2931 |           "Oceania"
2932 |         ],
2933 |         "Mogadishu (Somalia)": [
2934 |           "Africa"
2935 |         ],
2936 |         "Pretoria (South Africa)": [
2937 |           "Africa"
2938 |         ],
2939 |         "King Edward Point (South Georgia and the South Sandwich Islands)": [
2940 |           "Americas"
2941 |         ],
2942 |         "Seoul (Korea (Republic of))": [
2943 |           "Asia"
2944 |         ],
2945 |         "Juba (South Sudan)": [
2946 |           "Africa"
2947 |         ],
2948 |         "Madrid (Spain)": [
2949 |           "Europe"
2950 |         ],
2951 |         "Colombo (Sri Lanka)": [
2952 |           "Asia"
2953 |         ],
2954 |         "Khartoum (Sudan)": [
2955 |           "Africa"
2956 |         ],
2957 |         "Paramaribo (Suriname)": [
2958 |           "Americas"
2959 |         ],
2960 |         "Longyearbyen (Svalbard and Jan Mayen)": [
2961 |           "Europe"
2962 |         ],
2963 |         "Lobamba (Swaziland)": [
2964 |           "Africa"
2965 |         ],
2966 |         "Stockholm (Sweden)": [
2967 |           "Europe"
2968 |         ],
2969 |         "Bern (Switzerland)": [
2970 |           "Europe"
2971 |         ],
2972 |         "Damascus (Syrian Arab Republic)": [
2973 |           "Asia"
2974 |         ],
2975 |         "Taipei (Taiwan)": [
2976 |           "Asia"
2977 |         ],
2978 |         "Dushanbe (Tajikistan)": [
2979 |           "Asia"
2980 |         ],
2981 |         "Dodoma (Tanzania, United Republic of)": [
2982 |           "Africa"
2983 |         ],
2984 |         "Bangkok (Thailand)": [
2985 |           "Asia"
2986 |         ],
2987 |         "Dili (Timor-Leste)": [
2988 |           "Asia"
2989 |         ],
2990 |         "Lomé (Togo)": [
2991 |           "Africa"
2992 |         ],
2993 |         "Fakaofo (Tokelau)": [
2994 |           "Oceania"
2995 |         ],
2996 |         "Nuku'alofa (Tonga)": [
2997 |           "Oceania"
2998 |         ],
2999 |         "Port of Spain (Trinidad and Tobago)": [
3000 |           "Americas"
3001 |         ],
3002 |         "Tunis (Tunisia)": [
3003 |           "Africa"
3004 |         ],
3005 |         "Ankara (Turkey)": [
3006 |           "Asia"
3007 |         ],
3008 |         "Ashgabat (Turkmenistan)": [
3009 |           "Asia"
3010 |         ],
3011 |         "Cockburn Town (Turks and Caicos Islands)": [
3012 |           "Americas"
3013 |         ],
3014 |         "Funafuti (Tuvalu)": [
3015 |           "Oceania"
3016 |         ],
3017 |         "Kampala (Uganda)": [
3018 |           "Africa"
3019 |         ],
3020 |         "Kiev (Ukraine)": [
3021 |           "Europe"
3022 |         ],
3023 |         "Abu Dhabi (United Arab Emirates)": [
3024 |           "Asia"
3025 |         ],
3026 |         "London (United Kingdom of Great Britain and Northern Ireland)": [
3027 |           "Europe"
3028 |         ],
3029 |         "Washington, D.C. (United States of America)": [
3030 |           "Americas"
3031 |         ],
3032 |         "Montevideo (Uruguay)": [
3033 |           "Americas"
3034 |         ],
3035 |         "Tashkent (Uzbekistan)": [
3036 |           "Asia"
3037 |         ],
3038 |         "Port Vila (Vanuatu)": [
3039 |           "Oceania"
3040 |         ],
3041 |         "Caracas (Venezuela (Bolivarian Republic of))": [
3042 |           "Americas"
3043 |         ],
3044 |         "Hanoi (Viet Nam)": [
3045 |           "Asia"
3046 |         ],
3047 |         "Mata-Utu (Wallis and Futuna)": [
3048 |           "Oceania"
3049 |         ],
3050 |         "El Aaiún (Western Sahara)": [
3051 |           "Africa"
3052 |         ],
3053 |         "Sana'a (Yemen)": [
3054 |           "Asia"
3055 |         ],
3056 |         "Lusaka (Zambia)": [
3057 |           "Africa"
3058 |         ],
3059 |         "Harare (Zimbabwe)": [
3060 |           "Africa"
3061 |         ]
3062 |     }, "food": {
3063 |         "Applesauce": [
3064 |           "fruit",
3065 |           "tree",
3066 |           "glass",
3067 |           "preserving"
3068 |         ],
3069 |         "Beef patty": [
3070 |           "pork",
3071 |           "ground",
3072 |           "steak"
3073 |         ],
3074 |         "Beef steak": [
3075 |           "meat",
3076 |           "cow",
3077 |           "t-bone",
3078 |           "tenderloin"
3079 |         ],
3080 |         "Beer ham": [
3081 |           "sausage",
3082 |           "alcohol"
3083 |         ],
3084 |         "Beer": [
3085 |           "drink",
3086 |           "bottle",
3087 |           "toast"
3088 |         ],
3089 |         "Big Mac": [
3090 |           "McDonalds",
3091 |           "hamburger",
3092 |           "pattie",
3093 |           "salad"
3094 |         ],
3095 |         "Bratwurst": [
3096 |           "currywurst",
3097 |           "Thüringer",
3098 |           "barbecue"
3099 |         ],
3100 |         "Brown bread": [
3101 |           "toast",
3102 |           "dark",
3103 |           "baking"
3104 |         ],
3105 |         "Budweiser (beer)": [
3106 |           "brewed",
3107 |           "purity law",
3108 |           "drink",
3109 |           "Czech Republic"
3110 |         ],
3111 |         "Burger King": [
3112 |           "McDonalds",
3113 |           "hamburger",
3114 |           "fries",
3115 |           "fast food"
3116 |         ],
3117 |         "Butter": [
3118 |           "magarine",
3119 |           "fat",
3120 |           "roast",
3121 |           "bread"
3122 |         ],
3123 |         "Camembert": [
3124 |           "cheese",
3125 |           "white",
3126 |           "cranberries"
3127 |         ],
3128 |         "Carlsberg (beer)": [
3129 |           "brewed",
3130 |           "purity",
3131 |           "drink",
3132 |           "green"
3133 |         ],
3134 |         "Chicken breast fillet": [
3135 |           "meat",
3136 |           "fine",
3137 |           "eggs"
3138 |         ],
3139 |         "Chocolate": [
3140 |           "cocoa",
3141 |           "Nutella",
3142 |           "Ritter Sport"
3143 |         ],
3144 |         "Ciabatta": [
3145 |           "bread",
3146 |           "baked",
3147 |           "Italy"
3148 |         ],
3149 |         "Cocktail sauce": [
3150 |           "barbecue",
3151 |           "steak"
3152 |         ],
3153 |         "Cola": [
3154 |           "drink",
3155 |           "Fanta",
3156 |           "Sprite",
3157 |           "brown",
3158 |           "Coca"
3159 |         ],
3160 |         "Cornflakes": [
3161 |           "breakfast",
3162 |           "milk",
3163 |           "Kellogs",
3164 |           "cereal"
3165 |         ],
3166 |         "Corona (beer)": [
3167 |           "brewed",
3168 |           "purity",
3169 |           "drink",
3170 |           "tequila"
3171 |         ],
3172 |         "Cream cake": [
3173 |           "cake",
3174 |           "butter",
3175 |           "milk",
3176 |           "sweet",
3177 |           "wedding"
3178 |         ],
3179 |         "Cream cheese": [
3180 |           "butter",
3181 |           "yogurt",
3182 |           "spread",
3183 |           "bread"
3184 |         ],
3185 |         "Cream pudding": [
3186 |           "sweet",
3187 |           "dessert"
3188 |         ],
3189 |         "Cream": [
3190 |           "butter",
3191 |           "milk",
3192 |           "cake",
3193 |           "sundae"
3194 |         ],
3195 |         "Crispbread": [
3196 |           "dry",
3197 |           "hard",
3198 |           "bread",
3199 |           "baked"
3200 |         ],
3201 |         "Croissant": [
3202 |           "Breakfast",
3203 |           "bent",
3204 |           "baked",
3205 |           "sweet",
3206 |           "jam"
3207 |         ],
3208 |         "Croquettes": [
3209 |           "potatoes",
3210 |           "fries",
3211 |           "wedges"
3212 |         ],
3213 |         "Crème fraiche": [
3214 |           "Potatoes",
3215 |           "cream",
3216 |           "cooking",
3217 |           "salad"
3218 |         ],
3219 |         "Currywurst": [
3220 |           "barbecue",
3221 |           "Berlin",
3222 |           "Thüringer"
3223 |         ],
3224 |         "Donut": [
3225 |           "round",
3226 |           "sweet",
3227 |           "glaze",
3228 |           "coffee"
3229 |         ],
3230 |         "Dried fruit": [
3231 |           "wet",
3232 |           "vegetable",
3233 |           "apple",
3234 |           "banana"
3235 |         ],
3236 |         "Duck": [
3237 |           "pond",
3238 |           "christmas",
3239 |           "drake",
3240 |           "goose"
3241 |         ],
3242 |         "Dunkin Donuts": [
3243 |           "coffee",
3244 |           "round",
3245 |           "sweet",
3246 |           "glaze"
3247 |         ],
3248 |         "Döner Kebab": [
3249 |           "Dürum",
3250 |           "falafel",
3251 |           "salad"
3252 |         ],
3253 |         "Dürüm": [
3254 |           "kebab",
3255 |           "falafel",
3256 |           "batter",
3257 |           "salad"
3258 |         ],
3259 |         "Eggs": [
3260 |           "chicken",
3261 |           "round",
3262 |           "white",
3263 |           "mirror",
3264 |           "pan"
3265 |         ],
3266 |         "Falafel": [
3267 |           "kebab",
3268 |           "salad"
3269 |         ],
3270 |         "Fish sticks": [
3271 |           "Iglo",
3272 |           "Captain",
3273 |           "Sea"
3274 |         ],
3275 |         "French Fries": [
3276 |           "McDonalds",
3277 |           "potatoes",
3278 |           "Pommes"
3279 |         ],
3280 |         "Fried potatoes": [
3281 |           "potato",
3282 |           "skillet",
3283 |           "bacon"
3284 |         ],
3285 |         "Frikadelle": [
3286 |           "boulette",
3287 |           "meatball",
3288 |           "meat"
3289 |         ],
3290 |         "Frozen pizza": [
3291 |           "freezing",
3292 |           "ice",
3293 |           "Italy",
3294 |           "salami"
3295 |         ],
3296 |         "Frozen vegetables": [
3297 |           "freezing",
3298 |           "fruit",
3299 |           "ice cream"
3300 |         ],
3301 |         "Fruit juice": [
3302 |           "drink",
3303 |           "apple",
3304 |           "orange",
3305 |           "tree"
3306 |         ],
3307 |         "Fruit": [
3308 |           "vegetable",
3309 |           "apple",
3310 |           "banana",
3311 |           "strawberry"
3312 |         ],
3313 |         "Fruitcake": [
3314 |           "Baking",
3315 |           "apple",
3316 |           "plum",
3317 |           "granny",
3318 |           "vegetable"
3319 |         ],
3320 |         "Goose": [
3321 |           "duck",
3322 |           "Christmas",
3323 |           "turkey"
3324 |         ],
3325 |         "Gouda": [
3326 |           "cheese",
3327 |           "Emmental",
3328 |           "Maßdamer"
3329 |         ],
3330 |         "Green salad": [
3331 |           "ceasar",
3332 |           "tomatoes",
3333 |           "cucumber"
3334 |         ],
3335 |         "Ground beef": [
3336 |           "shredder",
3337 |           "cow",
3338 |           "milk",
3339 |           "boulette"
3340 |         ],
3341 |         "Half-fat butter": [
3342 |           "magarine",
3343 |           "whole",
3344 |           "spread",
3345 |           "bread"
3346 |         ],
3347 |         "Ham and cheese croissant": [
3348 |           "sausage",
3349 |           "breakfast",
3350 |           "Paris",
3351 |           "France"
3352 |         ],
3353 |         "Hamburger": [
3354 |           "McDonalds",
3355 |           "Burger King",
3356 |           "bread",
3357 |           "pattie",
3358 |           "salad"
3359 |         ],
3360 |         "Heineken (beer)": [
3361 |           "brewed",
3362 |           "purity",
3363 |           "drink"
3364 |         ],
3365 |         "Herb curd": [
3366 |           "potatoes",
3367 |           "garden",
3368 |           "parsley"
3369 |         ],
3370 |         "Herring fillet": [
3371 |           "fish",
3372 |           "sea",
3373 |           "fishing",
3374 |           "fine"
3375 |         ],
3376 |         "Hollandaise sauce": [
3377 |           "cutlet",
3378 |           "asparagus",
3379 |           "Holland",
3380 |           "Netherlands"
3381 |         ],
3382 |         "Honey": [
3383 |           "bees",
3384 |           "beekeeper",
3385 |           "sweet",
3386 |           "breakfast",
3387 |           "bear"
3388 |         ],
3389 |         "Hot dog": [
3390 |           "bread",
3391 |           "sausage",
3392 |           "IKEA",
3393 |           "USA"
3394 |         ],
3395 |         "Ice cream": [
3396 |           "summer",
3397 |           "cold",
3398 |           "frozen",
3399 |           "chocolate",
3400 |           "vanilla",
3401 |           "cup"
3402 |         ],
3403 |         "Jack Daniels (whisky)": [
3404 |           "drink",
3405 |           "black"
3406 |         ],
3407 |         "Jello": [
3408 |           "green",
3409 |           "woodruff",
3410 |           "trembling",
3411 |           "sweet",
3412 |           "dessert"
3413 |         ],
3414 |         "Johnnie Walker (whisky)": [
3415 |           "drink",
3416 |           "USA",
3417 |           "go"
3418 |         ],
3419 |         "KFC": [
3420 |           "chicken wings",
3421 |           "fat",
3422 |           "USA",
3423 |           "bucket"
3424 |         ],
3425 |         "Lemonade": [
3426 |           "drink",
3427 |           "cola",
3428 |           "fanta",
3429 |           "sprite"
3430 |         ],
3431 |         "Licorice": [
3432 |           "sweet",
3433 |           "black",
3434 |           "snacking"
3435 |         ],
3436 |         "Liqueur": [
3437 |           "drink",
3438 |           "liquor"
3439 |         ],
3440 |         "Liver sausage": [
3441 |           "spread",
3442 |           "bread",
3443 |           "meat"
3444 |         ],
3445 |         "Mackerel": [
3446 |           "Fish",
3447 |           "Sea",
3448 |           "Fishing"
3449 |         ],
3450 |         "Margarine": [
3451 |           "Butter",
3452 |           "Spread",
3453 |           "Bread"
3454 |         ],
3455 |         "Marmalade": [
3456 |           "Breakfast",
3457 |           "Spread",
3458 |           "Bread",
3459 |           "Strawberries"
3460 |         ],
3461 |         "Marzipan": [
3462 |           "cake",
3463 |           "sweet",
3464 |           "decoration",
3465 |           "white"
3466 |         ],
3467 |         "Mascarpone": [
3468 |           "Tiramisu",
3469 |           "sweet",
3470 |           "heavy",
3471 |           "Italy"
3472 |         ],
3473 |         "Mayonnaise": [
3474 |           "ketchup",
3475 |           "sausage",
3476 |           "fries",
3477 |           "white"
3478 |         ],
3479 |         "McDonalds": [
3480 |           "burger king",
3481 |           "hamburger",
3482 |           "fries",
3483 |           "yellow",
3484 |           "bow"
3485 |         ],
3486 |         "Milk": [
3487 |           "cow",
3488 |           "white",
3489 |           "drink",
3490 |           "cereal",
3491 |           "breakfast",
3492 |           "lactose"
3493 |         ],
3494 |         "Minced meat": [
3495 |           "boulette",
3496 |           "beef",
3497 |           "pork"
3498 |         ],
3499 |         "Mousse": [
3500 |           "chocolate",
3501 |           "airy",
3502 |           "brown",
3503 |           "foam"
3504 |         ],
3505 |         "Mozzarella": [
3506 |           "pizza",
3507 |           "tomato",
3508 |           "Italy",
3509 |           "cheese"
3510 |         ],
3511 |         "Muesli": [
3512 |           "breakfast",
3513 |           "cornflakes",
3514 |           "milk",
3515 |           "bowl"
3516 |         ],
3517 |         "Non-alcoholic beer": [
3518 |           "girl",
3519 |           "drink"
3520 |         ],
3521 |         "Nut nougat cream": [
3522 |           "nutella",
3523 |           "chocolate",
3524 |           "breakfast"
3525 |         ],
3526 |         "Nutella": [
3527 |           "nut nougat cream",
3528 |           "chocolate",
3529 |           "breakfast",
3530 |           "spread"
3531 |         ],
3532 |         "Nuts": [
3533 |           "Macadamia",
3534 |           "fruit",
3535 |           "bowl",
3536 |           "trail mix"
3537 |         ],
3538 |         "Olives": [
3539 |           "oil",
3540 |           "green",
3541 |           "black",
3542 |           "bitter"
3543 |         ],
3544 |         "Oranges": [
3545 |           "Tangerine",
3546 |           "fruit",
3547 |           "Christmas"
3548 |         ],
3549 |         "Pancakes": [
3550 |           "Baking",
3551 |           "sweet",
3552 |           "jam",
3553 |           "dessert",
3554 |           "pie"
3555 |         ],
3556 |         "Pasta": [
3557 |           "spaghetti",
3558 |           "pasta",
3559 |           "tomato sauce",
3560 |           "Italy"
3561 |         ],
3562 |         "Pesto": [
3563 |           "pasta",
3564 |           "spaghetti",
3565 |           "herbs",
3566 |           "paste"
3567 |         ],
3568 |         "Pizza Hut": [
3569 |           "USA",
3570 |           "KFC",
3571 |           "fast food",
3572 |           "red",
3573 |           "Italy"
3574 |         ],
3575 |         "Pollock": [
3576 |           "fish",
3577 |           "sea",
3578 |           "fishing"
3579 |         ],
3580 |         "Popcorn": [
3581 |           "corn",
3582 |           "movie theater",
3583 |           "salt",
3584 |           "butter",
3585 |           "sugar",
3586 |           "snacking"
3587 |         ],
3588 |         "Pork chop": [
3589 |           "meat",
3590 |           "steak",
3591 |           "T-bone",
3592 |           "cow",
3593 |           "beef"
3594 |         ],
3595 |         "Pork cutlet": [
3596 |           "meat",
3597 |           "steak",
3598 |           "T-bone",
3599 |           "cow",
3600 |           "beef",
3601 |           "breading",
3602 |           "fries"
3603 |         ],
3604 |         "Potato chips": [
3605 |           "salty",
3606 |           "nibble",
3607 |           "chio"
3608 |         ],
3609 |         "Potato dumpling dough": [
3610 |           "roast",
3611 |           "red cabbage",
3612 |           "boil"
3613 |         ],
3614 |         "Potato salad": [
3615 |           "potato",
3616 |           "mayonnaise"
3617 |         ],
3618 |         "Potatoes": [
3619 |           "earth apple",
3620 |           "brown",
3621 |           "cooking",
3622 |           "fries"
3623 |         ],
3624 |         "Pudding": [
3625 |           "chocolate",
3626 |           "vanilla",
3627 |           "sweet",
3628 |           "dessert"
3629 |         ],
3630 |         "Puff pastry": [
3631 |           "paper",
3632 |           "sweet",
3633 |           "cake",
3634 |           "baking"
3635 |         ],
3636 |         "Rice crackers": [
3637 |           "white",
3638 |           "air",
3639 |           "snacking",
3640 |           "breaking"
3641 |         ],
3642 |         "Rice": [
3643 |           "asia",
3644 |           "china",
3645 |           "white",
3646 |           "grain",
3647 |           "chopsticks"
3648 |         ],
3649 |         "Roast Chicken": [
3650 |           "Broiler",
3651 |           "oven",
3652 |           "chicken wings",
3653 |           "skin"
3654 |         ],
3655 |         "Rollmops": [
3656 |           "Fish",
3657 |           "Bread",
3658 |           "Herring"
3659 |         ],
3660 |         "Rolls": [
3661 |           "Schrippe",
3662 |           "Semmel",
3663 |           "baked",
3664 |           "bakers"
3665 |         ],
3666 |         "Salad dressing": [
3667 |           "tomato",
3668 |           "herbs",
3669 |           "ceasar",
3670 |           "yogurt"
3671 |         ],
3672 |         "Salami": [
3673 |           "sausage",
3674 |           "pork",
3675 |           "mince",
3676 |           "topping"
3677 |         ],
3678 |         "Salmon": [
3679 |           "fish",
3680 |           "sea",
3681 |           "fishing",
3682 |           "tuna fish"
3683 |         ],
3684 |         "Saltines": [
3685 |           "brown",
3686 |           "pretzels",
3687 |           "nibbles"
3688 |         ],
3689 |         "Semolina pudding": [
3690 |           "dessert",
3691 |           "sweet",
3692 |           "cherries",
3693 |           "rice pudding"
3694 |         ],
3695 |         "Shrimp": [
3696 |           "Sea",
3697 |           "Fruit",
3698 |           "Sushi"
3699 |         ],
3700 |         "Soup": [
3701 |           "liquid",
3702 |           "water",
3703 |           "herbs",
3704 |           "broth"
3705 |         ],
3706 |         "Sour cream": [
3707 |           "sweet",
3708 |           "salty",
3709 |           "butter",
3710 |           "milk"
3711 |         ],
3712 |         "Sparkling wine": [
3713 |           "drink",
3714 |           "carbonated",
3715 |           "toast",
3716 |           "new year's eve"
3717 |         ],
3718 |         "Speisequark": [
3719 |           "potatoes",
3720 |           "herbs",
3721 |           "yogurt",
3722 |           "cream"
3723 |         ],
3724 |         "Sponge cake": [
3725 |           "Bake",
3726 |           "granny",
3727 |           "stick"
3728 |         ],
3729 |         "Spätzle": [
3730 |           "noodles",
3731 |           "dough",
3732 |           "Austria"
3733 |         ],
3734 |         "Starbucks": [
3735 |           "coffee",
3736 |           "expensive",
3737 |           "cup",
3738 |           "green",
3739 |           "USA",
3740 |           "hipster"
3741 |         ],
3742 |         "Steak": [
3743 |           "meat",
3744 |           "cutlet",
3745 |           "fries",
3746 |           "t-bone",
3747 |           "filet"
3748 |         ],
3749 |         "Subway": [
3750 |           "sandwich",
3751 |           "salad",
3752 |           "meat",
3753 |           "USA",
3754 |           "fast food",
3755 |           "cookies",
3756 |           "cookies"
3757 |         ],
3758 |         "Sunflower oil": [
3759 |           "canola",
3760 |           "olive oil",
3761 |           "frying",
3762 |           "cooking",
3763 |           "butter"
3764 |         ],
3765 |         "Sushi": [
3766 |           "fish",
3767 |           "seaweed",
3768 |           "rice",
3769 |           "Asia",
3770 |           "China",
3771 |           "Japan"
3772 |         ],
3773 |         "Tiramisu": [
3774 |           "mascarpone",
3775 |           "coffee",
3776 |           "biscuit",
3777 |           "cake",
3778 |           "Italy"
3779 |         ],
3780 |         "Toast Hawaii": [
3781 |           "pineapple",
3782 |           "ham",
3783 |           "bread",
3784 |           "USA",
3785 |           "state"
3786 |         ],
3787 |         "Toast": [
3788 |           "bread",
3789 |           "baking",
3790 |           "white",
3791 |           "light"
3792 |         ],
3793 |         "Tomato sauce": [
3794 |           "pasta",
3795 |           "spaghetti",
3796 |           "red",
3797 |           "bolognese"
3798 |         ],
3799 |         "Trout": [
3800 |           "fish",
3801 |           "sea",
3802 |           "fishing"
3803 |         ],
3804 |         "Vegetables": [
3805 |           "fruit",
3806 |           "salad",
3807 |           "tomato"
3808 |         ],
3809 |         "Whiskey": [
3810 |           "drink",
3811 |           "spirit",
3812 |           "scotland",
3813 |           "brown"
3814 |         ],
3815 |         "White bread": [
3816 |           "toast",
3817 |           "light",
3818 |           "dark",
3819 |           "black"
3820 |         ],
3821 |         "Wiener": [
3822 |           "Hot Dog",
3823 |           "Bread",
3824 |           "Austria"
3825 |         ],
3826 |         "Wine": [
3827 |           "drink",
3828 |           "red",
3829 |           "white",
3830 |           "adult"
3831 |         ],
3832 |         "Yogurt": [
3833 |           "sweet",
3834 |           "dessert"
3835 |         ]
3836 |     }, "literature": {
3837 |         "1984": [
3838 |           "George Orwell"
3839 |         ],
3840 |         "A Doll's House": [
3841 |           "Henrik Ibsen"
3842 |         ],
3843 |         "Absalom, Absalom!": [
3844 |           "William Faulkner"
3845 |         ],
3846 |         "Anna Karenina": [
3847 |           "Leo Tolstoy"
3848 |         ],
3849 |         "Beloved (Beloved Trilogy, #1)": [
3850 |           "Toni Morrison"
3851 |         ],
3852 |         "Berlin Alexanderplatz": [
3853 |           "Alfred Döblin"
3854 |         ],
3855 |         "Blindness": [
3856 |           "José Saramago"
3857 |         ],
3858 |         "Buddenbrooks: The Decline of a Family": [
3859 |           "Thomas Mann"
3860 |         ],
3861 |         "Crime and Punishment": [
3862 |           "Fyodor Dostoyevsky"
3863 |         ],
3864 |         "Dead Souls": [
3865 |           "Nikolai Gogol"
3866 |         ],
3867 |         "Demons": [
3868 |           "Fyodor Dostoyevsky"
3869 |         ],
3870 |         "Diary of a Madman and Other Stories": [
3871 |           "Lu Xun"
3872 |         ],
3873 |         "Don Quixote": [
3874 |           "Miguel de Cervantes Saavedra"
3875 |         ],
3876 |         "Faust, First Part": [
3877 |           "Johann Wolfgang von Goethe"
3878 |         ],
3879 |         "Ficciones": [
3880 |           "Jorge Luis Borges"
3881 |         ],
3882 |         "Gargantua and Pantagruel": [
3883 |           "François Rabelais"
3884 |         ],
3885 |         "Grande Sertão: Veredas": [
3886 |           "João Guimarães Rosa"
3887 |         ],
3888 |         "Great Expectations": [
3889 |           "Charles Dickens"
3890 |         ],
3891 |         "Gulliver's Travels": [
3892 |           "Jonathan Swift"
3893 |         ],
3894 |         "Hamlet": [
3895 |           "William Shakespeare"
3896 |         ],
3897 |         "History (La Storia, #1-2)": [
3898 |           "Elsa Morante"
3899 |         ],
3900 |         "Hunger": [
3901 |           "Knut Hamsun"
3902 |         ],
3903 |         "Independent People": [
3904 |           "Halldór Laxness"
3905 |         ],
3906 |         "Invisible Man": [
3907 |           "Ralph Ellison"
3908 |         ],
3909 |         "Jacques the Fatalist": [
3910 |           "Denis Diderot"
3911 |         ],
3912 |         "Journey to the End of the Night": [
3913 |           "Louis-Ferdinand Céline"
3914 |         ],
3915 |         "King Lear": [
3916 |           "William Shakespeare"
3917 |         ],
3918 |         "Leaves of Grass": [
3919 |           "Walt Whitman"
3920 |         ],
3921 |         "Lolita": [
3922 |           "Vladimir Nabokov"
3923 |         ],
3924 |         "Love in the Time of Cholera": [
3925 |           "Gabriel García Márquez"
3926 |         ],
3927 |         "Madame Bovary": [
3928 |           "Gustave Flaubert"
3929 |         ],
3930 |         "Mahabharata": [
3931 |           "Anonymous"
3932 |         ],
3933 |         "Medea": [
3934 |           "Euripides"
3935 |         ],
3936 |         "Memoirs of Hadrian": [
3937 |           "Marguerite Yourcenar"
3938 |         ],
3939 |         "Metamorphoses": [
3940 |           "Ovid"
3941 |         ],
3942 |         "Middlemarch": [
3943 |           "George Eliot"
3944 |         ],
3945 |         "Midnight's Children": [
3946 |           "Salman Rushdie"
3947 |         ],
3948 |         "Moby-Dick or, the Whale": [
3949 |           "Herman Melville"
3950 |         ],
3951 |         "Molloy, Malone Dies, The Unnamable": [
3952 |           "Samuel Beckett"
3953 |         ],
3954 |         "Mrs. Dalloway": [
3955 |           "Virginia Woolf"
3956 |         ],
3957 |         "Njal's Saga": [
3958 |           "Unknown"
3959 |         ],
3960 |         "Nostromo": [
3961 |           "Joseph Conrad"
3962 |         ],
3963 |         "Oedipus Rex  (The Theban Plays, #1)": [
3964 |           "Sophocles"
3965 |         ],
3966 |         "One Hundred Years of Solitude": [
3967 |           "Gabriel García Márquez"
3968 |         ],
3969 |         "Othello": [
3970 |           "William Shakespeare"
3971 |         ],
3972 |         "Pedro Páramo": [
3973 |           "Juan Rulfo"
3974 |         ],
3975 |         "Pippi Longstocking": [
3976 |           "Astrid Lindgren"
3977 |         ],
3978 |         "Poems of Paul Celan": [
3979 |           "Paul Celan"
3980 |         ],
3981 |         "Pride and Prejudice": [
3982 |           "Jane Austen"
3983 |         ],
3984 |         "Père Goriot": [
3985 |           "Honoré de Balzac"
3986 |         ],
3987 |         "Ramayana": [
3988 |           "Vālmīki"
3989 |         ],
3990 |         "Romancero gitano": [
3991 |           "Federico García Lorca"
3992 |         ],
3993 |         "Season of Migration to the North": [
3994 |           "Tayeb Salih"
3995 |         ],
3996 |         "Selected Stories of Anton Chekhov": [
3997 |           "Anton Chekhov"
3998 |         ],
3999 |         "Sentimental Education": [
4000 |           "Gustave Flaubert"
4001 |         ],
4002 |         "Sons and Lovers": [
4003 |           "D.H. Lawrence"
4004 |         ],
4005 |         "Swann's Way": [
4006 |           "Marcel Prous"
4007 |         ],
4008 |         "The Adventures of Huckleberry Finn": [
4009 |           "Mark Twain"
4010 |         ],
4011 |         "The Aeneid": [
4012 |           "Virgil"
4013 |         ],
4014 |         "The Arabian Nights": [
4015 |           "Anonymous"
4016 |         ],
4017 |         "The Book of Disquiet": [
4018 |           "Fernando Pessoa"
4019 |         ],
4020 |         "The Book of Job": [
4021 |           "Anonymous"
4022 |         ],
4023 |         "The Brothers Karamazov": [
4024 |           "Fyodor Dostoyevsky"
4025 |         ],
4026 |         "The Canterbury Tales": [
4027 |           "Geoffrey Chaucer"
4028 |         ],
4029 |         "The Castle": [
4030 |           "Franz Kafka"
4031 |         ],
4032 |         "The Collected Tales of Edgar Allan Poe": [
4033 |           "Edgar Allan Poe"
4034 |         ],
4035 |         "The Complete Essays": [
4036 |           "Michel de Montaigne"
4037 |         ],
4038 |         "The Complete Fairy Tales": [
4039 |           "Hans Christian Andersen"
4040 |         ],
4041 |         "The Complete Stories": [
4042 |           "Franz Kafka"
4043 |         ],
4044 |         "The Death of Ivan Ilych": [
4045 |           "Leo Tolstoy"
4046 |         ],
4047 |         "The Decameron": [
4048 |           "Giovanni Boccaccio"
4049 |         ],
4050 |         "The Divine Comedy": [
4051 |           "Dante Alighieri"
4052 |         ],
4053 |         "The Epic of Gilgamesh": [
4054 |           "Anonymous"
4055 |         ],
4056 |         "The Golden Notebook": [
4057 |           "Doris Lessing"
4058 |         ],
4059 |         "The Idiot": [
4060 |           "Fyodor Dostoyevsky"
4061 |         ],
4062 |         "The Iliad": [
4063 |           "Homer"
4064 |         ],
4065 |         "The Life and Opinions of Tristram Shandy, Gentleman": [
4066 |           "Laurence Sterne"
4067 |         ],
4068 |         "The Magic Mountain": [
4069 |           "Thomas Mann"
4070 |         ],
4071 |         "The Man Without Qualities": [
4072 |           "Robert Musil"
4073 |         ],
4074 |         "The Odyssey": [
4075 |           "Homer"
4076 |         ],
4077 |         "The Old Man and the Sea": [
4078 |           "Ernest Hemingway"
4079 |         ],
4080 |         "The Orchard: The Bostan Of Saadi Of Shiraz": [
4081 |           "Saadi"
4082 |         ],
4083 |         "The Poems Of Leopardi": [
4084 |           "Giacomo Leopardi"
4085 |         ],
4086 |         "The Recognition of Śakuntalā": [
4087 |           "Kālidāsa"
4088 |         ],
4089 |         "The Red and the Black": [
4090 |           "Stendhal"
4091 |         ],
4092 |         "The Sound and the Fury": [
4093 |           "William Faulkner"
4094 |         ],
4095 |         "The Sound of the Mountain": [
4096 |           "Yasunari Kawabata"
4097 |         ],
4098 |         "The Stranger": [
4099 |           "Albert Camus"
4100 |         ],
4101 |         "The Tale of Genji": [
4102 |           "Murasaki Shikibu"
4103 |         ],
4104 |         "The Tin Drum": [
4105 |           "Günter Grass"
4106 |         ],
4107 |         "The Trial": [
4108 |           "Franz Kafka"
4109 |         ],
4110 |         "Things Fall Apart (The African Trilogy, #1)": [
4111 |           "Chinua Achebe"
4112 |         ],
4113 |         "To the Lighthouse": [
4114 |           "Virginia Woolf"
4115 |         ],
4116 |         "Ulysses": [
4117 |           "James Joyce"
4118 |         ],
4119 |         "War and Peace": [
4120 |           "Leo Tolstoy"
4121 |         ],
4122 |         "Wuthering Heights": [
4123 |           "Emily Brontë"
4124 |         ],
4125 |         "Zeno's Conscience": [
4126 |           "Italo Svevo"
4127 |         ],
4128 |         "Zorba the Greek": [
4129 |           "Nikos Kazantzakis"
4130 |         ]
4131 |     }, "people": {
4132 |         "50 Cent": [
4133 |           "Dollar",
4134 |           "half",
4135 |           "Rap",
4136 |           "Hip Hop",
4137 |           "USA"
4138 |         ],
4139 |         "Abigail Breslin": [
4140 |           "Zombieland",
4141 |           "actress",
4142 |           "Hollywood",
4143 |           "USA"
4144 |         ],
4145 |         "Abraham Lincoln": [
4146 |           "president",
4147 |           "USA",
4148 |           "murder"
4149 |         ],
4150 |         "Adam Sandler": [
4151 |           "Jack & Jill",
4152 |           "Little Nicky",
4153 |           "actor",
4154 |           "Hollywood",
4155 |           "USA",
4156 |           "comedy"
4157 |         ],
4158 |         "Adolf Hitler": [
4159 |           "World War",
4160 |           "Stalin",
4161 |           "1945",
4162 |           "jews",
4163 |           "Holocaust",
4164 |           "Germany"
4165 |         ],
4166 |         "Al Capone": [
4167 |           "gangster",
4168 |           "Chicago",
4169 |           "Mafia",
4170 |           "Italy"
4171 |         ],
4172 |         "Al Pacino": [
4173 |           "The Godfather",
4174 |           "Scarface",
4175 |           "actor",
4176 |           "Hollywood",
4177 |           "USA"
4178 |         ],
4179 |         "Alan Rickman": [
4180 |           "Harry Potter",
4181 |           "Snape",
4182 |           "actor",
4183 |           "Hollywood",
4184 |           "USA"
4185 |         ],
4186 |         "Albert Einstein": [
4187 |           "theory of relativity",
4188 |           "physicist",
4189 |           "scientist",
4190 |           "Germany",
4191 |           "Haare"
4192 |         ],
4193 |         "Alec Baldwin": [
4194 |           "actor",
4195 |           "Hollywood",
4196 |           "USA"
4197 |         ],
4198 |         "Alexander Graham Bell": [
4199 |           "inventor",
4200 |           "USA",
4201 |           "entrepreneur",
4202 |           "telephone"
4203 |         ],
4204 |         "Alfred Hitchcock": [
4205 |           "author",
4206 |           "director",
4207 |           "thriller",
4208 |           "Psycho",
4209 |           "Vertigo"
4210 |         ],
4211 |         "Alison Brie": [
4212 |           "BoJack Horseman",
4213 |           "Mad Men",
4214 |           "actress",
4215 |           "Hollywood",
4216 |           "USA"
4217 |         ],
4218 |         "Amanda Seyfried": [
4219 |           "Les Misérables",
4220 |           "The Big Wedding",
4221 |           "actress",
4222 |           "Hollywood",
4223 |           "USA"
4224 |         ],
4225 |         "Amy Adams": [
4226 |           "American Hustle",
4227 |           "Arrival",
4228 |           "actress",
4229 |           "Hollywood",
4230 |           "USA"
4231 |         ],
4232 |         "Andie MacDowell": [
4233 |           "Footloose",
4234 |           "actress",
4235 |           "Hollywood",
4236 |           "USA"
4237 |         ],
4238 |         "Andy Warhol": [
4239 |           "artist",
4240 |           "producer",
4241 |           "movies",
4242 |           "Pop Art",
4243 |           "illustrations",
4244 |           "dead"
4245 |         ],
4246 |         "Angela Merkel": [
4247 |           "Germany",
4248 |           "federal chancellor",
4249 |           "European Union",
4250 |           "CDU / CSU",
4251 |           "government",
4252 |           "rue"
4253 |         ],
4254 |         "Anne Hathaway": [
4255 |           "Les Misérables",
4256 |           "Interstellar",
4257 |           "actress",
4258 |           "Hollywood",
4259 |           "USA"
4260 |         ],
4261 |         "Anthony Hopkins": [
4262 |           "Silence of the Lambs",
4263 |           "Hannibal Lecter",
4264 |           "actor",
4265 |           "Hollywood",
4266 |           "USA"
4267 |         ],
4268 |         "Anthony Quinn": [
4269 |           "Alexis Sorbas",
4270 |           "actor",
4271 |           "Hollywood",
4272 |           "Mexiko"
4273 |         ],
4274 |         "Arnold Schwarzenegger": [
4275 |           "actor",
4276 |           "Hollywood",
4277 |           "USA",
4278 |           "Terminator",
4279 |           "I'll be back"
4280 |         ],
4281 |         "Audrey Hepburn": [
4282 |           "Breakfast at Tiffany's",
4283 |           "My Fair Lady",
4284 |           "actress",
4285 |           "Hollywood",
4286 |           "USA"
4287 |         ],
4288 |         "Barbara Streisand": [
4289 |           "Woman in Love",
4290 |           "Funny Girl",
4291 |           "singerin",
4292 |           "actress",
4293 |           "Hollywood",
4294 |           "USA"
4295 |         ],
4296 |         "Ben Kingsley": [
4297 |           "Schindlers List",
4298 |           "Shutter Island",
4299 |           "actor",
4300 |           "Hollywood",
4301 |           "USA"
4302 |         ],
4303 |         "Ben Stiller": [
4304 |           "Night in the Museum",
4305 |           "actor",
4306 |           "Hollywood",
4307 |           "USA",
4308 |           "comedy"
4309 |         ],
4310 |         "Benedict Cumberbatch": [
4311 |           "Doctor Strange",
4312 |           "Avengers",
4313 |           "Sherlock Holmes",
4314 |           "actor",
4315 |           "Hollywood",
4316 |           "USA"
4317 |         ],
4318 |         "Benicio Del Toro": [
4319 |           "Che",
4320 |           "The Usual Suspects",
4321 |           "Fear and Loathing in Las Vegas",
4322 |           "actor",
4323 |           "Hollywood"
4324 |         ],
4325 |         "Benjamin Franklin": [
4326 |           "inventor",
4327 |           "book printing",
4328 |           "kite",
4329 |           "electricity",
4330 |           "USA",
4331 |           "independence"
4332 |         ],
4333 |         "Bill Gates": [
4334 |           "Windows",
4335 |           "Microsoft",
4336 |           "Computer",
4337 |           "PC",
4338 |           "Software"
4339 |         ],
4340 |         "Bill Murray": [
4341 |           "Lost in Translation",
4342 |           "Ghost Busters",
4343 |           "actor",
4344 |           "Hollywood",
4345 |           "USA"
4346 |         ],
4347 |         "Blake Lively": [
4348 |           "Gossip Girl",
4349 |           "actress",
4350 |           "Hollywood",
4351 |           "USA"
4352 |         ],
4353 |         "Bob Dylan": [
4354 |           "singer",
4355 |           "songs",
4356 |           "harmonica",
4357 |           "Folk",
4358 |           "Rock"
4359 |         ],
4360 |         "Bob Marley": [
4361 |           "Three Little Birds",
4362 |           "Reggae",
4363 |           "chill",
4364 |           "joint",
4365 |           "Jamaica"
4366 |         ],
4367 |         "Bono": [
4368 |           "singer",
4369 |           "U2",
4370 |           "Rock",
4371 |           "England"
4372 |         ],
4373 |         "Brad Pitt": [
4374 |           "Fight Club",
4375 |           "12 Monkeys",
4376 |           "Interview with the Vampire",
4377 |           "actor",
4378 |           "Hollywood",
4379 |           "Angelina Jolie"
4380 |         ],
4381 |         "Bradley Cooper": [
4382 |           "Silver Linings",
4383 |           "American Hustle",
4384 |           "American Sniper",
4385 |           "actor",
4386 |           "Hollywood",
4387 |           "USA"
4388 |         ],
4389 |         "Bruce Lee": [
4390 |           "China",
4391 |           "Kung Fu",
4392 |           "Jackie Chan",
4393 |           "Karate"
4394 |         ],
4395 |         "Buzz Aldrin": [
4396 |           "astronaut",
4397 |           "NASA",
4398 |           "USA",
4399 |           "Big Bang Thory"
4400 |         ],
4401 |         "Catherine Zeta-Jones": [
4402 |           "Chicago",
4403 |           "Ocean's 12",
4404 |           "actress",
4405 |           "Hollywood",
4406 |           "USA"
4407 |         ],
4408 |         "Channing Tatum": [
4409 |           "actor",
4410 |           "Hollywood",
4411 |           "USA"
4412 |         ],
4413 |         "Charles Darwin": [
4414 |           "naturalist",
4415 |           "geologist",
4416 |           "biologist",
4417 |           "science of evolution"
4418 |         ],
4419 |         "Charles De Gaulle": [
4420 |           "president",
4421 |           "France",
4422 |           "World War"
4423 |         ],
4424 |         "Charles Dickens": [
4425 |           "writer",
4426 |           "author",
4427 |           "A Christmas Carol",
4428 |           "Oliver Twist"
4429 |         ],
4430 |         "Charlie Chaplin": [
4431 |           "actor",
4432 |           "Hollywood",
4433 |           "USA",
4434 |           "silent movies"
4435 |         ],
4436 |         "Charlie Sheen": [
4437 |           "actor",
4438 |           "Hollywood",
4439 |           "USA",
4440 |           "Two and a half Men",
4441 |           "Hot Shots"
4442 |         ],
4443 |         "Ernesto Che Guevara": [
4444 |           "revolution",
4445 |           "Cuba",
4446 |           "Fidel Castro"
4447 |         ],
4448 |         "Chris Evans": [
4449 |           "actor",
4450 |           "Hollywood",
4451 |           "USA",
4452 |           "Avengers",
4453 |           "Marvel"
4454 |         ],
4455 |         "Chris Hemsworth": [
4456 |           "actor",
4457 |           "Hollywood",
4458 |           "USA",
4459 |           "Thor"
4460 |         ],
4461 |         "Chris Pratt": [
4462 |           "actor",
4463 |           "Hollywood",
4464 |           "USA",
4465 |           "Guardians of the Galaxy",
4466 |           "Jurassic Park"
4467 |         ],
4468 |         "Christian Bale": [
4469 |           "actor",
4470 |           "Hollywood",
4471 |           "Batman",
4472 |           "The Dark Knight",
4473 |           "American Psycho"
4474 |         ],
4475 |         "Christoph Waltz": [
4476 |           "actor",
4477 |           "Django Unchained",
4478 |           "Inglorious Basterds"
4479 |         ],
4480 |         "Christopher Columbus": [
4481 |           "Italy",
4482 |           "explorer",
4483 |           "Atlantic Ocean",
4484 |           "America"
4485 |         ],
4486 |         "Christopher Nolan": [
4487 |           "director",
4488 |           "Inception",
4489 |           "Interstellar",
4490 |           "Dunkirk",
4491 |           "Prestige"
4492 |         ],
4493 |         "Christopher Walken": [
4494 |           "actor",
4495 |           "Hollywood",
4496 |           "USA",
4497 |           "7 Psychos"
4498 |         ],
4499 |         "Chuck Norris": [
4500 |           "actor",
4501 |           "Roundhouse Kick",
4502 |           "Walker Texas Ranger"
4503 |         ],
4504 |         "Clint Eastwood": [
4505 |           "actor",
4506 |           "Hollywood",
4507 |           "Million Dollar Baby",
4508 |           "Gran Turino"
4509 |         ],
4510 |         "Colin Firth": [
4511 |           "actor",
4512 |           "Hollywood",
4513 |           "A Single Man",
4514 |           "Kingsman"
4515 |         ],
4516 |         "Dame Elizabeth Taylor": [
4517 |           "actress",
4518 |           "There's One Born Every Minute",
4519 |           "Hollywood",
4520 |           "National Velvet"
4521 |         ],
4522 |         "Daniel Day-Lewis": [
4523 |           "actor",
4524 |           "There will be Blood",
4525 |           "Gangs of New York"
4526 |         ],
4527 |         "Daniel Radcliffe": [
4528 |           "actor",
4529 |           "Harry Potter",
4530 |           "mage",
4531 |           "Hogwarts"
4532 |         ],
4533 |         "Danny DeVito": [
4534 |           "actor",
4535 |           "Hollywood",
4536 |           "Twins",
4537 |           "Batman"
4538 |         ],
4539 |         "David Hasselhoff": [
4540 |           "Knight Rider",
4541 |           "Baywatch"
4542 |         ],
4543 |         "Demi Moore": [
4544 |           "actor",
4545 |           "Hollywood",
4546 |           "G.I. Jane",
4547 |           "Charlies Angels"
4548 |         ],
4549 |         "Denzel Washington": [
4550 |           "actor",
4551 |           "Hollywood",
4552 |           "The Book of Eli",
4553 |           "Training Day"
4554 |         ],
4555 |         "Diane Keaton": [
4556 |           "actress",
4557 |           "Manhattan"
4558 |         ],
4559 |         "Diane Kruger": [
4560 |           "actress",
4561 |           "Inglorious Basterds",
4562 |           "Unknown Identity"
4563 |         ],
4564 |         "Dr. Stephen Hawking": [
4565 |           "physicist",
4566 |           "dead"
4567 |         ],
4568 |         "Dustin Hoffman": [
4569 |           "actor",
4570 |           "Hollywood",
4571 |           "Tootsie",
4572 |           "Rain Man"
4573 |         ],
4574 |         "Dwayne 'The Rock' Johnson": [
4575 |           "actor",
4576 |           "Hollywood",
4577 |           "USA",
4578 |           "Fast and Furious",
4579 |           "wrestling"
4580 |         ],
4581 |         "Eddie Murphy": [
4582 |           "actor",
4583 |           "Hollywood",
4584 |           "USA",
4585 |           "Beverly Hills Cop"
4586 |         ],
4587 |         "Edgar Allan Poe": [
4588 |           "author",
4589 |           "poet",
4590 |           "Boston"
4591 |         ],
4592 |         "Edward Norton": [
4593 |           "actor",
4594 |           "Hollywood",
4595 |           "USA",
4596 |           "Fight Club",
4597 |           "American History X"
4598 |         ],
4599 |         "Ellen Page": [
4600 |           "Schauspielerin",
4601 |           "Juno",
4602 |           "Inception",
4603 |           "Hard Candy",
4604 |           "X-Men"
4605 |         ],
4606 |         "Elvis Presley": [
4607 |           "singer",
4608 |           "Rock",
4609 |           "Jailhouse Rock",
4610 |           "Las Vegas"
4611 |         ],
4612 |         "Elyas M'Barek": [
4613 |           "actor",
4614 |           "Germany"
4615 |         ],
4616 |         "Eminem": [
4617 |           "Rapper",
4618 |           "Slim Shady",
4619 |           "Detroit",
4620 |           "Without me"
4621 |         ],
4622 |         "Emma Stone": [
4623 |           "actress",
4624 |           "Zombieland",
4625 |           "La La Land"
4626 |         ],
4627 |         "Emma Watson": [
4628 |           "actor",
4629 |           "Hogwarts",
4630 |           "Harry Potter",
4631 |           "Hermine"
4632 |         ],
4633 |         "Ernest Hemingway": [
4634 |           "author",
4635 |           "Nobel Price",
4636 |           "The Old Man and the Sea"
4637 |         ],
4638 |         "Federico Fellini": [
4639 |           "Italia",
4640 |           "director",
4641 |           "screenwriter",
4642 |           "La Strada"
4643 |         ],
4644 |         "Felicity Jones": [
4645 |           "actress",
4646 |           "Star Wars: Rogue One",
4647 |           "Like Crazy",
4648 |           "Inferno",
4649 |           "The Theory of Everything"
4650 |         ],
4651 |         "Fidel Castro": [
4652 |           "Che Guevara",
4653 |           "Cuba"
4654 |         ],
4655 |         "Frank Sinatra": [
4656 |           "singer",
4657 |           "Swing",
4658 |           "Jazz",
4659 |           "New York, New York"
4660 |         ],
4661 |         "Freddie Mercury": [
4662 |           "Queen",
4663 |           "singer",
4664 |           "Rock",
4665 |           "We will Rock you"
4666 |         ],
4667 |         "Galileo Galilei": [
4668 |           "philosopher",
4669 |           "astrologer",
4670 |           "inventor",
4671 |           "church"
4672 |         ],
4673 |         "Geena Davis": [
4674 |           "actress",
4675 |           "Thelma & Louise"
4676 |         ],
4677 |         "Gene Hackman": [
4678 |           "actor",
4679 |           "Hollywood",
4680 |           "The French Connection"
4681 |         ],
4682 |         "Gene Kelly": [
4683 |           "actor",
4684 |           "Singin in the Rain"
4685 |         ],
4686 |         "General Dwight D. Eisenhower": [
4687 |           "World War",
4688 |           "president",
4689 |           "USA",
4690 |           "invasion of Normandy"
4691 |         ],
4692 |         "Geoffrey Rush": [
4693 |           "actor",
4694 |           "Shine",
4695 |           "Pirates of the Caribbean"
4696 |         ],
4697 |         "George Clooney": [
4698 |           "actor",
4699 |           "Hollywood",
4700 |           "Michael Clayton",
4701 |           "From Dusk till Dawn"
4702 |         ],
4703 |         "George Washington": [
4704 |           "first president",
4705 |           "USA",
4706 |           "US Constitution"
4707 |         ],
4708 |         "Gerard Depardieu": [
4709 |           "actor",
4710 |           "France",
4711 |           "The Man with the Iron Mask",
4712 |           "Danton"
4713 |         ],
4714 |         "Glenn Close": [
4715 |           "actress",
4716 |           "Fatal Attraction"
4717 |         ],
4718 |         "Grigorij Rasputin": [
4719 |           "Russia",
4720 |           "charlatan"
4721 |         ],
4722 |         "Harrison Ford": [
4723 |           "Han Solo",
4724 |           "Star Wars",
4725 |           "Indiana Jones",
4726 |           "actor",
4727 |           "Hollywood"
4728 |         ],
4729 |         "Harry Houdini": [
4730 |           "illusionist",
4731 |           "stunt performer",
4732 |           "escape performance"
4733 |         ],
4734 |         "Hayley Atwell": [
4735 |           "actress",
4736 |           "Marvel",
4737 |           "Captain America",
4738 |           "Peggy Carter"
4739 |         ],
4740 |         "Heath Ledger": [
4741 |           "actor",
4742 |           "Hollywood",
4743 |           "USA",
4744 |           "Batman",
4745 |           "Joker"
4746 |         ],
4747 |         "Helen Mirren": [
4748 |           "actress",
4749 |           "RED",
4750 |           "The Queen"
4751 |         ],
4752 |         "Hugh Grant": [
4753 |           "actor",
4754 |           "Hollywood",
4755 |           "England"
4756 |         ],
4757 |         "Hugh Jackman": [
4758 |           "Wolverine",
4759 |           "actor",
4760 |           "Hollywood",
4761 |           "USA"
4762 |         ],
4763 |         "Humphrey Bogart": [
4764 |           "actor",
4765 |           "Casablanca",
4766 |           "The Treasure of the Sierra Madre"
4767 |         ],
4768 |         "Ian McKellen": [
4769 |           "Gandalf",
4770 |           "Lord of the Rings",
4771 |           "actor",
4772 |           "Hollywood",
4773 |           "USA"
4774 |         ],
4775 |         "Jack Nicholson": [
4776 |           "actor",
4777 |           "Hollywood",
4778 |           "Shining",
4779 |           "As Good as it Gets"
4780 |         ],
4781 |         "Jackie Chan": [
4782 |           "actor",
4783 |           "China",
4784 |           "Kung Fu",
4785 |           "Karate"
4786 |         ],
4787 |         "Jake Gyllenhaal": [
4788 |           "actor",
4789 |           "Hollywood",
4790 |           "USA",
4791 |           "Nightcrawler"
4792 |         ],
4793 |         "James Dean": [
4794 |           "actor",
4795 |           "cigarette",
4796 |           "icon",
4797 |           "Rebel Without a Cause"
4798 |         ],
4799 |         "Jamie Lee Curtis": [
4800 |           "Alien",
4801 |           "actor",
4802 |           "Hollywood",
4803 |           "USA"
4804 |         ],
4805 |         "Janis Joplin": [
4806 |           "singer",
4807 |           "Rock",
4808 |           "Soul",
4809 |           "Piece of My Heart"
4810 |         ],
4811 |         "Jared Leto": [
4812 |           "actor",
4813 |           "Dallas Buyers Club",
4814 |           "Suicide Squad"
4815 |         ],
4816 |         "Jean Reno": [
4817 |           "actor",
4818 |           "France",
4819 |           "Leon",
4820 |           "Ronin",
4821 |           "Wasabi"
4822 |         ],
4823 |         "Jeff Bridges": [
4824 |           "actor",
4825 |           "The Big Lebowski",
4826 |           "Dude",
4827 |           "bowling"
4828 |         ],
4829 |         "Jennifer Aniston": [
4830 |           "Friends",
4831 |           "actress",
4832 |           "Hollywood",
4833 |           "USA"
4834 |         ],
4835 |         "Jennifer Lawrence": [
4836 |           "actress",
4837 |           "Hollywood",
4838 |           "The Hunger Games",
4839 |           "Silver Linings",
4840 |           "American Hustle",
4841 |           "X-Men"
4842 |         ],
4843 |         "Jim Carrey": [
4844 |           "actor",
4845 |           "Hollywood",
4846 |           "Ace Ventura",
4847 |           "comedy",
4848 |           "Bruce Almighty"
4849 |         ],
4850 |         "Jim Morrison": [
4851 |           "singer",
4852 |           "The Doors",
4853 |           "Rock"
4854 |         ],
4855 |         "Jimi Hendrix": [
4856 |           "singer",
4857 |           "Rock",
4858 |           "Woodstock",
4859 |           "E-Gitarre"
4860 |         ],
4861 |         "Joaquin Phoenix": [
4862 |           "actor",
4863 |           "Joker",
4864 |           "Batman",
4865 |           "her",
4866 |           "Walk the Line"
4867 |         ],
4868 |         "Jodie Foster": [
4869 |           "actor",
4870 |           "Hollywood",
4871 |           "Silence of the Lambs",
4872 |           "Taxi Driver"
4873 |         ],
4874 |         "John F. Kennedy": [
4875 |           "president",
4876 |           "USA",
4877 |           "murder",
4878 |           "Vietnam"
4879 |         ],
4880 |         "John Goodman": [
4881 |           "The Big Lebowski",
4882 |           "actor",
4883 |           "Hollywood",
4884 |           "USA"
4885 |         ],
4886 |         "John Lennon": [
4887 |           "singer",
4888 |           "activist",
4889 |           "Beatles",
4890 |           "Paul McCartney"
4891 |         ],
4892 |         "John Wayne": [
4893 |           "True Grit",
4894 |           "actor",
4895 |           "Alamo"
4896 |         ],
4897 |         "Johnny Depp": [
4898 |           "Pirates of the Caribbean",
4899 |           "Fear and Loathing in Las Vegas",
4900 |           "Charlie and the Cholocate Factory",
4901 |           "actor",
4902 |           "Hollywood"
4903 |         ],
4904 |         "Josef Stalin": [
4905 |           "Russia",
4906 |           "World War",
4907 |           "Soviet Union",
4908 |           "communists"
4909 |         ],
4910 |         "Joseph Gordon-Levitt": [
4911 |           "actor",
4912 |           "Inception",
4913 |           "Looper",
4914 |           "Don Jon",
4915 |           "50/50",
4916 |           "Snowden"
4917 |         ],
4918 |         "Julianne Moore": [
4919 |           "actress",
4920 |           "Far from Heaven",
4921 |           "The Kids are all right"
4922 |         ],
4923 |         "Justin Bieber": [
4924 |           "singer",
4925 |           "Pop",
4926 |           "Teenie-Star",
4927 |           "One Time"
4928 |         ],
4929 |         "Karl Lagerfeld": [
4930 |           "Designer",
4931 |           "fashion",
4932 |           "suit",
4933 |           "Germany",
4934 |           "fashionzar"
4935 |         ],
4936 |         "Kat Dennings": [
4937 |           "Two Broke Girls",
4938 |           "actress",
4939 |           "Hollywood",
4940 |           "USA"
4941 |         ],
4942 |         "Kate Beckinsale": [
4943 |           "actress",
4944 |           "Hollywood",
4945 |           "Underworld",
4946 |           "Aviator"
4947 |         ],
4948 |         "Kate Winslet": [
4949 |           "Titanic",
4950 |           "Leonardo DiCaprio",
4951 |           "actress",
4952 |           "Hollywood"
4953 |         ],
4954 |         "Keira Knightley": [
4955 |           "actress",
4956 |           "Pirates of the Caribbean",
4957 |           "Atonement",
4958 |           "The Immitation Game"
4959 |         ],
4960 |         "Kevin James": [
4961 |           "King of Queens",
4962 |           "Doug",
4963 |           "actor",
4964 |           "Hollywood",
4965 |           "comedy"
4966 |         ],
4967 |         "Kevin Spacey": [
4968 |           "actor",
4969 |           "Hollywood",
4970 |           "The usual Suspects",
4971 |           "LA Confidential",
4972 |           "Seven",
4973 |           "House of Cards"
4974 |         ],
4975 |         "Kiefer Sutherland": [
4976 |           "24h",
4977 |           "actor",
4978 |           "Hollywood",
4979 |           "USA"
4980 |         ],
4981 |         "Kristen Stewart": [
4982 |           "Twilight",
4983 |           "actor",
4984 |           "Bella",
4985 |           "Snow White and the Huntsman"
4986 |         ],
4987 |         "Kurt Cobain": [
4988 |           "singer",
4989 |           "Nirvana",
4990 |           "Rock",
4991 |           "suicide",
4992 |           "Smells Like Teen Spirit"
4993 |         ],
4994 |         "Lance Armstrong": [
4995 |           "sports",
4996 |           "road racing cyclist",
4997 |           "Tour de France",
4998 |           "Doping"
4999 |         ],
5000 |         "Leonardo Da Vinci": [
5001 |           "artist",
5002 |           "inventor",
5003 |           "The Last Supper",
5004 |           "Mona Lisa",
5005 |           "Italia",
5006 |           "Renaissance"
5007 |         ],
5008 |         "Leonardo DiCaprio": [
5009 |           "Titanic",
5010 |           "Wolf of Wallstreet",
5011 |           "Inception",
5012 |           "The Beach",
5013 |           "actor"
5014 |         ],
5015 |         "Liam Neeson": [
5016 |           "Star Wars",
5017 |           "actor",
5018 |           "Hollywood",
5019 |           "Schindlers List",
5020 |           "96 Hours"
5021 |         ],
5022 |         "Louis Armstrong": [
5023 |           "musician",
5024 |           "Jazz",
5025 |           "trumpet"
5026 |         ],
5027 |         "Ludwig van Beethoven": [
5028 |           "German",
5029 |           "composer",
5030 |           "Vienna",
5031 |           "Violin Concerto",
5032 |           "Classic"
5033 |         ],
5034 |         "Maggie Smith": [
5035 |           "Harry Potter",
5036 |           "Prof. McGonnagall",
5037 |           "actress",
5038 |           "Hogwarts"
5039 |         ],
5040 |         "Mahatma Gandhi": [
5041 |           "India",
5042 |           "Buddhism",
5043 |           "peace"
5044 |         ],
5045 |         "Malcolm X": [
5046 |           "black",
5047 |           "Muslim",
5048 |           "activist",
5049 |           "human civil rights",
5050 |           "Nation of Islam"
5051 |         ],
5052 |         "Margot Robbie": [
5053 |           "actress",
5054 |           "Wolf of Wallstreet",
5055 |           "Suicide Squad"
5056 |         ],
5057 |         "Marie Antoinette": [
5058 |           "France",
5059 |           "queen",
5060 |           "revolution"
5061 |         ],
5062 |         "Marie Curie": [
5063 |           "Polish",
5064 |           "physicist",
5065 |           "chemist",
5066 |           "radioactivity"
5067 |         ],
5068 |         "Marilyn Monroe": [
5069 |           "icon",
5070 |           "actress",
5071 |           "Hollywood",
5072 |           "dead"
5073 |         ],
5074 |         "Mark Twain": [
5075 |           "author",
5076 |           "writer",
5077 |           "humorist",
5078 |           "publisher",
5079 |           "Tom Sawyer",
5080 |           "Huckleberry Finn"
5081 |         ],
5082 |         "Mark Wahlberg": [
5083 |           "actor",
5084 |           "Hollywood",
5085 |           "Marky Mark",
5086 |           "Calvin Klein",
5087 |           "Ted",
5088 |           "Boogie Nights"
5089 |         ],
5090 |         "Marlene Dietrich": [
5091 |           "actress",
5092 |           "singer",
5093 |           "Germany",
5094 |           "silent films"
5095 |         ],
5096 |         "Marlon Brando": [
5097 |           "actor",
5098 |           "Godfather",
5099 |           "Mafia",
5100 |           "Apocalypse Now"
5101 |         ],
5102 |         "Martin Lawrence": [
5103 |           "actor",
5104 |           "black",
5105 |           "Bad Boys",
5106 |           "Big Mommas House"
5107 |         ],
5108 |         "Martin Luther King": [
5109 |           "civil rights movement",
5110 |           "black",
5111 |           "I have a Dream",
5112 |           "activist"
5113 |         ],
5114 |         "Matt Damon": [
5115 |           "Jason Bourne",
5116 |           "actor",
5117 |           "Good Will Hunting",
5118 |           "The Martian",
5119 |           "The talented Mr. Rippley"
5120 |         ],
5121 |         "Matthew McConaughey": [
5122 |           "actor",
5123 |           "Dallas Buyers Club",
5124 |           "Interstellar",
5125 |           "Lincoln",
5126 |           "Wolf of Wall Street"
5127 |         ],
5128 |         "Matthew Perry": [
5129 |           "Friends",
5130 |           "Chandler Bing",
5131 |           "actor",
5132 |           "The whole nine yards",
5133 |           "Studio 60"
5134 |         ],
5135 |         "Matthias Schweighöfer": [
5136 |           "actor",
5137 |           "Germany",
5138 |           "Till Schweiger",
5139 |           "You are Wanted"
5140 |         ],
5141 |         "Mel Gibson": [
5142 |           "actor",
5143 |           "Braveheart",
5144 |           "Leathal Weapon",
5145 |           "Martin Riggs",
5146 |           "Hacksaw Ridge",
5147 |           "The Passion of the Christ"
5148 |         ],
5149 |         "Meryl Streep": [
5150 |           "actress",
5151 |           "The Devil wears Prada",
5152 |           "Out of Africa"
5153 |         ],
5154 |         "Mette Marit": [
5155 |           "princess",
5156 |           "Norway",
5157 |           "Queen",
5158 |           "royal",
5159 |           "Scandinavia"
5160 |         ],
5161 |         "Michael Caine": [
5162 |           "Batman",
5163 |           "actor",
5164 |           "Dark Knight",
5165 |           "Cutter",
5166 |           "Prestige"
5167 |         ],
5168 |         "Michael Douglas": [
5169 |           "actor",
5170 |           "Wall Street",
5171 |           "Basic Instinct",
5172 |           "Hank Pym",
5173 |           "Marvel"
5174 |         ],
5175 |         "Michael J. Fox": [
5176 |           "Marty",
5177 |           "Back to the Future",
5178 |           "Doc",
5179 |           "actor",
5180 |           "Hollywood",
5181 |           "Pakinson"
5182 |         ],
5183 |         "Michael Jackson": [
5184 |           "singer",
5185 |           "white",
5186 |           "Beat it",
5187 |           "Billie Jean",
5188 |           "Thriller"
5189 |         ],
5190 |         "Michael Jordan": [
5191 |           "basketball",
5192 |           "NBA",
5193 |           "Space Jam",
5194 |           "Chicago Bulls"
5195 |         ],
5196 |         "Michelangelo": [
5197 |           "painter",
5198 |           "artist",
5199 |           "Italy",
5200 |           "Sistine Chapel",
5201 |           "Renaissance"
5202 |         ],
5203 |         "Michelle Pfeiffer": [
5204 |           "actress",
5205 |           "Hairspray",
5206 |           "Maleficent",
5207 |           "One Fine Day"
5208 |         ],
5209 |         "Mick Jagger": [
5210 |           "singer",
5211 |           "Rolling Stones",
5212 |           "Rock",
5213 |           "Keith Richards"
5214 |         ],
5215 |         "Mike Myers": [
5216 |           "actor",
5217 |           "Austin Powers",
5218 |           "Goldmember",
5219 |           "spy"
5220 |         ],
5221 |         "Mila Kunis": [
5222 |           "actress",
5223 |           "Black Swan",
5224 |           "Bad Moms",
5225 |           "Jupiter Ascending"
5226 |         ],
5227 |         "Miles Davis": [
5228 |           "musician",
5229 |           "jazz",
5230 |           "trumpeter",
5231 |           "blues",
5232 |           "Blue in Green",
5233 |           "So What"
5234 |         ],
5235 |         "Miranda Richardson": [
5236 |           "actress",
5237 |           "The Crying Game",
5238 |           "Spider",
5239 |           "Sleepy Hollow"
5240 |         ],
5241 |         "Mona Lisa": [
5242 |           "art",
5243 |           "painting",
5244 |           "Louvre, Paris",
5245 |           "Leonardo DaVinci"
5246 |         ],
5247 |         "Monica Bellucci": [
5248 |           "actress",
5249 |           "Malena",
5250 |           "Brotherhood of the Wolves",
5251 |           "Matrix",
5252 |           "Shoot 'em Up"
5253 |         ],
5254 |         "Morgan Freeman": [
5255 |           "actor",
5256 |           "Se7en",
5257 |           "Million Dollar Baby",
5258 |           "Lucky Number Slevin",
5259 |           "black",
5260 |           "The Shawshank Redemption"
5261 |         ],
5262 |         "Mother Teresa": [
5263 |           "Catholic Church",
5264 |           "holy",
5265 |           "nun",
5266 |           "missionary",
5267 |           "Calcutta"
5268 |         ],
5269 |         "Muhammad Ali": [
5270 |           "boxer",
5271 |           "activist",
5272 |           "The Greatest",
5273 |           "heavyweight"
5274 |         ],
5275 |         "Naomi Watts": [
5276 |           "actress",
5277 |           "Mulholland Drive",
5278 |           "King Kong",
5279 |           "Birdman"
5280 |         ],
5281 |         "Napoleon Bonaparte": [
5282 |           "Frankreich",
5283 |           "French Revolution",
5284 |           "small",
5285 |           "military",
5286 |           "commander",
5287 |           "poisoned"
5288 |         ],
5289 |         "Natalie Portman": [
5290 |           "Star Wars",
5291 |           "Anakin Skywalker",
5292 |           "Padme Amidalla",
5293 |           "actress",
5294 |           "Black Swan",
5295 |           "V for Vendetta",
5296 |           "Leon der Profi"
5297 |         ],
5298 |         "Neil Armstrong": [
5299 |           "astronaut",
5300 |           "moon landing",
5301 |           "USA",
5302 |           "NASA",
5303 |           "one small step"
5304 |         ],
5305 |         "Nelson Mandela": [
5306 |           "revolutionary",
5307 |           "black",
5308 |           "South Africa",
5309 |           "Nobel Peace Price"
5310 |         ],
5311 |         "Nicola Tesla": [
5312 |           "inventor",
5313 |           "engineer",
5314 |           "Tesla coil",
5315 |           "electricity",
5316 |           "futurist"
5317 |         ],
5318 |         "Nicolas Cage": [
5319 |           "The Rock",
5320 |           "actor",
5321 |           "Face Off",
5322 |           "Leaving Las Vegas",
5323 |           "Con Air"
5324 |         ],
5325 |         "Nicole Kidman": [
5326 |           "actor",
5327 |           "Moulin Rouge",
5328 |           "Dogville"
5329 |         ],
5330 |         "Orson Welles": [
5331 |           "actor",
5332 |           "Citizen Kane",
5333 |           "Touch of Evil",
5334 |           "The Lady from Shanghai"
5335 |         ],
5336 |         "Owen Wilson": [
5337 |           "actor",
5338 |           "Wedding Crashers",
5339 |           "Night in the Museum",
5340 |           "Starsky & Hutch",
5341 |           "The Royal Tenenbaums"
5342 |         ],
5343 |         "Pablo Picasso": [
5344 |           "artist",
5345 |           "painting",
5346 |           "Spain"
5347 |         ],
5348 |         "Patrick Stewart": [
5349 |           "Star Trek",
5350 |           "Picard",
5351 |           "actor",
5352 |           "Wolverine",
5353 |           "Charles"
5354 |         ],
5355 |         "Paul Walker": [
5356 |           "2 Fast 2 Furious",
5357 |           "car crash",
5358 |           "actor",
5359 |           "Hollywood",
5360 |           "dead"
5361 |         ],
5362 |         "Peter Sellers": [
5363 |           "actor",
5364 |           "Dr. Strangelove",
5365 |           "Inspector Clouseau",
5366 |           "The Pink Panther"
5367 |         ],
5368 |         "Pope John Paul II": [
5369 |           "catholic church",
5370 |           "Vatican",
5371 |           "representative of god",
5372 |           "bishop of Rome"
5373 |         ],
5374 |         "Prinzessin Diana": [
5375 |           "Great Britain",
5376 |           "United Kingdom",
5377 |           "Queen",
5378 |           "royal",
5379 |           "Paris",
5380 |           "car crash"
5381 |         ],
5382 |         "Rachel Weisz": [
5383 |           "actress",
5384 |           "The Mummy",
5385 |           "The Constant Gardener",
5386 |           "The Favourite"
5387 |         ],
5388 |         "Rami Malek": [
5389 |           "Mr. Robot",
5390 |           "Freddie Mercury",
5391 |           "Queen",
5392 |           "actor",
5393 |           "Oscar",
5394 |           "Elliot Alderson",
5395 |           "fsociety"
5396 |         ],
5397 |         "Rembrandt": [
5398 |           "artist",
5399 |           "painter",
5400 |           "Dutch",
5401 |           "Netherlands",
5402 |           "portraits"
5403 |         ],
5404 |         "Richard Gere": [
5405 |           "Pretty Woman",
5406 |           "actor",
5407 |           "Chicago",
5408 |           "The Jackal"
5409 |         ],
5410 |         "Robert De Niro": [
5411 |           "actor",
5412 |           "Taxi Driver",
5413 |           "Cape Fear",
5414 |           "The Irishman",
5415 |           "Joker",
5416 |           "Raging Bull"
5417 |         ],
5418 |         "Robert Downey Jr.": [
5419 |           "Ironman",
5420 |           "Avengers",
5421 |           "actor",
5422 |           "Marvel",
5423 |           "Sherlock Holmes"
5424 |         ],
5425 |         "Robert Pattinson": [
5426 |           "Twilight",
5427 |           "vampire",
5428 |           "actor",
5429 |           "Edward & Bella"
5430 |         ],
5431 |         "Robert Redford": [
5432 |           "actor",
5433 |           "The Natural",
5434 |           "Butch Cassidy and the Sundance Kid"
5435 |         ],
5436 |         "Robin Williams": [
5437 |           "actor",
5438 |           "Mrs. Doubtfire",
5439 |           "comedy",
5440 |           "suicide",
5441 |           "Good Morning, Vietnam",
5442 |           "Good Will Hunting"
5443 |         ],
5444 |         "Ronald Reagan": [
5445 |           "United States of America",
5446 |           "president",
5447 |           "actor",
5448 |           "Hollywood",
5449 |           "Governor of California"
5450 |         ],
5451 |         "Rowan Atkinson": [
5452 |           "Mr. Bean",
5453 |           "Mini",
5454 |           "Teddy",
5455 |           "actor",
5456 |           "England",
5457 |           "Great Britain"
5458 |         ],
5459 |         "Russell Crowe": [
5460 |           "actor",
5461 |           "A Beautiful Mind",
5462 |           "Les Miserables",
5463 |           "Gladiator",
5464 |           "LA Confidential"
5465 |         ],
5466 |         "Salvador Dali": [
5467 |           "artist",
5468 |           "painter",
5469 |           "surrealism",
5470 |           "clock",
5471 |           "raven"
5472 |         ],
5473 |         "Samuel L. Jackson": [
5474 |           "Pulp Fiction",
5475 |           "Jules Winnfield",
5476 |           "actor",
5477 |           "The Hateful Eight",
5478 |           "Captain Marvel",
5479 |           "Glass",
5480 |           "Nick Fury"
5481 |         ],
5482 |         "Scarlett Johansson": [
5483 |           "actress",
5484 |           "Lost in Translation",
5485 |           "Avengers",
5486 |           "Natasha Romanoff",
5487 |           "Under the Skin",
5488 |           "Sing"
5489 |         ],
5490 |         "Sean Connery": [
5491 |           "actor",
5492 |           "The Rock",
5493 |           "James Bond 007",
5494 |           "The Hunt for Red October"
5495 |         ],
5496 |         "Sean Penn": [
5497 |           "actor",
5498 |           "Mystic River",
5499 |           "Milk",
5500 |           "Dead Men Walking"
5501 |         ],
5502 |         "Shahrukh Khan": [
5503 |           "actor",
5504 |           "Bollywood",
5505 |           "India",
5506 |           "dancing"
5507 |         ],
5508 |         "Sir Isaac Newton": [
5509 |           "mathematician",
5510 |           "astronomer",
5511 |           "physicist",
5512 |           "gravity",
5513 |           "apple"
5514 |         ],
5515 |         "Stanley Kubrick": [
5516 |           "director",
5517 |           "2001: A Space Odyssey",
5518 |           "Eyes Wide Shut",
5519 |           "Clockwork Orange",
5520 |           "Barry Lyndon"
5521 |         ],
5522 |         "Steve Jobs": [
5523 |           "Apple",
5524 |           "MacBook",
5525 |           "iPhone",
5526 |           "iPad",
5527 |           "iPod",
5528 |           "dead"
5529 |         ],
5530 |         "Susan Sarandon": [
5531 |           "actress",
5532 |           "Thelma & Louise",
5533 |           "Dead Men Walking",
5534 |           "Stepmom"
5535 |         ],
5536 |         "Sylvester Stallone": [
5537 |           "Rambo",
5538 |           "Rocky",
5539 |           "Action",
5540 |           "actor",
5541 |           "Expandables"
5542 |         ],
5543 |         "Tim Allen": [
5544 |           "Home Improvement",
5545 |           "actor",
5546 |           "Toy Story",
5547 |           "Galaxy Quest",
5548 |           "Santa Clause"
5549 |         ],
5550 |         "Tobey Maguire": [
5551 |           "Spiderman",
5552 |           "actor",
5553 |           "Brothers",
5554 |           "The Wonder Boys",
5555 |           "Pleasantville"
5556 |         ],
5557 |         "Tom Cruise": [
5558 |           "Top Gun",
5559 |           "Scientology",
5560 |           "actor",
5561 |           "The Last Samurai",
5562 |           "Jerry Maguire",
5563 |           "Minority Report"
5564 |         ],
5565 |         "Tom Hanks": [
5566 |           "Forrest Gump",
5567 |           "Cast Away",
5568 |           "Wilson",
5569 |           "Saving Private Ryan",
5570 |           "actor",
5571 |           "Big",
5572 |           "Inferno"
5573 |         ],
5574 |         "Tom Hardy": [
5575 |           "Mad Max",
5576 |           "Inception",
5577 |           "actor",
5578 |           "The Dark Knight",
5579 |           "Taboo"
5580 |         ],
5581 |         "Tommy Lee Jones": [
5582 |           "actor",
5583 |           "No Country for Old Men",
5584 |           "Homesman",
5585 |           "Lincoln"
5586 |         ],
5587 |         "Uma Thurman": [
5588 |           "Kill Bill",
5589 |           "actor",
5590 |           "Pulp Fiction",
5591 |           "Batman & Robin"
5592 |         ],
5593 |         "Vin Diesel": [
5594 |           "Riddick",
5595 |           "2 Fast 2 Furious",
5596 |           "actor",
5597 |           "Triple X",
5598 |           "Groot"
5599 |         ],
5600 |         "Vincent Van Gogh": [
5601 |           "artist",
5602 |           "painter",
5603 |           "paintings",
5604 |           "ear",
5605 |           "brush technique",
5606 |           "Dutch"
5607 |         ],
5608 |         "Vladimir Lenin": [
5609 |           "Russia",
5610 |           "revolutionary",
5611 |           "politician",
5612 |           "Soviet Union",
5613 |           "Karl Marx",
5614 |           "communist"
5615 |         ],
5616 |         "Walt Disney": [
5617 |           "animatic",
5618 |           "Donald Duck",
5619 |           "Mickey Mouse",
5620 |           "Bambi",
5621 |           "The Lion King",
5622 |           "theme park"
5623 |         ],
5624 |         "Warren Buffet": [
5625 |           "hedgefonds",
5626 |           "investments",
5627 |           "finances",
5628 |           "business tycoon",
5629 |           "billionaire",
5630 |           "rich"
5631 |         ],
5632 |         "Will Smith": [
5633 |           "Independence Day",
5634 |           "Bad Boys",
5635 |           "actor",
5636 |           "Fresh Prince of Bel Air",
5637 |           "Men in Black",
5638 |           "I am Legend",
5639 |           "I Robot",
5640 |           "Wild Wild West"
5641 |         ],
5642 |         "William Shakespeare": [
5643 |           "playwright",
5644 |           "peot",
5645 |           "writer",
5646 |           "Hamlet",
5647 |           "Romeo and Juliet",
5648 |           "Othello",
5649 |           "Macbeth"
5650 |         ],
5651 |         "William Shatner": [
5652 |           "Star Trek",
5653 |           "Captain Kirk",
5654 |           "actor",
5655 |           "Spock",
5656 |           "Enterprise"
5657 |         ],
5658 |         "Winston Churchill": [
5659 |           "army officer",
5660 |           "prime minister",
5661 |           "United Kingdom",
5662 |           "Great Britain",
5663 |           "World War II"
5664 |         ],
5665 |         "Wolfgang Amadeus Mozart": [
5666 |           "composer",
5667 |           "Austria",
5668 |           "piano",
5669 |           "Eine Kleine Nacht-Musik",
5670 |           "The Marriage of Figaro",
5671 |           "The Magic Flute"
5672 |         ],
5673 |         "Woody Allen": [
5674 |           "director",
5675 |           "actor",
5676 |           "writer",
5677 |           "Manhattan",
5678 |           "Midnight in Paris",
5679 |           "Annie Hall"
5680 |         ],
5681 |         "Woody Harrelson": [
5682 |           "Zombieland",
5683 |           "actor",
5684 |           "True Detective",
5685 |           "Natural Born Killers",
5686 |           "Larry Flint"
5687 |         ],
5688 |         "Yuri Gagarin": [
5689 |           "astronaut",
5690 |           "cosmonaut",
5691 |           "space",
5692 |           "Russia",
5693 |           "Soviet Union"
5694 |         ],
5695 |         "Zooey Deschanel": [
5696 |           "actress",
5697 |           "New Girl",
5698 |           "Hitchhikers Guide to the Galaxy"
5699 |         ]
5700 |     }, "things": {
5701 |         "Air brake": [
5702 |           "car",
5703 |           "PSI"
5704 |         ],
5705 |         "Airship": [
5706 |           "hindenburg",
5707 |           "helium",
5708 |           "balloon"
5709 |         ],
5710 |         "Antenna": [
5711 |           "TV",
5712 |           "Internet",
5713 |           "WLAN"
5714 |         ],
5715 |         "Atomizer": [
5716 |           "flowers",
5717 |           "glass cleaner"
5718 |         ],
5719 |         "Backpack": [
5720 |           "carry",
5721 |           "bag",
5722 |           "school",
5723 |           "transport"
5724 |         ],
5725 |         "Baking pan": [
5726 |           "cake",
5727 |           "pie"
5728 |         ],
5729 |         "Ball bearing": [
5730 |           "bicycle",
5731 |           "store",
5732 |           "lubricate"
5733 |         ],
5734 |         "Bedding": [
5735 |           "pillow",
5736 |           "blanket",
5737 |           "cover"
5738 |         ],
5739 |         "BluRay": [
5740 |           "DVD",
5741 |           "CD",
5742 |           "movie",
5743 |           "gigabyte"
5744 |         ],
5745 |         "Bowl": [
5746 |           "transport",
5747 |           "food"
5748 |         ],
5749 |         "Broom": [
5750 |           "Cleaning",
5751 |           "sweeping",
5752 |           "cleaning",
5753 |           "sweeping"
5754 |         ],
5755 |         "Butter dish": [
5756 |           "magarine",
5757 |           "can",
5758 |           "refrigerator"
5759 |         ],
5760 |         "Cable drum": [
5761 |           "power",
5762 |           "electricity",
5763 |           "roll up"
5764 |         ],
5765 |         "Cable": [
5766 |           "electricity",
5767 |           "long",
5768 |           "plug",
5769 |           "television"
5770 |         ],
5771 |         "Cake bell": [
5772 |           "cake",
5773 |           "coffee",
5774 |           "transportation"
5775 |         ],
5776 |         "Cake server": [
5777 |           "cake",
5778 |           "coffee",
5779 |           "plate"
5780 |         ],
5781 |         "Can opener": [
5782 |           "canned",
5783 |           "tin can"
5784 |         ],
5785 |         "Carpet cleaner": [],
5786 |         "Carpet": [
5787 |           "laminate",
5788 |           "carpeting",
5789 |           "floor"
5790 |         ],
5791 |         "Cassette recorder": [
5792 |           "obsolete",
5793 |           "tape",
5794 |           "music"
5795 |         ],
5796 |         "CD": [
5797 |           "DVD",
5798 |           "Music"
5799 |         ],
5800 |         "Centrifuge": [
5801 |           "medicine",
5802 |           "spin"
5803 |         ],
5804 |         "Chopsticks": [
5805 |           "wood",
5806 |           "china",
5807 |           "two",
5808 |           "rice"
5809 |         ],
5810 |         "Cleaning bucket": [
5811 |           "cleaning",
5812 |           "mop"
5813 |         ],
5814 |         "Clothesline": [
5815 |           "dry",
5816 |           "hang",
5817 |           "clips"
5818 |         ],
5819 |         "Clothespin": [
5820 |           "clothes",
5821 |           "line",
5822 |           "dry",
5823 |           "hang up"
5824 |         ],
5825 |         "Coat hanger": [
5826 |           "hanging",
5827 |           "closet"
5828 |         ],
5829 |         "Coffee filter": [
5830 |           "machine",
5831 |           "pot"
5832 |         ],
5833 |         "Coffee machine": [
5834 |           "tea",
5835 |           "latte macchiato",
5836 |           "espresso"
5837 |         ],
5838 |         "Coffee maker": [
5839 |           "tea",
5840 |           "filter",
5841 |           "pot"
5842 |         ],
5843 |         "Colander": [
5844 |           "pasta",
5845 |           "draining"
5846 |         ],
5847 |         "Computer mouse": [
5848 |           "keyboard",
5849 |           "PC",
5850 |           "cursor"
5851 |         ],
5852 |         "Computer tomograph": [
5853 |           "Medicine",
5854 |           "doctor",
5855 |           "examination"
5856 |         ],
5857 |         "Computer": [
5858 |           "PC",
5859 |           "laptop",
5860 |           "notebook",
5861 |           "internet"
5862 |         ],
5863 |         "Contact lenses": [
5864 |           "eye",
5865 |           "glasses",
5866 |           "see"
5867 |         ],
5868 |         "Corkscrew": [
5869 |           "wine",
5870 |           "food",
5871 |           "restaurant",
5872 |           "waiter"
5873 |         ],
5874 |         "Credit card": [
5875 |           "money",
5876 |           "plastic",
5877 |           "EC",
5878 |           "bank"
5879 |         ],
5880 |         "Cutlery": [
5881 |           "knife",
5882 |           "spoon",
5883 |           "fork",
5884 |           "food"
5885 |         ],
5886 |         "Cutting board": [
5887 |           "knife",
5888 |           "food",
5889 |           "wood"
5890 |         ],
5891 |         "Digital camera": [
5892 |           "smartphone",
5893 |           "photo",
5894 |           "computer"
5895 |         ],
5896 |         "Dish towels": [
5897 |           "dry",
5898 |           "dry",
5899 |           "wet"
5900 |         ],
5901 |         "Dishes": [
5902 |           "cutlery",
5903 |           "plate",
5904 |           "knife",
5905 |           "fork"
5906 |         ],
5907 |         "Dishwasher": [
5908 |           "hand wash",
5909 |           "plate",
5910 |           "cutlery"
5911 |         ],
5912 |         "Duster": [
5913 |           "cleaning",
5914 |           "cleaning"
5915 |         ],
5916 |         "Dustpan": [
5917 |           "cleaning",
5918 |           "broom",
5919 |           "dirt"
5920 |         ],
5921 |         "DVD": [
5922 |           "movie",
5923 |           "player",
5924 |           "television",
5925 |           "CD"
5926 |         ],
5927 |         "Dynamo": [
5928 |           "bicycle",
5929 |           "lamp",
5930 |           "electricity"
5931 |         ],
5932 |         "Egg cup": [
5933 |           "chicken",
5934 |           "breakfast",
5935 |           "cooked"
5936 |         ],
5937 |         "Egg stove": [
5938 |           "clock",
5939 |           "chicken"
5940 |         ],
5941 |         "Egg timer": [
5942 |           "cooking",
5943 |           "time",
5944 |           "pointer",
5945 |           "chicken"
5946 |         ],
5947 |         "Exercise bike": [
5948 |           "sport",
5949 |           "muscle",
5950 |           "workout"
5951 |         ],
5952 |         "Extension cord": [
5953 |           "power",
5954 |           "television",
5955 |           "outlet"
5956 |         ],
5957 |         "Fan heater": [
5958 |           "wind",
5959 |           "warm",
5960 |           "winter"
5961 |         ],
5962 |         "Fan": [
5963 |           "wind",
5964 |           "air",
5965 |           "cool"
5966 |         ],
5967 |         "Feather duster": [
5968 |           "cleaning",
5969 |           "cleaning"
5970 |         ],
5971 |         "Flag": [
5972 |           "flag",
5973 |           "hoist",
5974 |           "mast",
5975 |           "flap"
5976 |         ],
5977 |         "Flashlight": [
5978 |           "dark",
5979 |           "light",
5980 |           "batteries"
5981 |         ],
5982 |         "Fountain pen": [
5983 |           "elementary school",
5984 |           "write",
5985 |           "ink"
5986 |         ],
5987 |         "Four-stroke engine": [
5988 |           "car",
5989 |           "ignition",
5990 |           "cylinder"
5991 |         ],
5992 |         "Freezer": [
5993 |           "refrigerator",
5994 |           "ice",
5995 |           "cold"
5996 |         ],
5997 |         "Garlic press": [
5998 |           "Vampire",
5999 |           "cut",
6000 |           "food",
6001 |           "Italy"
6002 |         ],
6003 |         "Gas turbine": [
6004 |           "power plant",
6005 |           "fart",
6006 |           "electricity",
6007 |           "airplane"
6008 |         ],
6009 |         "Gasoline engine": [
6010 |           "diesel",
6011 |           "car",
6012 |           "cylinder",
6013 |           "motorcycle"
6014 |         ],
6015 |         "Geiger counter": [
6016 |           "atom",
6017 |           "radiation",
6018 |           "music"
6019 |         ],
6020 |         "Hair dryer \/ blow dryer": [
6021 |           "warm",
6022 |           "hot",
6023 |           "air",
6024 |           "shower",
6025 |           "hair"
6026 |         ],
6027 |         "Hammer": [
6028 |           "nail",
6029 |           "wall",
6030 |           "tool"
6031 |         ],
6032 |         "Hand vacuum cleaner": [
6033 |           "foot",
6034 |           "clean",
6035 |           "cleaning",
6036 |           "dirt"
6037 |         ],
6038 |         "Hard disk": [
6039 |           "computer",
6040 |           "PC",
6041 |           "save",
6042 |           "gigabyte"
6043 |         ],
6044 |         "Heat blanket": [
6045 |           "heat",
6046 |           "pillow",
6047 |           "bed"
6048 |         ],
6049 |         "Heating pad": [
6050 |           "winter",
6051 |           "blanket",
6052 |           "warm"
6053 |         ],
6054 |         "Helicopter": [
6055 |           "rotor",
6056 |           "fly",
6057 |           "airplane"
6058 |         ],
6059 |         "High pressure cleaner": [
6060 |           "PSI",
6061 |           "Kärcher"
6062 |         ],
6063 |         "Home theater": [
6064 |           "movie",
6065 |           "projector",
6066 |           "sound system",
6067 |           "5.1"
6068 |         ],
6069 |         "Household scissors": [
6070 |           "cutting",
6071 |           "apartment"
6072 |         ],
6073 |         "Hovercraft": [
6074 |           "water",
6075 |           "airplane"
6076 |         ],
6077 |         "Humidifier": [
6078 |           "dry",
6079 |           "wet",
6080 |           "wind",
6081 |           "climate"
6082 |         ],
6083 |         "Hydrogen bomb": [
6084 |           "atom",
6085 |           "Einstein",
6086 |           "USA",
6087 |           "explosion"
6088 |         ],
6089 |         "Inkjet printer": [
6090 |           "toner",
6091 |           "paper",
6092 |           "computer"
6093 |         ],
6094 |         "Iron": [
6095 |           "Shirts",
6096 |           "hot",
6097 |           "smooth"
6098 |         ],
6099 |         "Ironing board": [
6100 |           "shirts",
6101 |           "hot",
6102 |           "smooth",
6103 |           "iron"
6104 |         ],
6105 |         "Jet engine": [
6106 |           "fighter pilot",
6107 |           "airplane",
6108 |           "fighter jet",
6109 |           "flying"
6110 |         ],
6111 |         "Jet plane": [
6112 |           "jet",
6113 |           "pilot",
6114 |           "engine"
6115 |         ],
6116 |         "Kettle": [
6117 |           "heat",
6118 |           "tea",
6119 |           "coffee"
6120 |         ],
6121 |         "Keyboard": [
6122 |           "computer",
6123 |           "keys",
6124 |           "input"
6125 |         ],
6126 |         "Kitchen broom": [
6127 |           "cleaning",
6128 |           "sweeping"
6129 |         ],
6130 |         "Kitchen knife": [
6131 |           "cut",
6132 |           "food",
6133 |           "prepare"
6134 |         ],
6135 |         "Kitchen scale": [
6136 |           "food",
6137 |           "weight",
6138 |           "weigh"
6139 |         ],
6140 |         "Kitchen towels": [
6141 |           "zewa",
6142 |           "dry",
6143 |           "stain",
6144 |           "wipe"
6145 |         ],
6146 |         "Ladder": [
6147 |           "climbing",
6148 |           "roof"
6149 |         ],
6150 |         "Laser printer": [
6151 |           "toner",
6152 |           "ink",
6153 |           "paper",
6154 |           "computer"
6155 |         ],
6156 |         "Laundry basket": [
6157 |           "dryer",
6158 |           "carry",
6159 |           "clothes"
6160 |         ],
6161 |         "Light bulb": [
6162 |           "LED",
6163 |           "wire",
6164 |           "light"
6165 |         ],
6166 |         "Longplaying record": [
6167 |           "CD",
6168 |           "vinyl",
6169 |           "music",
6170 |           "sounds"
6171 |         ],
6172 |         "Makeup mirror": [
6173 |           "make up",
6174 |           "carnival",
6175 |           "carnival"
6176 |         ],
6177 |         "Massager": [
6178 |           "soothing",
6179 |           "tension"
6180 |         ],
6181 |         "Monitor": [
6182 |           "computer",
6183 |           "display"
6184 |         ],
6185 |         "Mop": [
6186 |           "mopping",
6187 |           "bucket",
6188 |           "water"
6189 |         ],
6190 |         "Mouse pad": [
6191 |           "computer",
6192 |           "rest",
6193 |           "desk"
6194 |         ],
6195 |         "Multiple socket": [
6196 |           "power",
6197 |           "electricity",
6198 |           "television"
6199 |         ],
6200 |         "Nail scissors": [
6201 |           "fingers",
6202 |           "feet",
6203 |           "manicure"
6204 |         ],
6205 |         "Pacemaker": [
6206 |           "ECG",
6207 |           "infarction"
6208 |         ],
6209 |         "Padlock": [
6210 |           "key",
6211 |           "lock",
6212 |           "cellar"
6213 |         ],
6214 |         "Personal scale": [
6215 |           "fat",
6216 |           "kilogram"
6217 |         ],
6218 |         "Phone": [
6219 |           "long distance",
6220 |           "cell phone",
6221 |           "smart phone"
6222 |         ],
6223 |         "Pillow": [
6224 |           "bed",
6225 |           "sleep"
6226 |         ],
6227 |         "Plunger": [
6228 |           "toilet",
6229 |           "loo",
6230 |           "blockage"
6231 |         ],
6232 |         "Pot": [
6233 |           "tea",
6234 |           "coffee",
6235 |           "transport",
6236 |           "glass"
6237 |         ],
6238 |         "Potato masher": [
6239 |           "mash",
6240 |           "potato"
6241 |         ],
6242 |         "Potato peeler": [
6243 |           "potato"
6244 |         ],
6245 |         "Railroad": [
6246 |           "steam",
6247 |           "rails",
6248 |           "locomotive"
6249 |         ],
6250 |         "Refrigerator": [
6251 |           "freeze",
6252 |           "food",
6253 |           "cold"
6254 |         ],
6255 |         "Salad servers": [
6256 |           "fork",
6257 |           "spoon"
6258 |         ],
6259 |         "Satellite": [
6260 |           "GPS",
6261 |           "space"
6262 |         ],
6263 |         "Scrubber": [
6264 |           "mop",
6265 |           "cleaning",
6266 |           "cleaning"
6267 |         ],
6268 |         "Sewing needle": [
6269 |           "clothes",
6270 |           "hole",
6271 |           "repair"
6272 |         ],
6273 |         "Sewing thread": [
6274 |           "clothes",
6275 |           "hole",
6276 |           "mending"
6277 |         ],
6278 |         "Shoe polisher": [],
6279 |         "Shower curtain": [
6280 |           "tub",
6281 |           "bath",
6282 |           "water"
6283 |         ],
6284 |         "Smartphone": [
6285 |           "mobile",
6286 |           "Apple",
6287 |           "Samsung",
6288 |           "mobile"
6289 |         ],
6290 |         "Solar cell": [
6291 |           "house",
6292 |           "roof",
6293 |           "sun",
6294 |           "electricity"
6295 |         ],
6296 |         "Soldering iron": [
6297 |           "electronics",
6298 |           "tinkering",
6299 |           "building"
6300 |         ],
6301 |         "Spark plug": [
6302 |           "car",
6303 |           "engine",
6304 |           "start"
6305 |         ],
6306 |         "Spray can": [
6307 |           "graffiti",
6308 |           "vandalism",
6309 |           "paint"
6310 |         ],
6311 |         "Steam iron": [
6312 |           "Shirts",
6313 |           "hot",
6314 |           "smooth"
6315 |         ],
6316 |         "Stirring spoon": [
6317 |           "cake",
6318 |           "baking"
6319 |         ],
6320 |         "Streetcar": [
6321 |           "train",
6322 |           "streetcar",
6323 |           "transportation",
6324 |           "public transportation"
6325 |         ],
6326 |         "Sunbed": [
6327 |           "solarium",
6328 |           "tan",
6329 |           "tanning"
6330 |         ],
6331 |         "Tablecloth": [],
6332 |         "Tank": [
6333 |           "war",
6334 |           "steel"
6335 |         ],
6336 |         "Tea pot": [
6337 |           "vessel",
6338 |           "pour"
6339 |         ],
6340 |         "Tea strainer": [
6341 |           "coffee",
6342 |           "brew"
6343 |         ],
6344 |         "Telegraph": [
6345 |           "Telephone",
6346 |           "telex"
6347 |         ],
6348 |         "Toaster": [
6349 |           "bread",
6350 |           "hot",
6351 |           "reheat"
6352 |         ],
6353 |         "Toilet brush": [
6354 |           "toilet",
6355 |           "cleaning"
6356 |         ],
6357 |         "Toilet roll holder": [
6358 |           "toilet",
6359 |           "poop"
6360 |         ],
6361 |         "Toothbrush cup": [
6362 |           "dentist",
6363 |           "brush"
6364 |         ],
6365 |         "Touchpad": [
6366 |           "iPad",
6367 |           "smartphone",
6368 |           "display",
6369 |           "touch"
6370 |         ],
6371 |         "Transistor": [
6372 |           "electronics"
6373 |         ],
6374 |         "Trash can": [
6375 |           "garbage",
6376 |           "garbage can",
6377 |           "organic"
6378 |         ],
6379 |         "Tray": [
6380 |           "food",
6381 |           "transport",
6382 |           "bring",
6383 |           "waiter"
6384 |         ],
6385 |         "Trekking backpack": [
6386 |           "hiking",
6387 |           "transportation",
6388 |           "camping",
6389 |           "luggage"
6390 |         ],
6391 |         "TV": [
6392 |           "boob tube",
6393 |           "TV",
6394 |           "RTL",
6395 |           "ProSieben"
6396 |         ],
6397 |         "Typewriter": [
6398 |           "obsolete",
6399 |           "keys",
6400 |           "paper"
6401 |         ],
6402 |         "USB cable": [
6403 |           "power",
6404 |           "mobile",
6405 |           "smartphone",
6406 |           "computer"
6407 |         ],
6408 |         "USB stick": [
6409 |           "store",
6410 |           "computer",
6411 |           "PC",
6412 |           "hard drive"
6413 |         ],
6414 |         "Vacuum cleaner": [
6415 |           "cleaning",
6416 |           "cleaning",
6417 |           "vacuuming"
6418 |         ],
6419 |         "Wardrobe": [
6420 |           "clothes",
6421 |           "hang",
6422 |           "closet"
6423 |         ],
6424 |         "Washer dryer": [
6425 |           "machine",
6426 |           "clothes",
6427 |           "line"
6428 |         ],
6429 |         "Washing machine": [
6430 |           "dryer",
6431 |           "powder",
6432 |           "fabric softener"
6433 |         ],
6434 |         "Waterbed": [
6435 |           "sleep",
6436 |           "night",
6437 |           "pillow",
6438 |           "comforter"
6439 |         ],
6440 |         "Watering can": [
6441 |           "water",
6442 |           "flowers",
6443 |           "watering"
6444 |         ],
6445 |         "Whisk": [
6446 |           "Egg",
6447 |           "beat",
6448 |           "metal"
6449 |         ]
6450 |     }, "tv": {
6451 |         "12 Monkeys": [
6452 |           "Bruce Willis",
6453 |           "Thriller",
6454 |           "Brad Pitt"
6455 |         ],
6456 |         "12 Years a Slave": [
6457 |           "black man",
6458 |           "United States",
6459 |           "Drama"
6460 |         ],
6461 |         "2001: A Space Odyssey": [
6462 |           "Stanley Kubrick",
6463 |           "Sci Fi",
6464 |           "HAL 9000",
6465 |           "space"
6466 |         ],
6467 |         "A Beautiful Mind": [
6468 |           "Russell Crowe",
6469 |           "Ed Harris",
6470 |           "CIA",
6471 |           "schizophrenia",
6472 |           "cryptography"
6473 |         ],
6474 |         "Alien": [
6475 |           "Sigourney Weaver",
6476 |           "UFO",
6477 |           "space",
6478 |           "horror"
6479 |         ],
6480 |         "American Beauty": [
6481 |           "Kevin Spacey",
6482 |           "Annette Bening",
6483 |           "drama",
6484 |           "rose"
6485 |         ],
6486 |         "American History X": [
6487 |           "Edward Norton",
6488 |           "neo-nazi",
6489 |           "skinhead",
6490 |           "Hitler",
6491 |           "swastika"
6492 |         ],
6493 |         "Amélie": [
6494 |           "Drama",
6495 |           "Romance",
6496 |           "Paris",
6497 |           "France"
6498 |         ],
6499 |         "Apocalypse Now": [
6500 |           "Francis Ford Coppola",
6501 |           "Vietnam",
6502 |           "helicopters",
6503 |           "U.S. Army"
6504 |         ],
6505 |         "Back to the Future": [
6506 |           "time travelling",
6507 |           "Marty McFly",
6508 |           "Doc Emmett Brown",
6509 |           "DeLorean",
6510 |           "Lorraine Baines"
6511 |         ],
6512 |         "Batman Begins": [
6513 |           "Christian Bale",
6514 |           "Joker",
6515 |           "Gotham City",
6516 |           "Dark Knight"
6517 |         ],
6518 |         "Ben Hur": [
6519 |           "Charlton Heston",
6520 |           "Jewish prince"
6521 |         ],
6522 |         "Braveheart": [
6523 |           "Mel Gibson",
6524 |           "Scotland",
6525 |           "rebellion",
6526 |           "King Edward I of England"
6527 |         ],
6528 |         "Casablanca": [
6529 |           "Drama",
6530 |           "Humphrey Bogart",
6531 |           "Nazis",
6532 |           "French Morocco"
6533 |         ],
6534 |         "Casino": [
6535 |           "Drama",
6536 |           "Robert De Niro",
6537 |           "Martin Scorsese",
6538 |           "Mafia",
6539 |           "gambling"
6540 |         ],
6541 |         "Catch Me If You Can": [
6542 |           "Comedy",
6543 |           "Leonardo DiCaprio",
6544 |           "Tom Hanks",
6545 |           "PanAm",
6546 |           "airplane pilot"
6547 |         ],
6548 |         "Citizen Kane": [
6549 |           "Orson Welles",
6550 |           "Drama",
6551 |           "Rosebud",
6552 |           "Charles Foster Kane"
6553 |         ],
6554 |         "City of God": [
6555 |           "Drama",
6556 |           "Rio de Janeiro",
6557 |           "Brasil",
6558 |           "photographer"
6559 |         ],
6560 |         "Das Boot": [
6561 |           "Thriller",
6562 |           "Wolfgang Petersen",
6563 |           "Germany",
6564 |           "World War II",
6565 |           "u-boat"
6566 |         ],
6567 |         "Deadpool": [
6568 |           "Action",
6569 |           "Ryan Reynolds",
6570 |           "red suit",
6571 |           "mercenary"
6572 |         ],
6573 |         "Der Blade Runner": [
6574 |           "Action",
6575 |           "Sci Fi",
6576 |           "Harrison Ford",
6577 |           "original"
6578 |         ],
6579 |         "Der König der Löwen": [
6580 |           "Disney",
6581 |           "Simba",
6582 |           "Timon",
6583 |           "Pumba"
6584 |         ],
6585 |         "Die Hard": [
6586 |           "Action",
6587 |           "Bruce Willis",
6588 |           "Nakatomi Plaza",
6589 |           "christmas",
6590 |           "German terrorists"
6591 |         ],
6592 |         "Django Unchained": [
6593 |           "Action",
6594 |           "Jamie Foxx",
6595 |           "Quentin Tarantino",
6596 |           "Leonardo DiCaprio",
6597 |           "Mississippi"
6598 |         ],
6599 |         "Donnie Darko": [
6600 |           "Drama",
6601 |           "Jake Gyllenhaal",
6602 |           "rabbit"
6603 |         ],
6604 |         "Downfall": [
6605 |           "Drama",
6606 |           "Adolf Hitler",
6607 |           "World War II",
6608 |           "Berlin bunker"
6609 |         ],
6610 |         "Fight Club": [
6611 |           "Thriller",
6612 |           "Rule number one",
6613 |           "Brad Pitt",
6614 |           "Edward Norton",
6615 |           "underground"
6616 |         ],
6617 |         "Findet Nemo": [
6618 |           "Disney",
6619 |           "Pixar",
6620 |           "Great Barrier Reef",
6621 |           "orange clownfish",
6622 |           "Marlin",
6623 |           "Dory"
6624 |         ],
6625 |         "Forrest Gump": [
6626 |           "Drama",
6627 |           "Tom Hanks",
6628 |           "Vietnam War",
6629 |           "Baba",
6630 |           "Shrimp",
6631 |           "Football"
6632 |         ],
6633 |         "Full Metal Jacket": [
6634 |           "Action",
6635 |           "Stanley Kubrick",
6636 |           "Vietnam War",
6637 |           "Gny. Sgt. Hartman",
6638 |           "R. Lee Ermey"
6639 |         ],
6640 |         "Gladiator": [
6641 |           "Action",
6642 |           "Roman General",
6643 |           "Russell Crowe",
6644 |           "slavery",
6645 |           "Colosseum"
6646 |         ],
6647 |         "Gone with the Wind": [
6648 |           "American Civil War",
6649 |           "Drama",
6650 |           "Romance",
6651 |           "Clark Gable"
6652 |         ],
6653 |         "Good Will Hunting": [
6654 |           "Drama",
6655 |           "Robin Williams",
6656 |           "Matt Damon",
6657 |           "mathematics"
6658 |         ],
6659 |         "Goodfellas": [
6660 |           "Drama",
6661 |           "Robert De Niro",
6662 |           "Mafia",
6663 |           "Henry Hill"
6664 |         ],
6665 |         "Gran Torino": [
6666 |           "Drama",
6667 |           "Clint Eastwood",
6668 |           "Korean War veteran",
6669 |           "car"
6670 |         ],
6671 |         "Grand Budapest Hotel": [
6672 |           "Comedy",
6673 |           "Indie",
6674 |           "Ralph Fiennes",
6675 |           "lobby boy"
6676 |         ],
6677 |         "Guardians of the Galaxy": [
6678 |           "Action",
6679 |           "Marvel",
6680 |           "Peter Quill",
6681 |           "Groot",
6682 |           "Star-Lord"
6683 |         ],
6684 |         "Harry Potter": [
6685 |           "Witchcraft and Wizardry",
6686 |           "Hogwarts",
6687 |           "Ron & Hermine",
6688 |           "Dumbledore",
6689 |           "Voldemort"
6690 |         ],
6691 |         "How to Train Your Dragon": [
6692 |           "Disney",
6693 |           "Pixar",
6694 |           "Viking"
6695 |         ],
6696 |         "Inception": [
6697 |           "Action",
6698 |           "Christopher Nolan",
6699 |           "Leonardo DiCaprio",
6700 |           "lucid dreaming",
6701 |           "thoughts"
6702 |         ],
6703 |         "Indiana Jones and the Last Crusade": [
6704 |           "Action",
6705 |           "Indie",
6706 |           "Harrison Ford",
6707 |           "Sean Connery",
6708 |           "Germany",
6709 |           "World War II"
6710 |         ],
6711 |         "Inglourious Basterds": [
6712 |           "Quentin Tarantino",
6713 |           "Brad Pitt",
6714 |           "World War II",
6715 |           "U.S. Army",
6716 |           "Nazis"
6717 |         ],
6718 |         "Inside Out": [
6719 |           "Disney",
6720 |           "feelings",
6721 |           "emotions"
6722 |         ],
6723 |         "Interstellar": [
6724 |           "Sci Fi",
6725 |           "Matthew McConaughey",
6726 |           "space",
6727 |           "wormhole",
6728 |           "black hole"
6729 |         ],
6730 |         "Into the Wild": [
6731 |           "Drama",
6732 |           "nature",
6733 |           "camping",
6734 |           "Christopher McCandless"
6735 |         ],
6736 |         "Jaws": [
6737 |           "Thriller",
6738 |           "shark",
6739 |           "beach",
6740 |           "surfing"
6741 |         ],
6742 |         "Jurassic Park": [
6743 |           "dinosaurs",
6744 |           "Steven Spielberg",
6745 |           "T-Rex",
6746 |           "John Hammond"
6747 |         ],
6748 |         "Kill Bill: Vol. 1": [
6749 |           "Action",
6750 |           "Quentin Tarantino",
6751 |           "Uma Thurman",
6752 |           "katana",
6753 |           "yellow"
6754 |         ],
6755 |         "LA Confidential": [
6756 |           "Thriller",
6757 |           "Kevin Spacey",
6758 |           "Los Angeles",
6759 |           "police"
6760 |         ],
6761 |         "Lawrence of Arabia": [
6762 |           "T.E. Lawrence",
6763 |           "World War I",
6764 |           "Peter O'Toole"
6765 |         ],
6766 |         "Lock, Stock and Two Smoking Barrels": [
6767 |           "Guy Ritchie",
6768 |           "Action",
6769 |           "Comedy",
6770 |           "Hatchet Harry"
6771 |         ],
6772 |         "Léon - Der Profi": [
6773 |           "Drama",
6774 |           "Jean Reno",
6775 |           "Mathilda",
6776 |           "professional assassin"
6777 |         ],
6778 |         "Mad Max: Fury Road": [
6779 |           "Action",
6780 |           "Tom Hardy",
6781 |           "post-apocalyptic wasteland",
6782 |           "Witness me"
6783 |         ],
6784 |         "Memento": [
6785 |           "Christopher Nolan",
6786 |           "short-term memory",
6787 |           "murderer",
6788 |           "Leonard"
6789 |         ],
6790 |         "Million Dollar Baby": [
6791 |           "Drama",
6792 |           "Clint Eastwood",
6793 |           "professional boxing"
6794 |         ],
6795 |         "Monsters, Inc.": [
6796 |           "Disney",
6797 |           "Pixar",
6798 |           "Mike",
6799 |           "Sullivan",
6800 |           "Boo"
6801 |         ],
6802 |         "Monty Python and the Holy Grail": [
6803 |           "King Arthur",
6804 |           "tis but a scratch",
6805 |           "Knights of the Round Table",
6806 |           "blue.. no, red! Aaaaah"
6807 |         ],
6808 |         "Monty Python's Life of Brian": [
6809 |           "Comedy",
6810 |           "Jesus Christ",
6811 |           "Brian of Nazareth",
6812 |           "People's Front of Judea",
6813 |           "Holy Bible"
6814 |         ],
6815 |         "No Country for Old Men": [
6816 |           "Drama",
6817 |           "Tommy Lee Jones",
6818 |           "drug dealing",
6819 |           "Rio Grande"
6820 |         ],
6821 |         "Once Upon a Time in the West": [
6822 |           "Henry Fonda",
6823 |           "harmonica",
6824 |           "wild west"
6825 |         ],
6826 |         "Pirates of the Caribbean": [
6827 |           "Captain Jack Sparrow",
6828 |           "Will Turner",
6829 |           "Johnny Depp",
6830 |           "Orlando Bloom"
6831 |         ],
6832 |         "Platoon": [
6833 |           "Action",
6834 |           "Vietnam War",
6835 |           "Charlie Sheen",
6836 |           "Chris Taylor"
6837 |         ],
6838 |         "Psycho": [
6839 |           "Alfred Hitchcock",
6840 |           "Thriller",
6841 |           "bathroom",
6842 |           "knife"
6843 |         ],
6844 |         "Pulp Fiction": [
6845 |           "Quentin Tarantino",
6846 |           "John Travolta",
6847 |           "Samuel L. Jackson",
6848 |           "dancing",
6849 |           "Ezekiel 25:17"
6850 |         ],
6851 |         "Reservoir Dogs": [
6852 |           "Action",
6853 |           "jewelry heist",
6854 |           "Quentin Tarantino"
6855 |         ],
6856 |         "Rocky": [
6857 |           "Sylvester Stallone",
6858 |           "heavyweight boxing champion",
6859 |           "Eye of the tiger"
6860 |         ],
6861 |         "Saving Private Ryan": [
6862 |           "War",
6863 |           "Normandy",
6864 |           "U.S. Army",
6865 |           "Captain Miller",
6866 |           "Tom Hanks",
6867 |           "Matt Damon"
6868 |         ],
6869 |         "Scarface": [
6870 |           "Action",
6871 |           "Tony Montana",
6872 |           "drug dealer",
6873 |           "Miami",
6874 |           "drug cartel"
6875 |         ],
6876 |         "Schindler's List": [
6877 |           "Drama",
6878 |           "Biography",
6879 |           "Liam Neeson",
6880 |           "World War II",
6881 |           "Nazis"
6882 |         ],
6883 |         "Se7en": [
6884 |           "Thriller",
6885 |           "Morgan Freeman",
6886 |           "Brad Pitt",
6887 |           "serial killer",
6888 |           "deadly sins"
6889 |         ],
6890 |         "Shining": [
6891 |           "Thriller",
6892 |           "Stanley Kubrick",
6893 |           "Jack Nicholson",
6894 |           "hotel",
6895 |           "axe"
6896 |         ],
6897 |         "Shutter Island": [
6898 |           "Thriller",
6899 |           "Leonardo DiCaprio",
6900 |           "Teddy Daniels",
6901 |           "Andrew Laeddis",
6902 |           "Ashecliffe Hospital",
6903 |           "psychiatry"
6904 |         ],
6905 |         "Sin City": [
6906 |           "Action",
6907 |           "black white",
6908 |           "red",
6909 |           "Bruce Willis",
6910 |           "blood"
6911 |         ],
6912 |         "Star Wars: Episode IV - A New Hope": [
6913 |           "Luke Skywalker",
6914 |           "Jedi",
6915 |           "Yoda",
6916 |           "Han Solo",
6917 |           "Darth Vader",
6918 |           "Princess Leia"
6919 |         ],
6920 |         "Taxi Driver": [
6921 |           "Martin Scorsese",
6922 |           "Drama",
6923 |           "cab",
6924 |           "New York City"
6925 |         ],
6926 |         "The Avengers": [
6927 |           "Action",
6928 |           "Marvel",
6929 |           "Iron Man",
6930 |           "Captain America",
6931 |           "Thor",
6932 |           "Black Widow"
6933 |         ],
6934 |         "The Big Lebowski": [
6935 |           "Drama",
6936 |           "The Dude",
6937 |           "bowling",
6938 |           "Jeff Bridges",
6939 |           "Moscow mule"
6940 |         ],
6941 |         "The Bourne Ultimatum": [
6942 |           "Action",
6943 |           "CIA",
6944 |           "Jason Bourne",
6945 |           "assassination"
6946 |         ],
6947 |         "The Dark Knight": [
6948 |           "Christian Bale",
6949 |           "Joker",
6950 |           "Gotham City",
6951 |           "Batman"
6952 |         ],
6953 |         "The Departed": [
6954 |           "Thriller",
6955 |           "Leonardo DiCaprio",
6956 |           "Matt Damon",
6957 |           "South Boston"
6958 |         ],
6959 |         "The Godfather": [
6960 |           "Thriller",
6961 |           "Marlon Brando",
6962 |           "Mafia",
6963 |           "Don Vito Corleone",
6964 |           "offer you can't refuse"
6965 |         ],
6966 |         "The Good, the Bad and the Ugly": [
6967 |           "Clint Eastwood",
6968 |           "wild west",
6969 |           "cowboys"
6970 |         ],
6971 |         "The Great Dictator": [
6972 |           "Charles Chaplin",
6973 |           "silent film",
6974 |           "Comedy",
6975 |           "Hitler",
6976 |           "Nazi"
6977 |         ],
6978 |         "The Green Mile": [
6979 |           "Drama",
6980 |           "Stephen King",
6981 |           "Tom Hanks",
6982 |           "Death Row"
6983 |         ],
6984 |         "The Intouchables": [
6985 |           "Drama",
6986 |           "Omar Sy",
6987 |           "quadriplegic",
6988 |           "Driss & Philippe",
6989 |           "wheelchair"
6990 |         ],
6991 |         "The Lives of Others": [
6992 |           "Drama",
6993 |           "Germany",
6994 |           "DDR",
6995 |           "Stasi",
6996 |           "East Berlin"
6997 |         ],
6998 |         "The Lord of the Rings": [
6999 |           "One Ring",
7000 |           "Frodo & Sam",
7001 |           "Hobbit",
7002 |           "Gandalf",
7003 |           "Middle Earth",
7004 |           "J.R.R. Tolkien"
7005 |         ],
7006 |         "The Martian": [
7007 |           "Bring him Home",
7008 |           "space",
7009 |           "Matt Damon",
7010 |           "astronaut",
7011 |           "NASA"
7012 |         ],
7013 |         "The Matrix": [
7014 |           "green",
7015 |           "Neo",
7016 |           "Morpheus",
7017 |           "Agent Smith",
7018 |           "Keanu Reeves"
7019 |         ],
7020 |         "The Pianist": [
7021 |           "Drama",
7022 |           "Adrien Brody",
7023 |           "Polish Jewish musician",
7024 |           "World War II",
7025 |           "keyboard"
7026 |         ],
7027 |         "The Revenant - Der Rückkehrer": [
7028 |           "Drama",
7029 |           "Leonardo DiCaprio",
7030 |           "Oscar",
7031 |           "wilderness survival",
7032 |           "bear"
7033 |         ],
7034 |         "The Shawshank Redemption": [
7035 |           "Drama",
7036 |           "Tim Robbins",
7037 |           "Morgan Freeman",
7038 |           "imprisoned men",
7039 |           "escape"
7040 |         ],
7041 |         "The Silence of the Lambs": [
7042 |           "Anthony Hopkins",
7043 |           "Jodie Foster",
7044 |           "Dr. Hannibal Lecter",
7045 |           "cannibal"
7046 |         ],
7047 |         "The Sixth Sense": [
7048 |           "Drama",
7049 |           "spirits",
7050 |           "child psychologist",
7051 |           "Bruce Willis"
7052 |         ],
7053 |         "The Terminator": [
7054 |           "Action",
7055 |           "Arnold Schwarzenegger",
7056 |           "time traveling",
7057 |           "I am back"
7058 |         ],
7059 |         "The Truman Show": [
7060 |           "Drama",
7061 |           "live",
7062 |           "Jim Carrey",
7063 |           "reality TV show",
7064 |           "cameras"
7065 |         ],
7066 |         "The Usual Suspects": [
7067 |           "Drama",
7068 |           "Kevin Spacey",
7069 |           "gun battle",
7070 |           "police lineup"
7071 |         ],
7072 |         "The Wizard of Oz": [
7073 |           "Adventure",
7074 |           "Dorothy Gale",
7075 |           "wizard",
7076 |           "Judy Garland",
7077 |           "Fantasy"
7078 |         ],
7079 |         "The Wolf of Wall Street": [
7080 |           "Drama",
7081 |           "Comedy",
7082 |           "Leonardo DiCaprio",
7083 |           "penny stocks",
7084 |           "Jordan Belfort"
7085 |         ],
7086 |         "Toy Story": [
7087 |           "Disney",
7088 |           "Pixar",
7089 |           "Woody",
7090 |           "Buzz Lightyear",
7091 |           "Sid"
7092 |         ],
7093 |         "Up": [
7094 |           "Disney",
7095 |           "Pixar",
7096 |           "Carl Fredricksen",
7097 |           "house",
7098 |           "balloons"
7099 |         ],
7100 |         "V for Vendetta": [
7101 |           "Action",
7102 |           "freedom fighter",
7103 |           "Hugo Weaving",
7104 |           "Guy Fawkes mask"
7105 |         ],
7106 |         "WALL·E": [
7107 |           "Disney",
7108 |           "Pixar",
7109 |           "robots",
7110 |           "Eve",
7111 |           "space"
7112 |         ],
7113 |         "Zootopia": [
7114 |           "Disney",
7115 |           "Pixar",
7116 |           "animals",
7117 |           "rabbit",
7118 |           "police"
7119 |         ]
7120 |     }
7121 | }
```

## File: textarena/envs/two_player/Taboo/README.md

- Extension: .md
- Language: markdown
- Size: 8037 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Truth And Deception Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | **Taboo** is a classic two-player word game where one player, the **Clue Giver**, provides verbal clues to help the other player, the **Guesser**, identify a secret word without using a set of forbidden "taboo" words. The game emphasizes creativity and effective communication under constraints.
  6 | 
  7 | 
  8 | 
  9 | ## Action Space
 10 | 
 11 | - **Format:**
 12 |   - **Clue Giver:** Any string representing the clue, **excluding** the taboo words and the word to guess.
 13 |   - **Guesser:** Must provide their guess within squared brackets. For example: `[apple]`.
 14 | 
 15 | - **Examples:**
 16 |   - **Clue Giver:** `"It's something you might eat for breakfast."`
 17 |   - **Guesser:** `"[toast]"`
 18 | 
 19 | - **Notes:**
 20 |   - Clue Givers must avoid using any taboo words or the word to guess in their clues.
 21 |   - Guessers must format their guesses within squared brackets to be recognized by the environment.
 22 | 
 23 | 
 24 | ## Observation Space
 25 | 
 26 | ### Observations
 27 | 
 28 | Each player receives a series of messages exchanged during the game, along with their specific roles and objectives.
 29 | 
 30 | 
 31 | **Reset Observation:**
 32 | On reset, each player receives a prompt tailored to their role. For example:
 33 | 
 34 | - **Clue Giver (Player 0):**
 35 | ```plaintext
 36 | [Game]: You are Player 0, the Clue Giver in the Taboo game.
 37 | The word to guess is 'apple'.
 38 | Taboo words: fruit, red, pie.
 39 | Your goal is to provide clues to the Guesser without using the taboo words or the word to guess.
 40 | You have 30 turns to help the Guesser guess the word.
 41 | On your turn, simply type your clue.
 42 | ```
 43 | 
 44 | - **Guesser (Player 1):**
 45 | ```plaintext
 46 | [Game]: You are Player 1, the Guesser in the Taboo game.
 47 | Your goal is to guess the secret word based on the clues provided by the Clue Giver.
 48 | You have 30 turns to guess the word.
 49 | On your turn, type your guess within squared brackets. For example: '[apple]'.
 50 | ```
 51 | 
 52 | 
 53 | **Step Observation:**
 54 | After each step, players receive the latest action taken by their opponent. For example:
 55 | ```plaintext
 56 | [Clue Giver (Player 0)]: It's something you might eat for breakfast.
 57 | [Guesser (Player 1)]: [toast]
 58 | ```
 59 | 
 60 | 
 61 | ## Gameplay
 62 | - **Players**: 2
 63 | - **Roles**: Player 0 plays as the Clue Giver, Player 1 plays as the Guesser.
 64 | - **Turns**: Players alternate turns based on their roles.
 65 | - **Target Word**: The Clue Giver is assigned a secret word along with a list of taboo words that cannot be used in clues.
 66 | - **Objective**:
 67 |     - **Clue Giver**: Provide effective clues to help the Guesser identify the secret word without using any taboo words or the word itself.
 68 |     - **Guesser**: Deduce the secret word based on the clues provided by the Clue Giver by making guesses within squared brackets.
 69 | - **Turn Limit:** The game can be configured with a maximum number of turns. If the Guesser does not correctly guess the word within this limit, the game ends.
 70 | 
 71 | ## Key Rules
 72 | 1. Clue Giver's Rules:
 73 |     - Must not use any of the taboo words or the word to guess in their clues.
 74 |     - Clues should be clear enough to help the Guesser but subtle to avoid using forbidden terms.
 75 | 
 76 | 2. Guesser's Rules:
 77 |     - Must format their guesses within squared brackets (e.g., `[apple]`).
 78 |     - Only guesses within the correct format are considered valid.
 79 | 
 80 | 3. Winning Conditions:
 81 |     - **Win:** Both players win if the word is guessed correctly.
 82 |     - **Draw:** The game ends in a draw if the turn limit is reached.
 83 |     - **Invalid Move:** If a player makes an invalid move they lose with a -1 reward.
 84 | 
 85 | 4. Game Termination:
 86 |     - The game ends immediately upon a win or an invalid move.
 87 |     - If the turn limit is reached without a correct guess, the game ends in a draw.
 88 | 
 89 | ## Rewards
 90 | 
 91 | | Outcome          | Reward for Player | Reward for Opponent |
 92 | |------------------|:-----------------:|:-------------------:|
 93 | | **Win**          | `+1`              | `-1`                |
 94 | | **Draw**         |  `0`              |  `0`                |
 95 | | **Invalid Move** | `-1`              |  `0`                |
 96 | 
 97 | 
 98 | ## Parameters
 99 | 
100 | - `categories` (`List[str]`):
101 |     - **Description**: Specifies the categories from which words are selected (e.g., [`"animals"`]).
102 |     - **Impact**: Determines the pool of words and taboo words used in the game.
103 | 
104 | - `max_turns` (`int`):
105 |     - **Description**: Sets the maximum number of turns allowed before the game ends in a draw.
106 |     - **Impact**: Limits the duration of the game, encouraging timely clues and guesses.
107 | 
108 | - `data_path` (`str`):
109 |     - **Description**: Path to the JSON file containing the list of words and their associated taboo words.
110 |     - **Impact**: Allows customization of the word pool used in the game.
111 | 
112 | 
113 | 
114 | ## Variants
115 | 
116 | | Env-id                     | max_turns  | categories                                                                 |
117 | |----------------------------|:----------:|:--------------------------------------------------------------------------:|
118 | | `Taboo-v0`                 | `6`        | `things`                                                                   |
119 | | `Taboo-v0-animals`         | `6`        | `animals`                                                                  |
120 | | `Taboo-v0-cars`            | `6`        | `cars`                                                                     |
121 | | `Taboo-v0-city/country`    | `6`        | `city/country`                                                             |
122 | | `Taboo-v0-food`            | `6`        | `food`                                                                     |
123 | | `Taboo-v0-literature`      | `6`        | `literature`                                                               |
124 | | `Taboo-v0-people`          | `6`        | `people`                                                                   |
125 | | `Taboo-v0-tv`              | `6`        | `tv`                                                                       |
126 | | `Taboo-v0-long`            | `24`       | `things`                                                                   |
127 | | `Taboo-v0-full`            | `6`        | `things`,`animals`,`cars`,`city/country`,`food`,`literature`,`people`,`tv` |
128 | 
129 | 
130 | 
131 | ## Example Usage
132 | 
133 | ```python
134 | import textarena as ta
135 | 
136 | # Initialize the environment
137 | env = ta.make(env_id="Taboo-v0")
138 | 
139 | # Wrap the environment for easier observation handling
140 | env = ta.wrappers.LLMObservationWrapper(env=env)
141 | 
142 | # initalize agents
143 | agents = {
144 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
145 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
146 |     }
147 | 
148 | # reset the environment to start a new game
149 | observations = env.reset(seed=490)
150 | 
151 | # Game loop
152 | done = False
153 | while not done:
154 | 
155 |     # Get the current player
156 |     current_player_id = env.state.get("current_player")
157 | 
158 |     # Get the current observation for the player
159 |     obs = observations[current_player_id]
160 | 
161 |     # Agent decides on an action based on the observation
162 |     action = agents[current_player_id](obs)
163 | 
164 |     # Execute the action in the environment
165 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
166 | 
167 |     # Check if the game has ended
168 |     done = terminated or truncated
169 | 
170 |     # Optionally render the environment to see the current state
171 |     env.render()
172 | 
173 |     if done:
174 |         break
175 | 
176 | # Finally, print the game results
177 | for player_id, agent in agents.items():
178 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
179 | print(f"Reason: {info['reason']}")
180 | ```
181 | 
182 | ## Troubleshooting
183 | 
184 | - **Clue Giver Uses a Taboo Word:**
185 |     - **Issue:** The Clue Giver includes a taboo word or the word to guess in their clue.
186 |     - **Solution:** Ensure that the Clue Giver carefully avoids using any taboo words or the word to guess in their clues.
187 | 
188 | - **Guesser Fails to Format Guess Correctly:**
189 |     - **Issue:** The Guesser provides a guess without using squared brackets (e.g.,`apple` instead of `[apple]`).
190 |     - **Solution:** Instruct the Guesser to always format their guesses within squared brackets, such as `[apple]`.
191 | 
192 | 
193 | ## Version History
194 | - **v0**
195 |   - Initial release 
196 | 
197 | 
198 | 
199 | ### Contact
200 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/Mastermind/test.py

- Extension: .py
- Language: python
- Size: 4733 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | from textarena.envs.two_player.Mastermind.env import MastermindEnv
  4 | 
  5 | 
  6 | def generate_correct_move_sequence():
  7 |     
  8 |     return ["Let's make the first code guess attempt of [1 2 3 4].", "Seems like 1 2 4 3 gave 2 black pegs and 2 white pegs. Let's reorder the last two digts. My guess is [1 2 3 4]."]
  9 | 
 10 | def generate_invalid_move_sequence():
 11 |     
 12 |     return ["Let's make the first code guess attempt of (1 2 3 4).", "Seems like 1 2 4 3 gave 2 black pegs and 2 white pegs. Let's reorder the last two digts. My guess is 1 2 3 4."]
 13 | 
 14 | def generate_out_of_bounds_sequence():
 15 |     
 16 |     return ["Let's make the first code guess attempt of (1 2 3 100).", "Seems like 1 2 4 3 gave 2 black pegs and 2 white pegs. Let's reorder the last two digts. My guess is 100 20 3 4."]
 17 | 
 18 | def generate_player_winning_seqeunce():
 19 |     
 20 |     return ["I think the answer is [6 1 3 2]"]
 21 | 
 22 | class TestMastermindEnv(unittest.TestCase):
 23 |     
 24 | 
 25 |     
 26 |     env_variants = [
 27 |         {"difficulty": "easy"},
 28 |         {"difficulty": "medium"},
 29 |         {"difficulty": "hard"},
 30 |     ]
 31 | 
 32 |     
 33 |     test_cases = {
 34 |         "correct_move_easy": {
 35 |             "difficulty": "easy",
 36 |             "actions": generate_correct_move_sequence()
 37 |         },
 38 |         "invalid_move_easy": {
 39 |             "difficulty": "easy",
 40 |             "actions": generate_invalid_move_sequence()
 41 |         },
 42 |         "out_of_bounds_easy": {
 43 |             "difficulty": "easy",
 44 |             "actions": generate_out_of_bounds_sequence()
 45 |         },
 46 |         "player_winning_easy": {
 47 |             "difficulty": "easy",
 48 |             "actions": generate_player_winning_seqeunce()
 49 |         }
 50 |     }
 51 | 
 52 |     @parameterized.expand([
 53 |         (name, details['difficulty'], details['actions'])
 54 |         for name, details in test_cases.items()
 55 |     ])
 56 |     def test_mastermind_outcomes(self, name, difficulty, actions):
 57 |         
 58 |         env_config = next((env for env in self.env_variants if env['difficulty'] == difficulty), None)
 59 |         self.assertIsNotNone(env_config, f"Environment configuration not found for difficulty level: {difficulty}")
 60 | 
 61 |         env = MastermindEnv(difficulty=env_config['difficulty'])
 62 | 
 63 |         observations = env.reset(seed=490)
 64 | 
 65 |         terminated = False
 66 |         truncated = False
 67 |         rewards = {0: 0, 1: 0}
 68 | 
 69 |         for i, action in enumerate(actions):
 70 |             if terminated or truncated:
 71 |                 break
 72 |             player_id = i % 2
 73 | 
 74 |             env_action = action
 75 | 
 76 |             
 77 |             observations, reward, truncated, terminated, info = env.step(player_id, env_action)
 78 | 
 79 |             
 80 |             if reward:
 81 |                 rewards.update(reward)
 82 | 
 83 |         if "correct_move" in name:
 84 |             self.assertFalse(truncated, "Game should not truncate for correct moves.")
 85 |             self.assertFalse(terminated, "Game should not terminate until the puzzle is complete.")
 86 |         elif "invalid_move" in name:
 87 |             self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move.")
 88 |             self.assertEqual(rewards[player_id], -1, "Player should receive -1 reward for an invalid move.")
 89 |         elif "out_of_bounds" in name:
 90 |             self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move.")
 91 |             self.assertEqual(rewards[player_id], -1, "Player should receive -1 reward for an invalid move.")
 92 |         elif "player_winning" in name:
 93 |             self.assertTrue(terminated, "Game should terminate due to a player winning.")
 94 |             self.assertEqual(rewards[player_id], 1, f"Player {player_id} should have received +1 for winning.")
 95 |             self.assertEqual(rewards[1 - player_id], -1, f"Player {1 - player_id} should have received -1 for losing.")
 96 |         else:
 97 |             raise ValueError(f"Invalid test case name: {name}")
 98 |     
 99 |     def run_unit_test():
100 |         print("Running Mastermind tests...")
101 |         unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/two_player/Mastermind/env.py

- Extension: .py
- Language: python
- Size: 9875 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from typing import Optional, Tuple, List, Dict
  2 | import textarena as ta
  3 | import random
  4 | import re
  5 | 
  6 | class MastermindEnv(ta.Env):
  7 |     
  8 |     def __init__(
  9 |         self,
 10 |         difficulty: Optional[str] = "easy",
 11 |     ):
 12 |         
 13 |         super().__init__()
 14 |         self.environment_name = "Mastermind"
 15 |         self.difficulty = difficulty
 16 | 
 17 |         
 18 |         if self.difficulty == "easy":
 19 |             self.code_length = 4
 20 |             self.num_numbers = 6
 21 |             self.max_turns = 10
 22 |             self.duplicate_numbers = False
 23 |         elif self.difficulty == "medium":
 24 |             self.code_length = 5
 25 |             self.num_numbers = 8
 26 |             self.max_turns = 12
 27 |             self.duplicate_numbers = False
 28 |         elif self.difficulty == "hard":
 29 |             self.code_length = 6
 30 |             self.num_numbers = 10
 31 |             self.max_turns = 15
 32 |             self.duplicate_numbers = True
 33 |         else:
 34 |             raise ValueError(f"Invalid difficulty level: {difficulty}")
 35 |         
 36 |         
 37 |         self.state = ta.State(
 38 |             num_players=2,
 39 |             max_turns=self.max_turns,
 40 |             render_keys=["rendered_view"],
 41 |         )
 42 |         
 43 |     def reset(
 44 |         self,
 45 |         seed: Optional[int] = None
 46 |     ) -> Optional[ta.Observations]:
 47 |         
 48 |         if seed is not None:
 49 |             random.seed(seed)
 50 |         else:
 51 |             random.seed()
 52 | 
 53 |         
 54 |         self.secret_codes = self._generate_secret_codes()
 55 |         self.guesses = {0: [], 1: []}
 56 | 
 57 |         
 58 |         return self.state.reset(
 59 |             game_state={
 60 |                 "rendered_view": self._render_view()
 61 |             },
 62 |             player_prompt_function=self._generate_player_prompt
 63 |         )
 64 |     
 65 |     def _generate_secret_codes(self) -> Dict[List[int], List[int]]:
 66 |         
 67 | 
 68 |         available_numbers = list(range(1, self.num_numbers + 1))
 69 |         if self.duplicate_numbers:
 70 |             player1_code = random.choices(available_numbers, k=self.code_length)
 71 |             player2_code = random.choices(available_numbers, k=self.code_length)
 72 |         else:
 73 |             player1_code = random.sample(available_numbers, k=self.code_length)
 74 |             player2_code = random.sample(available_numbers, k=self.code_length)
 75 |         
 76 |         secret_codes = {
 77 |             0: player1_code,
 78 |             1: player2_code
 79 |         }
 80 | 
 81 |         return secret_codes
 82 |     
 83 |     def _render_view(self) -> str:
 84 |         
 85 |         view = "Player 0's Secret Code: " + " ".join(map(str, self.secret_codes[0])) + "\n"
 86 |         view += "Player 1's Guess: " + " ".join(map(str, self.guesses[1]) if self.guesses[1] else ["-"] * self.code_length) + "\n"
 87 |         view += "Player 1's Secret Code: " + " ".join(map(str, self.secret_codes[1])) + "\n"
 88 |         view += "Player 0's Guess: " + " ".join(map(str, self.guesses[0]) if self.guesses[0] else ["-"] * self.code_length) + "\n"
 89 | 
 90 |         return view
 91 | 
 92 |     def _generate_player_prompt(self, player_id: int) -> str:
 93 |         
 94 |         prompt = (
 95 |             f"You are Player {player_id}. You are playing Mastermind ({self.difficulty} level).\n"
 96 |             f"Your goal is to guess the other player's secret code that is {self.code_length} digits long, where each digit ranges from 1 to {self.num_numbers}, and the are {'' if self.duplicate_numbers else 'no '}duplicate digits.\n"
 97 |             "In your response, you can mention any code or previously submitted code in the format of 1 2 3 4. Only when you have decided to make your guess, then you must strictly enter the code in square brackets like [2 1 4 5]. This is to avoid submitting a wrong code to the game environment.\n"
 98 |             "After each guess, you will receive feedback in the form of black and white pegs.\n"
 99 |             "A black peg indicates a correct digit in the correct position, while a white peg indicates a correct digit in the wrong position.\n"
100 |             f"You have only {self.max_turns} turns to guess the code.\n"
101 |         )
102 | 
103 |         return prompt
104 |     
105 |     def step(
106 |         self,
107 |         player_id: int,
108 |         action: str,
109 |     ) -> Tuple[
110 |         ta.Observations,
111 |         ta.Rewards,
112 |         bool,
113 |         bool,
114 |         ta.Info
115 |     ]:
116 |         
117 |         
118 |         self.state.check_action_format(
119 |             action=action,
120 |             player_id=player_id,
121 |         )
122 | 
123 |         
124 |         self.state.add_observation(
125 |             from_id=player_id,
126 |             to_id=player_id, 
127 |             message=action,
128 |             for_logging=True
129 |         )
130 | 
131 |         
132 |         action_search_pattern = re.compile(r"\[(\d+(?:\s+\d+)*)\]") 
133 |         match = action_search_pattern.search(action)
134 | 
135 |         if match is None:
136 |             self.state.set_invalid_move(
137 |                 player_ids=[player_id],
138 |                 reasons=[f"Invalid move format. Player {player_id}, did not respond with a space-separated list of numbers wrapped in square brackets."]
139 |             )
140 | 
141 |         else:
142 |             
143 |             player_guess = list(map(int, match.group(1).split()))
144 | 
145 |             
146 |             if len(player_guess) != self.code_length:
147 |                 self.state.set_invalid_move(
148 |                     player_ids=[player_id],
149 |                     reasons=[f"Invalid move format. Player {player_id}, the guess should contain {self.code_length} numbers."]
150 |                 )
151 |             else:
152 |                 
153 |                 black_pegs, white_pegs = self._evaluate_guess(player_id, player_guess)
154 | 
155 |                 
156 |                 if any(num > self.num_numbers for num in player_guess):
157 |                     self.state.set_invalid_move(
158 |                         player_ids=[player_id],
159 |                         reasons=[f"Invalid move format. Player {player_id}, the guess should contain numbers between 1 and {self.num_numbers}."]
160 |                     )
161 |                 elif black_pegs == self.code_length:
162 |                     self.state.set_winners(
163 |                         player_ids=[player_id],
164 |                         reason=f"Player {player_id} has cracked the code!"
165 |                     )
166 |                 else:
167 |                     self.state.add_observation(
168 |                         from_id=ta.GAME_ID,
169 |                         to_id=player_id, 
170 |                         message=f"You have submitted [{match.group(1)}]. Feedback: {black_pegs} black peg(s), {white_pegs} white peg(s).",
171 |                         for_logging=False
172 |                     )
173 | 
174 |                 
175 |                 self.guesses[player_id] = player_guess
176 | 
177 |         
178 |         self.state.game_state["rendered_view"] = self._render_view()
179 | 
180 |         return self.state.step()
181 |     
182 |     def _evaluate_guess(self, player_id: int, player_guess: List[int]) -> Tuple[int, int]:
183 |         
184 |         black_pegs = 0
185 |         white_pegs = 0
186 |         matched_code = [False] * self.code_length
187 |         opponent_code = self.secret_codes[1 - player_id]
188 | 
189 |         for i in range(self.code_length):
190 |             if player_guess[i] == opponent_code[i]:
191 |                 black_pegs += 1
192 |                 matched_code[i] = True
193 |             else:
194 |                 for j in range(self.code_length):
195 |                     if not matched_code[j] and player_guess[i] == opponent_code[j]:
196 |                         white_pegs += 1
197 |                         matched_code[j] = True
198 |                         break
199 | 
200 |         return black_pegs, white_pegs
201 |     
202 |     def render(self):
203 |         
204 |         print(f"Turn: {self.state.turn}")
205 |         print("\nRecent Game Logs:")
206 |         recent_logs = self.state.logs[-5:]
207 | 
208 |         for sender_id, log in recent_logs:
209 |             if sender_id == ta.GAME_ID:
210 |                 print(f"[GAME] {log}")
211 |             else:
212 |                 print(f"[Player {sender_id}] {log}")
```

## File: textarena/envs/two_player/Mastermind/README.md

- Extension: .md
- Language: markdown
- Size: 8978 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Mastermind Environment Documentation
  2 | 
  3 | ## Overview
  4 | **Mastermind Game** is a two-player turn-based deduction game where each player attempts to guess the opponent's secret code set by the game environment. Each secret code consists of a series of numbers, with the length and range of these numbers determined by the difficulty level. Players submit guesses in a specific format, and after each guess, they receive feedback in the form of black and white pegs. A black peg represents a correct digit in the correct position, while a white peg indicates a correct digit in the wrong position. The game continues until a player correctly guesses the opponent’s secret code or until the maximum number of turns is reached. This environment supports flexible difficulty settings, feedback on guesses, and an interactive prompt system for engaging gameplay between agents.
  5 | 
  6 | ## Action Space
  7 | - **Format:** Actions are strings representing the player's choice. For example:
  8 | - **Example:**
  9 |     - Guessing the code 1 2 3 4: [1 2 3 4]
 10 |     - Guessing the code 4 2 5 1: [4 2 5 1]
 11 | - **Notes:** Players can have additional texts in their replies, as long as they provide their coordinates in the correct format.
 12 | 
 13 | ## Observation Space
 14 | **Reset Observations**
 15 | On reset, each player receives a prompt containing their beginning game instructions. For example:
 16 | ```plaintext
 17 | [GAME] You are Player 0. You are playing Mastermind (easy level).
 18 | Your goal is to guess the other player's secret code that is 4 digits long, where each digit ranges from 1 to 6, and the are no duplicate digits.
 19 | In your response, you can mention any code or previously submitted code in the format of 1 2 3 4. Only when you have decided to make your guess, then you must strictly enter the code in square brackets like [2 1 4 5]. This is to avoid submitting a wrong code to the game environment.
 20 | After each guess, you will receive feedback in the form of black and white pegs.
 21 | A black peg indicates a correct digit in the correct position, while a white peg indicates a correct digit in the wrong position.
 22 | You have only 10 turns to guess the code.
 23 | ```
 24 | 
 25 | **Step Observations:**
 26 | After each step, the players receive the latest message from the game environment. For example, here's player 0 making their first move:
 27 | ```plaintext
 28 | [Player 0] To start, I'll make an initial guess to gather some feedback. Since no digits repeat and the range is from 1 to 6, I'll begin with a simple sequence:
 29 | 
 30 | [1 2 3 4]
 31 | [GAME] You have submitted [1 2 3 4]. Feedback: 1 black peg(s), 2 white peg(s).
 32 | ```
 33 | 
 34 | ## Gameplay
 35 | 
 36 | - **Players**: 2
 37 | - **Turns**: Players alternate turns to guess the opponent's secret code. Each turn, a player submits a code guess in a specific format. After each guess, they receive feedback on their accuracy in the form of black and white pegs.
 38 | - **Code Structure**: Each player’s secret code is a sequence of numbers, with the code length and range determined by the difficulty level.
 39 | - **Objective**: Deduce the opponent's secret code by analyzing feedback and making strategic guesses.
 40 | - **Difficulty Levels**:
 41 |   - **Easy**: Code length of 4, numbers range from 1 to 6, no duplicate numbers, maximum of 10 turns.
 42 |   - **Medium**: Code length of 5, numbers range from 1 to 8, no duplicate numbers, maximum of 12 turns.
 43 |   - **Hard**: Code length of 6, numbers range from 1 to 10, duplicates allowed, maximum of 15 turns.
 44 | - **Feedback Mechanism**:
 45 |   - **Black Pegs**: Indicate digits that are correct in both value and position.
 46 |   - **White Pegs**: Indicate digits that are correct in value but incorrect in position.
 47 | - **Winning Condition**: The game is won when a player successfully guesses the opponent’s full secret code with the correct sequence within the allowed number of turns.
 48 | 
 49 | ## Key Rules
 50 | 
 51 | 1. **Guessing**:
 52 |    - Players take turns submitting a guess to deduce the opponent's secret code. Each guess is submitted as a space-separated list of numbers within square brackets (e.g., "[1 3 5 2]").
 53 |    - After each guess, the player receives feedback based on the correctness of the guess.
 54 | 
 55 | 2. **Valid Moves**:
 56 |    - Guesses must match the code length for the current difficulty level (e.g., 4 numbers for "easy" level).
 57 |    - The numbers in each guess must be within the allowed range for the difficulty level (e.g., 1 to 6 for "easy").
 58 |    - Guesses are invalid if they contain incorrect formatting or out-of-range numbers, and the player will receive an error message without feedback.
 59 | 
 60 | 3. **Feedback (Pegs)**:
 61 |    - **Black Pegs**: Each black peg indicates a digit that is correct in both value and position.
 62 |    - **White Pegs**: Each white peg represents a correct digit that is in the wrong position.
 63 |    - Players can use this feedback to refine their guesses in subsequent turns.
 64 | 
 65 | 4. **Winning Conditions**:
 66 |    - **Win**: The game is won when a player correctly guesses the opponent's full code with all digits in the correct order.
 67 |    - **Loss**: A player loses if their opponent guesses their code first.
 68 | 
 69 | 5. **Game Termination**:
 70 |    - The game ends as soon as one player correctly guesses the opponent’s code or if both players reach the maximum turn limit without a successful guess.
 71 |    - **Draw**: If both players fail to guess each other's code within the allotted turns, the game will be declared a draw.
 72 | 
 73 | 
 74 | ## Rewards
 75 | 
 76 | | Outcome          | Reward for Player | Reward for Opponent |
 77 | |------------------|:-----------------:|:-------------------:|
 78 | | **Win**          | `+1`              | `-1`                |
 79 | | **Lose**         | `-1`              | `+1`                |
 80 | | **Draw**         | `0`               | `0`                 |
 81 | | **Invalid**      | `-1`              | `0`                 |
 82 | 
 83 | 
 84 | ## Parameters
 85 | 
 86 | - `difficulty` (`str`):
 87 |     - **Description**: Sets the difficulty level, adjusting the code length, range of numbers, and maximum turns.
 88 |     - **Options**:
 89 |         - `"easy"`: Code length of 4, numbers range from 1 to 6, with no duplicate numbers allowed, and a maximum of 10 turns.
 90 |         - `"medium"`: Code length of 5, numbers range from 1 to 8, with no duplicate numbers allowed, and a maximum of 12 turns.
 91 |         - `"hard"`: Code length of 6, numbers range from 1 to 10, with duplicate numbers allowed, and a maximum of 15 turns.
 92 |     - **Impact**:
 93 |         - Higher difficulty levels increase the game’s complexity by expanding the code length, number range, and allowing duplicate numbers (for "hard"), requiring players to apply more complex deduction strategies to solve the code within a limited number of turns.
 94 | 
 95 | ## Variants
 96 | 
 97 | | Env-id                  | difficulty |
 98 | |-------------------------|:----------:|
 99 | | `Mastermind-v0-easy`    | `easy`     |
100 | | `Mastermind-v0-medium`  | `medium`   |
101 | | `Mastermind-v0-hard`    | `hard`     |
102 | 
103 | ## Example Usage
104 | ```python
105 | import textarena as ta
106 | 
107 | # Initialize the environment
108 | env = ta.make(env_id="Mastermind-v0-easy")
109 | 
110 | # Wrap the environment for easier observation handling
111 | env = ta.wrappers.LLMObservationWrapper(env=env)
112 | 
113 | # Wrap the environment for pretty rendering
114 | env = ta.wrappers.PrettyRenderWrapper(env=env)
115 | 
116 | # initalize agents
117 | agents = {
118 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
119 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
120 |     }
121 | 
122 | # reset the environment to start a new game
123 | observations = env.reset(seed=490)
124 | 
125 | # Game loop
126 | done = False
127 | while not done:
128 | 
129 |     # Get the current player
130 |     current_player_id = env.state.get("current_player")
131 | 
132 |     # Get the current observation for the player
133 |     obs = observations[current_player_id]
134 | 
135 |     # Agent decides on an action based on the observation
136 |     action = agents[current_player_id](obs)
137 | 
138 |     # Execute the action in the environment
139 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
140 | 
141 |     # Check if the game has ended
142 |     done = terminated or truncated
143 | 
144 |     # Optionally render the environment to see the current state
145 |     env.render()
146 | 
147 |     if done:
148 |         break
149 | 
150 | # Finally, print the game results
151 | for player_id, agent in agents.items():
152 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
153 | print(f"Reason: {info['reason']}")
154 | ```
155 | 
156 | 
157 | ## Troubleshooting
158 | 
159 | - **Repeatedly mentioning other trivial code in square brackets**:
160 |     - **Issue**: The game environment wrongly detects a trivial code sequence as the model's code submission for the turn. This causes the model to wrongly capture its decided code.
161 |     - **Solution**: Refine the prompt to explicitly highlight how mentioned code sequences can be in the format 1 2 3 4 or 4 2 5 1. And only when submitting its move, to wrap in square brackets.
162 | 
163 | - **Invalid Move Format**:
164 |     - **Issue**: A player keeps submitting its code sequence without the square brackets.
165 |     - **Solution**: Update the prompt with examples of good and bad code sequence submissions.
166 | 
167 | ## Version History
168 | - **v0**
169 |   - Initial release 
170 | 
171 | 
172 | ### Contact
173 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/two_player/Mastermind/example.py

- Extension: .py
- Language: python
- Size: 1338 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make(env_id="Mastermind-v0-easy")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
15 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
16 |     }
17 | 
18 | 
19 | observations = env.reset(seed=490)
20 | 
21 | 
22 | done = False
23 | while not done:
24 | 
25 |     
26 |     current_player_id = env.state.get("current_player")
27 | 
28 |     
29 |     obs = observations[current_player_id]
30 | 
31 |     
32 |     action = agents[current_player_id](obs)
33 | 
34 |     
35 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
36 | 
37 |     
38 |     done = terminated or truncated
39 | 
40 |     
41 |     env.render()
42 | 
43 |     if done:
44 |         break
45 | 
46 | 
47 | for player_id, agent in agents.items():
48 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
49 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/two_player/DontSayIt/test.py

- Extension: .py
- Language: python
- Size: 7769 bytes
- Created: 2024-11-14 13:09:16
- Modified: 2024-11-14 13:09:16

### Code

```python
  1 | from textarena.envs.two_player.DontSayIt.env import DontSayItEnv
  2 | 
  3 | import warnings
  4 | import unittest
  5 | from parameterized import parameterized
  6 | 
  7 | 
  8 | warnings.filterwarnings('ignore', category=UserWarning)
  9 | warnings.filterwarnings('ignore', category=FutureWarning)
 10 | 
 11 | 
 12 | 
 13 | def yield_normal_game_sequence(num_turns, secret_word):
 14 |     
 15 |     for _ in range(num_turns):
 16 |         yield " "
 17 | 
 18 | def yield_word_mentioned_sequence(num_turns, secret_word):
 19 |     
 20 |     for i in range(num_turns):
 21 |         if i > num_turns//4:
 22 |             yield f"Omg, I accidentally mentioned: {secret_word}"
 23 |         else:
 24 |             yield " "
 25 | 
 26 | class TestDontSayItEnv(unittest.TestCase):
 27 |     
 28 |     
 29 |     test_cases = {
 30 |         "Normal Game (Draw)": {
 31 |             "env_id": "DontSayIt-v0",
 32 |             "actions": {
 33 |                 0: yield_normal_game_sequence,
 34 |                 1: yield_normal_game_sequence,
 35 |             },
 36 |             "expected_rewards": {0: 0, 1: 0},
 37 |             "expected_truncated": True,
 38 |             "expected_terminated": False,
 39 |             "num_turns": 31
 40 |         },
 41 |         "Player 0 says opponent word": {
 42 |             "env_id": "DontSayIt-v0",
 43 |             "actions": {
 44 |                 0: yield_word_mentioned_sequence,
 45 |                 1: yield_normal_game_sequence,
 46 |             },
 47 |             "expected_rewards": {0: -1, 1: 1},
 48 |             "expected_truncated": False,
 49 |             "expected_terminated": True,
 50 |             "num_turns": 31
 51 |         },
 52 |         "Player 1 says opponent word": {
 53 |             "env_id": "DontSayIt-v0",
 54 |             "actions": {
 55 |                 0: yield_normal_game_sequence,
 56 |                 1: yield_word_mentioned_sequence,
 57 |             },
 58 |             "expected_rewards": {0: 1, 1: -1},
 59 |             "expected_truncated": False,
 60 |             "expected_terminated": True,
 61 |             "num_turns": 31
 62 |         },
 63 | 
 64 |         "Normal Game (Draw) [DontSayIt-v0-hardcore]": {
 65 |             "env_id": "DontSayIt-v0-hardcore",
 66 |             "actions": {
 67 |                 0: yield_normal_game_sequence,
 68 |                 1: yield_normal_game_sequence,
 69 |             },
 70 |             "expected_rewards": {0: 0, 1: 0},
 71 |             "expected_truncated": True,
 72 |             "expected_terminated": False,
 73 |             "num_turns": 31
 74 |         },
 75 |         "Player 0 says opponent word [DontSayIt-v0-hardcore]": {
 76 |             "env_id": "DontSayIt-v0-hardcore",
 77 |             "actions": {
 78 |                 0: yield_word_mentioned_sequence,
 79 |                 1: yield_normal_game_sequence,
 80 |             },
 81 |             "expected_rewards": {0: -1, 1: 1},
 82 |             "expected_truncated": False,
 83 |             "expected_terminated": True,
 84 |             "num_turns": 31
 85 |         },
 86 |         "Player 1 says opponent word [DontSayIt-v0-hardcore]": {
 87 |             "env_id": "DontSayIt-v0-hardcore",
 88 |             "actions": {
 89 |                 0: yield_normal_game_sequence,
 90 |                 1: yield_word_mentioned_sequence,
 91 |             },
 92 |             "expected_rewards": {0: 1, 1: -1},
 93 |             "expected_truncated": False,
 94 |             "expected_terminated": True,
 95 |             "num_turns": 31
 96 |         },
 97 |     }
 98 | 
 99 | 
100 | 
101 |     @parameterized.expand([
102 |         (name, details["env_id"], details["actions"], details["num_turns"], details["expected_rewards"],
103 |          details["expected_truncated"], details["expected_terminated"])
104 |         for name, details in test_cases.items()
105 |     ])
106 |     def test_dont_say_it_outcomes(
107 |         self, 
108 |         name, 
109 |         env_id, 
110 |         action_yield_fns, 
111 |         num_turns,
112 |         expected_rewards,
113 |         expected_truncated,
114 |         expected_terminated
115 |     ):
116 |         
117 |         try:
118 |             
119 |             env = DontSayItEnv(
120 |                 max_turns=30,
121 |                 hardcore=True if "hardcore" in env_id else False
122 |             )
123 |         except Exception as e:
124 |             self.fail(f"Failed to initialize environment '{env_id}': {e}")
125 | 
126 | 
127 |         try:
128 |             
129 |             observations = env.reset(seed=42)
130 |         except Exception as e:
131 |             self.fail(f"Failed to reset the environment {env_id}: {e}")
132 | 
133 | 
134 |         p0_secret = env.state.game_state["target_words"][0]
135 |         p1_secret = env.state.game_state["target_words"][1]
136 |         
137 |         
138 |         p0_yield = action_yield_fns[0](num_turns, p1_secret)
139 |         p1_yield = action_yield_fns[1](num_turns, p0_secret)
140 | 
141 | 
142 |         
143 |         terminated = False 
144 |         truncated = False 
145 | 
146 |         
147 |         while not (terminated or truncated):
148 |             for player_id, yield_fn in enumerate([p0_yield, p1_yield]):
149 |                 action = next(yield_fn)
150 | 
151 |                 
152 |                 try:
153 |                     step_result = env.step(player_id, action)
154 |                     if len(step_result) != 5:
155 |                         self.fail(f"env.step() returned {len(step_result)} elements, expected 5.")
156 |                     observations, rewards, truncated, terminated, info = step_result
157 |                 except Exception as e:
158 |                     self.fail(f"env.step() raised an unexpected exception for player {player_id}: {e}")
159 | 
160 |                 if terminated or truncated:
161 |                     break 
162 | 
163 |         
164 |         self.assertEqual(
165 |             rewards, 
166 |             expected_rewards, 
167 |             f"The rewards did not match. Expected {expected_rewards}; received {rewards}"
168 |         )
169 | 
170 |         self.assertEqual(
171 |             terminated,
172 |             expected_terminated,
173 |             f"Terminated flag mismatch. Expected {expected_terminated}; received {terminated}"
174 |         )
175 | 
176 |         self.assertEqual(
177 |             truncated,
178 |             expected_truncated,
179 |             f"Truncated flag mismatch. Expected {expected_truncated}; received {truncated}"
180 |         )
181 | 
182 | 
183 | if __name__ == '__main__':
184 |     unittest.main()
```

## File: textarena/envs/two_player/DontSayIt/env.py

- Extension: .py
- Language: python
- Size: 5405 bytes
- Created: 2024-11-22 11:38:00
- Modified: 2024-11-22 11:38:00

### Code

```python
  1 | 
  2 | import textarena as ta
  3 | 
  4 | import random
  5 | import nltk
  6 | from nltk import pos_tag
  7 | from nltk.corpus import words
  8 | from typing import Any, Dict, Optional, Tuple, List
  9 | 
 10 | 
 11 | nltk.download("words")
 12 | nltk.download("averaged_perceptron_tagger_eng")
 13 | 
 14 | 
 15 | class DontSayItEnv(ta.Env):
 16 |     
 17 |     def __init__(
 18 |         self,
 19 |         hardcore: Optional[bool] = False,
 20 |         max_turns: Optional[int] = None,
 21 |     ):
 22 |         
 23 |         
 24 |         self._load_word_list(hardcore=hardcore)
 25 | 
 26 |         
 27 |         self.state = ta.State(
 28 |             num_players=2,
 29 |             max_turns=max_turns,
 30 |         )
 31 | 
 32 |     def _load_word_list(self, hardcore: bool = False) -> None:
 33 |         
 34 |         
 35 |         if hardcore:
 36 |             word_list = words.words("en")
 37 |         else:
 38 |             word_list = words.words("en-basic")
 39 | 
 40 |         
 41 |         
 42 |         self.word_list = [
 43 |             word for word in word_list if pos_tag([word])[0][1] in ["NN", "VB", "JJ"]
 44 |         ]
 45 | 
 46 |     def reset(
 47 |         self, seed: Optional[int] = None
 48 |     ) -> Optional[ta.Observations]:
 49 |         
 50 |         if seed is not None:
 51 |             random.seed(seed)
 52 |         else:
 53 |             random.seed()
 54 | 
 55 |         
 56 |         target_words = {
 57 |             0: random.choice(self.word_list),
 58 |             1: random.choice(self.word_list),
 59 |         }
 60 |         while target_words[0] == target_words[1]:
 61 |             target_words[1] = random.choice(self.word_list)
 62 | 
 63 |         return self.state.reset(
 64 |             game_state={"target_words": target_words},
 65 |             player_prompt_function=self._generate_player_prompt
 66 |         )
 67 | 
 68 | 
 69 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[int, Any]) -> str:
 70 |         
 71 |         prompt = (
 72 |             f"You are playing 'Don't Say It'. You are Player {player_id}\n"
 73 |             f"Your secret word is: '{self.state.game_state['target_words'][player_id]}'.\n"
 74 |             "Your goal is to get the other player to say your secret word before you say theirs.\n"
 75 |             "You can converse freely, but try to be subtle to avoid making it obvious.\n"
 76 |             "On your turn, simply type your message.\n"
 77 |         )
 78 |         if self.state.max_turns:
 79 |             prompt += f"The game lasts for {self.state.max_turns} turns in total.\n"
 80 |         return prompt
 81 | 
 82 |     def get_current_player_id(self):
 83 |         return self.state.current_player 
 84 | 
 85 |     def step(
 86 |         self,
 87 |         player_id: int,
 88 |         action: str,
 89 |     ) -> Tuple[
 90 |         Optional[ta.Observations], 
 91 |         Optional[ta.Rewards], 
 92 |         bool, 
 93 |         bool, 
 94 |         ta.Info, 
 95 |     ]:
 96 |         
 97 |         
 98 |         self.state.check_action_format(
 99 |             action=action,
100 |             player_id=player_id
101 |         )
102 | 
103 |         
104 |         self.state.add_observation(
105 |             from_id=player_id,
106 |             to_id=-1, 
107 |             message=action,
108 |             for_logging=True
109 |         )
110 | 
111 |         
112 |         if self.state.game_state["target_words"][1 - player_id].lower() in action.lower():
113 |             self.state.set_winners(
114 |                 player_ids=[1-player_id], 
115 |                 reason=f"Player {player_id} mentioned the opponent's secret word."
116 |             )            
117 | 
118 |         return self.state.step()
119 | 
120 | 
121 |     def render(self):
122 |         
123 |         print(f"Turn: {self.state.turn}")
124 |         print("\nRecent Game Logs:")
125 |         recent_logs = self.state.logs[-5:]  
126 |         for sender_id, log in recent_logs:
127 |             if sender_id == ta.GAME_ID:
128 |                 print(f"[GAME] {log}")
129 |             else:
130 |                 print(f"[Player {sender_id}] {log}")
131 | 
```

## File: textarena/envs/two_player/DontSayIt/README.md

- Extension: .md
- Language: markdown
- Size: 5986 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Don't Say It Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | **Don't Say It** is a two-player conversational game where each player is assigned a secret word. The objective is to subtly guide the conversation to make the other player say your secret word while avoiding mentioning theirs. The game encourages strategic communication and subtlety, making it both challenging and entertaining.
  6 | 
  7 | ## Action Space
  8 | 
  9 | - **Format:** Actions are strings representing the player's messages.
 10 | - **Example:** `"Let's talk about something interesting."`, `"Do you enjoy traveling?"`
 11 | - **Notes:** Players can converse freely, but mentioning the opponent's secret word results in a loss.
 12 | 
 13 | ## Observation Space
 14 | 
 15 | ### Observations
 16 | 
 17 | Players receive messages in the form of a conversation history, including their own secret word in the initial prompt.
 18 | 
 19 | **Reset Observation:**
 20 | 
 21 | On reset, each player receives a prompt containing their secret word and game instructions. For example:
 22 | ```plaintext
 23 | [GAME]: You are Player {player_id} in 'Don't Say It'.
 24 | Your secret word is: '{secret_word}'.
 25 | Your goal is to get the other player to say your secret word before you say theirs.
 26 | You can converse freely, but try to be subtle to avoid mentioning your own secret word.
 27 | On your turn, simply type your message.
 28 | The game lasts for {max_turns} turns in total.
 29 | ```
 30 | 
 31 | **Step Observation:**
 32 | After each step, the players receive the latest message from the other player. For example:
 33 | ```plaintext
 34 | [Player 0]: How was your weekend?
 35 | [Player 1]: It was great! I went hiking in the mountains.
 36 | ```
 37 | 
 38 | ## Gameplay
 39 | - **Players**: 2
 40 | - **Turns**: Players alternate sending messages to each other.
 41 | - **Secret Words**: Each player has a unique secret word assigned at the start of the game.
 42 | - **Objective**: Make the opponent say your secret word while avoiding saying theirs.
 43 | - **Turn Limit**: The game can be configured with a maximum number of turns, after which it ends in a draw if no secret words are mentioned.
 44 | 
 45 | ## Key Rules
 46 | 1. Secret Words:
 47 |     - Each player is assigned a secret word at the start.
 48 |     - Players must avoid saying the opponent's secret word, while trying to make them say theirs.
 49 | 
 50 | 2. Valid Moves:
 51 |     - Players send messages as strings.
 52 |     - Messages can contain any text but should aim to indirectly lead the opponent to say the secret word.
 53 | 
 54 | 3. Winning Conditions:
 55 |     - **Win**: If a player successfully makes the opponent say their secret word.
 56 |     - **Loss**: If a player accidentally says the opponents secret word.
 57 |     - **Draw**: If the maximum number of turns is reached without any secret word being mentioned.
 58 | 
 59 | 4. Game Termination:
 60 |     - The game ends immediately upon a win or loss.
 61 |     - If the turn limit is reached, the game ends in a draw.
 62 | 
 63 | ## Rewards
 64 | 
 65 | | Outcome          | Reward for Player | Reward for Opponent |
 66 | |------------------|:-----------------:|:-------------------:|
 67 | | **Win**          | `+1`              | `-1`               |
 68 | | **Lose**         | `-1`              | `+1`               |
 69 | | **Draw**         | `0`               | `0`                |
 70 | 
 71 | 
 72 | ## Parameters
 73 | 
 74 | - `hardcore` (`bool`):
 75 |     - **Description**: Determines the complexity of the secret words.
 76 |     - **Impact**:
 77 |         - `True`: Uses a full English word set, including complex words.
 78 |         - `False`: Uses a simplified English word set for easier gameplay.
 79 | 
 80 | - `max_turns` (`int`):
 81 |     - **Description**: Specifies the maximum number of turns allowed before the game ends in a draw.
 82 |     - **Impact**: Limits the duration of the game, promoting quicker resolutions.
 83 | 
 84 | 
 85 | 
 86 | ## Variants
 87 | 
 88 | | Env-id                   | hardcore | max_turns |
 89 | |--------------------------|:--------:|:---------:|
 90 | | `DontSayIt-v0`           | `False`  |    `30`   |
 91 | | `DontSayIt-v0-hardcore`  | `True`   |    `30`   |
 92 | | `DontSayIt-v0-unlimited` | `False`  |   `None`  |
 93 | 
 94 | ## Example Usage
 95 | 
 96 | ```python
 97 | import textarena as ta
 98 | 
 99 | # Initialize the environment
100 | env = ta.make(env_id="DontSayIt-v0")
101 | 
102 | # Wrap the environment for easier observation handling
103 | env = ta.wrappers.LLMObservationWrapper(env=env)
104 | 
105 | # initalize agents
106 | agents = {
107 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
108 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
109 |     }
110 | 
111 | # reset the environment to start a new game
112 | observations = env.reset(seed=490)
113 | 
114 | # Game loop
115 | done = False
116 | while not done:
117 | 
118 |     # Get the current player
119 |     current_player_id = env.state.get("current_player")
120 | 
121 |     # Get the current observation for the player
122 |     obs = observations[current_player_id]
123 | 
124 |     # Agent decides on an action based on the observation
125 |     action = agents[current_player_id](obs)
126 | 
127 |     # Execute the action in the environment
128 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
129 | 
130 |     # Check if the game has ended
131 |     done = terminated or truncated
132 | 
133 |     # Optionally render the environment to see the current state
134 |     env.render()
135 | 
136 |     if done:
137 |         break
138 | 
139 | # Finally, print the game results
140 | for player_id, agent in agents.items():
141 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
142 | print(f"Reason: {info['reason']}")
143 | ```
144 | 
145 | ## Troubleshooting
146 | 
147 | - **Opponent's Word Not Being Mentioned:**
148 |     - **Issue:** Players are unable to guide the conversation towards the opponent's secret word.
149 |     - **Solution:** Encourage creative and subtle conversational strategies to indirectly reference the opponent's word.
150 | 
151 | - **Invalid Messages:**
152 |     - **Issue:** Players send non-string actions or invalid message formats.
153 |     - **Solution:** Ensure that all actions are valid strings representing meaningful messages.
154 | 
155 | - **Turn Limit Reached Without Outcome:**
156 |     - **Issue:** The game ends in a draw after reaching the maximum number of turns.
157 |     - **Solution:** Increase the max_turns parameter to allow more conversational exchanges if desired.
158 | 
159 | ## Version History
160 | - **v0**
161 |   - Initial release 
162 | 
163 | 
164 | 
165 | ### Contact
166 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/DontSayIt/__init__.py

- Extension: .py
- Language: python
- Size: 64 bytes
- Created: 2024-11-11 15:47:51
- Modified: 2024-11-11 15:47:51

### Code

```python
1 | from textarena.envs.two_player.DontSayIt.env import DontSayItEnv
```

## File: textarena/envs/two_player/SpiteAndMalice/test.py

- Extension: .py
- Language: python
- Size: 3299 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.two_player.SpiteAndMalice.env import SpiteAndMaliceEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["I play the card: [play K♠ 0]", "I discard the card: [discard J♣ 2]", "I will draw cards. [draw]"]
 9 | 
10 | def generate_invalid_move_sequence():
11 |     
12 |     return ["I play the card: play K♠ 0", "I discard the card: discard Q♣ 2", "I will draw cards. draw"]
13 | 
14 | def generate_out_of_bounds_sequence():
15 |     
16 |     return ["I play the card: [play Q♣ 2]", "I play the card: [play K♠ 4]", "I discard the card: [discard Q♣ 20]"]
17 | 
18 | class TestSpiteAndMaliceEnv(unittest.TestCase):
19 |     
20 | 
21 |     
22 |     test_cases = {
23 |         "correct_move_easy": {
24 |             "actions": generate_correct_move_sequence()
25 |         },
26 |         "invalid_move_easy": {
27 |             "actions": generate_invalid_move_sequence()
28 |         },
29 |         "out_of_bounds_easy": {
30 |             "actions": generate_out_of_bounds_sequence()
31 |         }
32 |     }
33 | 
34 |     @parameterized.expand([
35 |         (name, details["actions"])
36 |         for name, details in test_cases.items()
37 |     ])
38 |     def test_spiteandmalice_outcomes(self, name, actions):
39 |         
40 |         
41 |         env = SpiteAndMaliceEnv()
42 | 
43 |         
44 |         observations = env.reset(seed=490)
45 | 
46 |         terminated = False
47 |         truncated = False
48 |         rewards = {0: 0, 1: 0}
49 | 
50 |         for i, action in enumerate(actions):
51 |             if terminated or truncated:
52 |                 break
53 | 
54 |             player_id = i % 2
55 |             
56 |             env_action = action
57 | 
58 |             
59 |             observations, reward, truncated, terminated, info = env.step(player_id, env_action)
60 | 
61 |             
62 |             if reward:
63 |                 rewards.update(reward)
64 | 
65 |         if "correct_move" in name:
66 |             self.assertFalse(truncated, "Game should not truncate for correct moves.")
67 |             self.assertFalse(terminated, "Game should not terminate until the game is complete.")
68 |         elif "invalid_move" in name:
69 |             self.assertTrue(truncated or terminated, "Game should truncate for invalid moves.")
70 |             self.assertEqual(rewards[player_id], -1, "Player should receive -1 reward for an invalid move.")
71 |         elif "out_of_bounds" in name:
72 |             self.assertTrue(truncated or terminated, "Game should truncate for out-of-bounds moves.")
73 |             self.assertEqual(rewards[player_id], -1, "Player should receive -1 reward for an out-of-bounds move.")
74 |         else:
75 |             raise ValueError("Invalid test case name.")
76 |     
77 |     def run_unit_test():
78 |         print("Running SpiteAndMalice tests...")
79 |         unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/two_player/SpiteAndMalice/env.py

- Extension: .py
- Language: python
- Size: 16204 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from typing import Dict, Optional, List, Tuple
  2 | import random
  3 | import textarena as ta
  4 | import re
  5 | 
  6 | class SpiteAndMaliceEnv(ta.Env):
  7 |     
  8 |     def __init__(
  9 |         self,
 10 |     ):
 11 |         
 12 |         self.environment_name = "SpiteAndMalice"
 13 | 
 14 |         
 15 |         self.deck = [f"{rank}{suit}" for rank in "A23456789JQK" for suit in "♠♥♦♣"] * 2
 16 |         
 17 |         
 18 |         self.state = ta.State(
 19 |             num_players=2,
 20 |             max_turns=None,
 21 |             render_keys=["rendered_board","player_turn"],
 22 |         )
 23 | 
 24 |     def reset(
 25 |         self,
 26 |         seed: Optional[int] = None
 27 |     ) -> Optional[ta.Observations]:
 28 |         
 29 |         
 30 |         if seed is not None:
 31 |             random.seed(seed)
 32 |         else:
 33 |             random.seed()
 34 | 
 35 |         
 36 |         random.shuffle(self.deck)
 37 |         self.players = self._initialize_players()
 38 |         self.center_piles = [[] for _ in range(4)]
 39 |         
 40 |         
 41 |         self._draw_cards(0)
 42 |         self._draw_cards(1)
 43 | 
 44 |         
 45 |         return self.state.reset(
 46 |             game_state={
 47 |                 "players": self.players,
 48 |                 "center_piles": self.center_piles,
 49 |                 "player_turn": self.state.current_player,
 50 |                 "rendered_board": self._render_board()
 51 |             },
 52 |             player_prompt_function=self._generate_player_prompt
 53 |         )
 54 |     
 55 |     def _initialize_players(
 56 |         self
 57 |     ):
 58 |         
 59 |         players = {0: {"payoff": [], "hand": [], "discard": [[] for _ in range(4)]},
 60 |                    1: {"payoff": [], "hand": [], "discard": [[] for _ in range(4)]}}
 61 |         
 62 |         
 63 |         for player in players:
 64 |             players[player]["payoff"] = [self.deck.pop() for _ in range(20)]
 65 |         
 66 |         return players
 67 |     
 68 |     def _draw_cards(
 69 |         self,
 70 |         player_id: int
 71 |     ):
 72 |         
 73 |         while len(self.players[player_id]["hand"]) < 5 and self.deck:
 74 |             self.players[player_id]["hand"].append(self.deck.pop())
 75 | 
 76 |     def _generate_player_prompt(
 77 |         self,
 78 |         player_id: int
 79 |     ) -> str:
 80 |         
 81 |         prompt = (
 82 |             f"You are Player {player_id} in a two-player game of Spite and Malice. Your goal is to be the first to empty your payoff pile.\n\n"
 83 |             
 84 |             "### Game Overview:\n"
 85 |             "- The objective is to clear your payoff pile by playing cards to the center piles.\n"
 86 |             "- You can play cards from three sources:\n"
 87 |             "  1. Your **hand** (you start each turn with up to 5 cards in hand).\n"
 88 |             "  2. The **top card of your payoff pile**.\n"
 89 |             "  3. The **top card of any of your discard piles**.\n\n"
 90 |             
 91 |             "### Playing Rules:\n"
 92 |             "- You may play a card to a center pile if it is **one rank higher** than the top card on that pile (center piles start with Ace and go up to Queen; Kings are wild - they can be played on any card but do not change the rank sequence. This means if a King is used after 4, then that King is ranked 5 and the next card must be a 6).\n"
 93 |             "- If you can't play any more cards, you must **discard a card** to one of your discard piles to end your turn.\n"
 94 |             "- If a center pile reaches Queen, it will be cleared automatically.\n"
 95 |             "- The rank order is: A=1, 2=2, ..., 9=9, J=10, Q=11, K as wild.\n\n"
 96 |             
 97 |             "### Actions:\n"
 98 |             "1. **Draw**: At the start of your turn, draw cards to fill your hand up to 5 cards. Enter **[draw]** to begin.\n"
 99 |             "2. **Play a Card**: To play a card, specify the card and the center pile like this: **[play A♠ 0]** (where 'A♠' is the card and '0' is the center pile index).\n"
100 |             "3. **Discard**: If you can’t play any more cards, discard a card from your hand to a discard pile to end your turn. Enter **[discard A♠ 1]** (where 'A♠' is the card and '1' is the discard pile index).\n\n"
101 |             
102 |             "Here is the current game state:\n"
103 |         )
104 | 
105 | 
106 |         prompt += self._render_board(player_id=player_id)
107 | 
108 |         prompt += "\n\nPlayer 0, you will start first. Please enter your action in the format [action card center_index]."
109 | 
110 |         return prompt
111 |     
112 |     def _play_card(
113 |             self,
114 |             player_id: int,
115 |             card: str,
116 |             center_index: int
117 |         ):
118 |         
119 |         
120 |         if self._can_play_on_center(card, self.center_piles[center_index]):
121 |             
122 |             if self.players[player_id]["payoff"] and card == self.players[player_id]["payoff"][-1]:
123 |                 self.players[player_id]["payoff"].pop()
124 |             
125 |             elif card in self.players[player_id]["hand"]:
126 |                 self.players[player_id]["hand"].remove(card)
127 |             
128 |             else:
129 |                 found_in_discard = False
130 |                 for discard_pile in self.players[player_id]["discard"]:
131 |                     if discard_pile and discard_pile[-1] == card:
132 |                         discard_pile.pop()
133 |                         found_in_discard = True
134 |                         break
135 |                 if not found_in_discard:
136 |                     return False  
137 | 
138 |             
139 |             self.center_piles[center_index].append(card)
140 | 
141 |             
142 |             if len(self.center_piles[center_index]) == 12 and self.center_piles[center_index][-1][0] == "Q":
143 |                 print(f"Center pile {center_index} is complete and will be cleared.")
144 |                 self.center_piles[center_index] = []
145 |             
146 |             return True
147 |         
148 |         
149 |         return False
150 | 
151 |     def _can_play_on_center(
152 |         self,
153 |         card: str,
154 |         pile: List[str]
155 |     ):
156 |         
157 |         
158 |         if card[0] == "K":
159 |             return True
160 |         
161 |         if not pile:
162 |             return card[0] == "A" or card[0] == "K"
163 |         
164 |         if pile[-1][0] == "K":
165 |             
166 |             top_card_rank = self._card_rank(pile[-2][0]) if len(pile) > 1 else 0  
167 |         else:
168 |             
169 |             top_card_rank = self._card_rank(pile[-1][0])
170 |         
171 |         return self._card_rank(card[0]) == top_card_rank + 1
172 |     
173 |     def _card_rank(
174 |         self,
175 |         card: str
176 |     ):
177 |         
178 |         ranks = "A23456789JQK"
179 |         return ranks.index(card[0])
180 |     
181 |     def _discard_card(
182 |         self,
183 |         player_id: int,
184 |         card: str,
185 |         discard_index: int
186 |     ):
187 |         
188 |         self.players[player_id]["hand"].remove(card)
189 |         self.players[player_id]["discard"][discard_index].append(card)
190 | 
191 |     def _check_win(
192 |         self,
193 |         player_id: int
194 |     ):
195 |         
196 |         return len(self.players[player_id]["payoff"]) == 0
197 |         
198 |     def step(
199 |         self,
200 |         player_id: int,
201 |         action: str
202 |     ) -> Tuple[
203 |         Optional[ta.Observations],
204 |         Optional[ta.Rewards],
205 |         bool,
206 |         bool,
207 |         ta.Info
208 |     ]:
209 |         
210 |         
211 |         
212 | 
213 |         
214 |         self.state.add_observation(
215 |             from_id=player_id,
216 |             to_id=player_id, 
217 |             message=action,
218 |             for_logging=True
219 |         )
220 | 
221 |         
222 |         action_search_pattern = re.compile(r"\[(play|discard|draw)(?: ([A23456789JQK][♠♥♦♣]) ([0-3]))?\]") 
223 |         matches = action_search_pattern.findall(action)
224 |         
225 | 
226 |         rotate_player  = False
227 | 
228 |         if not matches:
229 |             self.state.set_invalid_move(
230 |                 player_ids=[player_id],
231 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with a valid move in square brackets."]
232 |             )
233 |             rotate_player  = True
234 |         else:
235 |             
236 |             for match in matches:
237 |                 action_type, card, index = match
238 |                 if action_type == "draw":
239 |                     self._draw_cards(player_id)
240 |                     self.state.add_observation(
241 |                         from_id=ta.GAME_ID,
242 |                         to_id=player_id,
243 |                         message=f"You drew cards. Your updated view:\n{self._render_board(player_id=player_id)}",
244 |                         for_logging=False
245 |                     )
246 |                     self.state.add_observation(
247 |                         from_id=ta.GAME_ID,
248 |                         to_id=1-player_id,
249 |                         message=f"Player {player_id} drew cards.",
250 |                         for_logging=True
251 |                     )
252 |                 elif action_type == "play":
253 |                     
254 |                     if self._play_card(player_id, card, int(index)):
255 |                         self.state.add_observation(
256 |                             from_id=ta.GAME_ID,
257 |                             to_id=player_id,
258 |                             message=f"You played {card} on center pile {index}. Your updated view:\n{self._render_board(player_id=player_id)}",
259 |                             for_logging=False
260 |                         )
261 |                         self.state.add_observation(
262 |                             from_id=ta.GAME_ID,
263 |                             to_id=1-player_id,
264 |                             message=f"Player {player_id} played {card} on center pile {index}.",
265 |                             for_logging=True
266 |                         )
267 |                     else:
268 |                         self.state.set_invalid_move(
269 |                             player_ids=[player_id],
270 |                             reasons=[f"Invalid play. Player {player_id} tried to play {card} on center pile {index}."]
271 |                         )
272 |                         break
273 |                 elif action_type == "discard":
274 |                     
275 |                     self._discard_card(player_id, card, int(index))
276 |                     self.state.add_observation(
277 |                         from_id=ta.GAME_ID,
278 |                         to_id=player_id,
279 |                         message=f"You have discarded {card} to discard pile {index}, which also means you have finished their turn. Your updated view:\n{self._render_board(player_id=player_id)}\n\nNo further actions of yours is considered for this turn. Player {1 - player_id} will go next.", 
280 |                         for_logging=False
281 |                     )
282 |                     self.state.add_observation(
283 |                         from_id=ta.GAME_ID,
284 |                         to_id=-1,
285 |                         message=f"Player {player_id} discarded {card} to discard pile {index}, which also means they finished their turn. No further actions of Player {player_id} is considered for this turn. Player {1 - player_id}, you will go next. Please enter your action in the format [action card center_index].", 
286 |                         for_logging=True
287 |                     )
288 |                     rotate_player  = True
289 |                     self.state.game_state["player_turn"] = 1 - player_id
290 |                     break
291 |                 else:
292 |                     self.state.set_invalid_move(
293 |                         player_ids=[player_id],
294 |                         reasons=[f"Invalid move type. Player {player_id} did not respond with a valid move type."]
295 |                     )
296 |                     break
297 |         
298 |         
299 |         self.state.game_state["rendered_board"] = self._render_board()
300 | 
301 |         
302 |         if self._check_win(player_id):
303 |             self.state.set_winners(
304 |                 player_ids=[player_id],
305 |                 reason=f"Player {player_id} has finished its payoff pile! Player {player_id} wins!"
306 |             )  
307 | 
308 |         return self.state.step(rotate_player )        
309 |     
310 |     def _render_board(
311 |         self,
312 |         player_id: Optional[int] = None
313 |     ) -> str:
314 |         
315 |         board = "--- Center Piles ---\n"
316 |         for i, pile in enumerate(self.center_piles):
317 |             board += f"Pile {i}: {pile}\n"
318 |         
319 |         if player_id is not None:
320 |             board += f"\n--- Player {player_id}'s View ---\n"
321 |             board += f"Payoff Pile (Top Card): {self.players[player_id]['payoff'][-1] if self.players[player_id]['payoff'] else 'Empty'}, Payoff Pile Length: {len(self.players[player_id]['payoff'])}\n"
322 |             board += f"Hand: {self.players[player_id]['hand']}\n"
323 |             board += f"Discard Piles: {self.players[player_id]['discard']}\n"
324 | 
325 |         else: 
326 |             for player in self.players:
327 |                 board += f"\n--- Player {player}'s View ---\n"
328 |                 board += f"Payoff Pile (Top Card): {self.players[player]['payoff'][-1] if self.players[player]['payoff'] else 'Empty'}, Payoff Pile Length: {len(self.players[player]['payoff'])}\n"
329 |                 board += f"Hand: {self.players[player]['hand']}\n"
330 |                 board += f"Discard Piles: {self.players[player]['discard']}\n"
331 |         
332 |         return board
333 |     
334 |     def render(
335 |         self
336 |     ):
337 |         
338 |         print(self._render_board())
```

## File: textarena/envs/two_player/SpiteAndMalice/README.md

- Extension: .md
- Language: markdown
- Size: 10782 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Spite and Malice Environment Documentation
  2 | 
  3 | ## Overview
  4 | **Spite and Malice** is a two-player competitive card game where players race to be the first to empty their “payoff” pile by playing cards onto shared center piles in sequential order. Each player has a hand, a payoff pile, and four personal discard piles, allowing for strategic play. Kings act as wild cards and can substitute any rank in the sequence. Players take turns drawing, playing, or discarding cards until one player wins by emptying their payoff pile. This environment includes clear rules for sequential play on center piles, support for using Kings as wild cards, and tracking of cards across hand, payoff, and discard piles, providing a robust environment for agent-based gameplay.
  5 | 
  6 | ## Action Space
  7 | - **Format:** Actions are strings representing the player's choice. For example:
  8 | - **Example:**
  9 |     - Draw cards from the replenishment pile: [draw]
 10 |     - Move "A♦" to the first pile of the Center Piles: [play A♦ 0]
 11 |     - Discard "Q♣" to the third pile of the Discard Piles: [discard Q♣ 2]
 12 | - **Notes:** The players are free to have additional texts and multiple moves in their replies, so long they provide their actions in the correct format of [action card index]. For draw, the positions `card` and `index` are ignored.
 13 | 
 14 | ## Observation Space
 15 | **Reset Obsevations**
 16 | On reset, each player receives a prompt containing their beginning game instructions. For example:
 17 | ```plaintext
 18 | [GAME] You are Player 0 in a two-player game of Spite and Malice. Your goal is to be the first to empty your payoff pile.
 19 | 
 20 | ### Game Overview:
 21 | - The objective is to clear your payoff pile by playing cards to the center piles.
 22 | - You can play cards from three sources:
 23 |   1. Your **hand** (you start each turn with up to 5 cards in hand).
 24 |   2. The **top card of your payoff pile**.
 25 |   3. The **top card of any of your discard piles**.
 26 | 
 27 | ### Playing Rules:
 28 | - You may play a card to a center pile if it is **one rank higher** than the top card on that pile (center piles start with Ace and go up to Queen; Kings are wild - they can be played on any card but do not change the rank sequence. This means if a King is used after 4, then that King is ranked 5 and the next card must be a 6).
 29 | - If you can't play any more cards, you must **discard a card** to one of your discard piles to end your turn.
 30 | - If a center pile reaches Queen, it will be cleared automatically.
 31 | - The rank order is: A=1, 2=2, ..., 9=9, J=10, Q=11, K as wild.
 32 | 
 33 | ### Actions:
 34 | 1. **Draw**: At the start of your turn, draw cards to fill your hand up to 5 cards. Enter **[draw]** to begin.
 35 | 2. **Play a Card**: To play a card, specify the card and the center pile like this: **[play A♠ 0]** (where 'A♠' is the card and '0' is the center pile index).
 36 | 3. **Discard**: If you can’t play any more cards, discard a card from your hand to a discard pile to end your turn. Enter **[discard A♠ 1]** (where 'A♠' is the card and '1' is the discard pile index).
 37 | 
 38 | Here is the current game state:
 39 | --- Center Piles ---
 40 | Pile 0: []
 41 | Pile 1: []
 42 | Pile 2: []
 43 | Pile 3: []
 44 | 
 45 | --- Player 0's View ---
 46 | Payoff Pile (Top Card): K♠, Payoff Pile Length: 20
 47 | Hand: ['Q♣', '9♦', '7♣', '8♠', 'K♠']
 48 | Discard Piles: [[], [], [], []]
 49 | 
 50 | 
 51 | Player 0, you will start first. Please enter your action in the format [action card center_index].
 52 | ```
 53 | 
 54 | **Step Observation:**
 55 | After each step, the players receive the latest message from the game environment. For example, here's player 0 making its first move and the environment responds back:
 56 | ```plaintext
 57 | [Player 0] Since all center piles are empty, you can start by playing an Ace to any of them. However, you don't currently have an Ace in your hand or on top of your payoff pile. Fortunately, Kings are wild and can be played as any card. Let's use the King from your hand to start a pile.
 58 | 
 59 | Let's play the King from your hand to center pile 0 to set up for further plays:
 60 | 
 61 | \```
 62 | [play K♠ 0]
 63 | \```
 64 | 
 65 | After this, you can continue playing cards. Let me know if you want to make another move or if you need further assistance!
 66 | [GAME] You played K♠ on center pile 0. Your updated view:
 67 | --- Center Piles ---
 68 | Pile 0: ['K♠']
 69 | Pile 1: []
 70 | Pile 2: []
 71 | Pile 3: []
 72 | 
 73 | --- Player 0's View ---
 74 | Payoff Pile (Top Card): 6♠, Payoff Pile Length: 19
 75 | Hand: ['Q♣', '9♦', '7♣', '8♠', 'K♠']
 76 | Discard Piles: [[], [], [], []]
 77 | ```
 78 | 
 79 | ## Gameplay
 80 | 
 81 | - **Players**: 2
 82 | - **Turns**: Players take turns attempting to play cards onto the center piles from one of three sources: their hand, the top card of their payoff pile, or the top card of any of their four personal discard piles. Unlike other turn-based games, this game only switches turns when the player has made the action of "discarding" a card. As such, readers will notice a slight difference in the example usage as compared to other games examples.
 83 | - **Draw Phase**: At the beginning of each turn, a player draws enough cards to restore their hand to 5 cards, provided there are cards left in the deck.
 84 | - **Playing Cards**: Players can play cards in sequential order onto one of the shared center piles, starting each sequence with an Ace and progressing up to Queen. Kings act as wild cards and can substitute for any rank within a sequence.
 85 |   - **Center Piles**: Up to four center piles are available for play. Once a pile reaches Queen, it is cleared, allowing for a new sequence to begin.
 86 |   - **Source of Cards**:
 87 |     - **Hand**: A player may play any card from their hand.
 88 |     - **Payoff Pile**: The top card of the payoff pile can be played if it fits the center pile sequence.
 89 |     - **Discard Piles**: The top card of any discard pile can also be played if it is sequentially valid.
 90 | - **Discarding**: If a player has no playable cards, they must discard one card from their hand to one of their four discard piles, which ends their turn.
 91 | - **Objective**: The goal of the game is to be the first player to completely empty their payoff pile by legally playing cards onto the center piles.
 92 | - **Wild Card (King) Usage**: Kings can be played as wild cards to represent any needed rank. When a King is played, it assumes the rank required for the sequence at that point. For example, if a pile shows `1 2 3 K`, the King represents `4`, meaning the next playable card on that pile would need to be a `5` (or another King acting as `5`).
 93 | - **Winning Condition**: The game is won by the first player to successfully play all the cards from their payoff pile.
 94 | 
 95 | 
 96 | ## Key Rules
 97 | 
 98 | 1. **Playing Cards**:
 99 |    - On their turn, players attempt to play cards onto the center piles from one of three sources: 
100 |      - **Hand**: Players can play any card from their hand.
101 |      - **Payoff Pile**: The top card of the payoff pile, which is the primary goal to clear.
102 |      - **Discard Piles**: The top card of any of the four personal discard piles.
103 |    - Cards must be played in ascending order on the center piles, starting with Ace and continuing up to Queen.
104 |    - **Kings** are wild cards and can be used to represent any rank in the sequence. When a King is played, it takes on the next required rank in the sequence. For example, if a pile shows `1 2 3 K`, the King represents `4`, meaning the next card played on that pile should be a `5` (or another King acting as `5`).
105 | 
106 | 2. **Draw Phase**:
107 |    - At the beginning of each turn, the player draws cards to restore their hand to 5 cards, provided there are cards left in the deck.
108 |    - Players cannot draw additional cards during their turn; drawing occurs only at the start of each turn.
109 | 
110 | 3. **Discarding**:
111 |    - If a player cannot play any more cards, they must discard one card from their hand to one of their four discard piles, ending their turn.
112 |    - Players may choose which discard pile to place the card in, allowing for strategic setup of future turns.
113 | 
114 | 4. **Center Pile Clearing**:
115 |    - There are up to four center piles in play. Once a center pile reaches a Queen, it is cleared from the board, making room for a new sequence to begin with an Ace (or a King acting as an Ace).
116 | 
117 | 5. **Winning Condition**:
118 |    - **Win**: The game is won by the first player to empty their payoff pile by legally playing all of its cards onto the center piles.
119 |    - **Loss**: The other player loses when their opponent successfully clears their payoff pile first.
120 | 
121 |    **Note:** In Spite and Malice, there are no draws. The game always continues until one player completes their payoff pile and wins.
122 | 
123 | 
124 | ## Rewards
125 | 
126 | | Outcome          | Reward for Player | Reward for Opponent |
127 | |------------------|:-----------------:|:-------------------:|
128 | | **Win**          | `+1`              | `-1`                |
129 | | **Lose**         | `-1`              | `+1`                |
130 | | **Invalid**      | `-1`              | `0`                 |
131 | 
132 | 
133 | ## Variants
134 | 
135 | | Env-id                  |
136 | |-------------------------|
137 | | `SpiteAndMalice-v0`     |
138 | 
139 | 
140 | ## Example Usage
141 | ```python
142 | import textarena as ta
143 | 
144 | # Initialize the environment
145 | env = ta.make(env_id="SpiteAndMalice-v0")
146 | 
147 | # Wrap the environment for easier observation handling
148 | env = ta.wrappers.LLMObservationWrapper(env=env)
149 | 
150 | # Wrap the environment for pretty rendering
151 | env = ta.wrappers.PrettyRenderWrapper(env=env)
152 | 
153 | # initalize agents
154 | agents = {
155 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
156 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o")
157 |     }
158 | 
159 | # reset the environment to start a new game
160 | observations = env.reset(seed=490)
161 | 
162 | # Game loop
163 | done = False
164 | while not done:
165 | 
166 |     # Get the current player
167 |     current_player_id = env.state.get("current_player")
168 | 
169 |     # Get the current observation for the player
170 |     obs = observations[current_player_id]
171 | 
172 |     # Agent decides on an action based on the observation
173 |     action = agents[current_player_id](obs)
174 | 
175 |     # Execute the action in the environment
176 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
177 | 
178 |     # Check if the game has ended
179 |     done = terminated or truncated
180 | 
181 |     # Optionally render the environment to see the current state
182 |     env.render()
183 | 
184 |     if done:
185 |         break
186 | 
187 | # Finally, print the game results
188 | for player_id, agent in agents.items():
189 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
190 | print(f"Reason: {info['reason']}")
191 | ```
192 | 
193 | ## Troubleshooting
194 | 
195 | - **Repeatedly making moves that defy the sequence order of the center piles**:
196 |     - **Issue**: The player repeats the mistake of adding cards to a new or existing center pile that are not incremental ranks above the top card of the selected pile, or begin as Aces.
197 |     - **Solution**: Refine the prompt to explicitly show how the incremental ranks should be like.
198 | 
199 | 
200 | ## Version History
201 | - **v0**
202 |   - Initial release 
203 | 
204 | 
205 | ### Contact
206 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/two_player/SpiteAndMalice/example.py

- Extension: .py
- Language: python
- Size: 1332 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make(env_id="SpiteAndMalice-v0")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
15 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o")
16 |     }
17 | 
18 | 
19 | observations = env.reset(seed=490)
20 | 
21 | 
22 | done = False
23 | while not done:
24 | 
25 |     
26 |     current_player_id = env.state.get("current_player")
27 | 
28 |     
29 |     obs = observations[current_player_id]
30 | 
31 |     
32 |     action = agents[current_player_id](obs)
33 | 
34 |     
35 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
36 | 
37 |     
38 |     done = terminated or truncated
39 | 
40 |     
41 |     env.render()
42 | 
43 |     if done:
44 |         break
45 | 
46 | 
47 | for player_id, agent in agents.items():
48 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
49 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/two_player/Negotiation/test.py

- Extension: .py
- Language: python
- Size: 8929 bytes
- Created: 2024-11-14 13:04:14
- Modified: 2024-11-14 13:04:14

### Code

```python
  1 | from textarena.envs.two_player.Negotiation.env import NegotiationEnv
  2 | 
  3 | import warnings
  4 | import unittest
  5 | from parameterized import parameterized
  6 | from typing import Dict, List, Optional
  7 | 
  8 | 
  9 | 
 10 | warnings.filterwarnings('ignore', category=UserWarning)
 11 | warnings.filterwarnings('ignore', category=FutureWarning)
 12 | 
 13 | 
 14 | class TestNegotiationEnv(unittest.TestCase):
 15 |     
 16 | 
 17 |     
 18 |     env_variants = [
 19 |         "Negotiation-v0",
 20 |         "Negotiation-v0-hardcore",
 21 |         "Negotiation-v0-unlimited"
 22 |     ]
 23 | 
 24 |     
 25 |     test_cases = {
 26 |         "No Trades": {
 27 |             "env_id": "Negotiation-v0",
 28 |             "actions": [" "]*19,
 29 |             "expected_rewards": None,
 30 |             "expected_truncated": False,
 31 |             "expected_terminated": False,
 32 |         },
 33 |         "No Trades, Turn-Limit": {
 34 |             "env_id": "Negotiation-v0",
 35 |             "actions": [" "] * 20,
 36 |             "expected_rewards": {0: 0, 1: 0},  
 37 |             "expected_truncated": False,
 38 |             "expected_terminated": True,  
 39 |         },
 40 |         "Single Trade Offer Accepted with Valid Resources": {
 41 |             "env_id": "Negotiation-v0",
 42 |             "actions": [
 43 |                 "[Offer: 1 Wheat -> 3 Wheat]", "[Accept]",
 44 |             ] + [" "]*18,
 45 |             "expected_rewards": {0: 1, 1: -1},  
 46 |             "expected_truncated": False, 
 47 |             "expected_terminated": True,
 48 |         },
 49 |         "Multiple Trade Offers Accepted": {
 50 |             "env_id": "Negotiation-v0",
 51 |             "actions": [" "] * 2 + [
 52 |                 "[Offer: 1 Wheat -> 5 Wood]", "[Accept]",
 53 |             ] + [" "] * 2 + [
 54 |                 "[Offer: 2 Sheep -> 3 Ore]", "[Accept]",
 55 |             ] + [" "]* 12,
 56 |             "expected_rewards": {0: 1, 1: -1},  
 57 |             "expected_truncated": False,
 58 |             "expected_terminated": True,
 59 |         },
 60 |         "Trade Offer with Insufficient Proposer Resources": {
 61 |             "env_id": "Negotiation-v0",
 62 |             "actions": [
 63 |                 "[Offer: 999 Wheat -> 1 Wood]", "[Accept]",
 64 |             ],
 65 |             "expected_rewards": {0: -1, 1: 0},  
 66 |             "expected_truncated": False,
 67 |             "expected_terminated": True,  
 68 |         },
 69 |         "Trade Offer with Insufficient Acceptor Resources": {
 70 |             "env_id": "Negotiation-v0",
 71 |             "actions": [
 72 |                 "[Offer: 1 Wheat -> 999 Wood]", "[Accept]",
 73 |             ],  
 74 |             "expected_rewards": {0: 0, 1: -1},  
 75 |             "expected_truncated": False,
 76 |             "expected_terminated": True,  
 77 |         },
 78 |         "Trade Offer Denied by Acceptor": {
 79 |             "env_id": "Negotiation-v0",
 80 |             "actions": [
 81 |                 "[Offer: 1 Wheat -> 2 Wheat]", "[Deny]",
 82 |             ]+[" "]*18,  
 83 |             "expected_rewards": {0: 0, 1: 0},  
 84 |             "expected_truncated": False,
 85 |             "expected_terminated": True,  
 86 |         },
 87 |         "Multiple Trades with Mixed Outcomes": {
 88 |             "env_id": "Negotiation-v0",
 89 |             "actions": [
 90 |                 "[Offer: 2 Wheat -> 1 Wheat]", "[Accept]",
 91 |                 "[Offer: 3 Sheep -> 2 Ore]", "[Deny]",
 92 |                 "[Offer: 2 Brick -> 1 Brick]", "[Accept]",
 93 |             ] + [" "]*14,
 94 |             "expected_rewards": {0: -1, 1: 1},  
 95 |             "expected_truncated": False,
 96 |             "expected_terminated": True,
 97 |         },
 98 |         "Two trades with same outcome": {
 99 |             "env_id": "Negotiation-v0",
100 |             "actions": [
101 |                 "[Offer: 2 Wheat -> 1 Ore]", "[Accept]",
102 |                 "Nice", "[Offer: 2 Wheat -> 1 Ore]",
103 |                 "[Accept]", "Nice"
104 |             ] + [" "]*14,
105 |             "expected_rewards": {0: 0, 1: 0},  
106 |             "expected_truncated": False,
107 |             "expected_terminated": True,
108 |         },
109 |         "Trade Offer with Invalid Format": {
110 |             "env_id": "Negotiation-v0",
111 |             "actions": [
112 |                 "[Offer: blabla -> Invalid Trade Format]", " ",
113 |                 " ", " ", " ", " ", " "  
114 |             ],  
115 |             "expected_rewards": {0: -1, 1: 0},  
116 |             "expected_truncated": False,
117 |             "expected_terminated": True,  
118 |         },
119 |         "Trade Cycle Test": {
120 |             "env_id": "Negotiation-v0",
121 |             "actions": [
122 |                 "[Offer: 2 Wheat -> 1 Wood]", "[Accept]",
123 |                 "[Offer: 1 Wood -> 2 Sheep]", "[Accept]",
124 |                 "[Offer: 2 Sheep -> 2 Ore]", "[Accept]",
125 |                 "[Offer: 2 Ore -> 2 Wheat]", "[Accept]",
126 |                 " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "
127 |             ],  
128 |             "expected_rewards": {0: 0, 1: 0},  
129 |             "expected_truncated": False,
130 |             "expected_terminated": True,
131 |         },
132 |     }
133 | 
134 |     @parameterized.expand([
135 |         (
136 |             name,
137 |             details["env_id"],
138 |             details["actions"],
139 |             details["expected_rewards"],
140 |             details["expected_truncated"],
141 |             details["expected_terminated"]
142 |         )
143 |         for name, details in test_cases.items()
144 |     ])
145 |     def test_negotiation_env_outcomes(
146 |         self,
147 |         name: str,
148 |         env_id: str,
149 |         actions: List[str],
150 |         expected_rewards: Optional[Dict[int, int]],
151 |         expected_truncated: bool,
152 |         expected_terminated: bool
153 |     ):
154 |         
155 |         with self.subTest(test_case=name):
156 |             try:
157 |                 
158 |                 env = NegotiationEnv(
159 |                     max_turns=20
160 |                 )
161 |             except Exception as e:
162 |                 self.fail(f"Failed to initialize environment '{env_id}': {e}")
163 | 
164 |             try:
165 |                 
166 |                 observations = env.reset(seed=42)
167 |             except Exception as e:
168 |                 self.fail(f"Failed to reset the environment '{env_id}': {e}")
169 | 
170 |             
171 |             terminated = False
172 |             truncated = False
173 | 
174 |             for i, action in enumerate(actions):
175 |                 player_id = i % 2
176 | 
177 |                 try:
178 |                     
179 |                     step_result = env.step(player_id, action)
180 |                     if len(step_result) != 5:
181 |                         self.fail(f"env.step() returned {len(step_result)} elements, expected 5.")
182 |                     observations, rewards, truncated, terminated, info = step_result
183 |                 except Exception as e:
184 |                     self.fail(f"env.step() raised an unexpected exception for player {player_id}: {e}")
185 | 
186 |                 if terminated or truncated:
187 |                     break
188 | 
189 |             
190 |             self.assertEqual(
191 |                 rewards,
192 |                 expected_rewards,
193 |                 f"The rewards did not match. Expected {expected_rewards}; received {rewards}"
194 |             )
195 | 
196 | 
197 |             self.assertEqual(
198 |                 terminated,
199 |                 expected_terminated,
200 |                 f"Terminated flag mismatch. Expected {expected_terminated}; received {terminated}"
201 |             )
202 | 
203 |             self.assertEqual(
204 |                 truncated,
205 |                 expected_truncated,
206 |                 f"Truncated flag mismatch. Expected {expected_truncated}; received {truncated}"
207 |             )
208 | 
209 | 
210 | 
211 | if __name__ == '__main__':
212 |     unittest.main()
```

## File: textarena/envs/two_player/Negotiation/env.py

- Extension: .py
- Language: python
- Size: 18412 bytes
- Created: 2024-11-22 09:09:35
- Modified: 2024-11-22 09:09:35

### Code

```python
  1 | import random
  2 | import re
  3 | from typing import Any, Dict, Optional, Tuple
  4 | 
  5 | import textarena as ta
  6 | 
  7 | 
  8 | class NegotiationEnv(ta.Env):
  9 |     
 10 |     def __init__(self, max_turns: Optional[int] = 10):
 11 |         
 12 |         self.resource_names = ["Wheat", "Wood", "Sheep", "Brick", "Ore"]
 13 |         self.base_values = {"Wheat": 5, "Wood": 10, "Sheep": 15, "Brick": 25, "Ore": 40}
 14 | 
 15 |         
 16 |         self.state = ta.State(
 17 |             num_players=2,
 18 |             max_turns=max_turns,
 19 |         )
 20 | 
 21 |         
 22 |         self.accept_pattern = re.compile(r"\[Accept\]", re.IGNORECASE)
 23 |         self.deny_pattern = re.compile(r"\[Deny\]", re.IGNORECASE)
 24 |         self.offer_pattern = re.compile(
 25 |             r"\[Offer:\s*(?:I\s+(?:give|offer)\s+)?([^\[\]]+?)\s*\.*\]",  
 26 |             re.IGNORECASE | re.DOTALL
 27 |         )
 28 | 
 29 | 
 30 |         
 31 |         self.board_state_render = ta.envs.two_player.Negotiation.render.GameStateRender
 32 | 
 33 |     def reset(self, seed: Optional[int] = None) -> Optional[ta.Observations]:
 34 |         
 35 |         if seed is not None:
 36 |             random.seed(seed)
 37 |         else:
 38 |             random.seed()
 39 | 
 40 |         game_state = {
 41 |             "current_offer": None,
 42 |             "player_resources": {
 43 |                 0: {resource: random.randint(5, 25) for resource in self.resource_names},
 44 |                 1: {resource: random.randint(5, 25) for resource in self.resource_names},
 45 |             },
 46 |             "player_values": {}
 47 |         }
 48 | 
 49 |         
 50 |         for player_id in [0, 1]:
 51 |             game_state["player_values"][player_id] = {}
 52 |             for resource in self.resource_names:
 53 |                 base_value = self.base_values[resource]
 54 |                 variation = int(0.2 * base_value)
 55 |                 min_value = max(base_value - variation, 5)
 56 |                 max_value = min(base_value + variation, 40)
 57 |                 value = random.randint(min_value, max_value)
 58 |                 game_state["player_values"][player_id][resource] = value
 59 | 
 60 |         
 61 |         for player_id in [0, 1]:
 62 |             initial_value = self._calculate_player_inventory_value(player_id, game_state)
 63 |             game_state.setdefault("inventory_value", {})[player_id] = {
 64 |                 "initial": initial_value,
 65 |                 "current": initial_value,
 66 |                 "change": 0,
 67 |             }
 68 | 
 69 |         return self.state.reset(
 70 |             game_state=game_state,
 71 |             player_prompt_function=self._generate_player_prompt
 72 |         )
 73 | 
 74 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[int, Any]) -> str:
 75 |         
 76 |         resource_value_list = "; ".join(
 77 |             [
 78 |                 f"{game_state['player_resources'][player_id][res]} {res} (Value of each: {game_state['player_values'][player_id][res]})"
 79 |                 for res in game_state['player_resources'][player_id].keys()
 80 |             ]
 81 |         )
 82 |         prompt = (
 83 |             f"You are Player {player_id} in the Negotiation Game.\n"
 84 |             "You have some resources, and your task is to trade such that the total value of your resources increases.\n"
 85 |             f"The resources and associated values you currently have are: {resource_value_list}.\n"
 86 |             "At each turn, you can talk to your opponent or make an explicit trade offer.\n"
 87 |             "Use the following special tokens for actions:\n"
 88 |             "  - [Offer]: To make a trade offer.\n"
 89 |             "    Format: [Offer: Offered Resources -> Requested Resources]\n"
 90 |             "    Example: [Offer: 3 Sheep, 2 Ore -> 5 Brick, 2 Sheep]\n"
 91 |             "  - [Accept]: To accept an incoming offer.\n"
 92 |             "  - [Deny]: To deny an incoming offer.\n"
 93 |             "  - Not replying to an offer is equivalent to rejecting it.\n"
 94 |             "You can include additional text before or after these tokens.\n"
 95 |         )
 96 |         if self.state.max_turns:
 97 |             prompt += f"The game lasts for {self.state.max_turns} turns in total.\n"
 98 |         else:
 99 |             prompt += "The game has no turn limit.\n"
100 |         return prompt
101 | 
102 | 
103 |     def get_current_player_id(self):
104 |         return self.state.current_player   
105 | 
106 |     def step(
107 |         self,
108 |         player_id: int,
109 |         action: str,
110 |     ) -> Tuple[
111 |         Optional[ta.Observations],  
112 |         Optional[ta.Rewards],       
113 |         bool,                        
114 |         bool,                        
115 |         ta.Info,                     
116 |     ]:
117 |         
118 | 
119 |         
120 |         self.state.check_action_format(
121 |             action=action,
122 |             player_id=player_id
123 |         )
124 | 
125 |         
126 |         self.state.add_observation(
127 |             from_id=player_id,
128 |             to_id=-1,  
129 |             message=action,
130 |             for_logging=True
131 |         )
132 | 
133 |         
134 |         self._check_and_execute_existing_offer(
135 |             player_id=player_id,
136 |             action=action
137 |         )
138 | 
139 |         
140 |         self._check_for_new_offer(
141 |             player_id=player_id,
142 |             action=action
143 |         )
144 | 
145 |         
146 |         if self.state.turn == self.state.max_turns-1:
147 |             self._determine_winner()
148 | 
149 |         return self.state.step()
150 | 
151 |     def _check_and_execute_existing_offer(self, player_id: int, action: str) -> None:
152 |         
153 |         
154 |         current_offer = self.state.game_state.get("current_offer")
155 |         
156 |         
157 |         if current_offer and self.accept_pattern.search(action):
158 |             self._attempt_to_execute_trade(
159 |                 player_id=player_id,
160 |                 action=action
161 |             )
162 |         else:
163 |             
164 |             self.state.game_state["current_offer"] = None  
165 | 
166 | 
167 |     def _attempt_to_execute_trade(self, player_id: int, action: str) -> None:
168 |         
169 |         current_offer = self.state.game_state["current_offer"]
170 |         proposer_id = current_offer["from_player"]
171 |         acceptor_id = player_id
172 | 
173 |         
174 |         proposer_valid = self._check_if_sufficient_resources(
175 |             trade_resources=current_offer["offered_resources"],
176 |             player_resources=self.state.game_state["player_resources"][proposer_id]
177 |         )
178 | 
179 |         
180 |         acceptor_valid = self._check_if_sufficient_resources(
181 |             trade_resources=current_offer["requested_resources"],
182 |             player_resources=self.state.game_state["player_resources"][acceptor_id]
183 |         )
184 | 
185 |         
186 |         if proposer_valid and acceptor_valid:
187 |             
188 |             for resource, qty in current_offer["offered_resources"].items():
189 |                 self.state.game_state["player_resources"][proposer_id][resource] -= qty
190 |                 self.state.game_state["player_resources"][acceptor_id][resource] += qty
191 |             for resource, qty in current_offer["requested_resources"].items():
192 |                 self.state.game_state["player_resources"][acceptor_id][resource] -= qty
193 |                 self.state.game_state["player_resources"][proposer_id][resource] += qty
194 | 
195 |             self.state.add_observation(
196 |                 from_id=ta.GAME_ID,
197 |                 to_id=-1,  
198 |                 message=f"Player {acceptor_id} accepted the trade offer from Player {proposer_id}."
199 |             )
200 | 
201 |             
202 |             self._update_inventory_values()
203 | 
204 |             
205 |             self.state.game_state["current_offer"] = None
206 | 
207 |         
208 |         else:
209 |             player_ids = []
210 |             reasons = []
211 |             if not proposer_valid:
212 |                 player_ids.append(proposer_id)
213 |                 reasons.append(f"Player {proposer_id} does not have enough resources to offer.")
214 |             if not acceptor_valid:
215 |                 player_ids.append(acceptor_id)
216 |                 reasons.append(f"Player {acceptor_id} does not have enough resources to fulfill the request.")
217 | 
218 |             self.state.set_invalid_move(
219 |                 player_ids=player_ids,
220 |                 reasons=reasons
221 |             )
222 | 
223 |     def _check_if_sufficient_resources(self, trade_resources: Dict[str, int], player_resources: Dict[str, int]) -> bool:
224 |         
225 |         for resource, qty in trade_resources.items():
226 |             if player_resources.get(resource, 0) < qty:
227 |                 return False
228 |         return True
229 | 
230 |     def _check_for_new_offer(self, player_id: int, action: str):
231 |         
232 |         
233 |         if not self.state.terminated:
234 |             offer_match = self.offer_pattern.search(action)
235 |             if offer_match:
236 |                 matched_offer = offer_match.group(1).strip()
237 |                 parsed_offer = self._parse_offer(matched_offer)
238 |                 if parsed_offer:
239 |                     
240 |                     self.state.game_state["current_offer"] = {
241 |                         "from_player": player_id,
242 |                         "to_player": 1 - player_id,
243 |                         "offered_resources": parsed_offer["offered_resources"],
244 |                         "requested_resources": parsed_offer["requested_resources"]
245 |                     }
246 | 
247 |                     self.state.add_observation(
248 |                         from_id=ta.GAME_ID,
249 |                         to_id=-1,  
250 |                         message=f"Player {player_id} made the following offer to Player {1 - player_id}: {self._offer_to_str(parsed_offer)}"
251 |                     )
252 |                 else:
253 |                     
254 |                     self.state.set_invalid_move(
255 |                         player_ids=[player_id],
256 |                         reasons=[f"Player {player_id} made a trade offer in an incorrect format."]
257 |                     )
258 | 
259 |     def _parse_offer(self, offer_str: str) -> Optional[Dict[str, Dict[str, int]]]:
260 |         
261 |         try:
262 |             
263 |             offer_str = ' '.join(offer_str.split())
264 | 
265 |             
266 |             offer_str = re.sub(r'[.,!?]+$', '', offer_str)
267 | 
268 |             
269 |             offer_str = re.sub(r'^(I\s+(?:give|offer)\s+)', '', offer_str, flags=re.IGNORECASE)
270 | 
271 |             
272 |             offer_parts = re.split(r'\s*->\s*', offer_str)
273 |             if len(offer_parts) != 2:
274 |                 return None  
275 | 
276 |             offered_items_str = offer_parts[0].strip()
277 |             requested_items_str = offer_parts[1].strip()
278 | 
279 |             offered_items = self._parse_resource_list(offered_items_str)
280 |             requested_items = self._parse_resource_list(requested_items_str)
281 | 
282 |             if not offered_items or not requested_items:
283 |                 return None  
284 | 
285 | 
286 |             return {'offered_resources': offered_items, 'requested_resources': requested_items}
287 | 
288 |         except Exception as e:
289 |             return None
290 | 
291 |     def _parse_resource_list(self, resource_str: str) -> Optional[Dict[str, int]]:
292 |         
293 |         resource_list = re.split(r',\s*|\s+and\s+', resource_str, flags=re.IGNORECASE)
294 |         resources = {}
295 |         for item in resource_list:
296 |             item = item.strip()
297 |             if not item:
298 |                 continue
299 |             try:
300 |                 match = re.match(r'^(\d+)\s+(.+)$', item)
301 |                 if not match:
302 |                     return None
303 |                 qty_str, resource_name = match.groups()
304 |                 qty = int(qty_str)
305 |                 resource_name = resource_name.strip().title()  
306 |                 
307 |                 resource_aliases = {
308 |                     "Sheeps": "Sheep",
309 |                     "Woods": "Wood",
310 |                     
311 |                 }
312 |                 resource_name = resource_aliases.get(resource_name, resource_name)
313 |                 if resource_name not in self.resource_names or qty <= 0:
314 |                     return None
315 |                 if resource_name in resources:
316 |                     resources[resource_name] += qty
317 |                 else:
318 |                     resources[resource_name] = qty
319 |             except Exception as e:
320 |                 return None
321 |         return resources
322 | 
323 |     def _offer_to_str(self, parsed_offer: Dict[str, Dict[str, int]]) -> str:
324 |         
325 |         offered = ", ".join(f"{qty} {res}" for res, qty in parsed_offer["offered_resources"].items())
326 |         requested = ", ".join(f"{qty} {res}" for res, qty in parsed_offer["requested_resources"].items())
327 |         return f"Offered items: {offered} -> Requested items: {requested}"
328 | 
329 |     def _determine_winner(self):
330 |         
331 |         
332 |         if not self.state.terminated:
333 |             if self.state.game_state["inventory_value"][0]["change"] == self.state.game_state["inventory_value"][1]["change"]:
334 |                 
335 |                 self.state.set_draw(
336 |                     reason=f"Same change in inventory value for all players. Draw."
337 |                 )
338 |             else:
339 |                 winner_id = 0 if (
340 |                     self.state.game_state["inventory_value"][0]["change"] > self.state.game_state["inventory_value"][1]["change"]
341 |                 ) else 1
342 |                 self.state.set_winners(
343 |                     player_ids=[winner_id],
344 |                     reason=f"Player {winner_id} won by having a larger gain in inventory value."
345 |                 )
346 | 
347 |     def _update_inventory_values(self):
348 |         
349 |         for player_id in range(self.state.num_players):
350 |             
351 |             current_inventory_value = self._calculate_player_inventory_value(
352 |                 player_id=player_id,
353 |                 game_state=self.state.game_state
354 |             )
355 | 
356 |             
357 |             self.state.game_state["inventory_value"][player_id]["current"] = current_inventory_value
358 |             self.state.game_state["inventory_value"][player_id]["change"] = (
359 |                 current_inventory_value - self.state.game_state["inventory_value"][player_id]["initial"]
360 |             )
361 | 
362 |     def _calculate_player_inventory_value(self, player_id: int, game_state: Dict[str, Any]) -> float:
363 |         
364 |         resources = game_state["player_resources"][player_id]
365 |         values = game_state["player_values"][player_id]
366 |         inventory_value = sum([qty * values[res] for res, qty in resources.items()])
367 |         return inventory_value
368 | 
369 |     def close(self):
370 |         pass
```

## File: textarena/envs/two_player/Negotiation/render.py

- Extension: .py
- Language: python
- Size: 17485 bytes
- Created: 2024-11-18 12:12:05
- Modified: 2024-11-18 12:12:05

### Code

```python
  1 | import tkinter as tk
  2 | from tkinter import ttk, scrolledtext
  3 | from typing import Any, Dict, Optional
  4 | from PIL import Image, ImageTk
  5 | import os 
  6 | import textarena as ta 
  7 | import time 
  8 | 
  9 | class GameStateRender(ttk.Frame):
 10 |     CARD_HEIGHT = 100
 11 |     CARD_WIDTH = 75
 12 |     WINDOW_WIDTH = 600
 13 |     WINDOW_HEIGHT = 950
 14 |     
 15 |     def __init__(self, master, env, player_names: Optional[Dict[int, str]] = None):
 16 |         super().__init__(master)
 17 |         self.master = master 
 18 |         self.env = env 
 19 |         self.player_names = player_names or {0: "Player 0", 1: "Player 1"}
 20 |         self.player_names[ta.GAME_ID] = "GAME"
 21 |         
 22 |         
 23 |         self.animation_id = None
 24 |         self.animation_items = []
 25 |         
 26 |         
 27 |         self.player_colors = {
 28 |             0: '#4A90E2',  
 29 |             1: '#E24A4A'   
 30 |         }
 31 |         self.bg_color = '#2B2B2B'
 32 |         
 33 |         
 34 |         self.master.title("Resource Trading")
 35 |         self.master.geometry(f"{self.WINDOW_WIDTH}x{self.WINDOW_HEIGHT}")
 36 |         self.master.resizable(False, False)
 37 |         self.master.configure(bg=self.bg_color)
 38 |         
 39 |         
 40 |         self.resource_images = {}
 41 |         self.load_resource_images()
 42 |         
 43 |         
 44 |         icon_path = os.path.join("textarena", "assets", "textarena-icon.png")
 45 |         if os.path.exists(icon_path):
 46 |             try:
 47 |                 self.master.iconphoto(False, tk.PhotoImage(file=icon_path))
 48 |             except Exception as e:
 49 |                 print(f"Could not set window icon: {e}")
 50 |         
 51 |         self.create_widgets()
 52 |         
 53 |         
 54 |         self.update_idletasks()
 55 |     
 56 |     
 57 |     def load_resource_images(self):
 58 |         
 59 |         resources = ['brick', 'ore', 'sheep', 'wheat', 'wood']
 60 |         for resource in resources:
 61 |             try:
 62 |                 image = Image.open(
 63 |                     os.path.join(
 64 |                         "textarena", "envs", "two_player",
 65 |                         "Negotiation", "render_assets",
 66 |                         f"{resource}.png"
 67 |                     )
 68 |                 )
 69 |                 image = image.resize((self.CARD_WIDTH, self.CARD_HEIGHT), Image.Resampling.LANCZOS)
 70 |                 self.resource_images[resource] = ImageTk.PhotoImage(image)
 71 |             except Exception as e:
 72 |                 print(f"Could not load image for {resource}: {e}")
 73 |                 self.create_fallback_image(resource)
 74 | 
 75 |     def create_widgets(self):
 76 |         
 77 |         
 78 |         self.container = ttk.Frame(self.master)
 79 |         self.container.pack(expand=True, fill='both', padx=20, pady=20)
 80 |         
 81 |         
 82 |         self.player_frames = {}
 83 |         self.player_frames[0] = self.create_player_frame(0)
 84 |         
 85 |         
 86 |         self.trade_container = ttk.Frame(self.container)
 87 |         self.trade_container.pack(fill='x', pady=20)
 88 |         
 89 |         
 90 |         self.trade_content = ttk.Frame(self.trade_container)
 91 |         self.trade_content.pack(expand=True, anchor='center')
 92 |         
 93 |         
 94 |         self.trade_frame = ttk.Frame(self.trade_content)
 95 |         self.trade_frame.pack(side='left', padx=10)
 96 |         
 97 |         self.trade_header = ttk.Label(
 98 |             self.trade_frame,
 99 |             text="Current Trade Offer",
100 |             font=('Arial', 14, 'bold'),
101 |             background=self.bg_color,
102 |             foreground='white'
103 |         )
104 |         self.trade_header.pack(pady=10)
105 |         
106 |         
107 |         self.trade_canvas = tk.Canvas(
108 |             self.trade_frame,
109 |             height=self.CARD_HEIGHT * 4,  
110 |             width=self.WINDOW_WIDTH - 100,  
111 |             bg=self.bg_color,
112 |             highlightthickness=0
113 |         )
114 |         self.trade_canvas.pack()
115 |         
116 |         self.player_frames[1] = self.create_player_frame(1)
117 | 
118 | 
119 |     def create_player_frame(self, player_id):
120 |         
121 |         frame = ttk.Frame(self.container)
122 |         frame.pack(fill='x', pady=10)
123 |         
124 |         
125 |         header_frame = ttk.Frame(frame)
126 |         header_frame.pack(fill='x', pady=5)
127 |         
128 |         
129 |         name_label = ttk.Label(
130 |             header_frame,
131 |             text=f"{self.player_names[player_id]}",
132 |             font=('Arial', 14, 'bold'),
133 |             background=self.bg_color,
134 |             foreground=self.player_colors[player_id]
135 |         )
136 |         name_label.pack(side='left', padx=(0, 10))
137 |         
138 |         
139 |         value_label = ttk.Label(
140 |             header_frame,
141 |             text="(Value Change: +0)",
142 |             font=('Arial', 12),
143 |             background=self.bg_color,
144 |             foreground='white'
145 |         )
146 |         value_label.pack(side='left')
147 |         
148 |         
149 |         frame.value_label = value_label
150 |         
151 |         
152 |         canvas = tk.Canvas(
153 |             frame,
154 |             height=self.CARD_HEIGHT + 40,
155 |             width=self.WINDOW_WIDTH - 40,  
156 |             bg=self.bg_color,
157 |             highlightthickness=0
158 |         )
159 |         canvas.pack(fill='x')
160 |         
161 |         return frame
162 | 
163 |     def animate_trade_result(self, accepted: bool):
164 |         
165 |         if self.animation_id:
166 |             self.master.after_cancel(self.animation_id)
167 |             for item in self.animation_items:
168 |                 try:
169 |                     self.trade_canvas.delete(item)
170 |                 except:
171 |                     pass
172 |         
173 |         result_text = "ACCEPTED" if accepted else "REJECTED"
174 |         color = "green" if accepted else "red"
175 |         
176 |         
177 |         canvas_width = self.trade_canvas.winfo_width()
178 |         canvas_height = self.trade_canvas.winfo_height()
179 |         cx = canvas_width // 2
180 |         cy = canvas_height // 2
181 |         
182 |         
183 |         overlay = self.trade_canvas.create_rectangle(
184 |             cx - 100, cy - 30,  
185 |             cx + 100, cy + 30,
186 |             fill='black',
187 |             stipple='gray50',
188 |             tags='animation'
189 |         )
190 |         
191 |         
192 |         text = self.trade_canvas.create_text(
193 |             cx, cy,
194 |             text=result_text,
195 |             font=('Arial', 48, 'bold'),
196 |             fill=color,
197 |             tags='animation'
198 |         )
199 |         
200 |         self.animation_items = [overlay, text]
201 |         
202 |         def clear_animation():
203 |             for item in self.animation_items:
204 |                 self.trade_canvas.delete(item)
205 |             self.animation_items = []
206 |             self.animation_id = None
207 |         
208 |         
209 |         self.animation_id = self.master.after(2000, clear_animation)  
210 |         self.master.update()  
211 | 
212 |     def calculate_card_positions(self, resources, canvas_width):
213 |         
214 |         num_cards = len(resources)
215 |         total_cards_width = num_cards * self.CARD_WIDTH
216 |         total_spacing = (num_cards - 1) * 20 if num_cards > 1 else 0
217 |         total_width = total_cards_width + total_spacing
218 |         
219 |         start_x = (canvas_width - total_width) // 2 + self.CARD_WIDTH // 2
220 |         
221 |         return [start_x + i * (self.CARD_WIDTH + 20) for i in range(num_cards)]
222 |     
223 | 
224 |     def draw_board(self):
225 |         
226 |         if hasattr(self.env.state, "game_state"):
227 |             game_state = self.env.state.game_state
228 |             
229 |             
230 |             for player_id in [0, 1]:
231 |                 frame = self.player_frames[player_id]
232 |                 value_change = game_state["inventory_value"][player_id]["change"]
233 |                 value_color = 'green' if value_change > 0 else 'red' if value_change < 0 else 'white'
234 |                 frame.value_label.configure(
235 |                     text=f"(Value Change: {value_change:+d})",
236 |                     foreground=value_color
237 |                 )
238 |             
239 |             
240 |             for player_id in [0, 1]:
241 |                 frame = self.player_frames[player_id]
242 |                 canvas = [w for w in frame.winfo_children() if isinstance(w, tk.Canvas)][0]
243 |                 canvas.delete('all')
244 |                 
245 |                 resources = game_state["player_resources"][player_id]
246 |                 values = game_state["player_values"][player_id]
247 |                 
248 |                 
249 |                 x_positions = self.calculate_card_positions(resources, canvas.winfo_width())
250 |                 
251 |                 for (resource, quantity), x in zip(resources.items(), x_positions):
252 |                     self.draw_resource_card(
253 |                         canvas,
254 |                         resource,
255 |                         quantity,
256 |                         values[resource],
257 |                         x,
258 |                         self.CARD_HEIGHT//2 + 20,
259 |                         self.player_colors[player_id],
260 |                         show_value=True
261 |                     )
262 |             
263 |             
264 |             current_offer = game_state.get("current_offer")
265 |             if current_offer:
266 |                 self.update_trade_display(current_offer)
267 |             else:
268 |                 self.trade_header.configure(text="No Current Trade Offers")
269 |                 self.trade_canvas.delete('all')
270 |             
271 | 
272 |     def draw_resource_card(self, canvas, resource, quantity, value, x, y, highlight_color=None, show_value=True):
273 |         
274 |         
275 |         padding = 4
276 |         frame_color = highlight_color if highlight_color else self.bg_color
277 |         canvas.create_rectangle(
278 |             x - self.CARD_WIDTH//2 - padding,
279 |             y - self.CARD_HEIGHT//2 - padding,
280 |             x + self.CARD_WIDTH//2 + padding,
281 |             y + self.CARD_HEIGHT//2 + padding,
282 |             fill=frame_color,
283 |             outline=frame_color
284 |         )
285 |         
286 |         
287 |         canvas.create_image(x, y, image=self.resource_images[resource.lower()])
288 |         
289 |         
290 |         if show_value:
291 |             canvas.create_text(
292 |                 x,
293 |                 y + self.CARD_HEIGHT//2 + 15,
294 |                 text=f"Value: {value}",
295 |                 fill='white',
296 |                 font=('Arial', 10, 'bold')
297 |             )
298 |         
299 |         
300 |         badge_radius = 12
301 |         badge_x = x + self.CARD_WIDTH//2 - badge_radius - 5
302 |         badge_y = y + self.CARD_HEIGHT//2 - badge_radius - 5
303 |         
304 |         canvas.create_oval(
305 |             badge_x - badge_radius,
306 |             badge_y - badge_radius,
307 |             badge_x + badge_radius,
308 |             badge_y + badge_radius,
309 |             fill='#2B2B2B',
310 |             outline='white'
311 |         )
312 |         canvas.create_text(
313 |             badge_x,
314 |             badge_y,
315 |             text=str(quantity),
316 |             fill='white',
317 |             font=('Arial', 10, 'bold')
318 |         )
319 | 
320 |     def calculate_trade_value(self, offer, player_id):
321 |         
322 |         if not offer:
323 |             return 0
324 |             
325 |         game_state = self.env.state.game_state
326 |         player_values = game_state["player_values"][player_id]
327 |         
328 |         
329 |         value_received = 0
330 |         if player_id == offer["to_player"]:
331 |             for resource, qty in offer["offered_resources"].items():
332 |                 value_received += player_values[resource] * qty
333 |         else:
334 |             for resource, qty in offer["requested_resources"].items():
335 |                 value_received += player_values[resource] * qty
336 |                 
337 |         
338 |         value_given = 0
339 |         if player_id == offer["to_player"]:
340 |             for resource, qty in offer["requested_resources"].items():
341 |                 value_given += player_values[resource] * qty
342 |         else:
343 |             for resource, qty in offer["offered_resources"].items():
344 |                 value_given += player_values[resource] * qty
345 |                 
346 |         return value_received - value_given
347 | 
348 | 
349 |     def update_trade_display(self, offer):
350 |         
351 |         self.trade_canvas.delete('all')
352 |         
353 |         from_player = offer["from_player"]
354 |         to_player = offer["to_player"]
355 |         
356 |         self.trade_header.configure(
357 |             text=f"Trade Offer from {self.player_names[from_player]} to {self.player_names[to_player]}"
358 |         )
359 |         
360 |         canvas_width = self.trade_canvas.winfo_width()
361 |         canvas_height = self.trade_canvas.winfo_height()
362 |         
363 |         
364 |         
365 |         if from_player == 0:
366 |             
367 |             top_resources = offer["offered_resources"]
368 |             bottom_resources = offer["requested_resources"]
369 |             arrow_direction = 1  
370 |         else:
371 |             
372 |             top_resources = offer["requested_resources"]
373 |             bottom_resources = offer["offered_resources"]
374 |             arrow_direction = -1  
375 |         
376 |         
377 |         value_change_top = self.calculate_trade_value(offer, 0)  
378 |         value_change_bottom = self.calculate_trade_value(offer, 1)  
379 |         
380 |         
381 |         value_text_top_y = canvas_height * 0.05
382 |         cards_top_y = canvas_height * 0.3
383 |         cards_bottom_y = canvas_height * 0.7
384 |         value_text_bottom_y = canvas_height * 0.95
385 |         
386 |         
387 |         color_top = 'green' if value_change_top > 0 else 'red' if value_change_top < 0 else 'white'
388 |         self.trade_canvas.create_text(
389 |             canvas_width // 2,
390 |             value_text_top_y,
391 |             text=f"{self.player_names[0]}'s value change: {value_change_top:+d}",
392 |             fill=color_top,
393 |             font=('Arial', 12, 'bold')
394 |         )
395 |         
396 |         
397 |         color_bottom = 'green' if value_change_bottom > 0 else 'red' if value_change_bottom < 0 else 'white'
398 |         self.trade_canvas.create_text(
399 |             canvas_width // 2,
400 |             value_text_bottom_y,
401 |             text=f"{self.player_names[1]}'s value change: {value_change_bottom:+d}",
402 |             fill=color_bottom,
403 |             font=('Arial', 12, 'bold')
404 |         )
405 |         
406 |         
407 |         x_start_top = (canvas_width - len(top_resources) * (self.CARD_WIDTH + 20)) // 2 + self.CARD_WIDTH//2
408 |         x_start_bottom = (canvas_width - len(bottom_resources) * (self.CARD_WIDTH + 20)) // 2 + self.CARD_WIDTH//2
409 |         
410 |         
411 |         cx = canvas_width // 2
412 |         arrow_y1 = cards_top_y + self.CARD_HEIGHT//2 + 10
413 |         arrow_y2 = cards_bottom_y - self.CARD_HEIGHT//2 - 10
414 |         
415 |         if arrow_direction == 1:
416 |             
417 |             start_y = arrow_y1
418 |             end_y = arrow_y2
419 |         else:
420 |             
421 |             start_y = arrow_y2
422 |             end_y = arrow_y1
423 |         
424 |         self.trade_canvas.create_line(
425 |             cx, start_y,
426 |             cx, end_y,
427 |             arrow='last',
428 |             fill='white',
429 |             width=2
430 |         )
431 |         
432 |         
433 |         for i, (resource, quantity) in enumerate(top_resources.items()):
434 |             x = x_start_top + i * (self.CARD_WIDTH + 20)
435 |             self.draw_resource_card(
436 |                 self.trade_canvas,
437 |                 resource,
438 |                 quantity,
439 |                 self.env.state.game_state["player_values"][0][resource],  
440 |                 x,
441 |                 cards_top_y,
442 |                 self.player_colors[0],  
443 |                 show_value=False
444 |             )
445 |         
446 |         
447 |         for i, (resource, quantity) in enumerate(bottom_resources.items()):
448 |             x = x_start_bottom + i * (self.CARD_WIDTH + 20)
449 |             self.draw_resource_card(
450 |                 self.trade_canvas,
451 |                 resource,
452 |                 quantity,
453 |                 self.env.state.game_state["player_values"][1][resource],  
454 |                 x,
455 |                 cards_bottom_y,
456 |                 self.player_colors[1],  
457 |                 show_value=False
458 |             )
459 | 
460 |     def on_window_resize(self, event):
461 |         
462 |         pass
```

## File: textarena/envs/two_player/Negotiation/README.md

- Extension: .md
- Language: markdown
- Size: 8064 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Negotiation Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | **Negotiation** is a strategic two-player game where each participant starts with a set of resources valued differently by each player. The objective is to negotiate trades that enhance the total value of your resources more than your opponent can. Players alternate turns to communicate and make trade offers, aiming to optimize their inventory's value while managing the opponent's resources.
  6 | 
  7 | ## Action Space
  8 | 
  9 | - **Format:** Actions are strings representing the player's messages or trade actions.
 10 | - **Special Tokens:**
 11 |     - **[Offer]:** To make a trade offer.
 12 |         - **Format:** `[Offer: <your resources> -> <their resources>.`
 13 |         - **Example:** `[Offer: 2 Wheat, 1 Ore -> 3 Sheep]`
 14 |     - **[Accept]:** To accept an incoming trade offer.
 15 |     - **[Deny]:** To deny an incoming trade offer.
 16 | - **Examples:**
 17 |     - `"I think we should collaborate on gathering more resources."`
 18 |     - `"[Offer: 1 Wood -> 2 Wheat]"`
 19 |     - `"That is not worth it for me. [Deny]. But how about this: [Offer: 2 Wood -> 5 Wheat]"`
 20 |     - `"Fantastic. [Accept]"`
 21 | - **Notes:**    
 22 |     - Players can include additional text before or after the special tokens.
 23 |     - When responding to an offer, ensure your reply contains either `[Accept]` or `[Deny]` as appropriate.
 24 | 
 25 | 
 26 | ## Observation Space
 27 | 
 28 | ### Observations
 29 | 
 30 | Players receive a series of messages exchanged during the game, including their own resource allocations and values. This information aids in making informed trade decisions to maximize their inventory value.
 31 | 
 32 | **Reset Observation:**
 33 | 
 34 | On reset, each player receives a prompt detailing their initial resources, their values, and instructions on how to interact within the game. For example:
 35 | ```plaintext
 36 | [GAME]: You are Player 0 in the Negotiation Game.
 37 | You have some resources, and your task is to trade such that the total value of your resources increases.
 38 | The resources and associated values you currently have are: 10 Wheat (Value of each: 5); 15 Wood (Value of each: 10); 20 Sheep (Value of each: 15); 5 Brick (Value of each: 25); 8 Ore (Value of each: 40).
 39 | At each turn, you can talk to your opponent or make an explicit trade offer.
 40 | Use the following special tokens for actions:
 41 |   - [Offer]: To make a trade offer.
 42 |     Format: [Offer] I give [your resources]; You give [their resources].
 43 |     Example: [Offer] I give 2 Wheat, 1 Ore; You give 3 Sheep.
 44 |   - [Accept]: To accept an incoming offer.
 45 |   - [Deny]: To deny an incoming offer.
 46 | You can include additional text before or after these tokens.
 47 | If responding to an offer, ensure your reply contains [Accept] or [Deny] as appropriate.
 48 | The game lasts for 10 turns in total.
 49 | 
 50 | ```
 51 | 
 52 | **Step Observation:**
 53 | After each step, players receive updates about trade offers and actions taken. For example:
 54 | ```plaintext
 55 | Player 1: [Offer] I give 3 Sheep; You give 2 Wheat.
 56 | ```
 57 | 
 58 | ## Gameplay
 59 | - **Players**: 2
 60 | - **Turns**: Players alternate sending messages or making trade offers.
 61 | - **Resources**: Each player starts with a random allocation of resources: Wheat, Wood, Sheep, Brick, Ore.
 62 | - **Resource Values**: Each resource has a value that varies per player (±20% of the base value), influencing the strategic value of trades.
 63 | - **Objective**: Maximize the total value of your resources by negotiating beneficial trades while minimizing the opponent's advantage.
 64 | - **Turn Limit**: The game can be configured with a maximum number of turns (default is 10), after which it ends and the player with the highest inventory value gain wins.
 65 | 
 66 | ## Key Rules
 67 | 1. Resources and Values:
 68 |     - Each player starts with a random quantity of resources.
 69 |     - The value of each resource is personalized for each player, affecting the trade dynamics.
 70 | 
 71 | 2. Making Trade Offers:
 72 |     - Players can propose trades using the `[Offer]` token.
 73 |     - The offer must specify what the proposer is giving and what they are requesting in return.
 74 |     - **Format:** `[Offer: <your resources> -> <their resources>]`
 75 |     - **Example:** `[Offer: 2 Wheat, 1 Ore -> 3 Sheep]`
 76 | 
 77 | 3. Responding to Offers:
 78 |     - When a player receives a trade offer, they must respond using `[Accept]` or `[Deny]`.
 79 |     - **[Accept]:** Agree to the trade, resulting in the exchange of specified resources.
 80 |     - **[Deny]:** Reject the trade, and the current offer is discarded.
 81 | 
 82 | 4. Valid Moves:
 83 |     - All actions must strings. If the opponent has made an offer (`[Offer]`), the immediate next action needs to contain either `[Accept]` or `[Deny]`; as appropriate.
 84 |     - Offers must follow the correct format and involve available resources.
 85 | 
 86 | 5. Winning Conditions:
 87 |     - **Win:** At the end of the game, the player with the highest increase in inventory value compared to their initial value wins.
 88 |     - **Draw:** If both players have the same increase in inventory value after the maximum number of turns.
 89 |     - **Loss:** If a player makes an invalid trade offer or accepts a trade without sufficient resources, they receive a penalty.
 90 | 
 91 | 6. Game Termination:
 92 |     - The game ends when the maximum number of turns is reached.
 93 |     - The winner is determined based on the change in inventory values.
 94 |     - In cases of invalid moves, the game will terminate early with penalties applied.
 95 | 
 96 | 
 97 | ## Rewards
 98 | 
 99 | | Outcome          | Reward for Player | Reward for Opponent |
100 | |------------------|:-----------------:|:-------------------:|
101 | | **Win**          | `+1`              | `-1`                |
102 | | **Lose**         | `-1`              | `+1`                |
103 | | **Draw**         |  `0`              |  `0`                |
104 | | **Invalid Move** | `-1`              |  `0`                |
105 | 
106 | 
107 | ## Parameters
108 | 
109 | - `max_turns` (`int`):
110 |     - **Description**: Specifies the maximum number of turns allowed before the game ends.
111 |     - **Impact**: Limits the duration of the game, encouraging strategic and efficient trading.
112 | 
113 | 
114 | 
115 | ## Variants
116 | 
117 | | Env-id                   | max_turns |
118 | |--------------------------|:---------:|
119 | | `Negotiation-v0`         |    `20`   |
120 | | `Negotiation-v0-short`   |    `10`   |
121 | | `Negotiation-v0-long`    |    `50`   |
122 | 
123 | ## Example Usage
124 | 
125 | ```python
126 | import textarena as ta
127 | 
128 | # Initialize the environment
129 | env = ta.make(env_id="Negotiation-v0")
130 | 
131 | # Wrap the environment for easier observation handling
132 | env = ta.wrappers.LLMObservationWrapper(env=env)
133 | 
134 | # initalize agents
135 | agents = {
136 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
137 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
138 |     }
139 | 
140 | # reset the environment to start a new game
141 | observations = env.reset(seed=490)
142 | 
143 | # Game loop
144 | done = False
145 | while not done:
146 | 
147 |     # Get the current player
148 |     current_player_id = env.state.get("current_player")
149 | 
150 |     # Get the current observation for the player
151 |     obs = observations[current_player_id]
152 | 
153 |     # Agent decides on an action based on the observation
154 |     action = agents[current_player_id](obs)
155 | 
156 |     # Execute the action in the environment
157 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
158 | 
159 |     # Check if the game has ended
160 |     done = terminated or truncated
161 | 
162 |     # Optionally render the environment to see the current state
163 |     env.render()
164 | 
165 |     if done:
166 |         break
167 | 
168 | # Finally, print the game results
169 | for player_id, agent in agents.items():
170 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
171 | print(f"Reason: {info['reason']}")
172 | ```
173 | 
174 | ## Troubleshooting
175 | 
176 | - **Invalid Trade Offer Format:**
177 |     - **Issue:** Player makes a trade offer that doesn't follow the `[Offer: ... -> ...]` format.
178 |     - **Solution:** Ensure that all trade offers strictly adhere to the specified format, clearly listing resources and quantities.
179 | 
180 | - **Insufficient Resources for Trade:**
181 |     - **Issue:** A player attempts to offer or accept a trade without having enough resources.
182 |     - **Solution:** Verify resource quantities before making or accepting offers. The environment will penalize invalid moves.
183 | 
184 | ## Version History
185 | - **v0**
186 |   - Initial release 
187 | 
188 | 
189 | 
190 | ### Contact
191 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/Negotiation/__init__.py

- Extension: .py
- Language: python
- Size: 141 bytes
- Created: 2024-11-18 10:32:05
- Modified: 2024-11-18 10:32:05

### Code

```python
1 | from textarena.envs.two_player.Negotiation.env import NegotiationEnv
2 | from textarena.envs.two_player.Negotiation.render import GameStateRender
```

## File: textarena/envs/two_player/MemoryGame/test.py

- Extension: .py
- Language: python
- Size: 6073 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | from textarena.envs.two_player.MemoryGame.env import MemoryGameEnv
  4 | import json
  5 | 
  6 | 
  7 | def generate_normal_game_sequence(player_moves):
  8 |     
  9 |     actions = []
 10 |     for move in player_moves:
 11 |         actions.append(move)
 12 |     return actions
 13 | 
 14 | def generate_correct_move_sequence():
 15 |     
 16 |     return ["[2 1 2 2]", "[0 1 1 3]"]
 17 | 
 18 | def generate_invalid_move_sequence():
 19 |     
 20 |     return ["(0 0) (1 2)", "[0 0] [1 2]", "[0 0 0 0]"]
 21 | 
 22 | def generate_out_of_bounds_sequence():
 23 |     
 24 |     return ["[10 10 11 11]"]
 25 | 
 26 | def generate_draw_winning_seqeunce():
 27 |     
 28 |     return ["[0 0 3 2]", "[0 1 1 3]", "[0 2 3 0]", "[0 3 1 2]", "[1 0 2 3]", "[1 1 2 0]", "[2 1 2 2]", "[3 1 3 3]"]
 29 | 
 30 | def generate_player_winning_seqeunce():
 31 |     
 32 |     return ["[0 0 3 2]", "[0 1 1 3]", "[0 2 3 0]", "[0 3 1 2]", "[1 0 2 3]", "[1 1 2 1]", "[1 1 2 0]", "[2 1 2 2]", "[3 1 3 3]"] 
 33 | 
 34 | class TestMemoryGameEnv(unittest.TestCase):
 35 |     
 36 | 
 37 |     
 38 |     env_variants = [
 39 |         {"difficulty": "easy"},
 40 |         {"difficulty": "medium"},
 41 |         {"difficulty": "hard"}
 42 |     ]
 43 | 
 44 |     
 45 |     test_cases = {
 46 |         "normal_game_easy": {
 47 |             "difficulty": "easy",
 48 |             "actions": generate_normal_game_sequence([
 49 |                 "[0 0 1 1]", "[2 2 3 3]", "[0 1 2 3]", "[0 1 2 3]"
 50 |             ])
 51 |         },
 52 |         "correct_move_easy": {
 53 |             "difficulty": "easy",
 54 |             "actions": generate_correct_move_sequence()
 55 |         },
 56 |         "invalid_move_easy": {
 57 |             "difficulty": "easy",
 58 |             "actions": generate_invalid_move_sequence()
 59 |         },
 60 |         "out_of_bounds_easy": {
 61 |             "difficulty": "easy",
 62 |             "actions": generate_out_of_bounds_sequence()
 63 |         },
 64 |         "draw_winning_easy": {
 65 |             "difficulty": "easy",
 66 |             "actions": generate_draw_winning_seqeunce()
 67 |         },
 68 |         "player_winning_easy": {
 69 |             "difficulty": "easy",
 70 |             "actions": generate_player_winning_seqeunce()
 71 |         }
 72 |     }
 73 | 
 74 |     @parameterized.expand([
 75 |         (name, details['difficulty'], details['actions'])
 76 |         for name, details in test_cases.items()
 77 |     ])
 78 |     def test_memorygame_outcomes(self, name, difficulty, actions):
 79 |         
 80 |         env_config = next((env for env in self.env_variants if env['difficulty'] == difficulty), None)
 81 |         self.assertIsNotNone(env_config, f"Invalid difficulty level: {difficulty}")
 82 | 
 83 |         env = MemoryGameEnv(difficulty=env_config['difficulty'])
 84 |         
 85 |         observations = env.reset(seed=490)
 86 | 
 87 |         terminated = False
 88 |         truncated = False
 89 |         rewards = {0: 0, 1: 0}
 90 | 
 91 |         for i, action in enumerate(actions):
 92 |             if terminated or truncated:
 93 |                 break
 94 |             player_id = i % 2
 95 |             
 96 |             env_action = action
 97 | 
 98 |             
 99 |             observations, reward, truncated, terminated, info = env.step(player_id, env_action)
100 | 
101 |             
102 |             if reward:
103 |                 rewards.update(reward)
104 | 
105 |         if "normal_game" in name:
106 |             self.assertFalse(truncated, "Game should not truncate for normal moves.")
107 |             self.assertFalse(terminated, "Game should not terminate until the puzzle is complete.")
108 |         elif "correct_move" in name:
109 |             self.assertFalse(truncated, "Game should not truncate for correct moves.")
110 |             self.assertFalse(terminated, "Game should not terminate until the puzzle is complete.")
111 |         elif "invalid_move" in name:
112 |             self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move.")
113 |             self.assertEqual(rewards[player_id], -1, "Player should receive -1 reward for an invalid move.")
114 |         elif "out_of_bounds" in name:
115 |             self.assertTrue(truncated or terminated, "Game should terminate due to an out-of-bounds move.")
116 |             self.assertEqual(rewards[player_id], -1, "Player should receive -1 reward for an out-of-bounds move.")
117 |         elif "draw_winning" in name:
118 |             self.assertTrue(terminated, "Game should terminate due to a draw.")
119 |             self.assertEqual(rewards[player_id], 0, "Player 0 should have received 0 reward for a draw.")
120 |             self.assertEqual(rewards[1 - player_id], 0, "Player 1 should have received 0 reward for a draw.")
121 |         elif "player_winning" in name:
122 |             self.assertTrue(terminated, "Game should terminate due to a player winning.")
123 |             self.assertEqual(rewards[player_id], 1, f"Player {player_id} should have received +1 for winning.")
124 |             self.assertEqual(rewards[1 - player_id], -1, f"Player {1 - player_id} should have received -1 for losing.")
125 |         else:
126 |             self.fail(f"Unknown test case name: {name}")
127 | 
128 |     def run_unit_test():
129 |         print("Running MemoryGame tests...")
130 |         unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/two_player/MemoryGame/env.py

- Extension: .py
- Language: python
- Size: 9186 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from typing import Any, Dict, Optional, Tuple, List
  2 | import random
  3 | import textarena as ta
  4 | import re
  5 | 
  6 | class MemoryGameEnv(ta.Env):
  7 |     
  8 |     def __init__(
  9 |         self,
 10 |         difficulty: Optional[str] = "easy",
 11 |     ):
 12 |         
 13 |         self.environment_name = "MemoryGame"
 14 |         self.difficulty = difficulty
 15 | 
 16 |         
 17 |         if self.difficulty == "easy":
 18 |             self.grid_size = 4
 19 |         elif self.difficulty == "medium":
 20 |             self.grid_size = 6
 21 |         elif self.difficulty == "hard":
 22 |             self.grid_size = 8
 23 |         else:
 24 |             raise ValueError("Invalid difficulty level. Please choose from 'easy', 'medium', or 'hard'.")
 25 |         
 26 |         
 27 |         self.state = ta.State(
 28 |             num_players=2,
 29 |             max_turns=None,
 30 |             render_keys=["rendered_board"],
 31 |         )
 32 | 
 33 |     def reset(
 34 |         self,
 35 |         seed: Optional[int] = None
 36 |     ) -> Optional[ta.Observations]:
 37 |         
 38 |         
 39 |         if seed is not None:
 40 |             random.seed(seed)
 41 |         else:
 42 |             random.seed()
 43 | 
 44 |         
 45 |         self.board = self._generate_board()
 46 |         self.matched_positions = set()
 47 |         self.score = {0: 0, 1: 0}
 48 | 
 49 |         
 50 |         return self.state.reset(
 51 |             game_state={
 52 |                 "board": self.board,
 53 |                 "rendered_board": self._render_board(self.board)
 54 |             },
 55 |             player_prompt_function=self._generate_player_prompt
 56 |         )
 57 |     
 58 |     def _generate_player_prompt(self, player_id: int) -> str:
 59 |         
 60 |         prompt = (
 61 |             f"You are Player {player_id}. You are playing the Memory Game ({self.difficulty} level).\n"
 62 |             "Your goal is to match more pairs of cards on the board, than your opponent.\n"
 63 |             "On your turn, select two cards to flip by entering the row and column numbers of the first and second card respectively like [0 1 1 0], where the first card is in row 0 and column 1, and the second card is in row 1 and column 0.\n"
 64 |             "If the two cards match, you get a point and the cards remain face up. If they do not match, the cards are flipped back face down, e.g. '.'.\n"
 65 |             "The game ends when all pairs have been matched.\n"
 66 |             "Here is the initial board with all cards faced down:\n"
 67 |         )
 68 | 
 69 |         prompt += self._render_board(self.board)
 70 | 
 71 |         return prompt
 72 |     
 73 |     def _generate_board(self) -> List[List[str]]:
 74 |         
 75 |         
 76 |         num_pairs = (self.grid_size ** 2) // 2
 77 |         symbols = [chr(65 + i) for i in range(num_pairs)] * 2
 78 |         random.shuffle(symbols)
 79 | 
 80 |         board = [symbols[i * self.grid_size:(i + 1) * self.grid_size] for i in range(self.grid_size)]
 81 | 
 82 |         return board
 83 |     
 84 |     def _render_board(self, board: List[List[str]]) -> str:
 85 |         
 86 |         rendered_board = "  " + " ".join(str(c) for c in range(self.grid_size)) + "\n"
 87 |         for r in range(self.grid_size):
 88 |             row = f"{r} "
 89 |             for c in range(self.grid_size):
 90 |                 if (r, c) in self.matched_positions:
 91 |                     row += f"{board[r][c]} "
 92 |                 else:
 93 |                     row += ". "
 94 |             rendered_board += row.strip() + "\n"
 95 |         
 96 |         return rendered_board
 97 |     
 98 |     def step(
 99 |         self,
100 |         player_id: int,
101 |         action: List[int]
102 |     ) -> Tuple[
103 |         ta.Observations,
104 |         ta.Rewards,
105 |         bool,
106 |         bool,
107 |         ta.Info
108 |     ]:
109 |         
110 |         
111 |         self.state.check_action_format(
112 |             action=action,
113 |             player_id=player_id
114 |         )
115 | 
116 |         
117 |         self.state.add_observation(
118 |             from_id=player_id,
119 |             to_id=-1, 
120 |             message=action,
121 |             for_logging=True
122 |         )
123 | 
124 |         
125 |         action_search_pattern = re.compile(r"\[([0-9]+) ([0-9]+) ([0-9]+) ([0-9]+)\]") 
126 |         match = action_search_pattern.search(action)
127 | 
128 |         if match is None:
129 |             self.state.set_invalid_move(
130 |                 player_ids=[player_id],
131 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with a valid direction in square brackets."]
132 |             )
133 |         else:
134 |             r1, c1, r2, c2 = map(int, match.groups())
135 |             if r1 < 0 or r1 >= self.grid_size or c1 < 0 or c1 >= self.grid_size or r2 < 0 or r2 >= self.grid_size or c2 < 0 or c2 >= self.grid_size:
136 |                 self.state.set_invalid_move(
137 |                     player_ids=[player_id],
138 |                     reasons=[f"Invalid move. Player {player_id} selected an out-of-bounds position."]
139 |                 )
140 |             elif (r1, c1) == (r2, c2):
141 |                 self.state.set_invalid_move(
142 |                     player_ids=[player_id],
143 |                     reasons=[f"Invalid move. Player {player_id} selected the same card twice."]
144 |                 )
145 |             elif (r1, c1) in self.matched_positions or (r2, c2) in self.matched_positions:
146 |                 self.state.set_invalid_move(
147 |                     player_ids=[player_id],
148 |                     reasons=[f"Invalid move. Player {player_id} selected one or both cards that have already been matched."]
149 |                 )
150 |             else:
151 |                 if self.board[r1][c1] == self.board[r2][c2]:
152 |                     
153 |                     self.score[player_id] += 1
154 | 
155 |                     
156 |                     self.matched_positions.update([(r1, c1), (r2, c2)])
157 | 
158 |                     
159 |                     if len(self.matched_positions) == self.grid_size ** 2:
160 |                         
161 |                         if self.score[0] == self.score[1]:
162 |                             self.state.set_draw(
163 |                                 reason="Both players matched the same number of pairs of cards."
164 |                             )
165 |                         else:
166 |                             
167 |                             winner_id = max(self.score, key=self.score.get)
168 |                             self.state.set_winners(
169 |                                 player_ids=[winner_id],
170 |                                 reason=f"Player {winner_id} matched more pairs of cards."
171 |                             )
172 | 
173 |                     
174 |                     self.state.add_observation(
175 |                         from_id=ta.GAME_ID,
176 |                         to_id=-1,
177 |                         message=f"Cards at positions [{r1} {c1}] and [{r2} {c2}] match!\nUpdated board:\n" + self._render_board(self.board),
178 |                         for_logging=False
179 |                     )
180 | 
181 |                 else:
182 |                     
183 |                     pos1 = self.board[r1][c1]
184 |                     pos2 = self.board[r2][c2]
185 |                     self.state.add_observation(
186 |                         from_id=ta.GAME_ID,
187 |                         to_id=-1,
188 |                         message=f"The cards do not match. Cards at positions [{r1} {c1}] and [{r2} {c2}] are {pos1} and {pos2} respectively.",
189 |                         for_logging=False
190 |                     )
191 | 
192 |         
193 |         self.state.game_state["rendered_board"] = self._render_board(self.board)
194 | 
195 |         
196 |         return self.state.step()
197 |             
198 |     def render(self):
199 |         
200 |         print(self.state.game_state["rendered_board"])
201 | 
202 |     
```

## File: textarena/envs/two_player/MemoryGame/README.md

- Extension: .md
- Language: markdown
- Size: 7958 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Memory Game Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | **Memory Game** is a two-player turn-based game designed to test players' memory and concentration. Each player takes turns flipping pairs of cards on a grid, attempting to find matching pairs. The objective is to remember the locations of previously revealed cards to maximize the number of matches and score points. The game ends when all pairs have been matched, and the player with the most matches wins. This environment supports multiple difficulty levels, with varying grid sizes that adjust the game's complexity.
  6 | 
  7 | ## Action Space
  8 | 
  9 | - **Format:** Actions are strings representing the player's choices. For example:
 10 | - **Example:**
 11 |     - Reveal the cards at row 1 column 2 and row 3 column 1: [1 2 3 1]
 12 |     - Reveal the cards at row 2 column 4 and row 2 column 3: [2 4 2 3]
 13 | - **Notes:** Players can have additional texts in their replies, as long as they provide their coodinate actions in the correct format.
 14 | 
 15 | ## Observation Space
 16 | **Reset Observation:**
 17 | On reset, each player receives a prompt containing their beginning game instructinos. For example:
 18 | ```plaintext
 19 | [GAME] You are Player 0. You are playing the Memory Game (easy level).
 20 | Your goal is to match more pairs of cards on the board, than your opponent.
 21 | On your turn, select two cards to flip by entering the row and column numbers of the first and second card respectively like [0 1 1 0], where the first card is in row 0 and column 1, and the second card is in row 1 and column 0.
 22 | If the two cards match, you get a point and the cards remain face up. If they do not match, the cards are flipped back face down, e.g. '.'.
 23 | The game ends when all pairs have been matched.
 24 | Here is the initial board with all cards faced down:
 25 |   0 1 2 3
 26 | 0 . . . .
 27 | 1 . . . .
 28 | 2 . . . .
 29 | 3 . . . .
 30 | ```
 31 | 
 32 | **Step Observation:**
 33 | After each step, the players receive the latest message from the other player. For example, here's player 1 making its move:
 34 | ```plaintext
 35 | [Player 0] To begin the Memory Game, I'll select two cards to flip. Since it's the first turn, I don't have any prior information about the cards. Let's start with these two positions:
 36 | 
 37 | Flip the card at row 0, column 0 and the card at row 0, column 1.
 38 | 
 39 | [0 0 0 1]
 40 | [GAME] The cards do not match. Cards at positions [0 0] and [0 1] are A and F respectively.
 41 | [Player 1] Now it's my turn. I'll try to remember the cards that have been revealed. The cards at positions [0 0] and [0 1] are A and F respectively.
 42 | 
 43 | I'll flip the card at row 0, column 2 and the card at row 0, column 3.
 44 | 
 45 | [0 2 0 3]
 46 | ```
 47 | 
 48 | ## Gameplay
 49 | 
 50 | - **Players**: 2
 51 | - **Turns**: Players take turns selecting two cards to flip on the grid.
 52 | - **Board**: A grid of facedown cards is presented at the start, with pairs of matching symbols hidden.
 53 | - **Objective**: Match pairs of cards by remembering previously revealed locations and flipping pairs with matching symbols.
 54 | - **Difficulty Levels**: The game can be configured with different grid sizes based on difficulty level (easy, medium, hard).
 55 | 
 56 | ## Key Rules
 57 | 
 58 | 1. Card Matching:
 59 |     - Players take turns flipping two cards on the board.
 60 |     - If the selected cards match, the player earns a point (not reward), and the matched cards remain face up.
 61 |     - If the selected cards do not match, they are flipped back face down.
 62 | 
 63 | 2. Valid Moves:
 64 |     - Players select two distinct card positions by specifying row and column coordinates.
 65 |     - Moves are invalid if a player selects the same card twice or if one or both selected cards have already been matched.
 66 | 
 67 | 3. Winning Conditions:
 68 |     - **Win**: The player with the most points for matched pairs at the end of the game wins.
 69 |     - **Loss**: The player with fewer points for matched pairs loses.
 70 |     - **Draw**: If both players have the same number of matches when all pairs have been matched, the game ends in a draw.
 71 | 
 72 | 4. Game Termination:
 73 |     - The game ends when all pairs have been matched.
 74 |     - If the game is tied, it ends in a draw; otherwise, the player with the most matches is declared the winner.
 75 | 
 76 | 
 77 | ## Rewards
 78 | 
 79 | | Outcome          | Reward for Player | Reward for Opponent |
 80 | |------------------|:-----------------:|:-------------------:|
 81 | | **Win**          | `+1`              | `-1`                |
 82 | | **Lose**         | `-1`              | `+1`                |
 83 | | **Invalid**      | `-1`              | `0`                 |
 84 | | **Draw**         | `0`               | `0`                 |
 85 | 
 86 | 
 87 | ## Parameters
 88 | 
 89 | - `difficulty` (`str`):
 90 |     - **Description**: Sets the difficulty level, adjusting the grid size.
 91 |     - **Options**:
 92 |         - `"easy"`: Creates a 4x4 grid, ideal for quick and simpler gameplay.
 93 |         - `"medium"`: Creates a 6x6 grid, offering moderate difficulty.
 94 |         - `"hard"`: Creates an 8x8 grid, challenging players’ memory with more cards.
 95 |     - **Impact**:
 96 |         - Larger grids increase the game’s difficulty by adding more card pairs, making it harder to remember card locations.
 97 | 
 98 | 
 99 | ## Variants
100 | 
101 | | Env-id                  | difficulty |
102 | |-------------------------|:----------:|
103 | | `MemoryGame-v0-easy`    | `easy`     |
104 | | `MemoryGame-v0-medium`  | `medium`   |
105 | | `MemoryGame-v0-hard`    | `hard`     |
106 | 
107 | 
108 | ## Example Usage
109 | 
110 | ```python
111 | import textarena as ta
112 | 
113 | # Initialize the environment
114 | env = ta.make(env_id="MemoryGame-v0-easy")
115 | 
116 | # Wrap the environment for easier observation handling
117 | env = ta.wrappers.LLMObservationWrapper(env=env)
118 | 
119 | # Wrap the environment for pretty rendering
120 | env = ta.wrappers.PrettyRenderWrapper(env=env)
121 | 
122 | # initalize agents
123 | agents = {
124 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
125 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
126 |     }
127 | 
128 | # reset the environment to start a new game
129 | observations = env.reset(seed=490)
130 | 
131 | # Game loop
132 | done = False
133 | while not done:
134 | 
135 |     # Get the current player
136 |     current_player_id = env.state.get("current_player")
137 | 
138 |     # Get the current observation for the player
139 |     obs = observations[current_player_id]
140 | 
141 |     # Agent decides on an action based on the observation
142 |     action = agents[current_player_id](obs)
143 | 
144 |     # Execute the action in the environment
145 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
146 | 
147 |     # Check if the game has ended
148 |     done = terminated or truncated
149 | 
150 |     # Optionally render the environment to see the current state
151 |     env.render()
152 | 
153 |     if done:
154 |         break
155 | 
156 | # Finally, print the game results
157 | for player_id, agent in agents.items():
158 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
159 | print(f"Reason: {info['reason']}")
160 | ```
161 | 
162 | 
163 | 
164 | ## Troubleshooting
165 | 
166 | - **Unmatched Pairs Despite Multiple Attempts**:
167 |     - **Issue**: Players are unable to find matching pairs after several turns, leading to a slower game pace.
168 |     - **Solution**: Encourage players to pay attention to the locations of previously revealed cards and remember their symbols.
169 | 
170 | - **Invalid Move Format**:
171 |     - **Issue**: A player selects an invalid format or repeats the same card coordinates for both selections.
172 |     - **Solution**: Ensure moves are formatted correctly as two distinct row and column coordinates (e.g., `[0 1 1 0]`). Check the selected positions to avoid choosing the same card twice.
173 | 
174 | - **Out-of-Bounds or Matched Cards Selected**:
175 |     - **Issue**: A player selects coordinates outside the board grid or chooses cards that have already been matched.
176 |     - **Solution**: Double-check the board dimensions based on difficulty level and avoid selecting already matched cards. Use valid, in-bounds coordinates only.
177 | 
178 | - **Game Ending in a Draw**:
179 |     - **Issue**: The game ends in a draw if players score equally after all pairs are matched.
180 |     - **Solution**: Increase the difficulty level to introduce a larger grid, making it harder to match pairs and reducing the likelihood of a tie.
181 | 
182 | 
183 | 
184 | ## Version History
185 | - **v0**
186 |   - Initial release 
187 | 
188 | 
189 | 
190 | ### Contact
191 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/two_player/MemoryGame/example.py

- Extension: .py
- Language: python
- Size: 1338 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make(env_id="MemoryGame-v0-easy")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
15 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
16 |     }
17 | 
18 | 
19 | observations = env.reset(seed=490)
20 | 
21 | 
22 | done = False
23 | while not done:
24 | 
25 |     
26 |     current_player_id = env.state.get("current_player")
27 | 
28 |     
29 |     obs = observations[current_player_id]
30 | 
31 |     
32 |     action = agents[current_player_id](obs)
33 | 
34 |     
35 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
36 | 
37 |     
38 |     done = terminated or truncated
39 | 
40 |     
41 |     env.render()
42 | 
43 |     if done:
44 |         break
45 | 
46 | 
47 | for player_id, agent in agents.items():
48 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
49 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/two_player/Debate/test.py

- Extension: .py
- Language: python
- Size: 5369 bytes
- Created: 2024-10-22 18:08:39
- Modified: 2024-10-22 18:08:39

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | from textarena.envs.two_player.Debate.env import DebateEnv
  4 | from unittest.mock import patch
  5 | 
  6 | 
  7 | def generate_debate_sequence(arguments_player_0, arguments_player_1):
  8 |     
  9 |     actions = []
 10 |     for arg0, arg1 in zip(arguments_player_0, arguments_player_1):
 11 |         actions.append((0, arg0))
 12 |         actions.append((1, arg1))
 13 |     return actions
 14 | 
 15 | class TestDebateEnv(unittest.TestCase):
 16 | 
 17 |     
 18 |     test_cases = {
 19 |         "affirmative_wins": {
 20 |             "max_turns": 4,
 21 |             "num_judges": 11,
 22 |             "pre_debate_votes": {"Affirmative": 5, "Negative": 6},
 23 |             "post_debate_votes": {"Affirmative": 7, "Negative": 4},
 24 |             "expected_winner": "Affirmative",
 25 |             "arguments_player_0": ["Affirmative argument 1", "Affirmative argument 2"],
 26 |             "arguments_player_1": ["Negative argument 1", "Negative argument 2"],
 27 |         },
 28 |         "negative_wins": {
 29 |             "max_turns": 4,
 30 |             "num_judges": 11,
 31 |             "pre_debate_votes": {"Affirmative": 6, "Negative": 5},
 32 |             "post_debate_votes": {"Affirmative": 5, "Negative": 6},
 33 |             "expected_winner": "Negative",
 34 |             "arguments_player_0": ["Affirmative argument 1", "Affirmative argument 2"],
 35 |             "arguments_player_1": ["Negative argument 1", "Negative argument 2"],
 36 |         },
 37 |         "draw": {
 38 |             "max_turns": 4,
 39 |             "num_judges": 11,
 40 |             "pre_debate_votes": {"Affirmative": 5, "Negative": 6},
 41 |             "post_debate_votes": {"Affirmative": 5, "Negative": 6},
 42 |             "expected_winner": None,
 43 |             "arguments_player_0": ["Affirmative argument 1", "Affirmative argument 2"],
 44 |             "arguments_player_1": ["Negative argument 1", "Negative argument 2"],
 45 |         },
 46 |         
 47 |     }
 48 | 
 49 |     @parameterized.expand([
 50 |         (name, details)
 51 |         for name, details in test_cases.items()
 52 |     ])
 53 |     @patch('textarena.game_makers.GPTJudgeVote.evaluate')
 54 |     def test_debate_outcomes(self, name, details, mock_evaluate):
 55 |         
 56 |         
 57 |         def side_effect(context):
 58 |             if "No debate has occurred yet" in context:
 59 |                 return details["pre_debate_votes"]
 60 |             else:
 61 |                 return details["post_debate_votes"]
 62 |         mock_evaluate.side_effect = side_effect
 63 | 
 64 |         
 65 |         env = DebateEnv(
 66 |             max_turns=details["max_turns"],
 67 |             num_judges=details["num_judges"],
 68 |             topics_path=None,  
 69 |         )
 70 |         observations = env.reset(seed=42)
 71 | 
 72 |         terminated = False
 73 |         truncated = False
 74 |         rewards = {0: 0, 1: 0}
 75 | 
 76 |         
 77 |         sides = env.state.game_state["sides"]
 78 |         affirmative_player_id = next(pid for pid, side in sides.items() if side == "Affirmative")
 79 |         negative_player_id = 1 - affirmative_player_id
 80 | 
 81 |         
 82 |         actions = generate_debate_sequence(
 83 |             details["arguments_player_0"], details["arguments_player_1"]
 84 |         )
 85 | 
 86 |         for player_id, action in actions:
 87 |             if terminated or truncated:
 88 |                 break
 89 |             
 90 |             observations, reward, truncated, terminated, info = env.step(player_id, action)
 91 | 
 92 |             
 93 |             if reward:
 94 |                 rewards.update(reward)
 95 | 
 96 |         
 97 |         if details["expected_winner"] == "Affirmative":
 98 |             winning_player_id = affirmative_player_id
 99 |             losing_player_id = negative_player_id
100 |             self.assertEqual(rewards[winning_player_id], 1, f"Player {winning_player_id} should have received +1 for winning.")
101 |             self.assertEqual(rewards[losing_player_id], -1, f"Player {losing_player_id} should have received -1 for losing.")
102 |         elif details["expected_winner"] == "Negative":
103 |             winning_player_id = negative_player_id
104 |             losing_player_id = affirmative_player_id
105 |             self.assertEqual(rewards[winning_player_id], 1, f"Player {winning_player_id} should have received +1 for winning.")
106 |             self.assertEqual(rewards[losing_player_id], -1, f"Player {losing_player_id} should have received -1 for losing.")
107 |         else:
108 |             
109 |             self.assertEqual(rewards[0], 0, "Player 0 should have received 0 reward for a draw.")
110 |             self.assertEqual(rewards[1], 0, "Player 1 should have received 0 reward for a draw.")
111 | 
112 | def run_unit_test():
113 |     print("Running ConnectFourEnv tests...")
114 |     unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/two_player/Debate/env.py

- Extension: .py
- Language: python
- Size: 9432 bytes
- Created: 2024-10-27 15:00:13
- Modified: 2024-10-27 15:00:13

### Code

```python
  1 | 
  2 | import textarena as ta 
  3 | 
  4 | import os, json, random
  5 | from typing import Optional, Dict, Tuple
  6 | 
  7 | 
  8 | class DebateEnv(ta.Env):
  9 |     
 10 |     def __init__(
 11 |         self,
 12 |         max_turns: Optional[int] = 4,
 13 |         judge_class: ta.JudgeVote = ta.game_makers.GPTJudgeVote,
 14 |         num_judges: Optional[int] = 11,
 15 |         topics_path: Optional[str] = None,
 16 |     ):
 17 |         
 18 |         assert max_turns%2==0, \
 19 |             f"Please use an even number of max turns. Current max_turns: {max_turns}"
 20 | 
 21 |         
 22 |         self._load_topics(topics_path)
 23 | 
 24 |         
 25 |         self.judge = judge_class(
 26 |             num_judges=num_judges,
 27 |             options=["Affirmative", "Negative"]
 28 |         )
 29 | 
 30 |         
 31 |         self.state = ta.State(
 32 |             num_players=2,
 33 |             max_turns=max_turns,
 34 |             render_keys=["topic", "sides", "votes"]
 35 |         )
 36 | 
 37 |     def _load_topics(self, topics_path: Optional[str]):
 38 |         
 39 |         if topics_path is None:
 40 |             topics_path = os.path.join(
 41 |                 "textarena", "envs", "two_player", "Debate", "topics.json"
 42 |             )
 43 | 
 44 |         if not os.path.exists(topics_path):
 45 |             raise FileNotFoundError(f"Debate topics file not found at {topics_path}")
 46 | 
 47 |         with open(topics_path, "r", encoding="utf-8") as f:
 48 |             data = json.load(f)
 49 | 
 50 |         if "topics" not in data or not isinstance(data["topics"], list):
 51 |             raise ValueError(
 52 |                 "Invalid format for debate topics JSON. Expected a key 'topics' with a list of topics."
 53 |             )
 54 | 
 55 |         self.topics = data["topics"]
 56 |         if not self.topics:
 57 |             raise ValueError("Debate topics list is empty.")
 58 |     
 59 |     def reset(
 60 |         self, seed: Optional[int] = None
 61 |     ) -> Optional[ta.Observations]:
 62 |         
 63 |         if seed is not None:
 64 |             random.seed(seed)
 65 |         else:
 66 |             random.seed()
 67 | 
 68 |         
 69 |         affirmative_player_id = random.choice([0, 1])
 70 |         game_state = {
 71 |             "arguments": {0: [], 1:[]},
 72 |             "topic": random.choice(self.topics), 
 73 |             "sides": {
 74 |                 affirmative_player_id: "Affirmative", 
 75 |                 1-affirmative_player_id: "Negative"
 76 |             },
 77 |             "votes": {
 78 |                 "pre-debate": {"Affirmative": 0, "Negative": 0},
 79 |                 "post-debate": {"Affirmative": 0, "Negative": 0}
 80 |             }
 81 |         }
 82 | 
 83 |         game_state["votes"]["pre-debate"] = self._evaluate_debate(
 84 |             topic=game_state["topic"],
 85 |             debate_transcript=None,
 86 |         )
 87 | 
 88 |         return self.state.reset(
 89 |             game_state=game_state,
 90 |             player_prompt_function=self._generate_player_prompt,
 91 |         )
 92 | 
 93 | 
 94 |     def _generate_player_prompt(self, player_id: int) -> str:
 95 |         
 96 |         prompt = (
 97 |             f"You are Player {player_id} in the Debate game.\n"
 98 |             f"Topic: {self.state.game_state['topic']}\n"
 99 |             f"Your position: {self.state.game_state['sides'][player_id]}\n"
100 |             f"You will have {self.state.max_turns} turns to present your arguments.\n"
101 |             "On your turn, simply type your argument."
102 |         )
103 |         return prompt 
104 | 
105 |     def _evaluate_debate(
106 |         self, 
107 |         topic: str, 
108 |         debate_transcript: Optional[str]=None
109 |     ) -> Dict[str, int]:
110 |         
111 |         prompt = f"Debate Topic: {topic}\n"
112 |         if debate_transcript:
113 |             prompt += f"Debate Transcript:\n{debate_transcript}\n"
114 |             prompt += "Based on the debate, please vote for either 'Affirmative' or 'Negative'. Provide only the side you vote for."
115 |         else:
116 |             prompt += "No debate has occurred yet. Please vote for either 'Affirmative' or 'Negative' based solely on the topic. Provide only the side you vote for."
117 | 
118 |         votes = self.judge.evaluate(
119 |             context=prompt
120 |         )
121 |         return votes
122 | 
123 |     def step(
124 |         self,
125 |         player_id: int,
126 |         action: str,
127 |     ) -> Tuple[
128 |         Optional[ta.Observations], 
129 |         Optional[ta.Rewards], 
130 |         bool, 
131 |         bool, 
132 |         ta.Info, 
133 |     ]:
134 |         
135 |         
136 |         self.state.check_action_format(
137 |             action=action,
138 |             player_id=player_id
139 |         )
140 | 
141 |         
142 |         self.state.add_observation(
143 |             from_id=player_id,
144 |             to_id=-1, 
145 |             message=action,
146 |             for_logging=True
147 |         )
148 | 
149 |         
150 |         self.state.game_state["arguments"][player_id].append(action)
151 | 
152 | 
153 |         
154 |         if self.state.turn >= self.state.max_turns-1: 
155 |             winner_id = self._determine_debate_winner()
156 |             if winner_id is None:
157 |                 
158 |                 self.state.set_draw(reason="The judges' opinions did not change.")
159 |             else:
160 |                 self.state.set_winners(
161 |                     player_ids=[winner_id],
162 |                     reason=f"Player {winner_id} wins by convincing the judges."
163 |                 )
164 | 
165 |         return self.state.step()
166 | 
167 |     def _determine_debate_winner(self) -> Optional[int]:
168 |         
169 |         
170 |         debate_transcript = ""
171 |         for i in range(len(self.state.game_state["arguments"][0])):
172 |             if i < len(self.state.game_state["arguments"][0]):
173 |                 debate_transcript += f"Player 0 ({self.state.game_state['sides'][0]}): {self.state.game_state['arguments'][0][i]}\n"
174 |             if i < len(self.state.game_state["arguments"][1]):
175 |                 debate_transcript += f"Player 1 ({self.state.game_state['sides'][1]}): {self.state.game_state['arguments'][1][i]}\n"
176 | 
177 |         
178 |         self.state.game_state["votes"]["post-debate"] = self._evaluate_debate(
179 |             topic=self.state.game_state["topic"],
180 |             debate_transcript=debate_transcript
181 |         )
182 | 
183 |         
184 |         gain_affirmative = (
185 |             self.state.game_state["votes"]["post-debate"]["Affirmative"]
186 |             - self.state.game_state["votes"]["pre-debate"]["Affirmative"]
187 |         )
188 |         gain_negative = (
189 |             self.state.game_state["votes"]["post-debate"]["Negative"]
190 |             - self.state.game_state["votes"]["pre-debate"]["Negative"]
191 |         )
192 | 
193 |         
194 |         if gain_affirmative > gain_negative:
195 |             winner_side = "Affirmative"
196 |         elif gain_negative > gain_affirmative:
197 |             winner_side = "Negative"
198 |         else:
199 |             winner_side = None  
200 | 
201 |         if winner_side:
202 |             winner_id = [
203 |                 pid
204 |                 for pid, side in self.state.game_state["sides"].items()
205 |                 if side == winner_side
206 |             ][0]
207 |         else:
208 |             winner_id = None 
209 | 
210 |         return winner_id 
211 | 
212 |     def render(self):
213 |         
214 |         print(f"Turn: {self.state.turn}/{self.max_turns * 2}")
215 |         print(f"Topic: {self.state.game_state['topic']}")
216 |         print(f"Player Sides: {self.state.game_state['sides']}")
217 |         print("\nGame Logs:")
218 |         for sender_id, message in self.state.logs:
219 |             if sender_id == ta.GAME_ID:
220 |                 print(f"[GAME]: {message}")
221 |             else:
222 |                 print(f"[Player {sender_id}]: {message}")
223 |         print("\n")
```

## File: textarena/envs/two_player/Debate/topics.json

- Extension: .json
- Language: json
- Size: 6193 bytes
- Created: 2024-10-22 17:29:45
- Modified: 2024-10-22 17:29:45

### Code

```json
  1 | {
  2 |     "topics": [
  3 |       "Should social media platforms be regulated by the government?",
  4 |       "Does artificial intelligence pose a threat to human employment?",
  5 |       "Should the voting age be lowered to 16?",
  6 |       "Is climate change the most critical issue humanity faces today?",
  7 |       "Should universal basic income be implemented in all countries?",
  8 |       "Is space exploration a worthwhile investment?",
  9 |       "Should education be free for all citizens?",
 10 |       "Is privacy more important than national security?",
 11 |       "Should animal testing be banned for all industries?",
 12 |       "Is globalization beneficial for most countries?",
 13 |       "Should countries adopt open border policies?",
 14 |       "Is nuclear energy a viable solution for the global energy crisis?",
 15 |       "Should drug use be decriminalized?",
 16 |       "Does the gig economy benefit workers?",
 17 |       "Should the minimum wage be increased?",
 18 |       "Is cryptocurrency a sustainable financial model?",
 19 |       "Should governments enforce mandatory vaccinations for public health?",
 20 |       "Is wealth inequality a threat to democracy?",
 21 |       "Should there be stricter regulations on gun ownership?",
 22 |       "Is nationalism more harmful than beneficial in today’s world?",
 23 |       "Is space exploration more important than solving problems on Earth?",
 24 |       "Is the global refugee crisis a threat to national security?",
 25 |       "Should voting be mandatory for all eligible citizens?",
 26 |       "Is capitalism inherently exploitative?",
 27 |       "Are universal basic income programs economically sustainable in the long term?",
 28 |       "Is it ethical to genetically modify human embryos?",
 29 |       "Should governments ban the use of fossil fuels?",
 30 |       "Are traditional gender roles still relevant in modern society?",
 31 |       "Should government surveillance be limited to protect privacy?",
 32 |       "Is cancel culture a threat to free speech?",
 33 |       "Is it moral to eat meat?",
 34 |       "Should euthanasia be legalized for terminally ill patients?",
 35 |       "Is democracy the best form of government?",
 36 |       "Is higher education worth the cost?",
 37 |       "Is automation more of an opportunity than a threat to workers?",
 38 |       "Should governments regulate the prices of essential drugs?",
 39 |       "Should nations be held to the same environmental standards?",
 40 |       "Is patriotism a positive force in modern society?",
 41 |       "Should internet access be considered a fundamental human right?",
 42 |       "Should school uniforms be mandatory in public schools?",
 43 |       "Is the pursuit of happiness more important than wealth?",
 44 |       "Should non-citizens have voting rights in certain elections?",
 45 |       "Should developed nations prioritize their own citizens over refugees?",
 46 |       "Is it ethical for companies to track online behavior for advertising?",
 47 |       "Should college athletes be paid?",
 48 |       "Should companies be required to disclose their environmental impact?",
 49 |       "Is economic inequality inevitable in a free market system?",
 50 |       "Should governments ban violent video games?",
 51 |       "Is space colonization the future of humanity?",
 52 |       "Should the state provide housing for all citizens?",
 53 |       "Is social media addiction a public health issue?",
 54 |       "Should parents have the right to refuse vaccinations for their children?",
 55 |       "Is social justice compatible with free market principles?",
 56 |       "Should countries enforce environmental regulations on corporations?",
 57 |       "Is automation making human labor obsolete?",
 58 |       "Should gig workers be classified as employees?",
 59 |       "Is intellectual property protection good for innovation?",
 60 |       "Should free trade be restricted to protect local industries?",
 61 |       "Is it ethical to use animals for food production?",
 62 |       "Should facial recognition technology be banned in public spaces?",
 63 |       "Is environmental conservation more important than economic growth?",
 64 |       "Should governments impose limits on executive pay?",
 65 |       "Is freedom of speech an absolute right?",
 66 |       "Should inheritance taxes be increased to reduce wealth inequality?",
 67 |       "Is consumerism detrimental to the environment?",
 68 |       "Should the production of single-use plastics be banned?",
 69 |       "Is it ethical for companies to use personal data for profit?",
 70 |       "Should governments fund free public transportation?",
 71 |       "Is healthcare a fundamental human right?",
 72 |       "Should governments prioritize renewable energy over fossil fuels?",
 73 |       "Is the rise of artificial intelligence inevitable?",
 74 |       "Should political lobbying be banned?",
 75 |       "Is direct democracy better than representative democracy?",
 76 |       "Should media companies be held accountable for fake news?",
 77 |       "Is it ethical to patent life-saving medications?",
 78 |       "Should nuclear power plants be phased out?",
 79 |       "Is military spending justified in times of peace?",
 80 |       "Should water be treated as a public good?",
 81 |       "Is urbanization harming biodiversity?",
 82 |       "Should companies have quotas for gender diversity?",
 83 |       "Is climate change caused by human activity?",
 84 |       "Should governments have a say in corporate governance?",
 85 |       "Are cryptocurrencies undermining national financial systems?",
 86 |       "Should advertising to children be banned?",
 87 |       "Is universal healthcare a financially viable system?",
 88 |       "Should big tech companies be subject to antitrust regulations?",
 89 |       "Is wealth redistribution necessary for social justice?",
 90 |       "Should fossil fuel subsidies be eliminated?",
 91 |       "Are digital currencies the future of finance?",
 92 |       "Is the regulation of AI technologies necessary for society's safety?",
 93 |       "Should meat consumption be taxed to combat climate change?",
 94 |       "Is data privacy more important than technological innovation?",
 95 |       "Should the government provide free childcare for working parents?",
 96 |       "Is the pursuit of scientific knowledge more important than ethical concerns?",
 97 |       "Should developing countries adopt a green economy?",
 98 |       "Is the commercialization of space a good idea?",
 99 |       "Should international trade agreements prioritize labor rights?",
100 |       "Is mandatory military service beneficial for society?"
101 |     ]
102 |   }
103 |   
```

## File: textarena/envs/two_player/Debate/README.md

- Extension: .md
- Language: markdown
- Size: 7373 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Debate Environment
  2 | 
  3 | ## Overview
  4 | **Debate** is a two-player game where each player is assigned a side on a given topic—either Affirmative or Negative. Players present arguments in turns to convince a panel of simulated judges. The winner is determined by the change in judges' opinions before and after the debate.
  5 | 
  6 | ## Action Space
  7 | - **Format:** Actions are strings representing the player's arguments.
  8 | - **Example:** `"I believe that technology improves our lives because..."`, `"My opponent overlooks the fact that..."`
  9 | 
 10 | ## Observation Space
 11 | 
 12 | ### Observations
 13 | Each player receives messages exchanged during the debate, including their assigned topic and position.
 14 | 
 15 | **Reset Observation:**
 16 | 
 17 | On reset, each player receives a prompt containing the debate topic, their position, and game instructions. For example:
 18 | ```plaintext
 19 | You are Player {player_id} in the Debate game.
 20 | Topic: {topic}
 21 | Your position: {'Affirmative'|'Negative'}
 22 | You will have {max_turns} turns to present your arguments.
 23 | On your turn, simply type your argument.
 24 | ```
 25 | 
 26 | **Step Observation:**
 27 | After each step, players receive the latest argument. For example:
 28 | ```plaintext
 29 | [Player 0]: While the idea of free education for all citizens sounds appealing, it is important to consider the economic implications and potential drawbacks. Implementing a system of free education would require substantial funding, which would likely result in increased taxes or budget cuts in other critical areas such as healthcare, infrastructure, or social services. This could place a strain on the economy and potentially lead to negative consequences for citizens in other aspects of their lives. Additionally, without the financial investment from students and their families, educational institutions may face challenges in maintaining the quality of education, as they may struggle to attract and retain qualified teachers, update their facilities, and provide necessary resources. Therefore, it is crucial to weigh the economic costs and potential impacts on educational quality before embracing free education for all.
 30 | ```
 31 | 
 32 | ## Gameplay
 33 | - **Players**: 2
 34 | - **Turns**: Players alternate presenting arguments.
 35 | - **Topic Assignment**: A debate topic is randomly selected at the start.
 36 | - **Position Assignment**: One player is randomly assigned the Affirmative side; the other is assigned the Negative side.
 37 | - **Objective**: Convince the judges to change their opinions in favor of your side.
 38 | - **Judges**: A panel of simulated judges evaluates the debate.
 39 | - **Turn Limit**: The number of back and forths before the judges make their decision.
 40 | 
 41 | ## Key Rules
 42 | 1. Debate Structure:
 43 |     - Each player has a set number of turns to present their arguments.
 44 |     - Players alternate turns.
 45 | 2. Judge Evaluation:
 46 |     - **Pre-Debate Vote:** Judges vote based solely on the topic before the debate begins.
 47 |     - **Post-Debate Vote:** Judges vote again after the debate concludes; this time based on the topic and debate transcript.
 48 |     - **Winner Determination:** The player whose side gains the most votes compared to the pre-debate vote wins. If the votes remain unchanged, the game ends in a draw.
 49 | 3. Winning Conditions:
 50 |     - **Win:** Achieve a higher increase in judge votes for your side compared to the opponent.
 51 |     - **Draw:** If both sides gain an equal number of votes, the game ends in a draw.
 52 | 4. Game Termination:
 53 |     - The game ends after all turns are completed and the judges have re-evaluated their votes.
 54 | 
 55 | ## Rewards
 56 | | Outcome          | Reward for Player | Reward for Opponent |
 57 | |------------------|:-----------------:|:-------------------:|
 58 | | **Win**          | `+1`              | `-1`                |
 59 | | **Lose**         | `-1`              | `+1`                |
 60 | | **Draw**         | `0`               | `0`                 |
 61 | 
 62 | ## Parameters
 63 | - `max_turns` (`int`):
 64 |     - **Description**: Number of turns per player
 65 |     - **Impact**: Determines the length of the debate
 66 | 
 67 | - `num_judges` (`int`):
 68 |     - **Description**: Number of simulated judges evaluating the debate.
 69 |     - **Impact**: Affects the granularity of judge opinion changes.
 70 | 
 71 | - `judge_class` (`ta.JudgeVote`)
 72 |     - **Description**: The type of judges used. By default, the `ta.game_makers.GPTJudgeVote` object is used, which utilized a random mix of different openai models.
 73 |     - **Impact:** This will significantly impact what types of arguments work well when trying to convince the judges.
 74 | 
 75 | - `topics_path` (`str`)
 76 |     - **Description:** Path to the JSON file containing debate topics.
 77 |     - **Impact:** Allows customization of the topics used in the debates.
 78 | 
 79 | ## Variants
 80 | 
 81 | | Env-id                   | max_turns | num_judges | judge_class    |
 82 | |--------------------------|:---------:|:----------:|:--------------:|
 83 | | `Debate-v0`              | `6`       | `7`        | `GPTJudgeVote` |
 84 | | `Debate-v0-long`         | `12`      | `11`       | `GPTJudgeVote` |
 85 | | `Debate-v0-super-long`   | `30`      | `15`       | `GPTJudgeVote` |
 86 | 
 87 | 
 88 | ## Example Usage
 89 | 
 90 | ```python
 91 | import textarena as ta
 92 | 
 93 | # Initialize the environment
 94 | env = ta.make(env_id="Debate-v0")
 95 | 
 96 | # Wrap the environment for easier observation handling
 97 | env = ta.wrappers.LLMObservationWrapper(env=env)
 98 | 
 99 | # initalize agents
100 | agents = {
101 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
102 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
103 |     }
104 | 
105 | # reset the environment to start a new game
106 | observations = env.reset(seed=490)
107 | 
108 | # Game loop
109 | done = False
110 | while not done:
111 | 
112 |     # Get the current player
113 |     current_player_id = env.state.get("current_player")
114 | 
115 |     # Get the current observation for the player
116 |     obs = observations[current_player_id]
117 | 
118 |     # Agent decides on an action based on the observation
119 |     action = agents[current_player_id](obs)
120 | 
121 |     # Execute the action in the environment
122 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
123 | 
124 |     # Check if the game has ended
125 |     done = terminated or truncated
126 | 
127 |     # Optionally render the environment to see the current state
128 |     env.render()
129 | 
130 |     if done:
131 |         break
132 | 
133 | # Finally, print the game results
134 | for player_id, agent in agents.items():
135 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
136 | print(f"Reason: {info['reason']}")
137 | ```
138 | 
139 | ## Troubleshooting
140 | - **Uneven Arguments:**
141 |     - **Issue:** One player provides significantly shorter or less substantive arguments.
142 |     - **Solution:** Encourage players to provide well-thought-out arguments within their turn limits.
143 | 
144 | - **Tie in Judge Votes:**
145 |     - **Issue:** Both players achieve the same gain in judge votes, resulting in a draw.
146 |     - **Solution:** Adjust the num_judges parameter to reduce the likelihood of ties.
147 | 
148 | - **Missing Topics File:**
149 |     - **Issue:** The topics JSON file is not found at the specified path.
150 |     - **Solution:** Verify the topics_path and ensure the file exists and is properly formatted.
151 | 
152 | - **Unbalanced Pre-Debate Vote:**
153 |     - **Issue:** All judges vote for one side in the pre-debate vote.
154 |     - **Solution:** We tried filtering out all too polarizing topics. If this still happens, please reach out to Guertlerlo@cfar.a-star.edu.sg, or submit a pull request that removes or adjusts the affected topic.
155 | 
156 | 
157 | ## Version History
158 | - **v0**
159 |   - Initial release 
160 | 
161 | 
162 | 
163 | ### Contact
164 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/LiarsDice/test.py

- Extension: .py
- Language: python
- Size: 6919 bytes
- Created: 2024-11-14 15:02:30
- Modified: 2024-11-14 15:02:30

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | import warnings
  4 | from typing import Dict, List, Optional
  5 | 
  6 | from textarena.envs.two_player.LiarsDice.env import LiarsDiceEnv
  7 | 
  8 | 
  9 | warnings.filterwarnings('ignore', category=UserWarning)
 10 | warnings.filterwarnings('ignore', category=FutureWarning)
 11 | 
 12 | class TestLiarsDiceEnv(unittest.TestCase):
 13 |     
 14 | 
 15 |     
 16 |     test_cases = {
 17 |         "Valid Bids and Successful Bluff Call": {
 18 |             "env_id": "LiarsDice-v0",
 19 |             "actions": [
 20 |                 "[Bid: 2, 3]", "[Bid: 3, 4]", "[Call]"
 21 |             ],
 22 |             "dice_rolls": {0: [2, 3, 5, 1, 4], 1: [4, 2, 6, 5, 1]},
 23 |             "expected_rewards": {0: 1, 1: -1},  
 24 |             "expected_truncated": False,
 25 |             "expected_terminated": True,
 26 |         },
 27 |         "Valid Bids and Unsuccessful Bluff Call": {
 28 |             "env_id": "LiarsDice-v0",
 29 |             "actions": [
 30 |                 "[Bid: 2, 3]", "[Bid: 3, 4]", "[Call]"
 31 |             ],
 32 |             "dice_rolls": {0: [4, 4, 5, 1, 4], 1: [4, 2, 6, 4, 1]},
 33 |             "expected_rewards": {0: -1, 1: 1},  
 34 |             "expected_truncated": False,
 35 |             "expected_terminated": True,
 36 |         },
 37 |         "Invalid Bid Format": {
 38 |             "env_id": "LiarsDice-v0",
 39 |             "actions": ["Invalid action"],
 40 |             "dice_rolls": {0: [2, 3, 5, 1, 4], 1: [4, 2, 6, 5, 1]},
 41 |             "expected_rewards": {0: -1, 1: 0},  
 42 |             "expected_truncated": False,
 43 |             "expected_terminated": True,
 44 |         },
 45 |         "Invalid Bluff Call without Prior Bid": {
 46 |             "env_id": "LiarsDice-v0",
 47 |             "actions": ["[Call]"],
 48 |             "dice_rolls": {0: [2, 3, 5, 1, 4], 1: [4, 2, 6, 5, 1]},
 49 |             "expected_rewards": {0: -1, 1: 0},  
 50 |             "expected_truncated": False,
 51 |             "expected_terminated": True,
 52 |         },
 53 |         "Bids Increasing Correctly and Valid Final Call": {
 54 |             "env_id": "LiarsDice-v0",
 55 |             "actions": [
 56 |                 "[Bid: 2, 2]", "[Bid: 2, 3]", "[Bid: 3, 3]", "[Call]"
 57 |             ],
 58 |             "dice_rolls": {0: [2, 3, 2, 1, 5], 1: [3, 2, 3, 4, 3]},
 59 |             "expected_rewards": {0: 1, 1: -1},  
 60 |             "expected_truncated": False,
 61 |             "expected_terminated": True,
 62 |         },
 63 |         "Incorrect Bid increase": {
 64 |             "env_id": "LiarsDice-v0",
 65 |             "actions": [
 66 |                 "[Bid: 2, 2]", "[Bid: 3, 1]"
 67 |             ],
 68 |             "dice_rolls": {0: [2, 3, 2, 1, 5], 1: [3, 2, 3, 4, 3]},
 69 |             "expected_rewards": {0: 0, 1: -1},  
 70 |             "expected_truncated": False,
 71 |             "expected_terminated": True,
 72 |         },
 73 |         "Incorrect Bid increase 2": {
 74 |             "env_id": "LiarsDice-v0",
 75 |             "actions": [
 76 |                 "[Bid: 2, 2]", "[Bid: 1, 3]"
 77 |             ],
 78 |             "dice_rolls": {0: [2, 3, 2, 1, 5], 1: [3, 2, 3, 4, 3]},
 79 |             "expected_rewards": {0: 0, 1: -1},  
 80 |             "expected_truncated": False,
 81 |             "expected_terminated": True,
 82 |         },
 83 |     }
 84 | 
 85 |     @parameterized.expand([
 86 |         (
 87 |             name,
 88 |             details["env_id"],
 89 |             details["actions"],
 90 |             details["dice_rolls"],
 91 |             details["expected_rewards"],
 92 |             details["expected_truncated"],
 93 |             details["expected_terminated"]
 94 |         )
 95 |         for name, details in test_cases.items()
 96 |     ])
 97 |     def test_liars_dice_env_outcomes(
 98 |         self,
 99 |         name: str,
100 |         env_id: str,
101 |         actions: List[str],
102 |         dice_rolls: Dict[int, List[int]],
103 |         expected_rewards: Optional[Dict[int, int]],
104 |         expected_truncated: bool,
105 |         expected_terminated: bool
106 |     ):
107 |         
108 |         with self.subTest(test_case=name):
109 |             try:
110 |                 
111 |                 env = LiarsDiceEnv()
112 |             except Exception as e:
113 |                 self.fail(f"Failed to initialize environment '{env_id}': {e}")
114 | 
115 |             try:
116 |                 
117 |                 env.reset(seed=42)
118 |                 
119 |                 env.state.game_state["dice_rolls"] = dice_rolls
120 |             except Exception as e:
121 |                 self.fail(f"Failed to reset the environment '{env_id}': {e}")
122 | 
123 |             
124 |             terminated = False
125 |             truncated = False
126 | 
127 |             for i, action in enumerate(actions):
128 |                 player_id = i % 2
129 | 
130 |                 try:
131 |                     
132 |                     step_result = env.step(player_id, action)
133 |                     if len(step_result) != 5:
134 |                         self.fail(f"env.step() returned {len(step_result)} elements, expected 5.")
135 |                     observations, rewards, truncated, terminated, info = step_result
136 |                 except Exception as e:
137 |                     self.fail(f"env.step() raised an unexpected exception for player {player_id}: {e}")
138 | 
139 |                 if terminated or truncated:
140 |                     break
141 | 
142 |             
143 |             self.assertEqual(
144 |                 rewards,
145 |                 expected_rewards,
146 |                 f"The rewards did not match. Expected {expected_rewards}; received {rewards}"
147 |             )
148 | 
149 |             self.assertEqual(
150 |                 terminated,
151 |                 expected_terminated,
152 |                 f"Terminated flag mismatch. Expected {expected_terminated}; received {terminated}"
153 |             )
154 | 
155 |             self.assertEqual(
156 |                 truncated,
157 |                 expected_truncated,
158 |                 f"Truncated flag mismatch. Expected {expected_truncated}; received {truncated}"
159 |             )
160 | 
161 | 
162 | 
163 | if __name__ == '__main__':
164 |     unittest.main()
```

## File: textarena/envs/two_player/LiarsDice/env.py

- Extension: .py
- Language: python
- Size: 9329 bytes
- Created: 2024-11-14 15:02:25
- Modified: 2024-11-14 15:02:25

### Code

```python
  1 | import random
  2 | import re
  3 | from typing import Any, Dict, Optional, Tuple, List
  4 | 
  5 | import textarena as ta
  6 | 
  7 | 
  8 | class LiarsDiceEnv(ta.Env):
  9 |     
 10 | 
 11 |     def __init__(
 12 |         self,
 13 |         num_dice: Optional[int] = 5,
 14 |     ):
 15 |         
 16 |         self.environment_name = "Liar's Dice"
 17 |         self.num_dice = num_dice
 18 | 
 19 |         
 20 |         self.state = ta.State(
 21 |             num_players=2,
 22 |             max_turns=None,  
 23 |             render_keys=[
 24 |                 ["dice_rolls", 0],
 25 |                 ["dice_rolls", 1],
 26 |             ]
 27 |         )
 28 | 
 29 |         
 30 |         self.bid_pattern = re.compile(r"\[bid:\s*(\d+),\s*(\d+)\]", re.IGNORECASE)
 31 |         self.call_pattern = re.compile(r"\[call\]", re.IGNORECASE)
 32 | 
 33 |     def reset(
 34 |         self, seed: Optional[int] = None
 35 |     ) -> Optional[ta.Observations]:
 36 |         
 37 |         if seed is not None:
 38 |             random.seed(seed)
 39 |         else:
 40 |             random.seed()
 41 | 
 42 |         
 43 |         game_state = {
 44 |             "current_bid": {"quantity": 0, "face_value": 0},
 45 |             "dice_rolls": {
 46 |                 0: [random.randint(1, 6) for _ in range(self.num_dice)],
 47 |                 1: [random.randint(1, 6) for _ in range(self.num_dice)],
 48 |             },
 49 |         }
 50 | 
 51 |         return self.state.reset(
 52 |             game_state=game_state,
 53 |             player_prompt_function=self._generate_player_prompt
 54 |         )
 55 | 
 56 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[int, Any]) -> str:
 57 |         
 58 |         dice = game_state["dice_rolls"][player_id]
 59 |         prompt = (
 60 |             f"You are Player {player_id} in Liar's Dice.\n"
 61 |             f"You have rolled {self.num_dice} dice: {', '.join(map(str, dice))}.\n"
 62 |             "Players take turns making bids on the total quantity of a face value among all dice.\n"
 63 |             "On your turn, you can either make a higher bid or call the opponent's bluff.\n"
 64 |             "Actions:\n"
 65 |             "- To make a bid: '[Bid: <quantity>, <face_value>]', e.g., '[Bid: 3, 4]'\n"
 66 |             "- To call a bluff: '[Call]'\n"
 67 |             "If you call a bluff, all dice are revealed:\n"
 68 |             "- If the actual quantity of the face value is less than the bid, you win.\n"
 69 |             "- If the actual quantity meets or exceeds the bid, you lose.\n"
 70 |             f"The current bid is: Quantity = 0, Face Value = 0\n"
 71 |             "It's your turn. What is your action?"
 72 |         )
 73 |         return prompt
 74 | 
 75 |     def step(
 76 |         self,
 77 |         player_id: int,
 78 |         action: str,
 79 |     ) -> Tuple[
 80 |         Optional[Dict[int, str]],  
 81 |         Optional[Dict[int, int]],  
 82 |         bool,  
 83 |         bool,  
 84 |         Dict[str, Any],  
 85 |     ]:
 86 |         
 87 |         
 88 |         self.state.check_action_format(
 89 |             action=action,
 90 |             player_id=player_id
 91 |         )
 92 | 
 93 | 
 94 |         
 95 |         self.state.add_observation(
 96 |             from_id=player_id,
 97 |             to_id=-1,  
 98 |             message=action,
 99 |             for_logging=True
100 |         )
101 | 
102 |         
103 |         bid_match = self.bid_pattern.search(action)
104 |         if bid_match:
105 |             new_quantity = int(bid_match.group(1))
106 |             new_face_value = int(bid_match.group(2))
107 | 
108 |             
109 |             current_bid = self.state.game_state["current_bid"]
110 |             if self._is_valid_bid(new_quantity, new_face_value, current_bid):
111 |                 
112 |                 self.state.game_state["current_bid"] = {
113 |                     "quantity": new_quantity,
114 |                     "face_value": new_face_value
115 |                 }
116 |                 
117 |                 self.state.add_observation(
118 |                     from_id=ta.GAME_ID,
119 |                     to_id=-1,  
120 |                     message=f"Player {player_id} increases the bid to Quantity = {new_quantity}, Face Value = {new_face_value}",
121 |                     for_logging=True
122 |                 )
123 | 
124 |             else:
125 |                 
126 |                 self.state.set_invalid_move(
127 |                     player_ids=[player_id],
128 |                     reasons=[f"Invalid bid by Player {player_id}: Quantity = {new_quantity}, Face Value = {new_face_value}."]
129 |                 )
130 | 
131 |         
132 |         elif self.call_pattern.search(action):
133 |             
134 |             if self.state.turn == 0:
135 |                 self.state.set_invalid_move(
136 |                     player_ids=[player_id],
137 |                     reasons=[f"Player {player_id} tried to call without a bid having been made by anybody."]
138 |                 )
139 |             else:
140 |                 current_bid = self.state.game_state["current_bid"]
141 |                 total_quantity = sum(
142 |                     dice.count(current_bid["face_value"])
143 |                     for dice in self.state.game_state["dice_rolls"].values()
144 |                 )
145 |                 bid_quantity = current_bid["quantity"]
146 | 
147 |                 
148 |                 if total_quantity < bid_quantity:
149 |                     
150 |                     self.state.set_winners(
151 |                         player_ids=[player_id],
152 |                         reason=(
153 |                             f"Bluff called by Player {player_id}. "
154 |                             f"Actual quantity of face value {current_bid['face_value']} is {total_quantity}, "
155 |                             f"which is less than the bid ({bid_quantity}). "
156 |                             f"Player {player_id} wins."
157 |                         )
158 |                     )
159 | 
160 |                 else:
161 |                     
162 |                     self.state.set_winners(
163 |                         player_ids=[1-player_id],
164 |                         reason=(
165 |                             f"Bluff called by Player {player_id}. "
166 |                             f"Actual quantity of face value {current_bid['face_value']} is {total_quantity}, "
167 |                             f"which meets or exceeds the bid ({bid_quantity}). "
168 |                             f"Player {player_id} loses."
169 |                         )
170 |                     )
171 | 
172 |         else:
173 |             
174 |             self.state.set_invalid_move(
175 |                 player_ids=[player_id],
176 |                 reasons=[f"Invalid action by Player {player_id}: '{action}'. Must use '[Bid: <quantity>, <face_value>]' or '[Call]'."]
177 |             )
178 | 
179 |         return self.state.step()
180 | 
181 |     def _is_valid_bid(self, new_quantity: int, new_face_value: int, current_bid: Dict[str, int]) -> bool:
182 |         
183 |         if new_quantity < current_bid["quantity"]:
184 |             return False
185 |         if new_face_value < current_bid["face_value"]:
186 |             return False
187 |         if new_quantity == current_bid["quantity"] and new_face_value <= current_bid["face_value"]:
188 |             return False
189 |         if new_face_value == current_bid["face_value"] and new_quantity <= current_bid["quantity"]:
190 |             return False 
191 |         if not (1 <= new_face_value <= 6):
192 |             return False
193 |         return True
194 | 
195 |     def render(self):
196 |         
197 |         current_bid = self.state.game_state["current_bid"]
198 |         print(f"Turn: {self.state.game_state.get('turn', 'N/A')}")
199 |         print(f"Current Bid: Quantity = {current_bid['quantity']}, Face Value = {current_bid['face_value']}")
200 |         print("\nGame Logs:")
201 |         for sender_id, message in self.state.game_state.get("logs", []):
202 |             if sender_id == "GAME":
203 |                 print(f"[GAME]: {message}")
204 |             else:
205 |                 print(f"Player {sender_id}: {message}")
206 |         print("\n")
```

## File: textarena/envs/two_player/LiarsDice/README.md

- Extension: .md
- Language: markdown
- Size: 7672 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Liar's Dice Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | **Liar's Dice** is a classic two-player bluffing game where each participant rolls a set number of dice, keeping their results hidden from their opponent. Players take turns making bids on the total number of dice showing a particular face value among all dice rolled. The objective is to either accurately bid based on your understanding of probabilities or to bluff convincingly to make your opponent doubt the validity of your bid. The game concludes when a bluff is called, determining the winner based on the accuracy of the bid.
  6 | 
  7 | ## Action Space
  8 | 
  9 | - **Format:** Actions are strings representing either a bid or a challenge.
 10 | - **Special Tokens:**
 11 |     - **[Bid]:** To make a bid on the total number of dice showing a specific face value.
 12 |         - **Format:** `[Bid] <quantity> <face_value>`
 13 |         - **Example:** `[Bid] 3 4`
 14 |     - **[Call]:** To challenge the opponent's bluff.
 15 |         - **Format:** `[Call]`
 16 | - **Examples:**
 17 |     - `"I believe there are at least [Bid] 2 5 in total."`
 18 |     - `"Based on my roll, I will [Bid] 3 3."`
 19 |     - `"That's a bold claim. I choose to [Call]."`
 20 | - **Notes:**    
 21 |     - Players can include additional text before or after the special tokens.
 22 |     - Each action must contain only one of the special tokens (`[Bid]` or `[Call]`).
 23 |     - The tokens `[Bid]` and `[Call]` are case-insensitive and can appear anywhere within the action string.
 24 |     - Ensure that `[Bid]` is followed by two integers representing the quantity and the face value respectively.
 25 | 
 26 | 
 27 | 
 28 | ## Observation Space
 29 | 
 30 | ### Observations
 31 | 
 32 | Players receive a series of messages exchanged during the game, including their own dice rolls, current bids, and actions taken by both players. This information aids in making informed decisions about whether to bid higher or call a bluff.
 33 | 
 34 | **Reset Observation:**
 35 | 
 36 | On reset, each player receives a prompt detailing their initial dice rolls and instructions on how to interact within the game. For example:
 37 | ```plaintext
 38 | [GAME]: Game started.
 39 | You are Player 0 in Liar's Dice.
 40 | You have rolled 3, 5, 2, 6, 1.
 41 | Players take turns making bids on the total quantity of a face value among all dice.
 42 | On your turn, you can either make a higher bid or call the opponent's bluff.
 43 | Actions:
 44 | - To make a bid: '[Bid] <quantity> <face_value>', e.g., '[Bid] 3 4'
 45 | - To call a bluff: '[Call]'
 46 | If you call a bluff, all dice are revealed:
 47 | - If the actual quantity of the face value is less than the bid, you win.
 48 | - If the actual quantity meets or exceeds the bid, you lose.
 49 | The current bid is: Quantity = 0, Face Value = 0
 50 | It's your turn. What is your action?
 51 | ```
 52 | 
 53 | **Step Observation:**
 54 | After each step, players receive updates about bids and actions taken. For example:
 55 | ```plaintext
 56 | Player 1: I believe there are at least [Bid] 2 5 in total.
 57 | [GAME]: Player 1 increases the bid to Quantity = 2, Face Value = 5.
 58 | 
 59 | ```
 60 | 
 61 | ## Gameplay
 62 | - **Players**: 2
 63 | - **Turns**: Players alternate making bids or calling bluffs.
 64 | - **Objective**: Accurately bid the number of dice showing a specific face value or bluff to make the opponent doubt the bid.
 65 | - **Turn Limit**: The game ends when a bluff is called; alternatively, it can be configured with a maximum number of turns, after which the player with the highest valid bid wins.
 66 | 
 67 | ## Key Rules
 68 | 1. Bidding Mechanics:
 69 |     - Players take turns making bids on the total number of dice showing a particular face value among all dice rolled.
 70 |     - A valid bid must either increase the quantity or, if the quantity is the same, increase the face value.
 71 |     - Example: If the current bid is `[Bid] 2 3`, the next bid must be at least `[Bid] 2 4` or `[Bid] 3 1`
 72 | 
 73 | 2. Calling a Bluff:
 74 |     - Instead of making a bid, a player can challenge the opponent's bid by using the `[Call]` token.
 75 |     - When a bluff is called, all dice are revealed:
 76 |         - **If the actual quantity of the bid face value is less than the bid**, the challenger wins.
 77 |         - **If the actual quantity meets or exceeds the bid**, the challenger loses.
 78 | 
 79 | 3. Valid Actions:
 80 |     - All actions must be strings containing either `[Bid] <quantity> <face_value>` or `[Call]`.
 81 |     - Only one action token is allowed per turn.
 82 |     - Actions can include additional natural language text but must contain exactly one valid action token.
 83 | 
 84 | 4. Winning Conditions:
 85 |     - **Win:** Successfully calling a bluff when the actual quantity is less than the bid.
 86 |     - **Loss:** Failing to call a bluff when the actual quantity meets or exceeds the bid.
 87 | 
 88 | 5. Invalid Moves:
 89 |     - Making a bid that does not increase the quantity or face value appropriately.
 90 |     - Including multiple action tokens in a single action string.
 91 |     - Calling a bluff when no bid has been made.
 92 |     - Any action that does not conform to the `[Bid] <quantity> <face_value>` or `[Call]` format.
 93 | 
 94 | 
 95 | ## Rewards
 96 | 
 97 | | Outcome          | Reward for Player | Reward for Opponent |
 98 | |------------------|:-----------------:|:-------------------:|
 99 | | **Win**          | `+1`              | `-1`                |
100 | | **Lose**         | `-1`              | `+1`                |
101 | | **Invalid Move** | `-1`              |  `0`                |
102 | 
103 | 
104 | ## Parameters
105 | 
106 | - `num_dice` (`int`):
107 |     - **Description**: Specifies the number of dice each player rolls at the start of the game.
108 |     - **Impact**: Determines the initial complexity and variability of the game.
109 | 
110 | 
111 | 
112 | 
113 | ## Variants
114 | 
115 | | Env-id                   | num_dice  |
116 | |--------------------------|:---------:|
117 | | `LiarsDice-v0`           |    `5`    |
118 | | `LiarsDice-v0-large`     |    `12`   |
119 | 
120 | ## Example Usage
121 | 
122 | ```python
123 | import textarena as ta
124 | 
125 | # Initialize the environment
126 | env = ta.make(env_id="LiarsDice-v0")
127 | 
128 | # Wrap the environment for easier observation handling
129 | env = ta.wrappers.LLMObservationWrapper(env=env)
130 | 
131 | # initalize agents
132 | agents = {
133 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
134 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
135 |     }
136 | 
137 | # reset the environment to start a new game
138 | observations = env.reset(seed=490)
139 | 
140 | # Game loop
141 | done = False
142 | while not done:
143 | 
144 |     # Get the current player
145 |     current_player_id = env.state.get("current_player")
146 | 
147 |     # Get the current observation for the player
148 |     obs = observations[current_player_id]
149 | 
150 |     # Agent decides on an action based on the observation
151 |     action = agents[current_player_id](obs)
152 | 
153 |     # Execute the action in the environment
154 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
155 | 
156 |     # Check if the game has ended
157 |     done = terminated or truncated
158 | 
159 |     # Optionally render the environment to see the current state
160 |     env.render()
161 | 
162 |     if done:
163 |         break
164 | 
165 | # Finally, print the game results
166 | for player_id, agent in agents.items():
167 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
168 | print(f"Reason: {info['reason']}")
169 | ```
170 | 
171 | ## Troubleshooting
172 | 
173 | - **Invalid Action Format:**
174 |     - **Issue:** Player makes an action that doesn't contain exactly one `[Bid] <quantity> <face_value>` or `[Call]` token.
175 |     - **Solution:** Ensure that each action string contains only one of the special tokens and follows the correct format. For example, avoid including multiple `[Bid]` or `[Call]` tokens in a single action.
176 | 
177 | - **Invalid Bid Parameters:**
178 |     - **Issue:** Player makes a bid that does not increase the quantity or face value appropriately.
179 |     - **Solution:** Verify that each new bid increases either the quantity or, if the quantity remains the same, the face value compared to the current bid.
180 | 
181 | 
182 | ## Version History
183 | - **v0**
184 |   - Initial release 
185 | 
186 | 
187 | 
188 | ### Contact
189 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/SpellingBee/test.py

- Extension: .py
- Language: python
- Size: 8579 bytes
- Created: 2024-11-18 17:36:34
- Modified: 2024-11-18 17:36:34

### Code

```python
  1 | from textarena.envs.two_player.SpellingBee.env import SpellingBeeEnv
  2 | 
  3 | import warnings
  4 | import unittest
  5 | from parameterized import parameterized
  6 | from typing import Dict, List, Optional, Any
  7 | 
  8 | 
  9 | 
 10 | warnings.filterwarnings('ignore', category=UserWarning)
 11 | warnings.filterwarnings('ignore', category=FutureWarning)
 12 | 
 13 | 
 14 | class TestSpellingBeeEnv(unittest.TestCase):
 15 |     
 16 | 
 17 |     test_cases = {
 18 |         "Valid Words Same Length": {
 19 |             "config": {"num_letters": 5},
 20 |             "allowed_letters": {"a", "b", "c", "d", "e"},
 21 |             "actions": ["[bed]", "[ace]"],
 22 |             "expected_state": {
 23 |                 "player_words": {0: "[bed]", 1: "[ace]"},
 24 |             },
 25 |             "expected_rewards": {0: 0, 1: 0},  
 26 |             "expected_terminated": True,
 27 |         },
 28 |         "Valid Words Different Length": {
 29 |             "config": {"num_letters": 5},
 30 |             "allowed_letters": {"a", "b", "c", "d", "e"},
 31 |             "actions": ["[bead]", "[ace]"],
 32 |             "expected_state": {
 33 |                 "player_words": {0: "[bead]", 1: "[ace]"},
 34 |             },
 35 |             "expected_rewards": {0: 1, 1: -1},  
 36 |             "expected_terminated": True,
 37 |         },
 38 |         "Invalid Word Format": {
 39 |             "config": {"num_letters": 5},
 40 |             "allowed_letters": {"a", "b", "c", "d", "e"},
 41 |             "actions": ["bead", "[ace]"],  
 42 |             "expected_state": {
 43 |                 "player_words": {0: "bead", 1: "[ace]"},
 44 |             },
 45 |             "expected_rewards": {0: -1, 1: 0},  
 46 |             "expected_terminated": True,
 47 |         },
 48 |         "Invalid Letters Used": {
 49 |             "config": {"num_letters": 5},
 50 |             "allowed_letters": {"a", "b", "c", "d", "e"},
 51 |             "actions": ["[zebra]", "[ace]"],  
 52 |             "expected_state": {
 53 |                 "player_words": {0: "[zebra]", 1: "[ace]"},
 54 |             },
 55 |             "expected_rewards": {0: -1, 1: 0},  
 56 |             "expected_terminated": True,
 57 |         },
 58 |         "Non-English Word": {
 59 |             "config": {"num_letters": 5},
 60 |             "allowed_letters": {"a", "b", "c", "d", "e"},
 61 |             "actions": ["[aaaa]", "[ace]"],  
 62 |             "expected_state": {
 63 |                 "player_words": {0: "[aaaa]", 1: "[ace]"},
 64 |             },
 65 |             "expected_rewards": {0: -1, 1: 0},  
 66 |             "expected_terminated": True,
 67 |         },
 68 |         "Both Players Invalid": {
 69 |             "config": {"num_letters": 5},
 70 |             "allowed_letters": {"a", "b", "c", "d", "e"},
 71 |             "actions": ["[zzz]", "[yyy]"],  
 72 |             "expected_state": {
 73 |                 "player_words": {0: "[zzz]", 1: "[yyy]"},
 74 |             },
 75 |             "expected_rewards": {0: -1, 1: -1},  
 76 |             "expected_terminated": True,
 77 |         }
 78 |     }
 79 | 
 80 |     def setUp(self):
 81 |         
 82 |         self.env = SpellingBeeEnv(num_letters=5)
 83 | 
 84 |     @parameterized.expand([
 85 |         (
 86 |             name,
 87 |             details["config"],
 88 |             details["allowed_letters"],
 89 |             details["actions"],
 90 |             details["expected_state"],
 91 |             details["expected_rewards"],
 92 |             details["expected_terminated"],
 93 |         )
 94 |         for name, details in test_cases.items()
 95 |     ])
 96 |     def test_spelling_bee_scenarios(
 97 |         self,
 98 |         name: str,
 99 |         config: Dict[str, int],
100 |         allowed_letters: set,
101 |         actions: List[str],
102 |         expected_state: Dict[str, Any],
103 |         expected_rewards: Dict[int, int],
104 |         expected_terminated: bool,
105 |     ):
106 |         
107 |         with self.subTest(test_case=name):
108 |             
109 |             env = SpellingBeeEnv(**config)
110 | 
111 |             try:
112 |                 
113 |                 observations = env.reset(seed=42)
114 |                 
115 |                 env.state.game_state["allowed_letters"] = allowed_letters
116 |             except Exception as e:
117 |                 self.fail(f"Failed to reset environment: {e}")
118 | 
119 |             
120 |             terminated = False
121 |             truncated = False
122 |             final_rewards = None
123 | 
124 |             
125 |             for i, action in enumerate(actions):
126 |                 if terminated or truncated:
127 |                     break
128 | 
129 |                 player_id = env.get_current_player_id()
130 |                 try:
131 |                     observations, rewards, truncated, terminated, info = env.step(
132 |                         player_id, action
133 |                     )
134 |                     final_rewards = rewards  
135 |                 except Exception as e:
136 |                     self.fail(f"env.step() failed for player {player_id}: {e}")
137 | 
138 |             
139 |             game_state = env.state.game_state
140 |             for key, expected_value in expected_state.items():
141 |                 self.assertEqual(
142 |                     game_state[key],
143 |                     expected_value,
144 |                     f"State mismatch for {key}. Expected {expected_value}, got {game_state[key]}"
145 |                 )
146 | 
147 |             
148 |             self.assertIsNotNone(final_rewards, "Final rewards should not be None")
149 |             for player_id, expected_reward in expected_rewards.items():
150 |                 self.assertEqual(
151 |                     final_rewards[player_id],
152 |                     expected_reward,
153 |                     f"Reward mismatch for Player {player_id}. Expected {expected_reward}, got {final_rewards[player_id]}"
154 |                 )
155 | 
156 |             
157 |             self.assertEqual(
158 |                 terminated,
159 |                 expected_terminated,
160 |                 f"Termination state mismatch. Expected {expected_terminated}, got {terminated}"
161 |             )
162 | 
163 |     def test_letter_generation(self):
164 |         
165 |         env = SpellingBeeEnv(num_letters=5)
166 |         env.reset(seed=42)
167 |         
168 |         
169 |         self.assertEqual(
170 |             len(env.state.game_state["allowed_letters"]),
171 |             5,
172 |             "Incorrect number of allowed letters"
173 |         )
174 |         
175 |         
176 |         self.assertTrue(
177 |             all(l.islower() for l in env.state.game_state["allowed_letters"]),
178 |             "All letters should be lowercase"
179 |         )
180 |         
181 |         
182 |         self.assertEqual(
183 |             len(env.state.game_state["allowed_letters"]),
184 |             len(set(env.state.game_state["allowed_letters"])),
185 |             "Letters should be unique"
186 |         )
187 | 
188 | 
189 |     def test_word_validation(self):
190 |         
191 |         env = SpellingBeeEnv(num_letters=5)
192 |         env.state.game_state = {"allowed_letters": {"a", "b", "c", "d", "e"}}
193 |         
194 |         
195 |         is_valid, reason, length = env._check_word_validity("[bed]", 0)
196 |         self.assertTrue(is_valid, "Should accept valid word")
197 |         self.assertEqual(length, 3, "Incorrect word length")
198 |         
199 |         
200 |         is_valid, reason, length = env._check_word_validity("[zebra]", 0)
201 |         self.assertFalse(is_valid, "Should reject word with invalid letters")
202 |         
203 |         
204 |         is_valid, reason, length = env._check_word_validity("[aaaa]", 0)
205 |         self.assertFalse(is_valid, "Should reject non-English word")
206 |         
207 |         
208 |         is_valid, reason, length = env._check_word_validity("bed", 0)
209 |         self.assertFalse(is_valid, "Should reject word without brackets")
210 | 
211 | 
212 | if __name__ == '__main__':
213 |     unittest.main()
```

## File: textarena/envs/two_player/SpellingBee/env.py

- Extension: .py
- Language: python
- Size: 9215 bytes
- Created: 2024-11-18 17:57:02
- Modified: 2024-11-18 17:57:02

### Code

```python
  1 | 
  2 | 
  3 | import random
  4 | import re
  5 | import string
  6 | import numpy as np
  7 | from typing import Optional, Tuple, List, Dict, Any
  8 | 
  9 | import textarena as ta
 10 | from textarena import utils
 11 | from nltk.corpus import words
 12 | 
 13 | import enchant
 14 | 
 15 | 
 16 | class SpellingBeeEnv(ta.Env):
 17 |     
 18 | 
 19 |     def __init__(self, num_letters: int):
 20 |         
 21 |         self.environment_name = "Spelling Bee Game"
 22 | 
 23 |         self.num_letters = num_letters
 24 | 
 25 |         
 26 |         self.state = ta.State(
 27 |             num_players=2,
 28 |             max_turns=None,
 29 |         )
 30 | 
 31 |         
 32 |         try:
 33 |             self.word_checker_us = enchant.Dict("en_US")
 34 |             self.word_checker_uk = enchant.Dict("en_GB")
 35 |         except enchant.errors.DictNotFoundError as e:
 36 |             raise ValueError(f"Enchant dictionary not found: {e}. Ensure that the en_US and en_GB dictionaries are installed.")
 37 | 
 38 |         self.board_state_render = ta.envs.two_player.SpellingBee.render.GameStateRender
 39 |     def reset(
 40 |         self, seed: Optional[int] = None
 41 |     ) -> Tuple[Dict[int, List[Tuple[int, str]]], Dict[int, Any]]:
 42 |         
 43 |         if seed is not None:
 44 |             random.seed(seed)
 45 |         else:
 46 |             random.seed()
 47 | 
 48 |         
 49 |         self.allowed_letters = self._generate_allowed_letters()
 50 | 
 51 |         return self.state.reset(
 52 |             game_state={
 53 |                 "allowed_letters": self.allowed_letters,
 54 |                 "player_words": {0: None, 1: None},
 55 |             },
 56 |             player_prompt_function=self._generate_player_prompt
 57 |         )
 58 | 
 59 |     def _generate_allowed_letters(self) -> set:
 60 |         
 61 |         if self.num_letters > 26:
 62 |             raise ValueError("num_letters cannot exceed 26.")
 63 |         return set(random.sample(string.ascii_lowercase, self.num_letters))
 64 | 
 65 |     def _generate_player_prompt(self, player_id: int, game_state: Dict[int, Any]) -> str:
 66 |         
 67 |         prompt = (
 68 |             f"You are Player {player_id} in the Spelling Bee Game.\n"
 69 |             f"Allowed Letters: {''.join(sorted(self.allowed_letters))}\n"
 70 |             "Create the longest possible English word using only the allowed letters. You may use each letter multiple times.\n"
 71 |             "Please wrap your word in square brackets, e.g., '[example]'.\n"
 72 |             "On your turn, simply type your word.\n"
 73 |         )
 74 |         return prompt
 75 | 
 76 | 
 77 |     def get_current_player_id(self):
 78 |         return self.state.current_player
 79 | 
 80 |     def step(
 81 |         self,
 82 |         player_id: int,
 83 |         action: str,
 84 |     ) -> Tuple[
 85 |         Optional[ta.Observations], 
 86 |         Optional[ta.Rewards], 
 87 |         bool, 
 88 |         bool, 
 89 |         ta.Info, 
 90 |     ]:
 91 |         
 92 |         
 93 |         self.state.check_action_format(
 94 |             action=action,
 95 |             player_id=player_id
 96 |         )
 97 | 
 98 |         
 99 |         self.state.add_log(
100 |             from_id=player_id,
101 |             message=action
102 |         )
103 |         
104 | 
105 |         
106 |         
107 |         word = action.strip().lower()
108 |         match = re.search(r"\[(\w+)\]", word)
109 |         if match:
110 |             
111 |             word = match.group(1)
112 |         else:
113 |             word = None
114 | 
115 |         self.state.game_state["player_words"][player_id] = word
116 | 
117 | 
118 |         if all (
119 |             player_action is not None for player_action in self.state.game_state["player_words"].values()
120 |         ):
121 |             
122 |             w0_is_valid, w0_reason, w0_len = self._check_word_validity(
123 |                 word=self.state.game_state["player_words"][0],
124 |                 player_id=0
125 |             )
126 |             w1_is_valid, w1_reason, w1_len = self._check_word_validity(
127 |                 word=self.state.game_state["player_words"][1],
128 |                 player_id=1
129 |             )
130 | 
131 |             if w0_is_valid and w1_is_valid:
132 |                 
133 |                 if w0_len == w1_len:
134 |                     
135 |                     self.state.set_draw(reason="Both words have the same length.")
136 |                 else:
137 |                     
138 |                     winner_id = 0 if w0_len > w1_len else 1
139 |                     self.state.set_winners(
140 |                         player_ids=[winner_id],
141 |                         reason=f"Player {winner_id} won by providing a longer word."
142 |                     )
143 |             
144 |             
145 |             else: 
146 |                 player_ids = np.array([0, 1])
147 |                 reasons = np.array([w0_reason, w1_reason])
148 |                 validity = np.array([w0_is_valid, w1_is_valid])
149 | 
150 |                 self.state.set_invalid_move(
151 |                     player_ids=player_ids[~validity],
152 |                     reasons=reasons[~validity]
153 |                 )
154 | 
155 |         return self.state.step()
156 | 
157 | 
158 | 
159 |     def _evaluate_words(self) -> Dict[str, int]:
160 |         
161 |         word_p0 = self.state.game_state["player_words"][0]
162 |         word_p1 = self.state.game_state["player_words"][1]
163 | 
164 |         
165 |         is_valid_p0, reason_p0 = self._check_word_validity(word_p0)
166 |         is_valid_p1, reason_p1 = self._check_word_validity(word_p1)
167 | 
168 |         votes = {"Player 0": 0, "Player 1": 0}
169 | 
170 |         
171 |         if not is_valid_p0 and not is_valid_p1:
172 |             
173 |             pass  
174 |         elif is_valid_p0 and not is_valid_p1:
175 |             votes["Player 0"] += 1
176 |         elif not is_valid_p0 and is_valid_p1:
177 |             votes["Player 1"] += 1
178 |         else:
179 |             
180 |             len_p0 = len(word_p0)
181 |             len_p1 = len(word_p1)
182 |             if len_p0 > len_p1:
183 |                 votes["Player 0"] += 1
184 |             elif len_p1 > len_p0:
185 |                 votes["Player 1"] += 1
186 |             else:
187 |                 
188 |                 pass
189 | 
190 |         return votes
191 | 
192 |     def _check_word_validity(self, word: str, player_id: int) -> Tuple[bool, Optional[str], Optional[int]]:
193 |         
194 |         allowed_letters = self.state.game_state["allowed_letters"]
195 | 
196 |         
197 |         
198 |         
199 |         
200 |         
201 |         
202 |         if word is None: 
203 |             return False, f"No word was provided by Player {player_id}", None
204 | 
205 | 
206 |         word_letters = set(word)
207 | 
208 | 
209 |         
210 |         if not word_letters.issubset(allowed_letters):
211 |             return False, f"The word by Player {player_id} contains illegal characters.", None
212 | 
213 |         
214 |         is_valid = self.word_checker_us.check(word) or self.word_checker_uk.check(word)
215 |         if not is_valid:
216 |             return False, f"The word by Player {player_id} is not a valid English word.", None
217 | 
218 |         return True, None, len(word)
219 | 
220 |     def render(self):
221 |         
222 |         print("Allowed Letters:")
223 |         print(" ".join(sorted(self.state.game_state["allowed_letters"])))
224 |         print("\nGame Logs:")
225 |         for sender_id, message in self.state.logs:
226 |             if sender_id == ta.GAME_ID:
227 |                 print(f"[GAME]: {message}")
228 |             else:
229 |                 print(f"[Player {sender_id}]: {message}")
230 |         print("\n")
```

## File: textarena/envs/two_player/SpellingBee/render.py

- Extension: .py
- Language: python
- Size: 7241 bytes
- Created: 2024-11-18 18:04:38
- Modified: 2024-11-18 18:04:38

### Code

```python
  1 | import tkinter as tk
  2 | from tkinter import ttk
  3 | from typing import Dict, Optional
  4 | import math
  5 | import re
  6 | 
  7 | 
  8 | class GameStateRender(ttk.Frame):
  9 |     
 10 |     
 11 |     
 12 |     WINDOW_WIDTH = 600
 13 |     WINDOW_HEIGHT = 800
 14 |     LETTER_CELL_SIZE = 40
 15 |     LETTER_FONT_SIZE = 18
 16 |     
 17 |     def __init__(self, master, env, player_names: Optional[Dict[int, str]] = None):
 18 |         
 19 |         super().__init__(master)
 20 |         self.master = master
 21 |         self.env = env
 22 |         self.player_names = player_names or {0: "Player 0", 1: "Player 1"}
 23 |         self.player_colors = {
 24 |             0: '#4A90E2',  
 25 |             1: '#E24A4A'   
 26 |         }
 27 |         
 28 |         
 29 |         self.bg_color = '#2B2B2B'  
 30 |         self.letter_colors = {
 31 |             'bg': '#FFD700',  
 32 |             'fg': '#000000',  
 33 |         }
 34 |         
 35 |         
 36 |         self.master.title("Spelling Bee Game")
 37 |         self.master.geometry(f"{self.WINDOW_WIDTH}x{self.WINDOW_HEIGHT}")
 38 |         self.master.resizable(False, False)
 39 |         self.master.configure(bg=self.bg_color)
 40 |         
 41 |         
 42 |         self.canvas_center_x = self.WINDOW_WIDTH // 2
 43 |         self.canvas_center_y = self.WINDOW_HEIGHT // 4
 44 |         
 45 |         self.create_widgets()
 46 | 
 47 |     def create_widgets(self):
 48 |         
 49 |         
 50 |         self.container = ttk.Frame(self.master)
 51 |         self.container.pack(expand=True, fill='both', padx=20, pady=10)
 52 |         
 53 |         
 54 |         self.title_label = ttk.Label(
 55 |             self.container,
 56 |             text="Spelling Bee",
 57 |             font=('Arial', 20, 'bold'),
 58 |             foreground='white',
 59 |             background=self.bg_color
 60 |         )
 61 |         self.title_label.pack(pady=(0, 10))
 62 |         
 63 |         
 64 |         canvas_size = max(self.WINDOW_WIDTH - 40, self.WINDOW_HEIGHT // 2)
 65 |         self.letters_canvas = tk.Canvas(
 66 |             self.container,
 67 |             height=canvas_size,
 68 |             width=canvas_size,
 69 |             bg=self.bg_color,
 70 |             highlightthickness=0
 71 |         )
 72 |         self.letters_canvas.pack(pady=10)
 73 |         
 74 |         
 75 |         self.letters_canvas.bind('<Configure>', self._update_canvas_center)
 76 |         
 77 |         
 78 |         self.player_frame = ttk.Frame(self.container)
 79 |         self.player_frame.pack(fill='x', pady=10)
 80 |         
 81 |         
 82 |         self.player_info_frames = {}
 83 |         for player_id in [0, 1]:
 84 |             frame = ttk.Frame(self.player_frame)
 85 |             frame.pack(side='left', expand=True, padx=10)
 86 |             
 87 |             
 88 |             label = tk.Label(
 89 |                 frame,
 90 |                 font=('Arial', 12),
 91 |                 fg='white',
 92 |                 bg=self.bg_color
 93 |             )
 94 |             label.pack(pady=5)
 95 |             
 96 |             self.player_info_frames[player_id] = {
 97 |                 'frame': frame,
 98 |                 'label': label
 99 |             }
100 | 
101 |     def _update_canvas_center(self, event=None):
102 |         
103 |         self.canvas_center_x = self.letters_canvas.winfo_width() // 2
104 |         self.canvas_center_y = self.letters_canvas.winfo_height() // 2
105 |         self.draw_board()
106 | 
107 |     def _calculate_hexagon_points(self, center_x: float, center_y: float, size: float) -> list:
108 |         
109 |         points = []
110 |         for i in range(6):
111 |             angle_deg = 60 * i - 30
112 |             angle_rad = math.pi / 180 * angle_deg
113 |             x = center_x + size * math.cos(angle_rad)
114 |             y = center_y + size * math.sin(angle_rad)
115 |             points.extend([x, y])
116 |         return points
117 | 
118 |     def _draw_letter_cell(self, x: float, y: float, letter: str, is_center: bool = False):
119 |         
120 |         points = self._calculate_hexagon_points(x, y, self.LETTER_CELL_SIZE)
121 |         
122 |         self.letters_canvas.create_polygon(
123 |             points,
124 |             fill=self.letter_colors['bg'],
125 |             outline='black',
126 |             width=2
127 |         )
128 |         
129 |         self.letters_canvas.create_text(
130 |             x, y,
131 |             text=letter.upper(),
132 |             font=('Arial', self.LETTER_FONT_SIZE, 'bold' if is_center else 'normal'),
133 |             fill=self.letter_colors['fg']
134 |         )
135 | 
136 |     def draw_board(self):
137 |         
138 |         if not hasattr(self.env.state, "game_state"):
139 |             return
140 |             
141 |         game_state = self.env.state.game_state
142 |         
143 |         
144 |         self.letters_canvas.delete('all')
145 |         
146 |         
147 |         letters = sorted(list(game_state["allowed_letters"]))
148 |         if not letters:
149 |             return
150 |             
151 |         
152 |         num_letters = len(letters)
153 |         if num_letters <= 6:
154 |             
155 |             positions = [
156 |                 (0, -2),      
157 |                 (1.75, -1),   
158 |                 (1.75, 1),    
159 |                 (0, 2),       
160 |                 (-1.75, 1),   
161 |                 (-1.75, -1),  
162 |             ]
163 |         else:
164 |             
165 |             positions = []
166 |             radius = 2  
167 |             for i in range(num_letters):
168 |                 angle = 2 * math.pi * i / num_letters - math.pi/2  
169 |                 x = radius * math.cos(angle)
170 |                 y = radius * math.sin(angle)
171 |                 positions.append((x * 1.75, y))  
172 |         
173 |         
174 |         spacing = self.LETTER_CELL_SIZE * 1.2
175 |         for i, letter in enumerate(letters):
176 |             if i < len(positions):
177 |                 dx, dy = positions[i]
178 |                 x = self.canvas_center_x + dx * spacing
179 |                 y = self.canvas_center_y + dy * spacing
180 |                 self._draw_letter_cell(x, y, letter)
181 |         
182 |         
183 |         for player_id in [0, 1]:
184 |             word = game_state["player_words"].get(player_id)
185 |             label = self.player_info_frames[player_id]['label']
186 |             
187 |             if not word:
188 |                 label.config(text=f"{self.player_names[player_id]}: ---")
189 |             else:
190 |                 label.config(text=f"{self.player_names[player_id]}: {word}")
191 |         
192 |         
193 |         self.update()
```

## File: textarena/envs/two_player/SpellingBee/README.md

- Extension: .md
- Language: markdown
- Size: 5199 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Spelling Bee Environment
  2 | 
  3 | ## Overview
  4 | **Spelling Bee** is a two-player competitive game where each player attempts to create the longest possible valid English word using a given set of allowed letters. Players submit their words simultaneously, and the player with the longer valid word wins. The game emphasizes vocabulary skills and strategic letter usage.
  5 | 
  6 | ## Action Space
  7 | - **Format:** Actions are strings representing the player's proposed word, wrapped in square brackets.
  8 | - **Examples:** 
  9 |     - `"[donkey]"`
 10 |     - `"I think a good word would be [apples]"`
 11 | 
 12 | ## Observation Space
 13 | 
 14 | ### Observations
 15 | **Reset Observation:**
 16 | 
 17 | On reset, each player receives a prompt containing the allowed letters and game instructions. For example:
 18 | ```plaintext
 19 | [GAME]: You are Player 0 in the Spelling Bee Game.
 20 | Allowed Letters: a e l m p s
 21 | Create the longest possible English word using only the allowed letters. You may use each letter multiple times.
 22 | Please wrap your word in square brackets, e.g., '[example]'.
 23 | On your turn, simply type your word.
 24 | ```
 25 | 
 26 | **Step Observation:**
 27 | The game provides no step-based observations. This is to make sure that neither player has an unfair advantage. 
 28 | 
 29 | ## Gameplay
 30 | - **Players**: 2
 31 | - **Turns**: Each player has one turn to submit their word.
 32 | - **Allowed Letters**: A set of unique lowercase letters randomly generated at the start of the game, configurable via the `num_letters` parameter.
 33 | - **Objective**: Submit the longest valid English word possible using the allowed letters.
 34 | - **Rules**:
 35 |     - Words must be composed only of the allowed letters.
 36 |     - Each letter can be used zero, once or multiple times.
 37 |     - Words must be valid English (british or us) words.
 38 |     - Words must be wrapped in square brackets.
 39 | 
 40 | ## Key Rules
 41 | 1. Word Composition:
 42 |     - Only allowed letters can be used.
 43 |     - Each letter can be used multiple times in a word.
 44 | 
 45 | 2. Word Validation:
 46 |     - Words must be recognized as valid English words by standard dictionaries (en_US or en_GB).
 47 | 3. Submission Format:
 48 |     - Words must be enclosed in square brackets, e.g., `[example]`.
 49 | 4. Game Termination:
 50 |     - The game ends after both players have submitted their words and the system has evaluated them
 51 | 
 52 | ## Rewards
 53 | | Outcome          | Reward for Player | Reward for Opponent |
 54 | |------------------|:-----------------:|:-------------------:|
 55 | | **Win**          | `+1`              | `-1`                |
 56 | | **Lose**         | `-1`              | `+1`                |
 57 | | **Draw**         |  `0`              |  `0`                |
 58 | | **Invalid Move** | `-1`              |  `0`                |
 59 | 
 60 | ## Parameters
 61 | - `num_letters` (`int`):
 62 |     - **Description**: Number of unique allowed letters in the game.
 63 |     - **Impact**: Determines the complexity and difficulty of the game. More letters generally allow for longer and more varied words.
 64 | 
 65 | 
 66 | ## Variants
 67 | 
 68 | | Env-id                   | num_letters |
 69 | |--------------------------|:-----------:|
 70 | | `SpellingBee-v0`         |     `6`     |
 71 | | `SpellingBee-v0-small`   |     `4`     |
 72 | | `SpellingBee-v0-large`   |     `10`    |
 73 | 
 74 | 
 75 | ## Example Usage
 76 | 
 77 | ```python
 78 | import textarena as ta
 79 | 
 80 | # Initialize the environment
 81 | env = ta.make(env_id="SpellingBee-v0")
 82 | 
 83 | # Wrap the environment for easier observation handling
 84 | env = ta.wrappers.LLMObservationWrapper(env=env)
 85 | 
 86 | # initalize agents
 87 | agents = {
 88 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o"),
 89 |     1: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
 90 |     }
 91 | 
 92 | # reset the environment to start a new game
 93 | observations = env.reset(seed=490)
 94 | 
 95 | # Game loop
 96 | done = False
 97 | while not done:
 98 | 
 99 |     # Get the current player
100 |     current_player_id = env.state.get("current_player")
101 | 
102 |     # Get the current observation for the player
103 |     obs = observations[current_player_id]
104 | 
105 |     # Agent decides on an action based on the observation
106 |     action = agents[current_player_id](obs)
107 | 
108 |     # Execute the action in the environment
109 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
110 | 
111 |     # Check if the game has ended
112 |     done = terminated or truncated
113 | 
114 |     # Optionally render the environment to see the current state
115 |     env.render()
116 | 
117 |     if done:
118 |         break
119 | 
120 | # Finally, print the game results
121 | for player_id, agent in agents.items():
122 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
123 | print(f"Reason: {info['reason']}")
124 | ```
125 | 
126 | ## Troubleshooting
127 | - **Missing Enchant Dictionaries:**
128 |     - **Issue:** The Enchant library cannot find the required dictionaries (`en_US` and `en_GB`).
129 |     - **Solution:** Install the necessary Enchant dictionaries. On Ubuntu, you can install them using:
130 |     ```bash
131 |     sudo apt-get install enchant
132 |     sudo apt-get install myspell-en-us myspell-en-gb
133 |     ```
134 | 
135 | - **Game Not Terminating Properly:**
136 |     - **Issue:** The game does not end after both players have submitted their words.
137 |     - **Solution:** Check the implementation of the step method to ensure it correctly identifies when both words have been submitted and terminates the game accordingly.
138 | 
139 | 
140 | ## Version History
141 | - **v0**
142 |   - Initial release 
143 | 
144 | 
145 | 
146 | ### Contact
147 | If you have questions or face issues with this specific environment, please reach out directly to Guertlerlo@cfar.a-star.edu.sg
```

## File: textarena/envs/two_player/SpellingBee/__init__.py

- Extension: .py
- Language: python
- Size: 141 bytes
- Created: 2024-11-18 17:38:06
- Modified: 2024-11-18 17:38:06

### Code

```python
1 | from textarena.envs.two_player.SpellingBee.env import SpellingBeeEnv
2 | from textarena.envs.two_player.SpellingBee.render import GameStateRender
```

## File: textarena/envs/single_player/Hangman/test.py

- Extension: .py
- Language: python
- Size: 2742 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.Hangman.env import HangmanEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["[t]", "[h]", "[o]"]  
 9 | 
10 | def generate_invalid_format_sequence():
11 |     
12 |     return ["[1]", "[2]", "[L L]", "[LL]"]  
13 | 
14 | class TestHangmanEnv(unittest.TestCase):
15 | 
16 |     
17 |     env_variants = [
18 |         {"hardcore": False},
19 |         {"hardcore": True}
20 |     ]
21 | 
22 |     
23 |     test_cases = {
24 |         "correct_moves": {
25 |             "hardcore": False,
26 |             "actions": generate_correct_move_sequence()
27 |         },
28 |         "invalid_format": {
29 |             "hardcore": False,
30 |             "actions": generate_invalid_format_sequence()
31 |         }
32 |     }
33 | 
34 |     @parameterized.expand([
35 |         (name, details['hardcore'], details['actions'])
36 |         for name, details in test_cases.items()
37 |     ])
38 |     def test_hangman_outcomes(self, name, hardcore, actions):
39 |         
40 |         env_config = next((env for env in self.env_variants if env['hardcore'] == hardcore), None)
41 |         self.assertIsNotNone(env_config, f"Invalid hardcore level: {hardcore}")
42 | 
43 |         env = HangmanEnv(hardcore=env_config["hardcore"])
44 | 
45 |         observations = env.reset(seed=490)
46 | 
47 |         terminated = False
48 |         truncated = False
49 | 
50 |         for i, action in enumerate(actions):
51 |             if terminated or truncated:
52 |                 break
53 |             player_id = 0
54 |             obs = observations
55 | 
56 |             
57 |             observations, reward, truncated, terminated, info = env.step(player_id, action)
58 | 
59 |             
60 |             if "correct_moves" in name:
61 |                 self.assertFalse(truncated, "Game should not truncate for correct moves.")
62 |                 self.assertFalse(terminated, "Game should not terminate for correct moves.")
63 |             elif "invalid_format" in name:
64 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
65 |                 self.assertEqual(reward[0], -1, "Player should receive -1 for out-of-bounds move.")
66 |             else:
67 |                 self.fail(f"Invalid test case name: {name}")
68 | 
69 |     def run_unit_test():
70 |         print("Running HangmanEnv tests...")
71 |         unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/single_player/Hangman/env.py

- Extension: .py
- Language: python
- Size: 10074 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | from typing import Any, Dict, List, Tuple, Optional, Union
  2 | import copy
  3 | import random
  4 | import textarena as ta
  5 | import re
  6 | 
  7 | 
  8 | import nltk
  9 | from nltk.corpus import words
 10 | nltk.download('words')
 11 | 
 12 | class HangmanEnv(ta.Env):
 13 |     
 14 | 
 15 |     def __init__(
 16 |         self,
 17 |         hardcore: Optional[bool] = False
 18 |     ):
 19 |         
 20 | 
 21 |         super().__init__()
 22 |         self.environment_name = "Hangman"
 23 |         self.hardcore = hardcore
 24 | 
 25 |         
 26 |         self.state = ta.State(
 27 |             num_players=1,
 28 |             render_keys=["rendered_board"],
 29 |         )
 30 | 
 31 |         
 32 |         if hardcore:
 33 |             self.word_list = words.words("en")
 34 |         else:
 35 |             self.word_list = words.words("en-basic")
 36 | 
 37 |     def reset(
 38 |         self,
 39 |         seed: Optional[int] = None
 40 |     ) -> Optional[ta.Observations]:
 41 |         
 42 | 
 43 |         
 44 |         if seed is not None:
 45 |             random.seed(seed)
 46 |         else:
 47 |             random.seed()
 48 | 
 49 |         
 50 |         self.game_board = self._generate_board() 
 51 |         self.game_board_hidden = self._hide_letters(self.game_board) 
 52 |         self.guessed_letters = set()
 53 | 
 54 |         
 55 |         return self.state.reset(
 56 |             game_state={
 57 |                 "board": copy.deepcopy(self.game_board_hidden),
 58 |                 "rendered_board": self._render_board(self.game_board_hidden, show_letters=False),
 59 |                 "num_incorrect_tries": 6
 60 |             },
 61 |             player_prompt_function=self._generate_player_prompt 
 62 |         )
 63 |     
 64 |     def _generate_player_prompt(self, player_id: int) -> str:
 65 |         
 66 |         prompt = (
 67 |             f"You are Player {player_id}. You are playing Hangman.\n"
 68 |             "The objective of the game is to guess the word by providing one letter guesses or the entire word.\n"
 69 |             "Here is the current state of the Hangman grid. Each column is numbered.\n"
 70 |             "The cells that need to be populated with letters are represented by '_'.\n\n"
 71 |             "Current Hangman Grid:\n"
 72 |         )
 73 | 
 74 |         grid_str = self._render_board(self.game_board_hidden, show_letters=False)
 75 |         prompt += grid_str
 76 | 
 77 |         
 78 |         
 79 |         prompt += ("\n\nThere are two ways you can answer. You can provide one letter guesses in the format of [L], or you can guess the entire word in the format of [LIGHT].\n"
 80 |                    "If the given letter is in the word, it will be revealed in the grid.\n"
 81 |                    "If the given word is correct, you win.\n"
 82 |                    "As you play, the history of your choices will be appended below. Use the information to figure out the word and win.\n")
 83 |     
 84 |         return prompt
 85 |     
 86 |     def _generate_board(self) -> List[str]:
 87 |         
 88 |         
 89 |         self.chosen_word = random.choice(self.word_list).upper()
 90 |         print(f"Chosen word: {self.chosen_word}")
 91 | 
 92 |         
 93 |         return list(self.chosen_word) 
 94 |     
 95 |     def _hide_letters(self, board: List[str]) -> List[str]:
 96 |         
 97 |         return ['_' for _ in board]
 98 |     
 99 |     def _render_board(self, board: List[str], show_letters: bool = False) -> str:
100 |         
101 |         header = " ".join(f"C{i:02}" for i in range(len(board)))
102 |         lines = [header]
103 |         
104 |         
105 |         row_str = ""  
106 |         for i, val in enumerate(board):
107 |             if show_letters:
108 |                 row_str += f"  {val} "
109 |             else:
110 |                 row_str += "  _ "
111 |         lines.append(row_str)
112 | 
113 |         return "\n".join(lines)
114 |     
115 |     def step(
116 |         self,
117 |         player_id: int,
118 |         action: str
119 |     ) -> Tuple[
120 |         Optional[ta.Observations], 
121 |         Optional[ta.Rewards], 
122 |         bool, 
123 |         bool, 
124 |         ta.Info 
125 |     ]:
126 |         
127 | 
128 |         
129 |         self.state.add_observation(
130 |             from_id=player_id,
131 |             to_id=-1,
132 |             message=action,
133 |             for_logging=True
134 |         )
135 | 
136 |         
137 |         
138 |         action_search_pattern = re.compile(r"\[([a-zA-Z]+)\]", re.IGNORECASE)  
139 |         matches = action_search_pattern.findall(action)
140 |         matches = set(matches)  
141 | 
142 |         if not matches:
143 |             self.state.set_invalid_move(
144 |                 player_ids=[player_id],
145 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with a valid 'letter' or 'word'."]
146 |             )
147 |         else:
148 |             for match in matches:
149 |                 letter = match.upper()  
150 |                 
151 |                 if len(letter) > 1:
152 |                     if letter == self.chosen_word:
153 |                         self.state.set_winners(
154 |                             player_ids=[player_id],
155 |                             reason=f"Congratulations! Player {player_id} completed the Hangman puzzle."
156 |                         )
157 |                         for i, char in enumerate(letter):
158 |                             self._reveal_letter(char)  
159 |                     else:
160 |                         self.state.set_invalid_move(
161 |                             player_ids=[player_id],
162 |                             reasons=[f"Invalid move. The word is incorrect."]
163 |                         )
164 |                     break
165 | 
166 |                 
167 |                 if letter in self.guessed_letters:
168 |                     self.state.set_invalid_move(
169 |                         player_ids=[player_id],
170 |                         reasons=[f"Invalid move. Player {player_id} guessed the letter '{letter}' which has already been guessed."]
171 |                     )
172 |                     break
173 |                 
174 |                 
175 |                 self.guessed_letters.add(letter)
176 | 
177 |                 
178 |                 if letter in self.chosen_word:
179 |                     self._reveal_letter(letter)  
180 |                     self.state.add_observation(
181 |                         from_id=ta.GAME_ID,
182 |                         to_id=-1,
183 |                         message=f"Board state: \n{self._render_board(self.state.game_state['board'], show_letters=True)}",
184 |                         for_logging=False
185 |                     )
186 |                 else:
187 |                     self.state.game_state["num_incorrect_tries"] -= 1
188 |                     self.state.add_observation(
189 |                         from_id=-1,
190 |                         to_id=player_id,
191 |                         message=f"Your guess of {letter} is not in the word. You have {self.state.game_state['num_incorrect_tries']} turns left.",
192 |                         for_logging=False
193 |                     )
194 |                     break
195 | 
196 |             
197 |             if self.state.game_state["num_incorrect_tries"] == 0:
198 |                 self.state.set_draw(reason="No turns left. Game over.")
199 |             
200 |             
201 |             self.state.game_state["rendered_board"] = self._render_board(self.state.game_state["board"], show_letters=True)
202 | 
203 |         return self.state.step()
204 |     
205 |     def _reveal_letter(self, letter: str) -> None:
206 |         
207 |         for i, char in enumerate(self.chosen_word):
208 |             if char == letter:
209 |                 self.state.game_state["board"][i] = letter
210 |     
211 |     def _is_game_over(self) -> bool:
212 |         
213 |         return self.state.game_state["board"] == self.game_board
214 |     
215 |     def render(self) -> None:
216 |         
217 |         print(self.state.game_state["rendered_board"])
218 | 
```

## File: textarena/envs/single_player/Hangman/readme.md

- Extension: .md
- Language: markdown
- Size: 6838 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Hangman Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | The Hangman environment is a single-player word-guessing game where the player attempts to guess a hidden word by suggesting letters or guessing the entire word. The objective is to reveal the correct word before the player runs out of attempts. The environment supports a "hardcore" mode where a more extensive vocabulary is used, adding to the difficulty.
  6 | 
  7 | ## Action Space
  8 | - **Format**: Actions are provided as strings in the format [letter] for guessing a single letter or [WORD] for guessing the entire word.
  9 | 
 10 | - **Examples**:
 11 |     - Guessing a letter: [A] attempts to reveal all instances of the letter 'A' in the word.
 12 |     - Guessing the entire word: [LIGHT] checks if the guessed word matches the hidden word.
 13 | 
 14 | - *Notes*:
 15 |     - Actions must strictly follow the [letter] or [WORD] format for validation.
 16 |     - Additional text can accompany the action, but the environment will only process valid patterns matching these formats.
 17 | 
 18 | ## Observation Space
 19 | **Reset Observation:**
 20 | On reset, the observation provides the initial prompt and the state of the Hangman grid. For example:
 21 | ```plaintext
 22 | [GAME] You are Player 0. You are playing Hangman.
 23 | The objective of the game is to guess the word by providing one letter guesses or the entire word.
 24 | Here is the current state of the Hangman grid. Each column is numbered.
 25 | The cells that need to be populated with letters are represented by '_'.
 26 | 
 27 | Current Hangman Grid:
 28 | C00 C01 C02 C03 C04 C05 C06
 29 |   _   _   _   _   _   _   _ 
 30 | 
 31 | There are two ways you can answer. You can provide one letter guesses in the format of [L], or you can guess the entire word in the format of [LIGHT].
 32 | If the given letter is in the word, it will be revealed in the grid.
 33 | If the given word is correct, you win.
 34 | As you play, the history of your choices will be appended below. Use the information to figure out the word and win.
 35 | ```
 36 | 
 37 | **Step Obervation:**
 38 | After each step, the environment returns the action and the updated Hangman grid as the observation. For example:
 39 | 
 40 | ```plaintext
 41 | [Player 0] I'll guess the letter 'O'. 
 42 | 
 43 | [O]
 44 | [GAME] Board state: 
 45 | C00 C01 C02 C03 C04 C05 C06
 46 |   _   _   O   _   _   _   _ 
 47 | ```
 48 | 
 49 | By default, the environment returns observations in the following format:
 50 | ```python
 51 | {
 52 |   player_id: int : [
 53 |     (sender_id: int, message: str),
 54 |     ...
 55 |   ]
 56 | }
 57 | ```
 58 | where each step can product zero, one or many message tuples.
 59 | 
 60 | ## Gameplay
 61 | - **Word Length:** The length of the word varies depending on the difficulty mode.
 62 | - *Turns:* The player guesses one letter or the entire word in each turn.
 63 | - **Letter Guessing:** The player suggests a letter, and if the letter exists in the word, it will be revealed in all its positions.
 64 | - **Word Guessing:** The player can guess the entire word at once. If correct, the player wins immediately; if incorrect, the guess counts as a failed attempt.
 65 | - **Winning Condition:** The game is won when all letters in the word are revealed or the entire word is correctly guessed.
 66 | - **Draw Condition:** The player draws if they exceed the maximum number of incorrect attempts (default is 6).
 67 | 
 68 | ## Key Rules
 69 | - **Valid Moves:**
 70 | 
 71 |     - The player must enter a single letter in the format [L] (e.g., [A]) or guess the entire word in the format [WORD] (e.g., [LIGHT]).
 72 |     - The move must be a valid letter not previously guessed. If it's a word, it must match the hidden word exactly to win.
 73 | 
 74 | - **Invalid Moves:**
 75 | 
 76 |     - Entering an invalid letter format or a word that doesn't match the hidden word results in a penalty.
 77 |     - Repeating a previously guessed letter will also be marked as invalid and will not affect the game state.
 78 |     - The player loses one of their allowed attempts for each incorrect guess.
 79 | 
 80 | ## Rewards
 81 | | Outcome          | Reward for Player |
 82 | |------------------|:-----------------:|
 83 | | **Win**          |       `+1`        |
 84 | | **Lose**         |       `0`         |
 85 | | **Invalid Move** |       `-1`        |
 86 | 
 87 | ## Parameters
 88 | - `hardcore` (`bool`)
 89 | - Description: Sets the difficulty level of the game by determining the vocabulary size from which words are chosen.
 90 | - Impact:
 91 | 
 92 |     - False (default): The game uses a basic word list (en-basic), making it easier for players with common and shorter words.
 93 |     - True: The game uses a larger and more challenging vocabulary (en), featuring less common and longer words, making it suitable for advanced players.
 94 | 
 95 | ## Variants
 96 | 
 97 | | Env-id                | hardcore |
 98 | |-----------------------|:--------:|
 99 | | `Hangman-v0`          | `False`  |
100 | | `Hangman-v0-hardcore` |  `True`  |
101 | 
102 | ## Example Usage
103 | 
104 | ```python
105 | import textarena as ta
106 | 
107 | ## initializa the environment
108 | env = ta.make("Hangman-v0")
109 | 
110 | ## Wrap the environment for easier observation handling
111 | env = ta.wrappers.LLMObservationWrapper(env=env)
112 | 
113 | ## Wrap the environment for pretty rendering
114 | env = ta.wrappers.PrettyRenderWrapper(env=env)
115 | 
116 | ## initalize agents
117 | agents = {
118 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
119 |     }
120 | 
121 | ## reset the environment to start a new game
122 | observations = env.reset(seed=490)
123 | 
124 | ## Game loop
125 | done = False
126 | while not done:
127 | 
128 |     # Get the current player
129 |     current_player_id = env.state.get("current_player")
130 | 
131 |     # Get the current observation for the player
132 |     obs = observations[current_player_id]
133 | 
134 |     # Agent decides on an action based on the observation
135 |     action = agents[current_player_id](obs)
136 | 
137 |     # Execute the action in the environment
138 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
139 | 
140 |     # Check if the game has ended
141 |     done = terminated or truncated
142 | 
143 |     # Optionally render the environment to see the current state
144 |     env.render()
145 | 
146 |     if done:
147 |         break
148 | 
149 | ## Finally, print the game results
150 | for player_id, agent in agents.items():
151 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
152 | print(f"Reason: {info['reason']}")
153 | ```
154 | 
155 | ## Troubleshooting
156 | 
157 | **Repeated Guess:**
158 | 
159 | - **Issue**: The player guesses a letter that has already been attempted.
160 | - **Solution**: Provide feedback indicating that the letter has been guessed and prompt the player to try a new letter.
161 | 
162 | **Board Not Updating:**
163 | 
164 | - **Issue**: The board does not reflect correct guesses or show the updated state after an action.
165 | - **Solution**: Verify that `_reveal_letter` is correctly updating self.state.game_state["board"] and that rendered_board reflects the latest game state.
166 | 
167 | **Invalid Guess Format:**
168 | 
169 | - **Issue**: The player submits a guess in an incorrect format (e.g., missing square brackets or using multiple letters for a single-letter guess).
170 | - **Solution**: Remind the player to format guesses as [L] for single letters or [WORD] for full word guesses.
171 | 
172 | 
173 | ## Version History
174 | - **v0**
175 |   - Initial release 
176 | 
177 | 
178 | ### Contact
179 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/Hangman/example.py

- Extension: .py
- Language: python
- Size: 1274 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("Hangman-v0")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/GuessWho/test.py

- Extension: .py
- Language: python
- Size: 3037 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.GuessWho.env import GuessWhoEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["Does the character have blue eyes?","Does the character have long hair?"]  
 9 | 
10 | def generate_correct_guess_sequence():
11 |     
12 |     return ["The character is [Tom]"]
13 | 
14 | def generate_invalid_guess_sequence():
15 |     
16 |     return ["The character is Tom!"]  
17 | 
18 | class TestGuessWhoEnv(unittest.TestCase):
19 |     
20 | 
21 | 
22 |     test_cases = {
23 |         "correct_move": {
24 |             "actions": generate_correct_move_sequence()
25 |         },
26 |         "correct_guess": {
27 |             "actions": generate_correct_guess_sequence()
28 |         },
29 |         "invalid_guess": {
30 |             "actions": generate_invalid_guess_sequence()
31 |         },
32 |     }
33 | 
34 |     @parameterized.expand([
35 |         (name, details['actions'])
36 |         for name, details in test_cases.items()
37 |     ])
38 |     def test_guesswho_env(self, name, action_sequence):
39 |         
40 |         env = GuessWhoEnv()
41 | 
42 |         observations = env.reset(seed=490)
43 | 
44 |         terminated = False
45 |         truncated = False
46 | 
47 |         for i, action in enumerate(action_sequence):
48 |             if terminated or truncated:
49 |                 break
50 |             player_id = 0
51 | 
52 |             
53 |             observations, rewards, truncated, terminated, info = env.step(player_id, action)
54 | 
55 |             
56 |             if "correct_move" in name:
57 |                 self.assertFalse(truncated, "Game should not truncate for correct moves.")
58 |                 self.assertFalse(terminated, "Game should not terminate for correct moves.")
59 |             elif "correct_guess" in name:
60 |                 self.assertFalse(truncated, "Game should not truncate for correct answer.")
61 |                 self.assertTrue(terminated, "Game should terminate for correct answer.")
62 |                 self.assertEqual(rewards[0], 1, "Player should receive a reward for correct answer.")
63 |             elif "invalid_guess" in name:
64 |                 self.assertFalse(truncated, "Game should not truncate for incorrect format of answer.")
65 |                 self.assertFalse(terminated, "Game should not terminate for incorrect format of answer.")
66 |             else:
67 |                 self.fail(f"Invalid test case: {name}")
68 | 
69 |     def run_unit_test():
70 |         print("Running TwentyQuestionsEnv tests...")
71 |         unittest.main(argv=['first-arg-is-ignored'], exit=False) 
72 |     
```

## File: textarena/envs/single_player/GuessWho/env.py

- Extension: .py
- Language: python
- Size: 7721 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from typing import Any, Dict, Optional, Tuple
  2 | import random
  3 | import re
  4 | import textarena as ta
  5 | import json
  6 | 
  7 | class GuessWhoEnv(ta.Env):
  8 |     
  9 |     
 10 |     def __init__(
 11 |         self,
 12 |         gamemaster_class: ta.JudgeVote = ta.game_makers.GPTGamemasterAction,
 13 |     ):
 14 |         
 15 |         self.environment_name = "GuessWho"
 16 |         
 17 |         
 18 |         self.state = ta.State(
 19 |             num_players=1,
 20 |             render_keys=["rendered_text"],
 21 |             max_turns=40
 22 |         )
 23 | 
 24 |         
 25 |         self.gamemaster = gamemaster_class(
 26 |             options=["Yes", "No", "I don't know"],
 27 |         )
 28 | 
 29 |         
 30 |         with open('textarena/envs/single_player/GuessWho/characters.json') as f:
 31 |             self.characters = json.load(f)
 32 | 
 33 |     def reset(
 34 |         self,
 35 |         seed: Optional[int] = None,
 36 |     ) -> Optional[ta.Observations]:
 37 |         
 38 |         if seed is not None:
 39 |             random.seed(seed)
 40 |         else:
 41 |             random.seed()
 42 |         
 43 |         
 44 |         self.target_character = random.choice(self.characters)
 45 | 
 46 |         
 47 |         initial_context = (
 48 |             f"You are the gamemaster for the game of 'Guess Who'.\n"
 49 |             f"You will provide responses to the player's questions that guides them into guessing the target character with the following name and traits: {self.target_character}.\n"
 50 |         )
 51 |         self.gamemaster.set_initial_context(initial_context=initial_context)
 52 | 
 53 |         
 54 |         return self.state.reset(
 55 |             game_state={
 56 |                 "target_character": self.target_character,
 57 |                 "rendered_text": self._render_text()
 58 |             },
 59 |             player_prompt_function=self._generate_player_prompt
 60 |         )
 61 | 
 62 |     def _generate_player_prompt(
 63 |         self, 
 64 |         player_id: int
 65 |     ) -> str:
 66 |         
 67 |         prompt = (
 68 |             f"You are Player {player_id}. You are playing Guess Who.\n"
 69 |             "The gamemaster has chosen one target character from the list of characters that you will be shown below.\n"
 70 |             "You have to guess the target character by asking yes-or-no questions about the target character's traits.\n"
 71 |             "You can ask questions like 'Is the character male?' or 'Does the character have a beard?'.\n"
 72 |             "You can also guess the name of the target character at any time by ensuring that you wrap their name in square brackets, e.g. [Zach].\n"
 73 |             "As you play, the history of your questions and gamemaster's responses will be displayed."
 74 |             "Here is the list of characters you can ask questions about:\n"
 75 |         )
 76 | 
 77 |         prompt += self._characters_to_string()
 78 | 
 79 |         return prompt
 80 |     
 81 |     def _characters_to_string(
 82 |         self
 83 |     ) -> str:
 84 |         
 85 |         formatted_descriptions = []
 86 |         for i, char in enumerate(self.characters, start=1):
 87 |             
 88 |             accessories = ", ".join(char["accessories"]) if char["accessories"] else "no accessories"
 89 |             description = (
 90 |                 f"{i}. {char['name']} is a {char['age_range']} {char['gender']} with {char['hair_style']} "
 91 |                 f"{char['hair_color']} hair and {char['eye_color']} eyes. {char['name']} has a {char['complexion']} complexion, "
 92 |                 f"{char['skin_tone']} skin tone, and {char['smile_type']} smile. They wear {accessories}, "
 93 |                 f"have {char['facial_hair']} facial hair, and their clothing style is {char['clothing_style']}. "
 94 |                 f"{char['name']} has {char['hair_texture']} hair texture, {char['eyewear_style']} glasses style, "
 95 |                 f"a {char['nose_shape']} nose, {char['ear_size']} ears, and {char['cheek_features']} on their cheeks."
 96 |             )
 97 |             formatted_descriptions.append(description)
 98 |         
 99 |         
100 |         return "\n\n".join(formatted_descriptions)
101 |     
102 |     def step(
103 |         self,
104 |         player_id: int,
105 |         action: str,
106 |     ) -> Tuple[
107 |         Optional[ta.Observations],
108 |         Optional[ta.Rewards],
109 |         bool,
110 |         bool,
111 |         ta.Info
112 |     ]:
113 |         
114 | 
115 |         
116 |         self.state.add_observation(
117 |             from_id=player_id,
118 |             to_id=-1,
119 |             message=action,
120 |             for_logging=True
121 |         )
122 | 
123 |         
124 |         action_search_pattern = re.compile(r"\[([a-zA-Z]+)\]") 
125 |         action_match = action_search_pattern.search(action)
126 | 
127 |         if not action_match:
128 |             
129 |             gamemaster_response = self._generate_gamemaster_response(action)
130 |             
131 |             self.state.add_observation(
132 |                 from_id=-1,
133 |                 to_id=player_id,
134 |                 message=gamemaster_response,
135 |                 for_logging=True
136 |             )
137 |         
138 |         else:
139 |             
140 |             action_text = action_match.group(1).lower()
141 |             if action_text == self.target_character["name"].lower():
142 |                 self.state.set_winners(
143 |                     player_ids=[player_id],
144 |                     reason=f"Congratulations! Player {player_id} guessed the target character."
145 |                 )
146 |             else:
147 |                 self.state.set_invalid_move(
148 |                     player_ids=[player_id],
149 |                     reasons=[f"Invalid guess. Player {player_id} guessed incorrectly."]
150 |                     )
151 |             
152 |             self.state.game_state["rendered_text"] = self._render_text()
153 |         
154 |         return self.state.step()
155 |     
156 |     def _generate_gamemaster_response(
157 |         self,
158 |         question: str
159 |     ) -> str:
160 |         
161 |         response = self.gamemaster.respond_to_action(question)
162 |         
163 |         return response
164 |     
165 |     def _render_text(self) -> str:
166 |         
167 |         res = ""
168 |         for key, value in self.target_character.items():
169 |             res += f"{key}: {value}\n"
170 |         return res
171 |     
172 |     def render(self):
173 |         
174 |         print(self.state.game_state["rendered_text"])
175 | 
176 |     
177 | 
178 | 
```

## File: textarena/envs/single_player/GuessWho/characters.json

- Extension: .json
- Language: json
- Size: 13742 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```json
  1 | [
  2 |     {
  3 |         "name": "Alex",
  4 |         "gender": "male",
  5 |         "hair_color": "brown",
  6 |         "hair_style": "short",
  7 |         "eye_color": "brown",
  8 |         "accessories": ["glasses"],
  9 |         "facial_hair": "mustache",
 10 |         "skin_tone": "light",
 11 |         "hat_type": "none",
 12 |         "hair_texture": "straight",
 13 |         "eyewear_style": "round",
 14 |         "nose_shape": "pointed",
 15 |         "ear_size": "medium",
 16 |         "smile_type": "wide",
 17 |         "clothing_style": "casual",
 18 |         "age_range": "middle-aged",
 19 |         "complexion": "fair",
 20 |         "cheek_features": "dimples"
 21 |     },
 22 |     {
 23 |         "name": "Alfred",
 24 |         "gender": "male",
 25 |         "hair_color": "white",
 26 |         "hair_style": "bald",
 27 |         "eye_color": "blue",
 28 |         "accessories": [],
 29 |         "facial_hair": "beard",
 30 |         "skin_tone": "fair",
 31 |         "hat_type": "beanie",
 32 |         "hair_texture": "none",
 33 |         "eyewear_style": "none",
 34 |         "nose_shape": "broad",
 35 |         "ear_size": "large",
 36 |         "smile_type": "closed-lip",
 37 |         "clothing_style": "formal",
 38 |         "age_range": "elderly",
 39 |         "complexion": "fair",
 40 |         "cheek_features": "none"
 41 |     },
 42 |     {
 43 |         "name": "Anita",
 44 |         "gender": "female",
 45 |         "hair_color": "blonde",
 46 |         "hair_style": "long",
 47 |         "eye_color": "blue",
 48 |         "accessories": ["earrings"],
 49 |         "facial_hair": "none",
 50 |         "skin_tone": "olive",
 51 |         "hat_type": "none",
 52 |         "hair_texture": "wavy",
 53 |         "eyewear_style": "none",
 54 |         "nose_shape": "round",
 55 |         "ear_size": "small",
 56 |         "smile_type": "wide",
 57 |         "clothing_style": "casual",
 58 |         "age_range": "young",
 59 |         "complexion": "fair",
 60 |         "cheek_features": "freckles"
 61 |     },
 62 |     {
 63 |         "name": "Anne",
 64 |         "gender": "female",
 65 |         "hair_color": "red",
 66 |         "hair_style": "long",
 67 |         "eye_color": "blue",
 68 |         "accessories": [],
 69 |         "facial_hair": "none",
 70 |         "skin_tone": "fair",
 71 |         "hat_type": "none",
 72 |         "hair_texture": "curly",
 73 |         "eyewear_style": "none",
 74 |         "nose_shape": "pointed",
 75 |         "ear_size": "medium",
 76 |         "smile_type": "neutral",
 77 |         "clothing_style": "sporty",
 78 |         "age_range": "middle-aged",
 79 |         "complexion": "olive",
 80 |         "cheek_features": "dimples"
 81 |     },
 82 |     {
 83 |         "name": "Bernard",
 84 |         "gender": "male",
 85 |         "hair_color": "brown",
 86 |         "hair_style": "bald",
 87 |         "eye_color": "brown",
 88 |         "accessories": [],
 89 |         "facial_hair": "mustache",
 90 |         "skin_tone": "olive",
 91 |         "hat_type": "bowler",
 92 |         "hair_texture": "none",
 93 |         "eyewear_style": "none",
 94 |         "nose_shape": "round",
 95 |         "ear_size": "medium",
 96 |         "smile_type": "closed-lip",
 97 |         "clothing_style": "formal",
 98 |         "age_range": "elderly",
 99 |         "complexion": "dark",
100 |         "cheek_features": "none"
101 |     },
102 |     {
103 |         "name": "Bill",
104 |         "gender": "male",
105 |         "hair_color": "blonde",
106 |         "hair_style": "short",
107 |         "eye_color": "brown",
108 |         "accessories": [],
109 |         "facial_hair": "none",
110 |         "skin_tone": "light",
111 |         "hat_type": "none",
112 |         "hair_texture": "straight",
113 |         "eyewear_style": "none",
114 |         "nose_shape": "pointed",
115 |         "ear_size": "large",
116 |         "smile_type": "wide",
117 |         "clothing_style": "casual",
118 |         "age_range": "young",
119 |         "complexion": "olive",
120 |         "cheek_features": "none"
121 |     },
122 |     {
123 |         "name": "Charles",
124 |         "gender": "male",
125 |         "hair_color": "brown",
126 |         "hair_style": "short",
127 |         "eye_color": "blue",
128 |         "accessories": ["hat"],
129 |         "facial_hair": "none",
130 |         "skin_tone": "fair",
131 |         "hat_type": "baseball",
132 |         "hair_texture": "wavy",
133 |         "eyewear_style": "none",
134 |         "nose_shape": "broad",
135 |         "ear_size": "medium",
136 |         "smile_type": "neutral",
137 |         "clothing_style": "sporty",
138 |         "age_range": "middle-aged",
139 |         "complexion": "olive",
140 |         "cheek_features": "freckles"
141 |     },
142 |     {
143 |         "name": "Claire",
144 |         "gender": "female",
145 |         "hair_color": "black",
146 |         "hair_style": "short",
147 |         "eye_color": "brown",
148 |         "accessories": [],
149 |         "facial_hair": "none",
150 |         "skin_tone": "olive",
151 |         "hat_type": "none",
152 |         "hair_texture": "straight",
153 |         "eyewear_style": "none",
154 |         "nose_shape": "pointed",
155 |         "ear_size": "medium",
156 |         "smile_type": "closed-lip",
157 |         "clothing_style": "formal",
158 |         "age_range": "middle-aged",
159 |         "complexion": "fair",
160 |         "cheek_features": "none"
161 |     },
162 |     {
163 |         "name": "David",
164 |         "gender": "male",
165 |         "hair_color": "blonde",
166 |         "hair_style": "short",
167 |         "eye_color": "brown",
168 |         "accessories": [],
169 |         "facial_hair": "mustache",
170 |         "skin_tone": "olive",
171 |         "hat_type": "none",
172 |         "hair_texture": "straight",
173 |         "eyewear_style": "none",
174 |         "nose_shape": "round",
175 |         "ear_size": "medium",
176 |         "smile_type": "wide",
177 |         "clothing_style": "casual",
178 |         "age_range": "young",
179 |         "complexion": "olive",
180 |         "cheek_features": "dimples"
181 |     },
182 |     {
183 |         "name": "Eric",
184 |         "gender": "male",
185 |         "hair_color": "blonde",
186 |         "hair_style": "short",
187 |         "eye_color": "blue",
188 |         "accessories": [],
189 |         "facial_hair": "beard",
190 |         "skin_tone": "light",
191 |         "hat_type": "none",
192 |         "hair_texture": "curly",
193 |         "eyewear_style": "none",
194 |         "nose_shape": "pointed",
195 |         "ear_size": "small",
196 |         "smile_type": "neutral",
197 |         "clothing_style": "formal",
198 |         "age_range": "middle-aged",
199 |         "complexion": "fair",
200 |         "cheek_features": "none"
201 |     },
202 |     {
203 |         "name": "Frans",
204 |         "gender": "male",
205 |         "hair_color": "red",
206 |         "hair_style": "short",
207 |         "eye_color": "brown",
208 |         "accessories": ["glasses"],
209 |         "facial_hair": "mustache",
210 |         "skin_tone": "light",
211 |         "hat_type": "bowler",
212 |         "hair_texture": "straight",
213 |         "eyewear_style": "square",
214 |         "nose_shape": "broad",
215 |         "ear_size": "large",
216 |         "smile_type": "closed-lip",
217 |         "clothing_style": "casual",
218 |         "age_range": "elderly",
219 |         "complexion": "dark",
220 |         "cheek_features": "none"
221 |     },
222 |     {
223 |         "name": "George",
224 |         "gender": "male",
225 |         "hair_color": "white",
226 |         "hair_style": "bald",
227 |         "eye_color": "blue",
228 |         "accessories": ["glasses"],
229 |         "facial_hair": "none",
230 |         "skin_tone": "olive",
231 |         "hat_type": "none",
232 |         "hair_texture": "none",
233 |         "eyewear_style": "round",
234 |         "nose_shape": "pointed",
235 |         "ear_size": "medium",
236 |         "smile_type": "neutral",
237 |         "clothing_style": "formal",
238 |         "age_range": "middle-aged",
239 |         "complexion": "olive",
240 |         "cheek_features": "freckles"
241 |     },
242 |     {
243 |         "name": "Herman",
244 |         "gender": "male",
245 |         "hair_color": "brown",
246 |         "hair_style": "short",
247 |         "eye_color": "brown",
248 |         "accessories": [],
249 |         "facial_hair": "beard",
250 |         "skin_tone": "light",
251 |         "hat_type": "none",
252 |         "hair_texture": "wavy",
253 |         "eyewear_style": "none",
254 |         "nose_shape": "round",
255 |         "ear_size": "small",
256 |         "smile_type": "wide",
257 |         "clothing_style": "sporty",
258 |         "age_range": "young",
259 |         "complexion": "fair",
260 |         "cheek_features": "none"
261 |     },
262 |     {
263 |         "name": "Joe",
264 |         "gender": "male",
265 |         "hair_color": "black",
266 |         "hair_style": "curly",
267 |         "eye_color": "brown",
268 |         "accessories": ["hat"],
269 |         "facial_hair": "mustache",
270 |         "skin_tone": "fair",
271 |         "hat_type": "baseball",
272 |         "hair_texture": "curly",
273 |         "eyewear_style": "none",
274 |         "nose_shape": "broad",
275 |         "ear_size": "medium",
276 |         "smile_type": "closed-lip",
277 |         "clothing_style": "casual",
278 |         "age_range": "young",
279 |         "complexion": "dark",
280 |         "cheek_features": "dimples"
281 |     },
282 |     {
283 |         "name": "Maria",
284 |         "gender": "female",
285 |         "hair_color": "brown",
286 |         "hair_style": "long",
287 |         "eye_color": "brown",
288 |         "accessories": ["glasses"],
289 |         "facial_hair": "none",
290 |         "skin_tone": "olive",
291 |         "hat_type": "none",
292 |         "hair_texture": "straight",
293 |         "eyewear_style": "round",
294 |         "nose_shape": "pointed",
295 |         "ear_size": "small",
296 |         "smile_type": "wide",
297 |         "clothing_style": "formal",
298 |         "age_range": "elderly",
299 |         "complexion": "fair",
300 |         "cheek_features": "none"
301 |     },
302 |     {
303 |         "name": "Max",
304 |         "gender": "male",
305 |         "hair_color": "blonde",
306 |         "hair_style": "short",
307 |         "eye_color": "blue",
308 |         "accessories": [],
309 |         "facial_hair": "none",
310 |         "skin_tone": "fair",
311 |         "hat_type": "none",
312 |         "hair_texture": "wavy",
313 |         "eyewear_style": "none",
314 |         "nose_shape": "broad",
315 |         "ear_size": "medium",
316 |         "smile_type": "neutral",
317 |         "clothing_style": "sporty",
318 |         "age_range": "young",
319 |         "complexion": "light",
320 |         "cheek_features": "freckles"
321 |     },
322 |     {
323 |         "name": "Paul",
324 |         "gender": "male",
325 |         "hair_color": "white",
326 |         "hair_style": "bald",
327 |         "eye_color": "brown",
328 |         "accessories": [],
329 |         "facial_hair": "none",
330 |         "skin_tone": "olive",
331 |         "hat_type": "bowler",
332 |         "hair_texture": "none",
333 |         "eyewear_style": "none",
334 |         "nose_shape": "round",
335 |         "ear_size": "large",
336 |         "smile_type": "closed-lip",
337 |         "clothing_style": "formal",
338 |         "age_range": "elderly",
339 |         "complexion": "fair",
340 |         "cheek_features": "dimples"
341 |     },
342 |     {
343 |         "name": "Peter",
344 |         "gender": "male",
345 |         "hair_color": "black",
346 |         "hair_style": "curly",
347 |         "eye_color": "blue",
348 |         "accessories": ["hat"],
349 |         "facial_hair": "none",
350 |         "skin_tone": "light",
351 |         "hat_type": "beanie",
352 |         "hair_texture": "curly",
353 |         "eyewear_style": "none",
354 |         "nose_shape": "pointed",
355 |         "ear_size": "medium",
356 |         "smile_type": "neutral",
357 |         "clothing_style": "casual",
358 |         "age_range": "middle-aged",
359 |         "complexion": "olive",
360 |         "cheek_features": "none"
361 |     },
362 |     {
363 |         "name": "Philip",
364 |         "gender": "male",
365 |         "hair_color": "red",
366 |         "hair_style": "short",
367 |         "eye_color": "brown",
368 |         "accessories": [],
369 |         "facial_hair": "none",
370 |         "skin_tone": "fair",
371 |         "hat_type": "none",
372 |         "hair_texture": "straight",
373 |         "eyewear_style": "none",
374 |         "nose_shape": "round",
375 |         "ear_size": "small",
376 |         "smile_type": "wide",
377 |         "clothing_style": "sporty",
378 |         "age_range": "young",
379 |         "complexion": "dark",
380 |         "cheek_features": "freckles"
381 |     },
382 |     {
383 |         "name": "Richard",
384 |         "gender": "male",
385 |         "hair_color": "brown",
386 |         "hair_style": "short",
387 |         "eye_color": "blue",
388 |         "accessories": ["glasses"],
389 |         "facial_hair": "beard",
390 |         "skin_tone": "light",
391 |         "hat_type": "none",
392 |         "hair_texture": "straight",
393 |         "eyewear_style": "square",
394 |         "nose_shape": "broad",
395 |         "ear_size": "large",
396 |         "smile_type": "closed-lip",
397 |         "clothing_style": "formal",
398 |         "age_range": "middle-aged",
399 |         "complexion": "olive",
400 |         "cheek_features": "none"
401 |     },
402 |     {
403 |         "name": "Robert",
404 |         "gender": "male",
405 |         "hair_color": "brown",
406 |         "hair_style": "short",
407 |         "eye_color": "brown",
408 |         "accessories": ["glasses"],
409 |         "facial_hair": "none",
410 |         "skin_tone": "olive",
411 |         "hat_type": "none",
412 |         "hair_texture": "wavy",
413 |         "eyewear_style": "round",
414 |         "nose_shape": "pointed",
415 |         "ear_size": "medium",
416 |         "smile_type": "neutral",
417 |         "clothing_style": "casual",
418 |         "age_range": "middle-aged",
419 |         "complexion": "fair",
420 |         "cheek_features": "dimples"
421 |     },
422 |     {
423 |         "name": "Sam",
424 |         "gender": "male",
425 |         "hair_color": "brown",
426 |         "hair_style": "short",
427 |         "eye_color": "brown",
428 |         "accessories": [],
429 |         "facial_hair": "mustache",
430 |         "skin_tone": "dark",
431 |         "hat_type": "none",
432 |         "hair_texture": "curly",
433 |         "eyewear_style": "none",
434 |         "nose_shape": "broad",
435 |         "ear_size": "small",
436 |         "smile_type": "closed-lip",
437 |         "clothing_style": "sporty",
438 |         "age_range": "young",
439 |         "complexion": "fair",
440 |         "cheek_features": "none"
441 |     },
442 |     {
443 |         "name": "Susan",
444 |         "gender": "female",
445 |         "hair_color": "blonde",
446 |         "hair_style": "short",
447 |         "eye_color": "blue",
448 |         "accessories": ["earrings"],
449 |         "facial_hair": "none",
450 |         "skin_tone": "light",
451 |         "hat_type": "none",
452 |         "hair_texture": "straight",
453 |         "eyewear_style": "none",
454 |         "nose_shape": "round",
455 |         "ear_size": "large",
456 |         "smile_type": "wide",
457 |         "clothing_style": "formal",
458 |         "age_range": "middle-aged",
459 |         "complexion": "olive",
460 |         "cheek_features": "freckles"
461 |     },
462 |     {
463 |         "name": "Tom",
464 |         "gender": "male",
465 |         "hair_color": "blonde",
466 |         "hair_style": "short",
467 |         "eye_color": "blue",
468 |         "accessories": [],
469 |         "facial_hair": "none",
470 |         "skin_tone": "olive",
471 |         "hat_type": "none",
472 |         "hair_texture": "curly",
473 |         "eyewear_style": "none",
474 |         "nose_shape": "pointed",
475 |         "ear_size": "medium",
476 |         "smile_type": "neutral",
477 |         "clothing_style": "sporty",
478 |         "age_range": "young",
479 |         "complexion": "fair",
480 |         "cheek_features": "none"
481 |     }
482 | ]
```

## File: textarena/envs/single_player/GuessWho/README.md

- Extension: .md
- Language: markdown
- Size: 14394 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Guess Who Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | The Guess Who Environment is a single-player adaptation of the two-player version we are familiar with. It is question-driven where a player aims to deduce the target character selected by the gamemaster. The gamemaster, configurable in behavior, responds to each question with "Yes", "No" or "I don't know" based on the target character, guiding the player toward a correct guess. The environment tracks player moves, validates guesses (formatted as [name]), and updates the game state for each interaction, offering a structured and engaging experience that challenges players' deductive reasoning and strategic questioning skills. 
  6 | 
  7 | ## Action Space
  8 | - **Format:** Actions are strings that can either be a question or a final guess that is formatted as [name]. For example:
  9 | - **Example:**
 10 |     - To ask a question: "Does the character have a blue eyes?"
 11 |     - To make a final guess: [Tom]
 12 | - **Notes:** Players can ask any yes-or-no question, and the gamemaster will respond with "Yes", "No" or "I don't know". To submit a final guess, the player must enclose their guess in square brackets (e.g. [Tom]). Incorrectly formatted guesses will be marked as a normal question. 
 13 | 
 14 | ## Observation Space
 15 | **Reset Observation:**
 16 | On reset, the observation provides the initial prompt. For example:
 17 | ```plaintext
 18 | [GAME] You are Player 0. You are playing Guess Who.
 19 | The gamemaster has chosen one target character from the list of characters that you will be shown below.
 20 | You have to guess the target character by asking yes-or-no questions about the target character's traits.
 21 | You can ask questions like 'Is the character male?' or 'Does the character have a beard?'.
 22 | You can also guess the name of the target character at any time by ensuring that you wrap their name in square brackets, e.g. [Zach].
 23 | As you play, the history of your questions and gamemaster's responses will be displayed.Here is the list of characters you can ask questions about:
 24 | 1. Alex is a middle-aged male with short brown hair and brown eyes. Alex has a fair complexion, light skin tone, and wide smile. They wear glasses, have mustache facial hair, and their clothing style is casual. Alex has straight hair texture, round glasses style, a pointed nose, medium ears, and dimples on their cheeks.
 25 | 
 26 | 2. Alfred is a elderly male with bald white hair and blue eyes. Alfred has a fair complexion, fair skin tone, and closed-lip smile. They wear no accessories, have beard facial hair, and their clothing style is formal. Alfred has none hair texture, none glasses style, a broad nose, large ears, and none on their cheeks.
 27 | 
 28 | 3. Anita is a young female with long blonde hair and blue eyes. Anita has a fair complexion, olive skin tone, and wide smile. They wear earrings, have none facial hair, and their clothing style is casual. Anita has wavy hair texture, none glasses style, a round nose, small ears, and freckles on their cheeks.
 29 | 
 30 | 4. Anne is a middle-aged female with long red hair and blue eyes. Anne has a olive complexion, fair skin tone, and neutral smile. They wear no accessories, have none facial hair, and their clothing style is sporty. Anne has curly hair texture, none glasses style, a pointed nose, medium ears, and dimples on their cheeks.
 31 | 
 32 | 5. Bernard is a elderly male with bald brown hair and brown eyes. Bernard has a dark complexion, olive skin tone, and closed-lip smile. They wear no accessories, have mustache facial hair, and their clothing style is formal. Bernard has none hair texture, none glasses style, a round nose, medium ears, and none on their cheeks.
 33 | 
 34 | 6. Bill is a young male with short blonde hair and brown eyes. Bill has a olive complexion, light skin tone, and wide smile. They wear no accessories, have none facial hair, and their clothing style is casual. Bill has straight hair texture, none glasses style, a pointed nose, large ears, and none on their cheeks.
 35 | 
 36 | 7. Charles is a middle-aged male with short brown hair and blue eyes. Charles has a olive complexion, fair skin tone, and neutral smile. They wear hat, have none facial hair, and their clothing style is sporty. Charles has wavy hair texture, none glasses style, a broad nose, medium ears, and freckles on their cheeks.
 37 | 
 38 | 8. Claire is a middle-aged female with short black hair and brown eyes. Claire has a fair complexion, olive skin tone, and closed-lip smile. They wear no accessories, have none facial hair, and their clothing style is formal. Claire has straight hair texture, none glasses style, a pointed nose, medium ears, and none on their cheeks.
 39 | 
 40 | 9. David is a young male with short blonde hair and brown eyes. David has a olive complexion, olive skin tone, and wide smile. They wear no accessories, have mustache facial hair, and their clothing style is casual. David has straight hair texture, none glasses style, a round nose, medium ears, and dimples on their cheeks.
 41 | 
 42 | 10. Eric is a middle-aged male with short blonde hair and blue eyes. Eric has a fair complexion, light skin tone, and neutral smile. They wear no accessories, have beard facial hair, and their clothing style is formal. Eric has curly hair texture, none glasses style, a pointed nose, small ears, and none on their cheeks.
 43 | 
 44 | 11. Frans is a elderly male with short red hair and brown eyes. Frans has a dark complexion, light skin tone, and closed-lip smile. They wear glasses, have mustache facial hair, and their clothing style is casual. Frans has straight hair texture, square glasses style, a broad nose, large ears, and none on their cheeks.
 45 | 
 46 | 12. George is a middle-aged male with bald white hair and blue eyes. George has a olive complexion, olive skin tone, and neutral smile. They wear glasses, have none facial hair, and their clothing style is formal. George has none hair texture, round glasses style, a pointed nose, medium ears, and freckles on their cheeks.
 47 | 
 48 | 13. Herman is a young male with short brown hair and brown eyes. Herman has a fair complexion, light skin tone, and wide smile. They wear no accessories, have beard facial hair, and their clothing style is sporty. Herman has wavy hair texture, none glasses style, a round nose, small ears, and none on their cheeks.
 49 | 
 50 | 14. Joe is a young male with curly black hair and brown eyes. Joe has a dark complexion, fair skin tone, and closed-lip smile. They wear hat, have mustache facial hair, and their clothing style is casual. Joe has curly hair texture, none glasses style, a broad nose, medium ears, and dimples on their cheeks.
 51 | 
 52 | 15. Maria is a elderly female with long brown hair and brown eyes. Maria has a fair complexion, olive skin tone, and wide smile. They wear glasses, have none facial hair, and their clothing style is formal. Maria has straight hair texture, round glasses style, a pointed nose, small ears, and none on their cheeks.
 53 | 
 54 | 16. Max is a young male with short blonde hair and blue eyes. Max has a light complexion, fair skin tone, and neutral smile. They wear no accessories, have none facial hair, and their clothing style is sporty. Max has wavy hair texture, none glasses style, a broad nose, medium ears, and freckles on their cheeks.
 55 | 
 56 | 17. Paul is a elderly male with bald white hair and brown eyes. Paul has a fair complexion, olive skin tone, and closed-lip smile. They wear no accessories, have none facial hair, and their clothing style is formal. Paul has none hair texture, none glasses style, a round nose, large ears, and dimples on their cheeks.
 57 | 
 58 | 18. Peter is a middle-aged male with curly black hair and blue eyes. Peter has a olive complexion, light skin tone, and neutral smile. They wear hat, have none facial hair, and their clothing style is casual. Peter has curly hair texture, none glasses style, a pointed nose, medium ears, and none on their cheeks.
 59 | 
 60 | 19. Philip is a young male with short red hair and brown eyes. Philip has a dark complexion, fair skin tone, and wide smile. They wear no accessories, have none facial hair, and their clothing style is sporty. Philip has straight hair texture, none glasses style, a round nose, small ears, and freckles on their cheeks.
 61 | 
 62 | 20. Richard is a middle-aged male with short brown hair and blue eyes. Richard has a olive complexion, light skin tone, and closed-lip smile. They wear glasses, have beard facial hair, and their clothing style is formal. Richard has straight hair texture, square glasses style, a broad nose, large ears, and none on their cheeks.
 63 | 
 64 | 21. Robert is a middle-aged male with short brown hair and brown eyes. Robert has a fair complexion, olive skin tone, and neutral smile. They wear glasses, have none facial hair, and their clothing style is casual. Robert has wavy hair texture, round glasses style, a pointed nose, medium ears, and dimples on their cheeks.
 65 | 
 66 | 22. Sam is a young male with short brown hair and brown eyes. Sam has a fair complexion, dark skin tone, and closed-lip smile. They wear no accessories, have mustache facial hair, and their clothing style is sporty. Sam has curly hair texture, none glasses style, a broad nose, small ears, and none on their cheeks.
 67 | 
 68 | 23. Susan is a middle-aged female with short blonde hair and blue eyes. Susan has a olive complexion, light skin tone, and wide smile. They wear earrings, have none facial hair, and their clothing style is formal. Susan has straight hair texture, none glasses style, a round nose, large ears, and freckles on their cheeks.
 69 | 
 70 | 24. Tom is a young male with short blonde hair and blue eyes. Tom has a fair complexion, olive skin tone, and neutral smile. They wear no accessories, have none facial hair, and their clothing style is sporty. Tom has curly hair texture, none glasses style, a pointed nose, medium ears, and none on their cheeks.
 71 | ```
 72 | 
 73 | **Step Observation:**
 74 | After each step, the environment returns the action (e.g. "Yes", "No", "I don't know"). For example:
 75 | ```plaintext
 76 | [Player 0] Is the character male?
 77 | [GAME] Yes
 78 | ```
 79 | 
 80 | By default, the environment returns observations in the following format:
 81 | ```python
 82 | {
 83 |   player_id: int : [
 84 |     (sender_id: int, message: str),
 85 |     (sender_id: int, message: str),
 86 |     ...
 87 |   ]
 88 | }
 89 | ```
 90 | 
 91 | **Note:** _Should the judge be unable to interpret the questions and provide one of the three assigned options - "yes", "no" or "I don't know" - the judge will respond with "I'm sorry, I don't understand. Please try asking again." in an effort to get the player to rephrase its action._
 92 | 
 93 | ## Gameplay
 94 | **Game Setup:** The game begins with the `reset` method selecting a target character from a predefined character list. The player then initiates the game by asking yes-or-no questions to uncover hints about the target character.
 95 | 
 96 | **Turns:** Players take turns by either asking questions or making a final guess. Each turn, the player can ask questions like, “Does the character have blue eyes?” The gamemaster will respond with "Yes," "No," or "I don’t know," providing clues for deducing the character. To submit a final guess of the character, players must wrap it in square brackets (e.g., [Tom]). The environment tracks questions asked, and the correctness of the final guess.
 97 | 
 98 | **Objective:** The player’s goal is to identify the target character using the information gleaned from the gamemaster's responses. By formulating strategic questions, the player can narrow down the possibilities and improve their chances of guessing correctly.
 99 | 
100 | **Winning Condition:** The game is won if the player successfully guesses the target character within the allowable turns of the game - 40 turns by default. If the player’s guess matches the target character, they receive a congratulatory message, confirming the win. If incorrect, the player loses the game.
101 | 
102 | 
103 | ## Key Rules:
104 | 
105 | - **Valid Moves:**
106 |     - For the submission of final guesses, the player must follow the structure of [Tom].
107 |     - The player is allowed to think through its questions, as well as also ask questions that are a combination of features.
108 | 
109 | - **Invalid Moves:**
110 |     - A move is invalid if the player makes the wrong guess of the target character.
111 | 
112 | ## Rewards
113 | | Outcome          | Reward for Player |
114 | |------------------|:-----------------:|
115 | | **Win**          |       `+1`        |
116 | | **Lose**         |       `0`         |
117 | | **Invalid Move** |       `-1`        |
118 | 
119 | ## Variants
120 | 
121 | | Env-id                |
122 | |-----------------------|
123 | | `GuessWho-v0`         |
124 | 
125 | 
126 | ## Example Usage
127 | 
128 | ```python
129 | import textarena as ta
130 | 
131 | ## initializa the environment
132 | env = ta.make("GuessWho-v0")
133 | 
134 | ## Wrap the environment for easier observation handling
135 | env = ta.wrappers.LLMObservationWrapper(env=env)
136 | 
137 | ## Wrap the environment for pretty rendering
138 | env = ta.wrappers.PrettyRenderWrapper(env=env)
139 | 
140 | ## initalize agents
141 | agents = {
142 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
143 |     }
144 | 
145 | ## reset the environment to start a new game
146 | observations = env.reset(seed=490)
147 | 
148 | ## Game loop
149 | done = False
150 | while not done:
151 | 
152 |     # Get the current player
153 |     current_player_id = env.state.get("current_player")
154 | 
155 |     # Get the current observation for the player
156 |     obs = observations[current_player_id]
157 | 
158 |     # Agent decides on an action based on the observation
159 |     action = agents[current_player_id](obs)
160 | 
161 |     # Execute the action in the environment
162 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
163 | 
164 |     # Check if the game has ended
165 |     done = terminated or truncated
166 | 
167 |     # Optionally render the environment to see the current state
168 |     env.render()
169 | 
170 |     if done:
171 |         break
172 | 
173 | ## Finally, print the game results
174 | for player_id, agent in agents.items():
175 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
176 | print(f"Reason: {info['reason']}")
177 | ```
178 | 
179 | ## Troubleshooting
180 | 
181 | **Repeated Question:**
182 | 
183 | - **Issue**: Due to the open response, the player has given questions that are closely similar to earlier ones.
184 | - **Solution**: Insert into the player's initial prompt the strategy of seeking a diverse range of questions.
185 | 
186 | **Gamemaster Response Missing or Incorrect:**
187 | 
188 | - **Issue**: The gamemaster doesn’t respond or provides an unclear answer to a valid question.
189 | - **Solution**: Check that _generate_gamemaster_response correctly processes the player’s question and that self.gamemaster.respond_to_action is functioning as expected.
190 | 
191 | 
192 | ## Version History
193 | - **v0**
194 |   - Initial release 
195 | 
196 | 
197 | ### Contact
198 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/GuessWho/example.py

- Extension: .py
- Language: python
- Size: 1275 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("GuessWho-v0")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/Minesweeper/test.py

- Extension: .py
- Language: python
- Size: 3314 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.Minesweeper.env import MinesweeperEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["[reveal 3 3]", "[flag 0 0]"]  
 9 | 
10 | def generate_out_of_bounds_sequence():
11 |     
12 |     return ["[reveal 100 100]"]  
13 | 
14 | def generate_invalid_format_sequence():
15 |     
16 |     return ["(reveal 3 3)", "reveal 3 3"]  
17 | 
18 | class TestMinesweeperEnv(unittest.TestCase):
19 |     
20 |     env_variants = [
21 |         {"difficulty": "easy"},
22 |         {"difficulty": "medium"},
23 |         {"difficulty": "hard"}
24 |     ]
25 | 
26 |     test_cases = {
27 |         "correct_move": {
28 |             "difficulty": "easy",
29 |             "actions": generate_correct_move_sequence()
30 |         },
31 |         "out_of_bounds": {
32 |             "difficulty": "medium",
33 |             "actions": generate_out_of_bounds_sequence()
34 |         },
35 |         "invalid_format": {
36 |             "difficulty": "hard",
37 |             "actions": generate_invalid_format_sequence()
38 |         }
39 |     }
40 | 
41 |     @parameterized.expand([
42 |         (name, details['difficulty'], details['actions'])
43 |         for name, details in test_cases.items()
44 |     ])
45 |     def test_minesweeper_env(self, name, difficulty, actions):
46 |         
47 |         env_config = next((env for env in self.env_variants if env["difficulty"] == difficulty), None)
48 |         self.assertIsNotNone(env_config, f"Invalid difficulty level: {difficulty}")
49 | 
50 |         env = MinesweeperEnv(difficulty=env_config["difficulty"])
51 | 
52 |         observations = env.reset(seed=490)
53 | 
54 |         terminated = False
55 |         truncated = False
56 | 
57 |         for i, action in enumerate(actions):
58 |             if terminated or truncated:
59 |                 break
60 |             player_id = 0
61 |             obs = observations
62 | 
63 |             
64 |             observations, rewards, truncated, terminated, info = env.step(player_id, action)
65 | 
66 |             
67 |             if name == "correct_move":
68 |                 self.assertFalse(truncated, "Game should not be truncated")
69 |                 self.assertFalse(terminated, "Game should not be terminated")
70 |             elif "out_of_bounds" in name:
71 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an out-of-bounds move.")
72 |                 self.assertEqual(rewards[0], -1, "Player should receive -1 for out-of-bounds move.")
73 |             elif "invalid_format" in name:
74 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
75 |                 self.assertEqual(rewards[0], -1, "Player should receive -1 reward for an invalid move format.")
76 |             else:
77 |                 self.fail(f"Unknown test case name: {name}")
78 |     
79 |     def run_unit_test():
80 |         print("Running CrosswordsEnv tests...")
81 |         unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/single_player/Minesweeper/env.py

- Extension: .py
- Language: python
- Size: 11680 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from typing import Optional, Tuple, List
  2 | import random
  3 | import re
  4 | import textarena as ta
  5 | from collections import deque
  6 | 
  7 | class MinesweeperEnv(ta.Env):
  8 |     
  9 | 
 10 |     def __init__(
 11 |         self,
 12 |         difficulty: str = "easy",
 13 |     ):
 14 |         
 15 |         self.environment = "Minesweeper"
 16 |         self.difficulty = difficulty
 17 | 
 18 |         
 19 |         if self.difficulty == "easy":
 20 |             self.rows = 8
 21 |             self.cols = 8
 22 |             self.num_mines = 10
 23 |         elif self.difficulty == "medium":
 24 |             self.rows = 10
 25 |             self.cols = 10
 26 |             self.num_mines = 20
 27 |         elif self.difficulty == "hard":
 28 |             self.rows = 12
 29 |             self.cols = 12
 30 |             self.num_mines = 30
 31 | 
 32 |         
 33 |         self.state = ta.State(
 34 |             num_players=1,
 35 |             render_keys=["rendered_board"],
 36 |             max_turns=100
 37 |         )
 38 | 
 39 |     def reset(
 40 |         self,
 41 |         seed: Optional[int] = None
 42 |     ) -> Optional[ta.Observations]:
 43 |         
 44 |         
 45 |         if seed is not None:
 46 |             random.seed(seed)
 47 |         else:
 48 |             random.seed()
 49 | 
 50 |         
 51 |         self.grid = [[0 for _ in range(self.cols)] for _ in range(self.rows)]
 52 |         self.revealed = [[False for _ in range(self.cols)] for _ in range(self.rows)]
 53 |         self.flags = [[False for _ in range(self.cols)] for _ in range(self.rows)]
 54 |         self.first_move = True 
 55 | 
 56 |         
 57 |         return self.state.reset(
 58 |             game_state={
 59 |                 "grid": self.grid,
 60 |                 "rendered_board": self._render_board()
 61 |             },
 62 |             player_prompt_function=self._generate_player_prompt
 63 |         )
 64 |     
 65 |     def _generate_player_prompt(self, player_id: int) -> str:
 66 |         
 67 | 
 68 |         prompt = (
 69 |             f"You are Player {player_id}. You are playing the Minesweeper game.\n"
 70 |             "The objective of the game is to reveal all cells that do not contain mines.\n"
 71 |             "To make a move, you can either reveal a cell or place a flag on a suspected mine location using one of the following commands:\n"
 72 |             "- 'reveal': Reveal the contents of a specific cell.\n"
 73 |             "- 'flag': Place or remove a flag on a specific cell to mark it as a potential mine.\n"
 74 |             "To submit your move, type the command followed by the row and column in square brackets.\n"
 75 |             "For example:\n"
 76 |             "- [reveal 3 2] to reveal the cell in Row 3, Column 2.\n"
 77 |             "- [flag 5 6] to place or remove a flag on the cell in Row 5, Column 6.\n"
 78 |             "On your first move, you will reveal an area around the cell you choose to ensure a safe start.\n"
 79 |             "The current board layout is shown below. Cells that are unrevealed are represented by a dot ('.'), revealed numbers show the count of adjacent mines, and flagged cells are marked with an 'F'.\n"
 80 |             "Use logic and deduction to avoid revealing cells with mines!\n"
 81 |             "Be mindful not to choose revealed or flagged cells.\n"
 82 |             "Here is the current board layout:\n"
 83 |         )
 84 | 
 85 |         prompt += self.state.game_state["rendered_board"]
 86 |         return prompt
 87 |     
 88 |     def _render_board(self) -> str:
 89 |         
 90 |         board_str = "   " + " ".join([str(c).rjust(2) for c in range(self.cols)]) + "\n"
 91 |         for r in range(self.rows):
 92 |             row_str = f"{r:2} "
 93 |             for c in range(self.cols):
 94 |                 if self.revealed[r][c]:
 95 |                     if self.grid[r][c] == -1:
 96 |                         row_str += " * "
 97 |                     else:
 98 |                         row_str += f" {self.grid[r][c]} "
 99 |                 elif self.flags[r][c]:
100 |                     row_str += " F "
101 |                 else:
102 |                     row_str += " . "
103 |             board_str += row_str + "\n"
104 |         return board_str
105 |         
106 |     def step(
107 |         self,
108 |         player_id: int,
109 |         action: str
110 |     ) -> Tuple[
111 |         Optional[ta.Observations],
112 |         Optional[ta.Rewards],
113 |         bool,
114 |         bool,
115 |         ta.Info
116 |     ]:
117 |         
118 | 
119 |         
120 |         self.state.add_observation(
121 |             from_id=player_id,
122 |             to_id=-1,
123 |             message=action,
124 |             for_logging=True
125 |         )
126 | 
127 |         
128 |         action_search_pattern = re.compile(r"\[([a-zA-Z]+)\s(\d+)\s(\d+)\]") 
129 |         match = action_search_pattern.search(action)
130 | 
131 |         if match is None:
132 |             self.state.set_invalid_move(
133 |                 player_ids=[player_id],
134 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with a valid action and coordinates in square brackets."]
135 |             )
136 |         else:
137 |             action, row, col = match.group(1).lower(), int(match.group(2)), int(match.group(3))
138 |             if not (0 <= row < self.rows and 0 <= col < self.cols):
139 |                 self.state.set_invalid_move(
140 |                     player_ids=[player_id],
141 |                     reasons=[f"Invalid move. The specified row and column coordinates are out of bounds."]
142 |                 )
143 |             else:
144 |                 if action == "reveal":
145 |                     if self.revealed[row][col] or self.flags[row][col]:
146 |                         print("REVEALED", self.revealed, "FLAGS", self.flags)
147 |                         self.state.set_invalid_move(
148 |                             player_ids=[player_id],
149 |                             reasons=[f"Invalid move. The cell at ({row}, {col}) has already been revealed or flagged."]
150 |                         )
151 |                     
152 |                     if self.first_move:
153 |                         self.clear_all_flags()
154 |                         self.setup_mines(row, col)
155 |                         self.first_move = False
156 |                     
157 |                     queue = deque([(row, col)])  
158 |                     self.revealed[row][col] = True  
159 | 
160 |                     while queue:
161 |                         current_row, current_col = queue.popleft()
162 | 
163 |                         
164 |                         if self.grid[current_row][current_col] == -1:
165 |                             self.state.set_invalid_move(
166 |                                 player_ids=[player_id],
167 |                                 reasons=[f"Game over! Player {player_id} hit a mine at ({current_row}, {current_col})."]
168 |                             )
169 | 
170 |                         
171 |                         if self.grid[current_row][current_col] == 0:
172 |                             for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:
173 |                                 neighbor_row, neighbor_col = current_row + dr, current_col + dc
174 |                                 
175 |                                 if 0 <= neighbor_row < self.rows and 0 <= neighbor_col < self.cols:
176 |                                     if not self.revealed[neighbor_row][neighbor_col] and not self.flags[neighbor_row][neighbor_col]:
177 |                                         self.revealed[neighbor_row][neighbor_col] = True  
178 |                                         queue.append((neighbor_row, neighbor_col))
179 | 
180 |                     self.state.add_observation(
181 |                             from_id=-1,
182 |                             to_id=player_id,
183 |                             message=f"Game Board:\n{self._render_board()}",
184 |                             for_logging=False
185 |                         )
186 |                     
187 |                 elif action == "flag":
188 |                     if not self.revealed[row][col]:
189 |                         self.flags[row][col] = not self.flags[row][col]
190 |                         print(f"Flag {'placed' if self.flags[row][col] else 'removed'} at ({row}, {col})")
191 | 
192 |                 else:
193 |                     self.state.set_invalid_move(
194 |                         player_ids=[player_id],
195 |                         reasons=[f"Invalid move format. Player {player_id} did not respond with a valid action in square brackets."]
196 |                     )
197 | 
198 |         
199 |         self.state.game_state["rendered_board"] = self._render_board()
200 | 
201 |         
202 |         if self._is_solved():
203 |             self.state.set_winners(
204 |                 player_ids=[player_id],
205 |                 reason=f"Congratulations! Player {player_id} has successfully cleared the Minesweeper board."
206 |             )
207 |         
208 |         return self.state.step()
209 |     
210 |     def setup_mines(self, safe_row: int, safe_col: int):
211 |         mines = set()
212 |         while len(mines) < self.num_mines:
213 |             r = random.randint(0, self.rows - 1)
214 |             c = random.randint(0, self.cols - 1)
215 |             
216 |             if (r, c) not in mines and (r < safe_row - 1 or r > safe_row + 1 or c < safe_col - 1 or c > safe_col + 1):
217 |                 mines.add((r, c))
218 |                 self.grid[r][c] = -1  
219 |         self.calculate_adjacent_numbers()
220 | 
221 |     def calculate_adjacent_numbers(self):
222 |         directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
223 |         for r in range(self.rows):
224 |             for c in range(self.cols):
225 |                 if self.grid[r][c] == -1:
226 |                     continue
227 |                 mine_count = sum((0 <= r + dr < self.rows and 0 <= c + dc < self.cols and self.grid[r + dr][c + dc] == -1)
228 |                                  for dr, dc in directions)
229 |                 self.grid[r][c] = mine_count
230 | 
231 |     def clear_all_flags(self):
232 |         
233 |         self.flags = [[False for _ in range(self.cols)] for _ in range(self.rows)]
234 | 
235 |     def _is_solved(self) -> bool:
236 |         
237 |         return all(
238 |             (self.grid[r][c] == -1 and self.flags[r][c]) or (self.grid[r][c] != -1 and self.revealed[r][c])
239 |             for r in range(self.rows) for c in range(self.cols)
240 |         )
241 |     
242 |     def render(self):
243 |         return self.state.game_state["rendered_board"]
```

## File: textarena/envs/single_player/Minesweeper/README.md

- Extension: .md
- Language: markdown
- Size: 8171 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Minesweeper Environment Documentation
  2 | 
  3 | ## Overview
  4 | The Minesweeper Environment is a single-player puzzle game where the player aims to reveal all safe cells on a grid while avoiding hidden mines. The board’s difficulty—easy, medium, or hard—determines its size and mine count. Each revealed cell shows the number of adjacent mines around it, helping the player identify safe cells through deduction. Players can flag cells they suspect contain mines, which they must avoid revealing. The game ensures a safe start by revealing an area around the first chosen cell, and it ends in failure if a mine is revealed. The player wins by successfully revealing all non-mine cells.
  5 | 
  6 | ## Action Space
  7 | - **Format:** Actions are strings in the format [action row col], where:
  8 | - **Example:**
  9 |     - To reveal the grid at row 3 col 3: [reveal 3 3]
 10 |     - To place a flag at row 4 col 3 because of a suspected mine: [flag 4 3]
 11 | - **Notes:** Additional texts may accompany the action, but the agent can only make 1 action step at a time. Its actions cannot be an invalid action.
 12 | 
 13 | ## Observation Space
 14 | **Reset Observation:**
 15 | On reset, the observation provides the initial prompt and the empty grid. For example:
 16 | ```plaintext
 17 | [GAME] You are Player 0. You are playing the Minesweeper game.
 18 | The objective of the game is to reveal all cells that do not contain mines.
 19 | To make a move, you can either reveal a cell or place a flag on a suspected mine location using one of the following commands:
 20 | - 'reveal': Reveal the contents of a specific cell.
 21 | - 'flag': Place or remove a flag on a specific cell to mark it as a potential mine.
 22 | To submit your move, type the command followed by the row and column in square brackets.
 23 | For example:
 24 | - [reveal 3 2] to reveal the cell in Row 3, Column 2.
 25 | - [flag 5 6] to place or remove a flag on the cell in Row 5, Column 6.
 26 | On your first move, you will reveal an area around the cell you choose to ensure a safe start.
 27 | The current board layout is shown below. Cells that are unrevealed are represented by a dot ('.'), revealed numbers show the count of adjacent mines, and flagged cells are marked with an 'F'.
 28 | Use logic and deduction to avoid revealing cells with mines!
 29 | Be mindful not to choose revealed or flagged cells.
 30 | Here is the current board layout:
 31 |     0  1  2  3  4  5  6  7
 32 |  0  .  .  .  .  .  .  .  . 
 33 |  1  .  .  .  .  .  .  .  . 
 34 |  2  .  .  .  .  .  .  .  . 
 35 |  3  .  .  .  .  .  .  .  . 
 36 |  4  .  .  .  .  .  .  .  . 
 37 |  5  .  .  .  .  .  .  .  . 
 38 |  6  .  .  .  .  .  .  .  . 
 39 |  7  .  .  .  .  .  .  .  . 
 40 | ```
 41 | 
 42 | **Step Observations:**
 43 | After each step, the environment returns the action and the updated grid as the observation. For example:
 44 | ```plaintext
 45 | [Player 0] To start the game safely, I'll reveal a cell that is likely to uncover a larger area. A good choice would be to reveal the center of the board, as it tends to have more adjacent cells. 
 46 | 
 47 | I will reveal the cell at Row 3, Column 3.
 48 | 
 49 | Let's make the move: 
 50 | 
 51 | [reveal 3 3]
 52 | [GAME] Game Board:
 53 |     0  1  2  3  4  5  6  7
 54 |  0  .  .  .  .  .  .  .  . 
 55 |  1  .  .  .  .  .  .  .  . 
 56 |  2  .  .  1  1  1  1  1  . 
 57 |  3  .  3  1  0  0  0  1  1 
 58 |  4  .  2  0  0  0  0  0  0 
 59 |  5  1  1  0  1  2  2  2  1 
 60 |  6  0  0  1  2  .  .  .  . 
 61 |  7  0  0  1  .  .  .  .  . 
 62 | ```
 63 | 
 64 | By default, the environment returns observations in the following format:
 65 | ```python
 66 | {
 67 |   player_id: int : [
 68 |     (sender_id: int, message: str),
 69 |     (sender_id: int, message: str),
 70 |     ...
 71 |   ]
 72 | }
 73 | ```
 74 | 
 75 | ## Gameplay
 76 | **Grid Configuration:** The board consists of a grid of cells, with dimensions and the number of hidden mines determined by the selected difficulty level. At the start, all cells are hidden, and the player’s objective is to reveal all cells that do not contain mines. The player can also flag cells suspected to contain mines to mark them as dangerous.
 77 | 
 78 | **Turns:** 
 79 | - **\[For the first move only\]**  The player may freely choose any cell to reveal. This initial move will always be safe, and it will clear an area of cells around the selected cell to provide a secure start. Any flags that may have been placed on these cells will be removed automatically to ensure clarity and prevent confusion in this safe zone.
 80 | - **\[After the first move\]** The player takes a turn by specifying an action and a cell location in the format [action row col], where action is either reveal (to uncover a cell) or flag (to mark a cell as a suspected mine). For example, entering [reveal 3 2] uncovers the cell at row 3, column 2, while [flag 5 6] places or removes a flag on the cell at row 5, column 6. The player must use logic and deduction to safely uncover cells without triggering mines.
 81 | 
 82 | **Objective:** The goal is to reveal all safe cells on the grid, indicated by numbers showing the count of adjacent mines. The game provides a safe first move by clearing an area around the chosen cell, allowing the player to start without hitting a mine.
 83 | 
 84 | **Winning Condition:** The game is won when all cells without mines are revealed. However, if the player accidentally reveals a cell containing a mine, the game is lost.
 85 | 
 86 | ## Key Rules
 87 | 
 88 | **Valid Moves:**
 89 | 
 90 | - **Reveal:** [reveal row col] uncovers the specified cell. If it contains no adjacent mines, surrounding cells may also be revealed.
 91 | - **Flag:** [flag row col] places or removes a flag on the specified cell to indicate suspicion of a mine. Flags can only be placed on hidden cells.
 92 | 
 93 | **Invalid Moves:**
 94 | 
 95 | - Revealing or flagging a cell that has already been revealed or flagged.
 96 | - Selecting a cell outside the grid boundaries.
 97 | - Using a format that does not follow the [action row col] structure.
 98 | 
 99 | ## Rewards
100 | 
101 | | Outcome          | Reward for Player  |
102 | |------------------|:------------------:|
103 | | **Win**          |       `+1`         |
104 | | **Lose**         |       `0`          |
105 | | **Invalid Move** |       `-1`         |
106 | 
107 | # Variants
108 | 
109 | | Env-id                    |
110 | |---------------------------|
111 | | `Minesweeper-v0-easy`     |
112 | | `Minesweeper-v0-medium`   |
113 | | `Minesweeper-v0-hard`     |
114 | 
115 | ## Example Usage
116 | ```python
117 | import textarena as ta
118 | 
119 | ## initializa the environment
120 | env = ta.make("Minesweeper-v0-easy")
121 | 
122 | ## Wrap the environment for easier observation handling
123 | env = ta.wrappers.LLMObservationWrapper(env=env)
124 | 
125 | ## Wrap the environment for pretty rendering
126 | env = ta.wrappers.PrettyRenderWrapper(env=env)
127 | 
128 | ## initalize agents
129 | agents = {
130 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
131 |     }
132 | 
133 | ## reset the environment to start a new game
134 | observations = env.reset(seed=490)
135 | 
136 | ## Game loop
137 | done = False
138 | while not done:
139 | 
140 |     # Get the current player
141 |     current_player_id = env.state.get("current_player")
142 | 
143 |     # Get the current observation for the player
144 |     obs = observations[current_player_id]
145 | 
146 |     # Agent decides on an action based on the observation
147 |     action = agents[current_player_id](obs)
148 | 
149 |     # Execute the action in the environment
150 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
151 | 
152 |     # Check if the game has ended
153 |     done = terminated or truncated
154 | 
155 |     # Optionally render the environment to see the current state
156 |     env.render()
157 | 
158 |     if done:
159 |         break
160 | 
161 | ## Finally, print the game results
162 | for player_id, agent in agents.items():
163 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
164 | print(f"Reason: {info['reason']}")
165 | ```
166 | 
167 | ## Troubleshooting
168 | 
169 | **Invalid Move Format:**
170 | 
171 |   - **Issue**: The player submits a move in an incorrect format (e.g., missing square brackets or improper action keywords).
172 |   - **Solution**: Ensure the player prompt clearly specifies that moves must follow the format [action row col], where action is either reveal or flag, and row and col represent valid coordinates within the grid.
173 | 
174 | **No Mines Indicated Around First Move:**
175 | 
176 |   - **Issue**: The player’s first move does not reveal the expected safe area or adjacent numbers.
177 |   - **Solution**: Ensure the first move is correctly coded to clear all mines in the area surrounding the selected cell, revealing a safe zone for better gameplay clarity.
178 | 
179 | 
180 | ## Version History
181 | - **v0**
182 |   - Initial release 
183 | 
184 | 
185 | ### Contact
186 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/Minesweeper/example.py

- Extension: .py
- Language: python
- Size: 1283 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("Minesweeper-v0-easy")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/TwentyQuestions/test.py

- Extension: .py
- Language: python
- Size: 3579 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.TwentyQuestions.env import TwentyQuestionsEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["Is it a living thing?",]
 9 | 
10 | def generate_correct_answer_sequence():
11 |     
12 |     return ["[science]","[Science]","I know the answer. It is [SCIENCE]."]
13 | 
14 | def generate_invalid_answer_sequence():
15 |     
16 |     return ["[imagination]"]  
17 | 
18 | class TestTwentyQuestionsEnv(unittest.TestCase):
19 | 
20 |     
21 |     env_variants = [
22 |         {"hardcore": False},
23 |         {"hardcore": True}
24 |     ]
25 | 
26 |     
27 |     test_cases = {
28 |         "correct_moves": {
29 |             "hardcore": False,
30 |             "actions": generate_correct_move_sequence()
31 |         },
32 |         "correct_answer": {
33 |             "hardcore": False,
34 |             "actions": generate_correct_answer_sequence()
35 |         },
36 |         "invalid_answer": {
37 |             "hardcore": False,
38 |             "actions": generate_invalid_answer_sequence()
39 |         }
40 |     }
41 | 
42 |     @parameterized.expand([
43 |         (name, details['hardcore'], details['actions'])
44 |         for name, details in test_cases.items()
45 |     ])
46 |     def test_twentyquestions_outcomes(self, name, hardcore, action_sequence):
47 |         
48 |         
49 |         env_config = next((env for env in self.env_variants if env['hardcore'] == hardcore), None)
50 |         self.assertIsNotNone(env_config, f"Invalid hardcore level: {hardcore}")
51 | 
52 |         env = TwentyQuestionsEnv(hardcore=env_config["hardcore"])
53 | 
54 |         _ = env.reset(seed=490)
55 | 
56 |         terminated = False
57 |         truncated = False
58 | 
59 |         for i, action in enumerate(action_sequence):
60 |             if terminated or truncated:
61 |                 break
62 |             player_id = 0
63 | 
64 |             
65 |             observations, reward, truncated, terminated, info = env.step(player_id, action)
66 | 
67 |             
68 |             if "correct_moves" in name:
69 |                 self.assertFalse(truncated, "Game should not truncate for correct moves.")
70 |                 self.assertFalse(terminated, "Game should not terminate for correct moves.")
71 |             elif "correct_answer" in name:
72 |                 self.assertFalse(truncated, "Game should not truncate for correct answer.")
73 |                 self.assertTrue(terminated, "Game should terminate for correct answer.")
74 |                 self.assertEqual(reward[0], 1, "Player should receive a reward for correct answer.")
75 |             elif "invalid_answer" in name:
76 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid answer.")
77 |                 self.assertEqual(reward[0], -1, "Player should receive -1 reward for an invalid answer.")
78 |             else:
79 |                 self.fail(f"Invalid test case: {name}")
80 | 
81 |     def run_unit_test():
82 |         print("Running TwentyQuestionsEnv tests...")
83 |         unittest.main(argv=['first-arg-is-ignored'], exit=False) 
84 | 
```

## File: textarena/envs/single_player/TwentyQuestions/env.py

- Extension: .py
- Language: python
- Size: 6581 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from typing import Any, Dict, Optional, Tuple
  2 | import random
  3 | import re
  4 | import textarena as ta
  5 | 
  6 | import nltk
  7 | from nltk.corpus import words
  8 | from nltk import pos_tag
  9 | 
 10 | nltk.download("words")
 11 | nltk.download("averaged_perceptron_tagger_eng")
 12 | 
 13 | class TwentyQuestionsEnv(ta.Env):
 14 |     
 15 | 
 16 |     def __init__(
 17 |         self, 
 18 |         hardcore: Optional[bool] = False,
 19 |         gamemaster_class: ta.JudgeVote = ta.game_makers.GPTGamemasterAction,
 20 |     ):
 21 |         
 22 |         self.environment_name = "TwentyQuestions"
 23 |         self.hardcore = hardcore
 24 | 
 25 |         
 26 |         self.state = ta.State(
 27 |             num_players=1,
 28 |             render_keys=["rendered_text"],
 29 |             max_turns=21
 30 |         )
 31 | 
 32 |         
 33 |         self.gamemaster = gamemaster_class(
 34 |             options=["Yes", "No", "I don't know"],
 35 |         )
 36 | 
 37 |         
 38 |         if self.hardcore:
 39 |             self.word_list = self._load_word_list(words.words("en"))
 40 |         else:
 41 |             self.word_list = self._load_word_list(words.words("en-basic"))
 42 |         
 43 | 
 44 |     def reset(
 45 |         self,
 46 |         seed: Optional[int] = None,
 47 |     ) -> Optional[ta.Observations]:
 48 |         
 49 |         if seed is not None:
 50 |             random.seed(seed)
 51 |         else:
 52 |             random.seed()
 53 | 
 54 |         
 55 |         self.game_word = random.choice(self.word_list)
 56 | 
 57 |         
 58 |         initial_context = (
 59 |             f"You are the gamemaster for the game of '20 Questions'.\n"
 60 |             f"You will provide responses to the players' questions that guides them into guessing the target word: {self.game_word}\n"
 61 |         )
 62 |         self.gamemaster.set_initial_context(initial_context=initial_context)
 63 |         
 64 |         
 65 |         return self.state.reset(
 66 |             game_state={
 67 |                 "target_word": self.game_word,
 68 |                 "rendered_text": self._render_text() 
 69 |             },
 70 |             player_prompt_function=self._generate_player_prompt
 71 |         )
 72 |     
 73 |     def _generate_player_prompt(
 74 |         self,
 75 |         player_id: int,
 76 |     ) -> str:
 77 |         
 78 |         prompt = (
 79 |             f"You are Player {player_id}. You are playing 20 Questions ({'Hardcore' if self.hardcore else 'Basic'}).\n"
 80 |             "The gamemaster has chosen one word. You have to guess that word by asking yes-or-no questions.\n"
 81 |             "The game will last for a maximum of 20 questions. After 20 questions, the gamemaster will prompt you to make a guess.\n"
 82 |             "You may ask your question in any manner.\n"
 83 |             "But, to make your final word guess, ensure that you wrap it with square brackets, e.g. [plane].\n"
 84 |             "As you play, the history of your questions and gamemaster's responses will be displayed."
 85 |         )
 86 | 
 87 |         return prompt
 88 |     
 89 |     def step(
 90 |         self,
 91 |         player_id: int,
 92 |         action: str,
 93 |     ) -> Tuple[
 94 |         Optional[ta.Observations],
 95 |         Optional[ta.Rewards],
 96 |         bool,
 97 |         bool,
 98 |         ta.Info
 99 |     ]:
100 |         
101 | 
102 |         
103 |         self.state.add_observation(
104 |             from_id=player_id,
105 |             to_id=-1,
106 |             message=action,
107 |             for_logging=True
108 |         )
109 | 
110 |         
111 |         action_search_pattern = re.compile(r"\[([a-zA-Z]+)\]") 
112 |         action_match = action_search_pattern.search(action)
113 | 
114 |         if not action_match:
115 |             
116 |             gamemaster_response = self._generate_gamemaster_response(action)
117 |             if self.state.turn == self.state.max_turns-2:
118 |                 gamemaster_response += "\nYou have run out of questions. What is your final guess?"
119 |             self.state.add_observation(
120 |                 from_id=-1,
121 |                 to_id=player_id,
122 |                 message=gamemaster_response,
123 |                 for_logging=True
124 |             )
125 | 
126 |         else:
127 |             
128 |             action_text = action_match.group(1).lower()
129 |             if action_text == self.game_word:
130 |                 self.state.set_winners(
131 |                     player_ids=[player_id],
132 |                     reason=f"Congratulations! Player {player_id} guessed the word."
133 |                 )
134 |             else:
135 |                 self.state.set_invalid_move(
136 |                     player_ids=[player_id],
137 |                     reasons=[f"Invalid guess. Player {player_id} guessed incorrectly."]
138 |                     )
139 | 
140 |             self.state.game_state["rendered_text"] = self._render_text() 
141 | 
142 |         return self.state.step()
143 | 
144 |     def _generate_gamemaster_response(self, question: str) -> str:
145 |         
146 |         responses = self.gamemaster.respond_to_action(question)
147 | 
148 |         return responses
149 |     
150 |     def _render_text(self) -> str:
151 |         
152 |         return f"Game word: {self.game_word}"
153 |     
154 |     def render(self):
155 |         
156 |         print(self.state.game_state["rendered_text"])
157 | 
158 |     def _load_word_list(self, word_list: list) -> list:
159 |         
160 |         
161 |         return [word for word in word_list if pos_tag([word])[0][1] in ["NN"]]
162 | 
```

## File: textarena/envs/single_player/TwentyQuestions/README.md

- Extension: .md
- Language: markdown
- Size: 7342 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Twenty Questions Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | The Twenty Questions Environment is a single-player, question-driven game where a player aims to deduce a secret word selected by a gamemaster within a limit of 20 yes-or-no questions, followed by a final guess. The gamemaster, configurable in behavior, responds to each question with "Yes," "No," or "I don't know" based on the chosen word, guiding the player toward a correct guess. In hardcore mode, the game uses a refined word list with only common nouns for added difficulty. The environment tracks player moves, validates guesses (formatted as [word]), and updates the game state for each interaction, offering a structured and engaging experience that challenges players’ deductive reasoning and strategic questioning skills.
  6 | 
  7 | ## Action Space
  8 | - **Format:** Actions are strings that can either be a question or a final guess that is formatted as [guess]. For example:
  9 | - **Examples:**
 10 |     - To ask a question: "Is it a living thing?"
 11 |     - To make a final guess: [elephant]
 12 | - **Notes:** Players can ask any yes-or-no question, and the gamemaster will respond with "Yes," "No," or "I don't know." To submit a final guess, players must enclose their guess in square brackets (e.g., [word]). Incorrectly formatted guesses or statements outside this format will be marked as invalid.
 13 | 
 14 | ## Observation Space
 15 | **Reset Observation:**
 16 | On reset, the observation provides the initial prompt. For example:
 17 | ```plaintext
 18 | [GAME] You are Player 0. You are playing 20 Questions (Basic).
 19 | The gamemaster has chosen one word. You have to guess that word by asking yes-or-no questions.
 20 | The game will last for a maximum of 20 questions. After 20 questions, the gamemaster will prompt you to make a guess.
 21 | You may ask your question in any manner.
 22 | But, to make your final word guess, ensure that you wrap it with square brackets, e.g. [plane].
 23 | As you play, the history of your questions and gamemaster's responses will be displayed.
 24 | ```
 25 | 
 26 | **Step Observation:**
 27 | After each step, the environment returns the action (e.g. "Yes", "No", "I don't know"). For example:
 28 | ```plaintext
 29 | [Player 0] Great! Let's get started.
 30 | 
 31 | Is the word you're thinking of a living thing?
 32 | [GAME] No
 33 | ```
 34 | 
 35 | By default, the environment returns observations in the following format:
 36 | ```python
 37 | {
 38 |   player_id: int : [
 39 |     (sender_id: int, message: str),
 40 |     (sender_id: int, message: str),
 41 |     ...
 42 |   ]
 43 | }
 44 | ```
 45 | 
 46 | **Note:** _Should the judge be unable to interpret the questions and provide one of the three assigned options - "yes", "no" or "I don't know" - the judge will respond with "I'm sorry, I don't understand. Please try asking again." in an effort to get the player to rephrase its action._
 47 | 
 48 | 
 49 | ## Gameplay
 50 | **Game Setup:** The game begins with the `reset` method selecting a target word from a predefined word list, based on the selected difficulty. The player then initiates the game by asking yes-or-no questions to uncover hints about the target word.
 51 | 
 52 | **Turns:** Players take turns by either asking questions or making a final guess within a maximum of 20 questions. Each turn, the player can ask questions like, “Is it a living thing?” The gamemaster will respond with "Yes," "No," or "I don’t know," providing clues for deducing the word. To submit a final guess, players must wrap it in square brackets (e.g., [elephant]). The environment tracks questions asked, and the correctness of the final guess.
 53 | 
 54 | **Objective:** The player’s goal is to identify the target word using the information gleaned from the gamemaster's responses. By formulating strategic questions, the player can narrow down the possibilities and improve their chances of guessing correctly within the question limit.
 55 | 
 56 | **Winning Condition:** The game is won if the player successfully guesses the target word within 20 questions. If the player’s guess matches the target word, they receive a congratulatory message, confirming the win. If incorrect, the player loses the game.
 57 | 
 58 | ## Key Rules:
 59 | 
 60 | - **Valid Moves:**
 61 |     - For the submission of final guesses, the player must follow the structure of [guess].
 62 |     - It is possible for the player to make a final guess even before the 20 question limit is up.
 63 |     - The player still can win if on the 21st attempt, it correctly guesses the word. This follows the gameplay rules where after 20 questions, the player would have to makes its final guess.
 64 | 
 65 | ## Rewards
 66 | | Outcome          | Reward for Player |
 67 | |------------------|:-----------------:|
 68 | | **Win**          |       `+1`        |
 69 | | **Lose**         |       `0`         |
 70 | | **Invalid Move** |       `-1`        |
 71 | 
 72 | ## Parameters
 73 | - `hardcore` (`bool`)
 74 | - Description: Sets the difficulty level of the game by determining the word list difficulty from which words are chosen.
 75 | - Impact:
 76 |     - False (default): The game uses a basic word list (en-basic), making it easier for players with common and shorter words.
 77 |     - True: The game uses a larger and more challenging vocabulary (en), featuring less common and longer words, making it suitable for advanced players.
 78 | 
 79 | ## Variants
 80 | 
 81 | | Env-id                       | hardcore |
 82 | |------------------------------|:--------:|
 83 | | `TwentyQuestions-v0`         | `False`  |
 84 | | `TwentyQuestions-v0-hardcore`|  `True`  |
 85 | 
 86 | ## Example Usage
 87 | 
 88 | ```python
 89 | import textarena as ta
 90 | 
 91 | ## initializa the environment
 92 | env = ta.make("TwentyQuestions-v0")
 93 | 
 94 | ## Wrap the environment for easier observation handling
 95 | env = ta.wrappers.LLMObservationWrapper(env=env)
 96 | 
 97 | ## Wrap the environment for pretty rendering
 98 | env = ta.wrappers.PrettyRenderWrapper(env=env)
 99 | 
100 | ## initalize agents
101 | agents = {
102 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
103 |     }
104 | 
105 | ## reset the environment to start a new game
106 | observations = env.reset(seed=490)
107 | 
108 | ## Game loop
109 | done = False
110 | while not done:
111 | 
112 |     # Get the current player
113 |     current_player_id = env.state.get("current_player")
114 | 
115 |     # Get the current observation for the player
116 |     obs = observations[current_player_id]
117 | 
118 |     # Agent decides on an action based on the observation
119 |     action = agents[current_player_id](obs)
120 | 
121 |     # Execute the action in the environment
122 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
123 | 
124 |     # Check if the game has ended
125 |     done = terminated or truncated
126 | 
127 |     # Optionally render the environment to see the current state
128 |     env.render()
129 | 
130 |     if done:
131 |         break
132 | 
133 | ## Finally, print the game results
134 | for player_id, agent in agents.items():
135 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
136 | print(f"Reason: {info['reason']}")
137 | ```
138 | 
139 | ## Troubleshooting
140 | 
141 | **Repeated Question:**
142 | 
143 | - **Issue**: Due to the open response, the player has given questions that are closely similar to earlier ones.
144 | - **Solution**: Insert into the player's initial prompt the strategy of seeking a diverse range of questions.
145 | 
146 | **Gamemaster Response Missing or Incorrect:**
147 | 
148 |   - **Issue**: The gamemaster doesn’t respond or provides an unclear answer to a valid question.
149 |   - **Solution**: Check that _generate_gamemaster_response correctly processes the player’s question and that self.gamemaster.respond_to_action is functioning as expected.
150 | 
151 | 
152 | ## Version History
153 | - **v0**
154 |   - Initial release 
155 | 
156 | 
157 | ### Contact
158 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/TwentyQuestions/example.py

- Extension: .py
- Language: python
- Size: 1282 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("TwentyQuestions-v0")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/Sudoku/test.py

- Extension: .py
- Language: python
- Size: 5225 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | import unittest
  2 | from parameterized import parameterized
  3 | from textarena.envs.single_player.Sudoku.env import SudokuEnv  
  4 | 
  5 | 
  6 | def generate_correct_move_sequence():
  7 |     
  8 |     return ["[6 4 4]", "[7 3 3]"]  
  9 | 
 10 | def generate_invalid_format_sequence():
 11 |     
 12 |     return ["row 3 col 2 4"]  
 13 | 
 14 | def generate_out_of_bounds_sequence():
 15 |     
 16 |     return ["[10 3 5]"]  
 17 | 
 18 | def generate_overwrite_pre_filled_sequence():
 19 |     
 20 |     return ["[2 1 7]"]  
 21 | 
 22 | def generate_invalid_move_sequence():
 23 |     
 24 |     return ["[7 3 9]", "[1 2 5]"]  
 25 | 
 26 | class TestSudokuEnv(unittest.TestCase):
 27 | 
 28 |     
 29 |     env_variants = [
 30 |         {"difficulty": "easy", "max_turns": 5},
 31 |         {"difficulty": "medium", "max_turns": 10},
 32 |         {"difficulty": "hard", "max_turns": 15},
 33 |     ]
 34 |     
 35 |     
 36 |     test_cases = {
 37 |         "correct_move_easy": {
 38 |             "difficulty": "easy",
 39 |             "actions": generate_correct_move_sequence()
 40 |         },
 41 |         "invalid_format_easy": {
 42 |             "difficulty": "easy",
 43 |             "actions": generate_invalid_format_sequence()
 44 |         },
 45 |         "out_of_bounds_easy": {
 46 |             "difficulty": "easy",
 47 |             "actions": generate_out_of_bounds_sequence()
 48 |         },
 49 |         "overwrite_pre_filled_easy": {
 50 |             "difficulty": "easy",
 51 |             "actions": generate_overwrite_pre_filled_sequence()
 52 |         },
 53 |         "invalid_move_easy": {
 54 |             "difficulty": "easy",
 55 |             "actions": generate_invalid_move_sequence()
 56 |         },
 57 |     }
 58 |     
 59 |     @parameterized.expand([
 60 |         (name, details["difficulty"], details["actions"])
 61 |         for name, details in test_cases.items()
 62 |     ])
 63 |     def test_sudoku_outcomes(self, name, difficulty, action_sequence):
 64 |         
 65 |         
 66 |         env_config = next((env for env in self.env_variants if env["difficulty"] == difficulty), None)
 67 |         self.assertIsNotNone(env_config, f"Environment config for {difficulty} not found.")
 68 |         
 69 |         env = SudokuEnv(difficulty=env_config["difficulty"], max_turns=env_config["max_turns"])
 70 | 
 71 |         observations = env.reset(seed=490)
 72 |         
 73 |         terminated = False
 74 |         truncated = False
 75 | 
 76 |         for i, action in enumerate(action_sequence):
 77 |             if terminated or truncated:
 78 |                 break
 79 |             player_id = 0  
 80 |             obs = observations
 81 |             
 82 |             
 83 |             observations, reward, truncated, terminated, info = env.step(player_id, action)
 84 |             
 85 |             
 86 |             if "correct_move" in name:
 87 |                 self.assertFalse(truncated, "Game should not truncate for correct moves.")
 88 |                 self.assertFalse(terminated, "Game should not terminate until the puzzle is complete.")
 89 |             elif "invalid_format" in name:
 90 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
 91 |                 self.assertEqual(reward[0], -1, "Player should receive -1 reward for an invalid move format.")
 92 |             elif "out_of_bounds" in name:
 93 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an out-of-bounds move.")
 94 |                 self.assertEqual(reward[0], -1, "Player should receive -1 for out-of-bounds move.")
 95 |             elif "overwrite_pre_filled" in name:
 96 |                 self.assertTrue(truncated or terminated, "Game should terminate due to overwriting a pre-filled cell.")
 97 |                 self.assertEqual(reward[0], -1, "Player should receive -1 for overwriting a pre-filled cell.")
 98 |             elif "invalid_move" in name:
 99 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move.")
100 |                 self.assertEqual(reward[0], -1, "Player should receive -1 for violating Sudoku rules.")
101 |             else:
102 |                 self.fail(f"Unknown test case name: {name}")
103 | 
104 | def run_unit_test():
105 |     print("Running SudokuEnv tests...")
106 |     unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/single_player/Sudoku/env.py

- Extension: .py
- Language: python
- Size: 17902 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from typing import Any, Dict, Optional, Tuple, List
  2 | import random, re
  3 | import copy
  4 | import textarena as ta
  5 | import time
  6 | 
  7 | class SudokuEnv(ta.Env):
  8 |     
  9 | 
 10 |     def __init__(
 11 |         self, 
 12 |         difficulty: Optional[str] = "easy",
 13 |         max_turns: Optional[int] = 5,
 14 |     ):
 15 |         
 16 |         self.environment_name = "Sudoku"
 17 |         self.difficulty = difficulty
 18 |         self.max_turns = max_turns
 19 | 
 20 |         
 21 |         self.state = ta.State(
 22 |             num_players=1,
 23 |             max_turns=max_turns,
 24 |             render_keys=["rendered_board"], 
 25 |         )
 26 | 
 27 |     def _generate_board(self, difficulty: str) -> List[List[int]]:
 28 |         
 29 |         
 30 |         difficulty_levels = {
 31 |             "easy": 30, 
 32 |             "medium": 40, 
 33 |             "hard": 50 
 34 |         }
 35 |         clues = difficulty_levels.get(difficulty, 30) 
 36 | 
 37 |         
 38 |         full_grid = self._generate_full_grid()
 39 | 
 40 |         
 41 |         puzzle_grid = self._remove_cells(full_grid, clues)
 42 | 
 43 |         return puzzle_grid
 44 |     
 45 |     def _generate_full_grid(self) -> List[List[int]]:
 46 |         
 47 |         grid = [[0 for _ in range(9)] for _ in range(9)]
 48 |         self._fill_grid(grid)
 49 |         return grid
 50 | 
 51 |     def _fill_grid(self, grid: List[List[int]]) -> bool:
 52 |         
 53 |         empty = self._find_empty(grid)
 54 |         if not empty:
 55 |             return True  
 56 |         row, col = empty
 57 | 
 58 |         numbers = list(range(1, 10))
 59 |         random.shuffle(numbers)
 60 |         for num in numbers:
 61 |             if self.is_safe(grid, row, col, num):
 62 |                 grid[row][col] = num
 63 |                 if self._fill_grid(grid):
 64 |                     return True
 65 |                 grid[row][col] = 0
 66 |         return False
 67 |     
 68 |     def _find_empty(self, grid: List[List[int]]) -> Optional[Tuple[int, int]]:
 69 |         
 70 |         for i in range(9):
 71 |             for j in range(9):
 72 |                 if grid[i][j] == 0:
 73 |                     return (i, j)
 74 |         return None
 75 | 
 76 |     def is_safe(self, grid: List[List[int]], row: int, col: int, num: int) -> bool:
 77 |         
 78 |         
 79 |         if num in grid[row]:
 80 |             return False
 81 |         
 82 |         if num in [grid[i][col] for i in range(9)]:
 83 |             return False
 84 |         
 85 |         start_row, start_col = 3 * (row // 3), 3 * (col // 3)
 86 |         for i in range(start_row, start_row + 3):
 87 |             for j in range(start_col, start_col + 3):
 88 |                 if grid[i][j] == num:
 89 |                     return False
 90 |         return True
 91 | 
 92 |     def _remove_cells(self, grid: List[List[int]], clues: int) -> List[List[int]]:
 93 |         
 94 |         puzzle = copy.deepcopy(grid)
 95 |         cells = [(i, j) for i in range(9) for j in range(9)]
 96 |         random.shuffle(cells)
 97 | 
 98 |         while len(cells) > (81 - clues):
 99 |             row, col = cells.pop()
100 |             removed = puzzle[row][col]
101 |             puzzle[row][col] = 0
102 | 
103 |             
104 |             grid_copy = copy.deepcopy(puzzle)
105 |             solutions = []
106 |             self._count_solutions(grid_copy, solutions)
107 |             if len(solutions) != 1:
108 |                 
109 |                 puzzle[row][col] = removed
110 | 
111 |         return puzzle
112 | 
113 |     def _solve_sudoku(self, grid: List[List[int]]) -> bool:
114 |         
115 |         empty = self._find_empty(grid)
116 |         if not empty:
117 |             return True  
118 |         row, col = empty
119 | 
120 |         for num in range(1, 10):
121 |             if self.is_safe(grid, row, col, num):
122 |                 grid[row][col] = num
123 |                 if self._solve_sudoku(grid):
124 |                     return True
125 |                 grid[row][col] = 0
126 |         return False
127 | 
128 |     def _count_solutions(self, grid: List[List[int]], solutions: List[List[List[int]]], limit: int = 2) -> int:
129 |         
130 |         if len(solutions) >= limit:
131 |             return len(solutions)
132 | 
133 |         empty = self._find_empty(grid)
134 |         if not empty:
135 |             solutions.append(copy.deepcopy(grid))
136 |             return len(solutions)
137 |         row, col = empty
138 | 
139 |         for num in range(1, 10):
140 |             if self.is_safe(grid, row, col, num):
141 |                 grid[row][col] = num
142 |                 self._count_solutions(grid, solutions, limit)
143 |                 grid[row][col] = 0
144 |         return len(solutions)
145 |     
146 |     def reset(
147 |         self, 
148 |         seed: Optional[int] = None 
149 |     ) -> Optional[ta.Observations]:
150 |         
151 |         if seed is not None:
152 |             random.seed(seed)
153 |         else:
154 |             random.seed()
155 | 
156 |         
157 |         self.game_board = self._generate_board(self.difficulty)
158 | 
159 |         return self.state.reset(
160 |             game_state={
161 |                 "board": copy.deepcopy(self.game_board),
162 |                 "rendered_board": self._get_grid_string_with_indices(self.game_board),
163 |                 "start_time": time.time(),
164 |                 "completed": False,
165 |             },
166 |             player_prompt_function=self._generate_player_prompt,
167 |         )
168 |     
169 |     def _generate_player_prompt(self, player_id: int) -> str:
170 |         
171 |         prompt = (
172 |             f"You are Player {player_id}. You are playing Sudoku ({self.difficulty}).\n"
173 |             "Here is the current state of the Sudoku grid. Each row is numbered from 1 to 9, and each column is also numbered from 1 to 9.\n"
174 |             "Empty cells are represented by '.', and pre-filled cells contain digits from 1 to 9.\n\n"
175 |             "Current Sudoku Grid:\n"
176 |         )
177 |         
178 |         
179 |         grid_str = self._get_grid_string_with_indices()
180 |         prompt += f"{grid_str}\n\n"
181 |         
182 |         prompt += (
183 |             "Your objective is to fill the empty cells in the 9x9 grid with digits from 1 to 9 such that:\n"
184 |             "1. Each row contains all digits from 1 to 9 without repetition.\n"
185 |             "2. Each column contains all digits from 1 to 9 without repetition.\n"
186 |             "3. Each of the nine 3x3 subgrids contains all digits from 1 to 9 without repetition.\n\n"
187 |             "Rules and Instructions:\n"
188 |             "1. **Do not overwrite** the initial numbers provided in the grid.\n"
189 |             "2. **Only fill** empty cells represented by '.'.\n"
190 |             "3. You may respond in any manner you prefer, but ensure that your response includes the format of '[row column number]'.\n"
191 |             "4. **Ensure** that your move does not violate Sudoku rules. Invalid moves will result in penalties.\n"
192 |             "Examples:\n"
193 |             "- **Valid Move**:\n"
194 |             "  - Grid Snippet Before Move:\n"
195 |             "  \n"
196 |             "  - Move: `[5 3 7]`\n"
197 |             "  - Explanation: Placing 7 at row 5, column 3 does not violate any Sudoku rules.\n\n"
198 |             "- **Invalid Move** (Overwriting a pre-filled cell):\n"
199 |             "  - Grid Snippet Before Move:\n"
200 |             "  \n"
201 |             "  - Move: `[1 1 9]`\n"
202 |             "  - Explanation: Cell (1,1) is already filled with 5. You cannot overwrite it.\n\n"
203 |             "- **Invalid Move** (Violating Sudoku rules):\n"
204 |             "  - Grid Snippet Before Move:\n"
205 |             "  \n"
206 |             "  - Move: `[1 3 5]`\n"
207 |             "  - Explanation: Placing 5 in row 1, column 3 violates the rule since 5 already exists in row 1.\n\n"
208 |             "The history of your moves and thoughts will be appended as you play more rounds. Use the history of your move to improve your decision making by avoiding the moves you have tried. Good luck!\n\n"
209 |         )
210 |         
211 |         return prompt
212 | 
213 | 
214 |     def step(
215 |         self, 
216 |         player_id: int, 
217 |         action: str
218 |     ) -> Tuple[
219 |         Optional[ta.Observations], 
220 |         Optional[ta.Rewards], 
221 |         bool, 
222 |         bool, 
223 |         ta.Info 
224 |     ]:
225 |         
226 | 
227 |         
228 |         self.state.add_observation(
229 |             from_id=player_id,
230 |             to_id=-1, 
231 |             message=action,
232 |             for_logging=True
233 |         )
234 | 
235 |         
236 |         
237 |         action_search_pattern = re.compile(r"\[(\d+)\s(\d+)\s(\d+)\]")
238 |         match = action_search_pattern.search(action)
239 | 
240 |         if not match:
241 |             self.state.set_invalid_move(
242 |                 player_ids=[player_id],
243 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with valid 'row column number'."]
244 |             )
245 |         else:
246 |             row, col, num = map(int, match.groups())
247 |             if row < 1 or row > 9 or col < 1 or col > 9 or num < 1 or num > 9:
248 |                 self.state.set_invalid_move(
249 |                     player_ids=[player_id],
250 |                     reasons=[f"Invalid move. Player {player_id} attempted to place {num} at ({row}, {col}), which is out of bounds."]
251 |                 )
252 |             else:
253 |                 row_idx, col_idx = row - 1, col - 1
254 |                 
255 |                 if self.game_board[row_idx][col_idx] != 0:
256 |                     self.state.set_invalid_move(
257 |                         player_ids=[player_id],
258 |                         reasons=[f"Invalid move. Player {player_id} attempted to overwrite a pre-filled cell ({row}, {col})."]
259 |                     )
260 |                 elif self._is_move_correct(row_idx, col_idx, num):
261 |                     
262 |                     self.state.game_state["board"][row_idx][col_idx] = num
263 |                     self.state.add_observation(
264 |                         from_id=ta.GAME_ID,
265 |                         to_id=-1,
266 |                         message=f"Board state: \n{self._get_grid_string_with_indices()}",
267 |                         for_logging=False
268 |                     )
269 |                 else:
270 |                     self.state.set_invalid_move(
271 |                         player_ids=[player_id],
272 |                         reasons=[f"Invalid move. Player {player_id} attempted to place {num} at ({row}, {col}), which violates Sudoku rules."]
273 |                     )
274 | 
275 |                 
276 |                 if self._is_puzzle_complete():
277 |                     self.state.game_state["completed"] = True
278 |                     self.state.set_winners(
279 |                         player_ids=[player_id],
280 |                         reason=f"Congratulations! Player {player_id} completed the Sudoku puzzle."
281 |                     )
282 | 
283 |                 
284 |                 self.state.game_state["rendered_board"] = self._get_grid_string_with_indices(self.state.game_state["board"])
285 | 
286 |         
287 |         return self.state.step()
288 |             
289 |     def render(self):
290 |         
291 |         grid_str = self._get_grid_string_with_indices()
292 |         print("Board State\n", grid_str)
293 |         print(f"Turn Number {self.state.turn} of {self.max_turns}")
294 |     
295 |     def _get_grid_string_with_indices(self, game_board: Optional[List[int]] = None) -> str:
296 |         
297 |         if game_board is None:
298 |             game_board = self.state.game_state["board"]
299 |         header = "   " + " ".join([f"C{j+1}" + ("  " if (j + 1) % 3 == 0 else "") for j in range(9)])  
300 |         lines = [header]
301 |         for i, row in enumerate(game_board):
302 |             row_str = f"R{i+1} "  
303 |             for j, num in enumerate(row):
304 |                 cell = str(num) if num != 0 else "."
305 |                 row_str += f" {cell} "
306 |                 if (j + 1) % 3 == 0 and j < 8:
307 |                     row_str += "| "
308 |             lines.append(row_str.strip())
309 |             if (i + 1) % 3 == 0 and i < 8:
310 |                 lines.append("   " + "- " * 16)
311 | 
312 |         return "\n".join(lines)
313 |     
314 |     def _is_move_correct(self, row: int, col: int, num: int) -> bool:
315 |         
316 |         
317 |         if num in self.state.game_state["board"][row]:
318 |             return False
319 |         
320 |         if num in [self.state.game_state["board"][i][col] for i in range(9)]:
321 |             return False
322 |         
323 |         start_row, start_col = 3 * (row // 3), 3 * (col // 3)
324 |         for i in range(start_row, start_row + 3):
325 |             for j in range(start_col, start_col + 3):
326 |                 if self.state.game_state["board"][i][j] == num:
327 |                     return False
328 |         return True
329 |     
330 |     def _is_puzzle_complete(self) -> bool:
331 |         
332 |         for i in range(9):
333 |             for j in range(9):
334 |                 num = self.state.game_state["board"][i][j]
335 |                 if num == 0 or not self._is_move_correct_complete(i, j, num):
336 |                     return False
337 |         return True
338 |     
339 |     def _is_move_correct_complete(self, row: int, col: int, num: int) -> bool:
340 |         
341 |         
342 |         self.state.game_state["board"][row][col] = 0
343 |         correct = self._is_move_correct(row, col, num)
344 |         self.state.game_state["board"][row][col] = num
345 |         return correct
```

## File: textarena/envs/single_player/Sudoku/readme.md

- Extension: .md
- Language: markdown
- Size: 10850 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Sudoku Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | Sudoku is a single-player puzzle game where the player fills a 9x9 grid with numbers from 1 to 9. The goal is to ensure that each number appears only once in each row, column, and 3x3 subgrid. This environment supports varying difficulty levels and allows for hint-enabled or hint-disabled gameplay.
  6 | 
  7 | ## Action Space
  8 | - **Format**: Actions are strings in the format [row col num], where row and col are grid indices (1-9) and num is the number (1-9) the player wants to place.
  9 | - **Examples**: [5 3 7], I would like to place 7 in row 5, column 3: [5 3 7]
 10 | - **Notes**: Additional text can accompany the action, but it must include the correct format [row col num] for the action to be processed correctly.
 11 | 
 12 | ## Observation Space
 13 | 
 14 | **Reset Observation:**
 15 | On reset, the observation provides the initial prompt and the state of the Sudoku grid. For example:
 16 | ```plaintext
 17 | [GAME] You are Player 0. You are playing Sudoku (easy).
 18 | Here is the current state of the Sudoku grid. Each row is numbered from 1 to 9, and each column is also numbered from 1 to 9.
 19 | Empty cells are represented by '.', and pre-filled cells contain digits from 1 to 9.
 20 | 
 21 | Current Sudoku Grid:
 22 |    C1 C2 C3   C4 C5 C6   C7 C8 C9  
 23 | R1  .  8  9 |  1  .  . |  .  3  7
 24 | R2  2  7  1 |  9  4  3 |  6  .  8
 25 | R3  .  6  5 |  .  2  7 |  4  9  .
 26 |    - - - - - - - - - - - - - - - - 
 27 | R4  .  .  . |  7  8  . |  9  2  3
 28 | R5  .  9  2 |  .  5  6 |  .  .  4
 29 | R6  7  3  8 |  .  .  2 |  1  .  .
 30 |    - - - - - - - - - - - - - - - - 
 31 | R7  8  4  . |  .  .  9 |  5  .  .
 32 | R8  5  .  . |  6  .  8 |  3  4  9
 33 | R9  9  .  6 |  5  3  4 |  8  7  2
 34 | 
 35 | Your objective is to fill the empty cells in the 9x9 grid with digits from 1 to 9 such that:
 36 | 1. Each row contains all digits from 1 to 9 without repetition.
 37 | 2. Each column contains all digits from 1 to 9 without repetition.
 38 | 3. Each of the nine 3x3 subgrids contains all digits from 1 to 9 without repetition.
 39 | 
 40 | Rules and Instructions:
 41 | 1. Do not overwrite the initial numbers provided in the grid.
 42 | 2. Only fill empty cells represented by '.'.
 43 | 3. You may respond in any manner you prefer, but ensure that your response includes the format of '[row column number]'.
 44 | 4. Ensure that your move does not violate Sudoku rules. Invalid moves will result in penalties.
 45 | Examples:
 46 | - Valid Move:
 47 |   - Grid Snippet Before Move:
 48 |   
 49 |   - Move: [5 3 7]
 50 |   - Explanation: Placing 7 at row 5, column 3 does not violate any Sudoku rules.
 51 | 
 52 | - Invalid Move (Overwriting a pre-filled cell):
 53 |   - Grid Snippet Before Move:
 54 |   
 55 |   - Move: [1 1 9]
 56 |   - Explanation: Cell (1,1) is already filled with 5. You cannot overwrite it.
 57 | 
 58 | - Invalid Move (Violating Sudoku rules):
 59 |   - Grid Snippet Before Move:
 60 |   
 61 |   - Move: [1 3 5]
 62 |   - Explanation: Placing 5 in row 1, column 3 violates the rule since 5 already exists in row 1.
 63 | 
 64 | The history of your moves and thoughts will be appended as you play more rounds. Use the history of your move to improve your decision making by avoiding the moves you have tried. Good luck!
 65 | 
 66 | ```
 67 | **Step Observation:**
 68 | After each step, the environment returns the action and the updated Sudoku grid as the observation. For example:
 69 | ```plaintext
 70 | [Player 0] Let's analyze the given Sudoku grid and identify the possible moves:
 71 | 
 72 | Current Sudoku Grid:
 73 |    C1 C2 C3   C4 C5 C6   C7 C8 C9  
 74 | R1  .  8  9 |  1  .  . |  .  3  7
 75 | R2  2  7  1 |  9  4  3 |  6  .  8
 76 | R3  .  6  5 |  .  2  7 |  4  9  .
 77 |    - - - - - - - - - - - - - - - - 
 78 | R4  .  .  . |  7  8  . |  9  2  3
 79 | R5  .  9  2 |  .  5  6 |  .  .  4
 80 | R6  7  3  8 |  .  .  2 |  1  .  .
 81 |    - - - - - - - - - - - - - - - - 
 82 | R7  8  4  . |  .  .  9 |  5  .  .
 83 | R8  5  .  . |  6  .  8 |  3  4  9
 84 | R9  9  .  6 |  5  3  4 |  8  7  2
 85 | 
 86 | Step-by-Step Analysis
 87 | 
 88 | 1. Row Analysis:
 89 |    - Row 1: Missing values are 2, 4, 5, 6, 8.
 90 |    - Row 2: Missing value is 5.
 91 |    - Row 3: Missing values are 1, 3, 8.
 92 |    - Row 4: Missing values are 1, 4, 5, 6.
 93 |    - Row 5: Missing values are 1, 3, 7, 8, 9.
 94 |    - Row 6: Missing values are 4, 5, 6, 9.
 95 |    - Row 7: Missing values are 1, 2, 3, 6, 7.
 96 |    - Row 8: Missing values are 1, 2, 7.
 97 |    - Row 9: Missing value is 1.
 98 | 
 99 | 2. Column Analysis:
100 |    - Column 1: Missing values are 1, 3, 4, 5, 6.
101 |    - Column 2: Missing values are 1, 2, 3, 5.
102 |    - Column 3: Missing values are 2, 3, 4.
103 |    - Column 4: Missing values are 2, 3, 4, 5.
104 |    - Column 5: Missing values are 1, 3, 6, 7.
105 |    - Column 6: Missing values are 1, 4, 5, 7, 8.
106 |    - Column 7: Missing values are 2, 3, 6, 7, 8.
107 |    - Column 8: Missing values are 1, 2, 4, 6.
108 |    - Column 9: Missing values are 1.
109 | 
110 | 3. Subgrid Analysis:
111 |    - Subgrid 1 (R1-R3, C1-C3): Missing values are 1, 3, 4, 5, 6.
112 |    - Subgrid 2 (R1-R3, C4-C6): Missing values are 2, 3, 4, 5, 6.
113 |    - Subgrid 3 (R1-R3, C7-C9): Missing values are 1, 2, 3, 5, 6.
114 |    - Subgrid 4 (R4-R6, C1-C3): Missing values are 1, 3, 4, 5, 6.
115 |    - Subgrid 5 (R4-R6, C4-C6): Missing values are 1, 2, 3, 4, 5, 6.
116 |    - Subgrid 6 (R4-R6, C7-C9): Missing values are 1, 3, 5, 6, 7, 8.
117 |    - Subgrid 7 (R7-R9, C1-C3): Missing values are 1, 2, 3, 6, 7.
118 |    - Subgrid 8 (R7-R9, C4-C6): Missing values are 1, 2, 3, 6, 7.
119 |    - Subgrid 9 (R7-R9, C7-C9): Missing values are 1, 2, 3.
120 | 
121 | First Move
122 | Now, let's make a move:
123 | - Looking at Row 5, I notice that the missing values are 1, 3, 7, 8, 9. 
124 | - Column 1 has values 2, 7, 8, 9, so the only possible value in Row 5, Column 1 is 1.
125 | 
126 | Valid Move: 
127 | - Move: [5 1 1] (Placing 1 at Row 5, Column 1)
128 | 
129 | After this move, the grid will be updated. 
130 | 
131 | Updated Grid after Move
132 |    C1 C2 C3   C4 C5 C6   C7 C8 C9  
133 | R1  .  8  9 |  1  .  . |  .  3  7
134 | R2  2  7  1 |  9  4  3 |  6  .  8
135 | R3  .  6  5 |  .  2  7 |  4  9  .
136 |    - - - - - - - - - - - - - - - - 
137 | R4  .  .  . |  7  8  . |  9  2  3
138 | R5  1  9  2 |  .  5  6 |  .  .  4
139 | R6  7  3  8 |  .  .  2 |  1  .  .
140 |    - - - - - - - - - - - - - - - - 
141 | R7  8  4  . |  .  .  9 |  5  .  .
142 | R8  5  .  . |  6  .  8 |  3  4  9
143 | R9  9  .  6 |  5  3  4 |  8  7  2
144 | 
145 | Next Move
146 | Now, I will analyze the grid again and continue making moves based on valid placements. 
147 | 
148 | Please let me know if you want me to continue with the next move!
149 | [GAME] Board state: 
150 |    C1 C2 C3   C4 C5 C6   C7 C8 C9  
151 | R1  .  8  9 |  1  .  . |  .  3  7
152 | R2  2  7  1 |  9  4  3 |  6  .  8
153 | R3  .  6  5 |  .  2  7 |  4  9  .
154 |    - - - - - - - - - - - - - - - - 
155 | R4  .  .  . |  7  8  . |  9  2  3
156 | R5  1  9  2 |  .  5  6 |  .  .  4
157 | R6  7  3  8 |  .  .  2 |  1  .  .
158 |    - - - - - - - - - - - - - - - - 
159 | R7  8  4  . |  .  .  9 |  5  .  .
160 | R8  5  .  . |  6  .  8 |  3  4  9
161 | R9  9  .  6 |  5  3  4 |  8  7  2
162 | ```
163 | 
164 | By default, the environment returns observations in the following format:
165 | ```python
166 | {
167 |   player_id: int : [
168 |     (sender_id: int, message: str),
169 |     (sender_id: int, message: str),
170 |     ...
171 |   ]
172 | }
173 | ```
174 | where each step can product zero, one or many message tuples.
175 | 
176 | ## Gameplay
177 | - **Grid Size**: Fixed at 9x9.
178 | - **Turns**: The player fills empty cells with numbers from 1 to 9.
179 | - **Number Placement**: A number can only be placed in an empty cell, ensuring it doesn’t violate Sudoku rules (no repetition in rows, columns, or 3x3 subgrids).
180 | - **Winning Condition**: The game is won when all cells are filled correctly according to Sudoku rules.
181 | - **Restart Condition**: The player can restart if they make an error and wish to try again.
182 | 
183 | ## Key Rules
184 | - **Valid Moves**:
185 | 
186 |     - The player must enter a valid row, column, and number (1-9) in the [row col num] format.
187 |     - The move must not overwrite a pre-filled cell or violate Sudoku rules.
188 | 
189 | - **Invalid Moves**:
190 |  
191 |     - Entering an invalid row, column, or number (outside the 1-9 range).
192 |     - Overwriting a pre-filled cell or placing a number that violates - Sudoku rules (duplicates in the same row, column, or 3x3 subgrid) will result in a penalty.
193 | 
194 | 
195 | ## Rewards
196 | | Outcome          | Reward for Player  |
197 | |------------------|:------------------:|
198 | | **Win**          |       `+1`         |
199 | | **Lose**         |       `0`         |
200 | | **Invalid Move** |       `-1`         |
201 | 
202 | ## Parameters
203 | 
204 | - `difficulty` (`str`):
205 |     - **Description:** Determines how many clues the player has to begin with.
206 |     - **Impact:**
207 |         - **Easy:** Player is provided with 50 pre-filled positions. It has to only guess 31 values.
208 |         - **Medium**: Player is provided with 40 pre-filled positions. It has to only guess 41 values.
209 |         - **Hard**: Player is provided with 30 pre-filled positions. It has to only guess 51 values.
210 | 
211 | - `max_turns` (`int`):
212 |     - **Description:** Determines how many turns the player has to make its decisions.
213 |     - **Impact:** This affects the number of tries it can make to complete the game. 
214 | 
215 | 
216 | ## Variants
217 | 
218 | | Env-id              | difficulty | max_turns |
219 | |---------------------|:----------:|:---------:|
220 | | `Sudoku-v0-easy`    |   `easy`   | `31`      |
221 | | `Sudoku-v0-medium`  |   `medium` | `41`      |
222 | | `Sudoku-v0-hard`    |   `hard`   | `51`      |
223 | 
224 | ## Example Usage
225 | 
226 | ```python
227 | import textarena as ta
228 | 
229 | ## initializa the environment
230 | env = ta.make("Sudoku-v0-easy")
231 | 
232 | ## Wrap the environment for easier observation handling
233 | env = ta.wrappers.LLMObservationWrapper(env=env)
234 | 
235 | ## Wrap the environment for pretty rendering
236 | env = ta.wrappers.PrettyRenderWrapper(env=env)
237 | 
238 | ## initalize agents
239 | agents = {
240 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
241 |     }
242 | 
243 | ## reset the environment to start a new game
244 | observations = env.reset(seed=490)
245 | 
246 | ## Game loop
247 | done = False
248 | while not done:
249 | 
250 |     # Get the current player
251 |     current_player_id = env.state.get("current_player")
252 | 
253 |     # Get the current observation for the player
254 |     obs = observations[current_player_id]
255 | 
256 |     # Agent decides on an action based on the observation
257 |     action = agents[current_player_id](obs)
258 | 
259 |     # Execute the action in the environment
260 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
261 | 
262 |     # Check if the game has ended
263 |     done = terminated or truncated
264 | 
265 |     # Optionally render the environment to see the current state
266 |     env.render()
267 | 
268 |     if done:
269 |         break
270 | 
271 | ## Finally, print the game results
272 | for player_id, agent in agents.items():
273 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
274 | print(f"Reason: {info['reason']}")
275 | ```
276 | 
277 | ## Troubleshooting
278 | 
279 | **Invalid Move Format**
280 | 
281 | - **Issue**: The player enters a move in an incorrect format (e.g., without using [row col num]).
282 | - **Solution**: Remind the player to follow the correct format [row col num] for each move. For example, placing 5 in row 2, column 8 should be entered as [2 8 5].
283 | 
284 | **Overwriting Pre-Filled Cells**
285 | 
286 | - **Issue**: The player attempts to overwrite a cell that already contains a number.
287 | - **Solution**: Notify the player that pre-filled cells cannot be modified. Prompt them to select an empty cell represented by . on the grid.
288 | 
289 | 
290 | ## Version History
291 | - **v0**
292 |   - Initial release 
293 | 
294 | 
295 | ### Contact
296 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/Sudoku/example.py

- Extension: .py
- Language: python
- Size: 1278 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("Sudoku-v0-easy")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/Sudoku/__init__.py

- Extension: .py
- Language: python
- Size: 0 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python

```

## File: textarena/envs/single_player/TowerOfHanoi/test.py

- Extension: .py
- Language: python
- Size: 3932 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.TowerOfHanoi.env import TowerOfHanoiEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["[A B]", "[A C]"] 
 9 | 
10 | def generate_invalid_move_sequence():
11 |     
12 |     return ["[B A]", "[C A]", "[A A]", "[B C]"] 
13 | 
14 | def generate_out_of_bounds_sequence():
15 |     
16 |     return ["[A D]"] 
17 | 
18 | def generate_invalid_format_sequence():
19 |     
20 |     return ["A B", "(A C)", "[A, C]"] 
21 | 
22 | class TestTowerOfHanoiEnv(unittest.TestCase):
23 | 
24 |     
25 |     env_variants = [
26 |         {"difficulty": "easy"},
27 |         {"difficulty": "medium"},
28 |         {"difficulty": "hard"}
29 |     ]
30 | 
31 |     
32 |     test_cases = {
33 |         "correct_move_easy": {
34 |             "difficulty": "easy",
35 |             "actions": generate_correct_move_sequence()
36 |         },
37 |         "invalid_move_easy": {
38 |             "difficulty": "easy",
39 |             "actions": generate_invalid_move_sequence()
40 |         },
41 |         "out_of_bounds_easy": {
42 |             "difficulty": "easy",
43 |             "actions": generate_out_of_bounds_sequence()
44 |         },
45 |         "invalid_format_easy": {
46 |             "difficulty": "easy",
47 |             "actions": generate_invalid_format_sequence()
48 |         }
49 |     }
50 | 
51 |     @parameterized.expand([
52 |         (name, details['difficulty'], details['actions'])
53 |         for name, details in test_cases.items()
54 |     ])
55 |     def test_towerofhanoi_outcomes(self, name, difficulty, actions):
56 |         
57 |         env_config = next((env for env in self.env_variants if env['difficulty'] == difficulty), None)
58 |         self.assertIsNotNone(env_config, f"Invalid difficulty level: {difficulty}")
59 | 
60 |         env = TowerOfHanoiEnv(difficulty=env_config['difficulty'])
61 | 
62 |         observations = env.reset(seed=490)
63 | 
64 |         terminated = False
65 |         truncated = False
66 | 
67 |         for i, action in enumerate(actions):
68 |             if terminated or truncated:
69 |                 break
70 |             player_id = 0
71 |             obs = observations
72 | 
73 |             
74 |             observations, rewards, truncated, terminated, info = env.step(player_id, action)
75 | 
76 |             if "correct_move" in name:
77 |                 self.assertFalse(truncated, "Game should not truncate for correct moves.")
78 |                 self.assertFalse(terminated, "Game should not terminate until the puzzle is complete.")
79 |             elif "invalid_move" in name:
80 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
81 |                 self.assertEqual(rewards[0], -1, "Player should receive -1 reward for an invalid move format.")
82 |             elif "out_of_bounds" in name:
83 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an out-of-bounds move.")
84 |                 self.assertEqual(rewards[0], -1, "Player should receive -1 for out-of-bounds move.")
85 |             elif "invalid_format" in name:
86 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move.")
87 |                 self.assertEqual(rewards[0], -1, "Player should receive -1 for violating Sudoku rules.")
88 |             else:
89 |                 self.fail(f"Unknown test case name: {name}")
90 | 
91 |     def run_unit_test():
92 |         print("Running CrosswordsEnv tests...")
93 |         unittest.main(argv=['first-arg-is-ignored'], exit=False)
94 | 
```

## File: textarena/envs/single_player/TowerOfHanoi/env.py

- Extension: .py
- Language: python
- Size: 6554 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from typing import Any, Dict, Optional, Tuple, Union
  2 | import copy
  3 | import random
  4 | import textarena as ta
  5 | import re
  6 | 
  7 | class TowerOfHanoiEnv(ta.Env):
  8 |     
  9 | 
 10 |     def __init__(
 11 |         self, 
 12 |         difficulty: Optional[str] = "easy",
 13 |     ):
 14 |         
 15 |         self.environment_name = "TowerOfHanoi"
 16 |         self.difficulty = difficulty
 17 | 
 18 |         if difficulty == "easy":
 19 |             self.num_disks = 3
 20 |         elif difficulty == "medium":
 21 |             self.num_disks = 4
 22 |         elif difficulty == "hard":
 23 |             self.num_disks = 5
 24 | 
 25 |         
 26 |         self.state = ta.State(
 27 |             num_players=1,
 28 |             render_keys=["rendered_board"],
 29 |             max_turns=100
 30 |         )
 31 | 
 32 |     def reset(
 33 |         self,
 34 |         seed: Optional[int] = None,
 35 |     ) -> Optional[ta.Observations]:
 36 |         
 37 | 
 38 |         if seed is not None:
 39 |             random.seed(seed)
 40 |         else:
 41 |             random.seed()
 42 | 
 43 |         
 44 |         self.towers = self._generate_board()
 45 | 
 46 |         
 47 |         return self.state.reset(
 48 |             game_state={
 49 |                 "towers": copy.deepcopy(self.towers),
 50 |                 "rendered_board": self._render_board()
 51 |             },
 52 |             player_prompt_function=self._generate_player_prompt
 53 |         )
 54 |     
 55 |     def _generate_player_prompt(
 56 |         self, 
 57 |         player_id: int,
 58 |     ) -> str:
 59 |         
 60 |         prompt = (
 61 |             f"You are Player {player_id}. You are playing Tower of Hanoi ({self.difficulty}).\n"
 62 |             f"You have to move the disks from tower A to tower C.\n"
 63 |             "To move a disk, type the source tower and the target tower (e.g., '[A C]').\n"
 64 |             "Note that you can only move the top disk of a tower, and that a bigger disk cannot be placed on a smaller disk.\n"
 65 |             "As you play, the history of your moves will be displayed.\n"
 66 |             "Here is the current state of the towers:\n"
 67 |         )
 68 | 
 69 |         prompt += self._render_board()
 70 | 
 71 |         return prompt
 72 | 
 73 |     def _generate_board(self):
 74 |         
 75 |         towers = {
 76 |             "A": list(range(self.num_disks, 0, -1)),
 77 |             "B": [],
 78 |             "C": []
 79 |         }
 80 | 
 81 |         return towers
 82 |     
 83 |     def _render_board(self):
 84 |         
 85 |         rendered_board = ""
 86 |         for tower, disks in self.towers.items():
 87 |             rendered_board += f"{tower}: {disks}\n"
 88 | 
 89 |         return rendered_board
 90 |     
 91 |     def step(
 92 |         self,
 93 |         player_id: int,
 94 |         action: str,
 95 |     ) -> Tuple[
 96 |         Optional[ta.Observations],
 97 |         Optional[ta.Rewards],
 98 |         bool,
 99 |         bool,
100 |         ta.Info
101 |     ]:
102 |         
103 |         
104 |         self.state.add_observation(
105 |             from_id=player_id,
106 |             to_id=-1,
107 |             message=action,
108 |             for_logging=True
109 |         )
110 | 
111 |         
112 |         action_search_pattern = re.compile(r"\[([ABC]) ([ABC])\]") 
113 |         matches = action_search_pattern.findall(action)
114 | 
115 |         if not matches:
116 |             self.state.set_invalid_move(
117 |                 player_ids=[player_id],
118 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with valid '[source] [target]'."]
119 |             )
120 |         else:
121 |             for match in matches:
122 |                 print("Checking match", match)
123 |                 source, target = match
124 |                 if source not in self.towers or target not in self.towers:
125 |                     self.state.set_invalid_move(
126 |                         player_ids=[player_id],
127 |                         reasons=[f"Invalid move. Player {player_id} specified an invalid source or target tower."]
128 |                     )
129 |                     break
130 |                 elif not self.towers[source]:
131 |                     self.state.set_invalid_move(
132 |                         player_ids=[player_id],
133 |                         reasons=[f"Invalid move. Player {player_id} tried to move a disk from an empty tower."]
134 |                     )
135 |                 elif self.towers[target] and self.towers[target][-1] < self.towers[source][-1]:
136 |                     self.state.set_invalid_move(
137 |                         player_ids=[player_id],
138 |                         reasons=[f"Invalid move. Player {player_id} tried to place a larger disk on a smaller disk."]
139 |                     )
140 |                 else:
141 |                     disk = self.towers[source].pop()
142 |                     self.towers[target].append(disk)
143 |                     self.state.add_observation(
144 |                         from_id=-1,
145 |                         to_id=player_id,
146 |                         message=(f"Player {player_id} moved disk from {source} to {target}. Here is the current state of the towers:\n{self._render_board()}"),
147 |                         for_logging=False
148 |                         )
149 | 
150 |             
151 |             if self.towers["C"] == list(range(self.num_disks, 0, -1)):
152 |                 self.state.set_winners(
153 |                     player_ids=[player_id],
154 |                     reason=f"Congratulations! Player {player_id} solved the Tower of Hanoi puzzle."
155 |                 )
156 |             
157 |             self.state.game_state["rendered_board"] = self._render_board()
158 | 
159 |         return self.state.step()
160 |     
161 |     def render(
162 |         self,
163 |         player_id: int,
164 |     ) -> str:
165 |         
166 |         return self.state.game_state["rendered_board"]
167 |     
168 |                     
```

## File: textarena/envs/single_player/TowerOfHanoi/README.md

- Extension: .md
- Language: markdown
- Size: 6696 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Tower of Hanoi Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | The Tower of Hanoi Environment is a single-player puzzle game in which the player transfers a set number of disks from one tower (source) to another (target) using an auxiliary tower. The disks are arranged by size, with larger disks initially stacked below smaller ones on the source tower. The goal is to move all disks to the last tower while adhering to the game's rules: only one disk can be moved at a time, a larger disk cannot be placed on a smaller disk, and only the top disk of any tower can be moved. The player must complete the puzzle within a a given number of steps. 
  6 | 
  7 | ## Action Space
  8 | - **Format:** Actions are strings in the format [source target], where:
  9 | - **Example:**
 10 |     - To move the top disc from tower A to Tower C: [A C]
 11 | - **Notes:** Additional texts may accompany the action, and the agent is free to provide any number of actions. So long it does not make an invalid action. 
 12 | 
 13 | ## Observation Space
 14 | **Reset Observation:**
 15 | On reset, the observation provides the initial prompt and the initial view of the towers. For example:
 16 | ```plaintext
 17 | [GAME] You are Player 0. You are playing Tower of Hanoi (easy).
 18 | You have to move the disks from tower A to tower C.
 19 | To move a disk, type the source tower and the target tower (e.g., '[A C]').
 20 | Note that you can only move the top disk of a tower, and that a bigger disk cannot be placed on a smaller disk.
 21 | As you play, the history of your moves will be displayed.
 22 | Here is the current state of the towers:
 23 | A: [3, 2, 1]
 24 | B: []
 25 | C: []
 26 | ```
 27 | 
 28 | **Step Observations:**
 29 | After each step, the environment returns the action and the updated towers as the observation. For example:
 30 | ```plaintext
 31 | [Player 0] To move the disks from tower A to tower C, I'll start by moving the top disk from A to C.
 32 | 
 33 | [A C]
 34 | [GAME] Player 0 moved disk from A to C. Here is the current state of the towers:
 35 | A: [3, 2]
 36 | B: []
 37 | C: [1]
 38 | ```
 39 | 
 40 | By default, the environment returns observations in the following format:
 41 | ```python
 42 | {
 43 |   player_id: int : [
 44 |     (sender_id: int, message: str),
 45 |     (sender_id: int, message: str),
 46 |     ...
 47 |   ]
 48 | }
 49 | ```
 50 | 
 51 | ## Gameplay
 52 | **Board Configuration:** The game begins with three towers labeled 'A', 'B', and 'C'. The selected number of disks, based on the difficulty level (3 disks for easy, 4 for medium, and 5 for hard), are arranged on tower 'A' in descending order, with the largest disk at the bottom and the smallest at the top. Towers 'B' and 'C' are initially empty, and the player’s objective is to transfer all disks from tower 'A' to tower 'C' using tower 'B' as an auxiliary tower.
 53 | 
 54 | **Turns:** The player makes a move by specifying a source and target tower in the format [source target], where source and target are one of the towers 'A', 'B', or 'C'. For example, entering [A C] moves the top disk from tower 'A' to tower 'C', if allowed by the game rules. The game enforces a maximum of 100 moves, though this limit can be modified for extended gameplay.
 55 | 
 56 | **Objective:** The goal is to transfer all disks from tower 'A' to tower 'C' while following the Tower of Hanoi rules:
 57 | 
 58 | 1. Only one disk can be moved at a time.
 59 | 2. A larger disk cannot be placed on top of a smaller disk.
 60 | 3. Disks can only be moved from the top of a tower.
 61 | 
 62 | **Winning Condition:** The game is won when all disks are successfully transferred to tower 'C' in descending order (largest at the bottom and smallest at the top) within the allowed number of moves.
 63 | 
 64 | ## Key Rules:
 65 | **Valid Moves:**
 66 | 
 67 | - The player must enter a command in square brackets specifying the source and target towers to move a disk:
 68 |     - [A B]: Moves the top disk from tower 'A' to tower 'B', if allowed by the game rules.
 69 |     - [B C]: Moves the top disk from tower 'B' to tower 'C', and so on.
 70 | - The move is valid only if it meets the following conditions:
 71 |     - The source tower has at least one disk (i.e., it is not empty).
 72 |     - The top disk on the source tower can be placed on the target tower’s top disk, following the rule that a larger disk cannot be placed on a smaller disk.
 73 | 
 74 | **Invalid Moves:**
 75 | 
 76 | - Attempting to move a disk from an empty tower.
 77 | - Trying to place a larger disk on top of a smaller disk.
 78 | - Using an unsupported format or any input that does not follow the [source target] structure.
 79 | 
 80 | ## Rewards
 81 | | Outcome          | Reward for Player  |
 82 | |------------------|:------------------:|
 83 | | **Win**          |       `+1`         |
 84 | | **Lose**         |       `0`          |
 85 | | **Invalid Move** |       `-1`         |
 86 | 
 87 | # Variants
 88 | 
 89 | | Env-id                    |
 90 | |---------------------------|
 91 | | `TowerOfHanoi-v0-easy`    |
 92 | | `TowerOfHanoi-v0-medium`  |
 93 | | `TowerOfHanoi-v0-hard`    |
 94 | 
 95 | ## Example Usage
 96 | ```python
 97 | import textarena as ta
 98 | 
 99 | ## initializa the environment
100 | env = ta.make("TowerOfHanoi-v0-easy")
101 | 
102 | ## Wrap the environment for easier observation handling
103 | env = ta.wrappers.LLMObservationWrapper(env=env)
104 | 
105 | ## Wrap the environment for pretty rendering
106 | env = ta.wrappers.PrettyRenderWrapper(env=env)
107 | 
108 | ## initalize agents
109 | agents = {
110 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
111 |     }
112 | 
113 | ## reset the environment to start a new game
114 | observations = env.reset(seed=490)
115 | 
116 | ## Game loop
117 | done = False
118 | while not done:
119 | 
120 |     # Get the current player
121 |     current_player_id = env.state.get("current_player")
122 | 
123 |     # Get the current observation for the player
124 |     obs = observations[current_player_id]
125 | 
126 |     # Agent decides on an action based on the observation
127 |     action = agents[current_player_id](obs)
128 | 
129 |     # Execute the action in the environment
130 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
131 | 
132 |     # Check if the game has ended
133 |     done = terminated or truncated
134 | 
135 |     # Optionally render the environment to see the current state
136 |     env.render()
137 | 
138 |     if done:
139 |         break
140 | 
141 | ## Finally, print the game results
142 | for player_id, agent in agents.items():
143 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
144 | print(f"Reason: {info['reason']}")
145 | ```
146 | 
147 | ## Troubleshooting
148 | 
149 | **Invalid Move Format:**
150 | 
151 |   - **Issue**: The player submits a move in an incorrect format (e.g., missing square brackets).
152 |   - **Solution**: Revise the player prompt to enter moves in the format [source target], where source and target are valid tower names ('A', 'B', or 'C').
153 | 
154 | **Disk Cannot Be Moved:**
155 | 
156 |   - **Issue**: The player repeatedly attempts to move a disk from an empty tower, or tries to place a larger disk on a smaller one
157 |   - **Solution**: Revise the prompt to include examples of accaptable moves.
158 | 
159 | 
160 | ## Version History
161 | - **v0**
162 |   - Initial release 
163 | 
164 | 
165 | ### Contact
166 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/TowerOfHanoi/example.py

- Extension: .py
- Language: python
- Size: 1284 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("TowerOfHanoi-v0-easy")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/WordLadder/test.py

- Extension: .py
- Language: python
- Size: 3431 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.WordLadder.env import WordLadderEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["[tain]", "[main]"]  
 9 | 
10 | def generate_invalid_format_sequence():
11 |     
12 |     return ["(sain)", "[sage]"]  
13 | 
14 | def generate_incorrect_move_sequence():
15 |     
16 |     return ["[sang]", "[join]"]  
17 | 
18 | 
19 | class TestWordLadderEnv(unittest.TestCase):
20 | 
21 |     
22 |     env_variants = [
23 |         {"Hardcore": True, "word_len": 4},
24 |     ]
25 | 
26 |     
27 |     test_cases = {
28 |         "correct_move_hardcore": {
29 |             "Hardcore": True,
30 |             "actions": generate_correct_move_sequence()
31 |         },
32 |         "invalid_format_hardcore": {
33 |             "Hardcore": True,
34 |             "actions": generate_invalid_format_sequence()
35 |         },
36 |         "incorrect_move_hardcore": {
37 |             "Hardcore": True,
38 |             "actions": generate_incorrect_move_sequence()
39 |         }
40 |     }
41 | 
42 |     @parameterized.expand([
43 |         (name, details["Hardcore"], details["actions"])
44 |         for name, details in test_cases.items()
45 |     ])
46 |     def test_wordladder_outcomes(self, name, hardcore, action_sequence):
47 |         
48 |         
49 |         env_config = next((env for env in self.env_variants if env["Hardcore"] == hardcore), None)
50 |         self.assertIsNotNone(env_config, f"Environment configuration for {hardcore} not found.")
51 | 
52 |         env = WordLadderEnv(hardcore=env_config["Hardcore"], word_len=env_config["word_len"])
53 | 
54 |         observations = env.reset(seed=490)
55 | 
56 |         terminated = False
57 |         truncated = False
58 | 
59 |         for i, action in enumerate(action_sequence):
60 |             if terminated or truncated:
61 |                 break
62 |             player_id = 0
63 | 
64 |             
65 |             observations, reward, terminated, truncated, info = env.step(player_id, action)
66 | 
67 |             
68 |             if "correct_move" in name:
69 |                 self.assertFalse(truncated, "Game should not truncate for correct moves.")
70 |                 self.assertFalse(terminated, "Game should not terminate until the puzzle is complete.")
71 |             elif "invalid_format" in name:
72 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
73 |                 self.assertEqual(reward[0], -1, "Player should receive -1 reward for an invalid move format.")
74 |             elif "incorrect_move" in name:
75 |                 self.assertFalse(truncated, "Game should not truncate for correct moves.")
76 |                 self.assertFalse(terminated, "Game should not terminate until the puzzle is complete.")
77 |             else:
78 |                 self.fail(f"Unknown test case name: {name}")
79 | 
80 | def run_unit_test():
81 |     print("Running WordLadderEnv tests...")
82 |     unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/single_player/WordLadder/env.py

- Extension: .py
- Language: python
- Size: 11029 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from typing import Any, Dict, List, Tuple, Optional, Union
  2 | import copy
  3 | import random
  4 | import textarena as ta
  5 | import re
  6 | import networkx as nx
  7 | 
  8 | 
  9 | import nltk
 10 | from nltk.corpus import words
 11 | nltk.download('words')
 12 | 
 13 | class WordLadderEnv(ta.Env):
 14 |     
 15 | 
 16 |     def __init__(
 17 |         self,
 18 |         hardcore: Optional[bool] = False,
 19 |         word_len: int = 4
 20 |     ):
 21 |         
 22 | 
 23 |         super().__init__()
 24 |         self.environment_name = "WordLadder"
 25 |         self.hardcore = hardcore
 26 |         self.word_len = word_len
 27 | 
 28 |         
 29 |         self.state = ta.State(
 30 |             num_players=1,
 31 |             render_keys=["rendered_text"],
 32 |             max_turns=10 
 33 |         )
 34 | 
 35 |         
 36 |         if hardcore:
 37 |             self.word_list = words.words("en")
 38 |         else:
 39 |             self.word_list = words.words("en-basic")
 40 | 
 41 |     def reset(
 42 |         self,
 43 |         seed: Optional[int] = None
 44 |     ) -> Optional[ta.Observations]:
 45 |         
 46 | 
 47 |         
 48 |         if seed is not None:
 49 |             random.seed(seed)
 50 |         else:
 51 |             random.seed()
 52 | 
 53 |         
 54 |         self.word_graph = self._generate_word_graph(word_len = self.word_len)
 55 |         self.start_word, self.target_word = self._generate_words()
 56 |         self.current_word = self.start_word
 57 |         self.history = [self.start_word]
 58 | 
 59 |         
 60 |         return self.state.reset(
 61 |             game_state={
 62 |                 "start_word": self.start_word,
 63 |                 "target_word": self.target_word,
 64 |                 "rendered_text": self._render_text() 
 65 |             },
 66 |             player_prompt_function=self._generate_player_prompt
 67 |         )
 68 |     
 69 |     def _generate_player_prompt(self, player_id: int) -> str:
 70 |         
 71 |         prompt = (
 72 |             f"You are Player {player_id}. You are playing Word Ladder ({'Hardcore' if self.hardcore else 'basic'}).\n"
 73 |             "The objective of the game is to convert the start word to the target word by changing one letter at a time.\n"
 74 |             f"The start word is: {self.start_word}\n"
 75 |             f"The target word is: {self.target_word}\n"
 76 |             "To submit your word, you must wrap it in square brackets, e.g. [word].\n"
 77 |             "As you play, the history of your choices will be appended below. Use the information to win the game.\n"
 78 |         )
 79 | 
 80 |         return prompt
 81 |     
 82 |     def _render_text(self) -> str:
 83 |         
 84 |         
 85 |         return (
 86 |             f"Word Ladder History: {' -> '.join(self.history)}. Target Word: {self.target_word}\n", 
 87 |         )
 88 | 
 89 |     def _generate_word_graph(self, word_len: int) -> Any:
 90 |         
 91 |         graph = nx.Graph()
 92 |         self.k_len_words = [word for word in self.word_list if len(word) == word_len]
 93 |         graph.add_nodes_from(self.k_len_words)
 94 |         for i, word in enumerate(self.k_len_words):
 95 |             for other_word in self.k_len_words[i + 1 :]:
 96 |                 if sum(a != b for a, b in zip(word, other_word)) == 1: 
 97 |                     graph.add_edge(word, other_word)
 98 |         
 99 |         graph.remove_nodes_from(list(nx.isolates(graph)))
100 |         
101 |         return graph
102 |     
103 |     
104 |     
105 |     
106 | 
107 |     
108 |     
109 | 
110 |     
111 |     
112 |         
113 |     
114 |     
115 |     
116 |     
117 |     
118 | 
119 |     
120 | 
121 |     def _generate_words(self) -> Tuple[str, str]:
122 |         
123 |         while True:
124 |             start_word = random.choice(self.k_len_words)
125 |             
126 |             
127 |             if start_word not in self.word_graph:
128 |                 continue
129 |             
130 |             
131 |             path_lengths = nx.single_source_shortest_path_length(self.word_graph, start_word)
132 |             candidates = [word for word, distance in path_lengths.items() if distance == 5]
133 |             
134 |             
135 |             if candidates:
136 |                 target_word = random.choice(candidates)
137 |                 return start_word, target_word
138 | 
139 | 
140 |     
141 |     def _validate_solution_existence(self, graph, start_word, target_word) -> bool:
142 |         
143 |         return nx.has_path(graph, start_word, target_word)
144 |     
145 |     def step(
146 |         self,
147 |         player_id: int,
148 |         action: str
149 |     ) -> Tuple[
150 |         Optional[ta.Observations], 
151 |         Optional[ta.Rewards], 
152 |         bool, 
153 |         bool, 
154 |         ta.Info 
155 |     ]:
156 |         
157 | 
158 |         
159 |         self.state.add_observation(
160 |             from_id=player_id,
161 |             to_id=-1,
162 |             message=action,
163 |             for_logging=True
164 |         )
165 | 
166 |         
167 |         action_search_pattern = re.compile(r"\[([a-zA-Z]+)\]") 
168 |         match = action_search_pattern.search(action)
169 | 
170 | 
171 |         if match is None:
172 |             self.state.set_invalid_move(
173 |                 player_ids= [player_id],
174 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with a valid word format in square brackets."]
175 |             )
176 | 
177 |         else:
178 |             next_word = match.group(1)
179 |             if len(next_word) != len(self.target_word):
180 |                 
181 |                 self.state.set_invalid_move(
182 |                     player_ids= [player_id],
183 |                     reasons=[f"Invalid move format. Player {player_id} did not respond with a word of the correct length."]
184 |                 )
185 |             elif not self.word_graph.has_node(next_word):
186 |                 
187 |                 self.state.set_invalid_move(
188 |                     player_ids= [player_id],
189 |                     reasons=[f"Invalid move format. Player {player_id} did not respond with a valid word."]
190 |                 )
191 |             elif not self._is_valid_move(next_word):
192 |                 
193 |                 self.state.add_observation(
194 |                     from_id=-1,
195 |                     to_id=player_id,
196 |                     message="You have provided an invalid word! The word must differ by exactly one letter.",
197 |                     for_logging=False
198 |                 )
199 | 
200 |             else:
201 |                 
202 |                 self.current_word = next_word
203 |                 self.history.append(next_word)
204 |                 if next_word == self.target_word:
205 |                     
206 |                     self.state.set_winners(
207 |                         player_ids=[player_id],
208 |                         reason=f"Congratulations! Player {player_id} has found the target word."
209 |                     )
210 |                 else:
211 |                     
212 |                     self.state.add_observation(
213 |                         from_id=-1,
214 |                         to_id=player_id,
215 |                         message=f"You've selected a valid word.\n{self._render_text()}",
216 |                         for_logging=False
217 |                     )
218 | 
219 |             
220 |             self.state.game_state["rendered_text"] = self._render_text()
221 | 
222 |         return self.state.step()            
223 |     
224 |     def _is_valid_move(self, next_word: str) -> bool:
225 |         
226 |         next_word = next_word.lower()
227 |         
228 |         if not self.word_graph.has_edge(self.current_word, next_word):
229 |             return False
230 |         
231 |         return True
232 | 
233 |     def render(self):
234 |         
235 |         print(f"Start word: {self.start_word}")
236 |         print(f"Target word: {self.target_word}")
237 |         print(f"Current word: {self.current_word}")
238 |         print(f"History: {self.history}")
```

## File: textarena/envs/single_player/WordLadder/readme.md

- Extension: .md
- Language: markdown
- Size: 6855 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Word Ladder Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | Word Ladder is a single-player puzzle game where the player aims to transform a starting word into a target word by changing one letter at a time. Each step must yield a valid word that differs by exactly one letter from the previous word, forming a chain from the start word to the target. The environment provides both a standard and a hardcore mode, impacting the word list difficulty. Players are guided by a prompt detailing the rules and gameplay, and their move history is displayed to track progress.
  6 | 
  7 | ## Action Space
  8 | - **Format**: Actions are strings in the format [word], where:
  9 | - **Examples**:
 10 |     - To say that the next word after "sain" is "main": [main]
 11 | - **Notes**: Additional text may accompany the action, but it must contain the correct format for the action to be processed. Incorrectly formatted actions will be marked as invalid.
 12 | 
 13 | ## Observation Space
 14 | **Reset Observation:**
 15 | On reset, the observation provides the initial prompt and the starting words and target words. For example:
 16 | ```plaintext
 17 | [GAME] You are Player 0. You are playing Word Ladder (Hardcore).
 18 | The objective of the game is to convert the start word to the target word by changing one letter at a time.
 19 | The start word is: sain
 20 | The target word is: teal
 21 | To submit your word, you must wrap it in square brackets, e.g. [word].
 22 | As you play, the history of your choices will be appended below. Use the information to win the game.
 23 | ```
 24 | 
 25 | ** Step Observation: **
 26 | After each step, the environment returns the action and the updated Word Ladder text as the observation. For example:
 27 | ```plaintext
 28 | [Player 0] To start, I'll change one letter in "sain" to get closer to "teal." 
 29 | 
 30 | I'll change the first letter 's' to 't' to form "tain."
 31 | 
 32 | My move: [tain]
 33 | [GAME] You've selected a valid word.
 34 | ('Word Ladder History: sain -> tain. Target Word: teal\n',)
 35 | ```
 36 | 
 37 | By default, the environment returns observations in the following format:
 38 | ```python
 39 | {
 40 |   player_id: int : [
 41 |     (sender_id: int, message: str),
 42 |     (sender_id: int, message: str),
 43 |     ...
 44 |   ]
 45 | }
 46 | ```
 47 | 
 48 | ## Gameplay
 49 | **Word Length:** The length of the words is customizable, with a default setting of four-letter words. Both the starting and target words are of this length, with other words in the chain matching this requirement.
 50 | 
 51 | **Turns:** The player enters words by typing them in the format [word], where each word differs from the previous one by exactly one letter. Players continue to submit words in this format until they reach the target word or exhaust their turns. The game defaults to a maximum of 10 turns.
 52 | 
 53 | **Word Graph:** All words of the specified length are represented as nodes in a graph, with edges connecting words that differ by one letter. The start and target words are selected to ensure a valid path exists between them.
 54 | 
 55 | **Winning Condition: **The game is won when the player reaches the target word within the allowed number of turns, transforming the start word into the target word through a chain of valid single-letter changes.
 56 | 
 57 | ## Key Rules
 58 | - **Valid Moves**:
 59 |     - The player must enter a word that:
 60 |         - Is exactly one letter different from the current word.
 61 |         - Exists within the game's word list and matches the length of the target word.
 62 | 
 63 | - **Invalid Moves**:
 64 |     - Entering a word that is not in the list of valid words.
 65 |     - Entering a word that does not match the target word length.
 66 | 
 67 | - **Incorrect Tries:**
 68 |     - Entering a word that differs by more than one letter from the current word.
 69 | 
 70 | ## Rewards
 71 | | Outcome          | Reward for Player  |
 72 | |------------------|:------------------:|
 73 | | **Win**          |       `+1`         |
 74 | | **Lose**         |       `0`          |
 75 | | **Invalid Move** |       `-1`         |
 76 | 
 77 | ## Parameters
 78 | 
 79 | - `hardcore` (`bool`):
 80 |     - **Description:** Determines the type of words to spot
 81 |     - **Impact:**
 82 |         - **False:** Hidden words follow basic english.
 83 |         - **True**: Hidden words would be uncommon and challenging words.
 84 | 
 85 | - `word_len` (`int`):
 86 |     - **Description:** Determines the length of the words used in the word graph.
 87 |     - **Impact:** Longer words are typically more challenging. 
 88 | 
 89 | ## Variants
 90 | 
 91 | | Env-id                      | hardcore | word_len |
 92 | |-----------------------------|:--------:|:--------:|
 93 | | `WordLadder-v0-hardcore`    | `True`   | `5`      |
 94 | | `WordLadder-v0-hardcore-10` | `True`   | `10`     |
 95 | 
 96 | ## Example Usage
 97 | ```python
 98 | import textarena as ta
 99 | 
100 | ## initializa the environment
101 | env = ta.make("WordLadder-v0-hardcore")
102 | 
103 | ## Wrap the environment for easier observation handling
104 | env = ta.wrappers.LLMObservationWrapper(env=env)
105 | 
106 | ## Wrap the environment for pretty rendering
107 | env = ta.wrappers.PrettyRenderWrapper(env=env)
108 | 
109 | ## initalize agents
110 | agents = {
111 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
112 |     }
113 | 
114 | ## reset the environment to start a new game
115 | observations = env.reset(seed=490)
116 | 
117 | ## Game loop
118 | done = False
119 | while not done:
120 | 
121 |     # Get the current player
122 |     current_player_id = env.state.get("current_player")
123 | 
124 |     # Get the current observation for the player
125 |     obs = observations[current_player_id]
126 | 
127 |     # Agent decides on an action based on the observation
128 |     action = agents[current_player_id](obs)
129 | 
130 |     # Execute the action in the environment
131 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
132 | 
133 |     # Check if the game has ended
134 |     done = terminated or truncated
135 | 
136 |     # Optionally render the environment to see the current state
137 |     env.render()
138 | 
139 |     if done:
140 |         break
141 | 
142 | ## Finally, print the game results
143 | for player_id, agent in agents.items():
144 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
145 | print(f"Reason: {info['reason']}")
146 | ```
147 | 
148 | ## Troubleshooting
149 | 
150 | **Incorrect Word Length**
151 | - **Issue**: The player submits a word that does not match the required length.
152 | - **Solution**: Ensure the chosen word matches the specified word length set for the environment (e.g., 4 letters by default).
153 | 
154 | **Invalid Move Format**
155 | - **Issue**: The player’s word is not in the required [word] format.
156 | - **Solution**: Prompt the player to submit their word inside square brackets, like [word], for correct processing.
157 | 
158 | **No Path Between Words**
159 | - **Issue**: The generated start and target words do not have a valid path connecting them.
160 | - **Solution**: Restart the game to regenerate words or preselect start and target pairs with known paths to reduce such occurrences.
161 | 
162 | **Isolated Nodes in Graph**
163 | - **Issue**: Some words may be isolated (no one-letter connections) in the word graph, preventing path validation.
164 | - **Solution**: Filter out isolated nodes during graph construction to ensure connectivity.
165 | 
166 | 
167 | ## Version History
168 | - **v0**
169 |   - Initial release 
170 | 
171 | 
172 | ### Contact
173 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/WordLadder/example.py

- Extension: .py
- Language: python
- Size: 1277 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("WordLadder-v0")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/GuessTheNumber/test.py

- Extension: .py
- Language: python
- Size: 3470 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.GuessTheNumber.env import GuessTheNumberEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["[5]"]  
 9 | 
10 | def generate_invalid_format_sequence():
11 |     
12 |     return ["[1, 2]", "[3]", "4"]  
13 | 
14 | def generate_out_of_bounds_sequence():
15 |     
16 |     return ["[10000]"]  
17 | 
18 | class TestGuessTheNumberEnv(unittest.TestCase):
19 | 
20 |     
21 |     env_variants = [
22 |         {"hardcore": False},
23 |         {"hardcore": True}
24 |     ]
25 | 
26 |     
27 |     test_cases = {
28 |         "correct_moves": {
29 |             "hardcore": False,
30 |             "actions": generate_correct_move_sequence()
31 |         },
32 |         "invalid_format": {
33 |             "hardcore": False,
34 |             "actions": generate_invalid_format_sequence()
35 |         },
36 |         "out_of_bounds": {
37 |             "hardcore": False,
38 |             "actions": generate_out_of_bounds_sequence()
39 |         }
40 |     }
41 | 
42 |     @parameterized.expand([
43 |         (name, details['hardcore'], details['actions'])
44 |         for name, details in test_cases.items()
45 |     ])
46 |     def test_guessthenumber_outcomes(self, name, difficulty, action_sequence):
47 |         
48 |         
49 |         env_config = next((env for env in self.env_variants if env['hardcore'] == difficulty), None)
50 |         self.assertIsNotNone(env_config, f"Invalid difficulty level: {difficulty}")
51 | 
52 |         env = GuessTheNumberEnv(hardcore=env_config["hardcore"])
53 | 
54 |         observations = env.reset(seed=490)
55 | 
56 |         terminated = False
57 |         truncated = False
58 | 
59 |         for i, action in enumerate(action_sequence):
60 |             if terminated or truncated:
61 |                 break
62 |             player_id = 0
63 |             obs = observations
64 | 
65 |             
66 |             observations, reward, truncated, terminated, info = env.step(player_id, action)
67 | 
68 |             
69 |             if "correct_moves" in name:
70 |                 self.assertFalse(truncated, "Game should not truncate for correct moves.")
71 |                 self.assertFalse(terminated, "Game should not terminate for correct moves.")
72 |             elif "invalid_format" in name:
73 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
74 |                 self.assertEqual(reward[0], -1, "Player should receive -1 reward for an invalid move format.")
75 |             elif "out_of_bounds" in name:
76 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an out-of-bounds number.")
77 |                 self.assertEqual(reward[0], -1, "Player should receive -1 reward for an invalid move format.")
78 |             else:
79 |                 self.fail(f"Unknown test case name: {name}")
80 | 
81 |     def run_unit_test():
82 |         print("Running GuessTheNumberEnv tests...")
83 |         unittest.main(argv=['first-arg-is-ignored'], exit=False)    
```

## File: textarena/envs/single_player/GuessTheNumber/env.py

- Extension: .py
- Language: python
- Size: 5762 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | from typing import Any, Dict, Optional, Tuple, Union
  2 | import copy
  3 | import random
  4 | import textarena as ta
  5 | import re
  6 | 
  7 | class GuessTheNumberEnv(ta.Env):
  8 |     
  9 | 
 10 |     def __init__(
 11 |         self,
 12 |         hardcore: Optional[bool] = False,
 13 |     ):
 14 |         
 15 |         self.environment_name = "GuessTheNumber"
 16 |         self.hardcore = hardcore
 17 | 
 18 |         if not hardcore:
 19 |             self.min_number = 1
 20 |             self.max_number = 20
 21 |         else:
 22 |             self.min_number = 1
 23 |             self.max_number = 100
 24 | 
 25 |         
 26 |         self.state = ta.State(
 27 |             num_players=1,
 28 |             render_keys=["rendered_text"],
 29 |             max_turns=10
 30 |         )
 31 | 
 32 |     def reset(
 33 |         self, 
 34 |         seed: Optional[int] = None,
 35 |     ) -> Optional[ta.Observations]:
 36 |         
 37 | 
 38 |         if seed is not None:
 39 |             random.seed(seed)
 40 |         else:
 41 |             random.seed()
 42 | 
 43 |         
 44 |         self.game_number = random.randint(self.min_number, self.max_number)
 45 |         print(f"Game number: {self.game_number}")
 46 |         self.guessed_numbers = set()
 47 | 
 48 |         
 49 |         return self.state.reset(
 50 |             game_state={
 51 |                 "game_number": self.game_number,
 52 |                 "rendered_text": "Guess the number between {} and {}.".format(self.min_number, self.max_number),
 53 |             },
 54 |             player_prompt_function=self._generate_player_prompt
 55 |         )
 56 |     
 57 |     def _generate_player_prompt(
 58 |         self, 
 59 |         player_id: int,
 60 |     ) -> str:
 61 |         
 62 |         prompt = (
 63 |             f"You are Player {player_id}. You are playing Guess The Number ({'Hardcore' if self.hardcore else 'Basic'}).\n"
 64 |             f"You have to guess the number between {self.min_number} and {self.max_number}.\n"
 65 |             "As you enter your guess, the game will provide you with hints such as 'higher' or 'lower'.\n"
 66 |             "You may provide your response in any manner. Only the number that is wrapped in square brackets will be considered as your guess. For example, [5].\n"
 67 |             "As you play, the history of your guesses will be appended below. Use the information to complete the game before you run out of guesses.\n"
 68 |             "Enter your guess."
 69 |         )
 70 | 
 71 |         return prompt
 72 |     
 73 |     def step(
 74 |         self,
 75 |         player_id: int,
 76 |         action: str
 77 |     ) -> Tuple[
 78 |         Optional[ta.Observations],
 79 |         Optional[ta.Rewards],
 80 |         bool,
 81 |         bool,
 82 |         ta.Info 
 83 |     ]:
 84 |         
 85 |         
 86 |         self.state.add_observation(
 87 |             from_id=player_id,
 88 |             to_id=-1,
 89 |             message=action,
 90 |             for_logging=True
 91 |         )
 92 | 
 93 |         
 94 |         action_search_pattern = re.compile(r"\[(\d+)\]") 
 95 |         match = action_search_pattern.search(action)
 96 | 
 97 |         if not match:
 98 |             self.state.set_invalid_move(
 99 |                 player_ids=[player_id],
100 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with valid '[number]'."]
101 |             )
102 |         else:
103 |             player_guess = int(match.group(1))
104 |             if player_guess < self.min_number or player_guess > self.max_number:
105 |                 self.state.set_invalid_move(
106 |                     player_ids=[player_id],
107 |                     reasons=[f"Invalid move. Player {player_id} guessed a number outside the range specified."]
108 |                 )
109 |             elif player_guess in self.guessed_numbers:
110 |                 self.state.set_invalid_move(
111 |                     player_ids=[player_id],
112 |                     reasons=[f"Invalid move. Player {player_id} has already guessed the number."]
113 |                 )
114 |             else:
115 |                 self.guessed_numbers.add(player_guess)
116 |                 if player_guess == self.game_number:
117 |                     self.state.set_winners(
118 |                         player_ids=[player_id],
119 |                         reason=f"Congratulations! Player {player_id} guessed the correct number."
120 |                     )
121 |                 else:
122 |                     if player_guess < self.game_number:
123 |                         hint = "lower"
124 |                     else:
125 |                         hint = "higher"
126 |                     self.state.add_observation(
127 |                         from_id=-1,
128 |                         to_id=player_id,
129 |                         message=f"Your guess of {player_guess} is {hint}.",
130 |                         for_logging=False
131 |                     )
132 | 
133 |             self.state.game_state["rendered_text"] = f"Player {player_id} guessed {player_guess}."
134 | 
135 |         return self.state.step()
136 |     
137 |     def render(self):
138 |         
139 |         print(self.state.game_state["rendered_text"])
```

## File: textarena/envs/single_player/GuessTheNumber/readme.md

- Extension: .md
- Language: markdown
- Size: 6051 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Guess The Number Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | Guess The Number is a single-player game where the player attempts to guess a randomly chosen number within a specified range. The environment supports two modes: Basic (numbers between 1 and 20) and Hardcore (numbers between 1 and 100). The player receives hints ("higher" or "lower") after each guess until they find the correct number or run out of turns.
  6 | 
  7 | ## Action Space
  8 | 
  9 |     - **Format**: Actions are strings containing a guess in the format [number], where number is the player's guess within the range specified for the game mode.
 10 |     - **Examples**:
 11 |         [7]: Player guesses the number 7.
 12 |         [25]: Player guesses the number 25 (only valid in Hardcore mode).
 13 |     - **Notes**: Additional text may accompany the action, but it must include the correct format [number] for the guess to be processed. For example, "I think the number is [10]" would be valid as long as the number is within the allowed range.
 14 | 
 15 | ## Observation Space
 16 | **Reset Observation:**
 17 | On reset, the observation provides the initial prompt and the state of the Sudoku grid. For example:
 18 | ```plaintext
 19 | [GAME] You are Player 0. You are playing Guess The Number (Basic).
 20 | You have to guess the number between 1 and 20.
 21 | As you enter your guess, the game will provide you with hints such as 'higher' or 'lower'.
 22 | You may provide your response in any manner. Only the number that is wrapped in square brackets will be considered as your guess. For example, [5].
 23 | As you play, the history of your guesses will be appended below. Use the information to complete the game before you run out of guesses.
 24 | Enter your guess.
 25 | ```
 26 | 
 27 | **Step Observation:**
 28 | After each step, the environment returns the action and the updated Sudoku grid as the observation. For example:
 29 | ```plaintext
 30 | [Player 0] Let's start the game. I'll make my first guess.
 31 | 
 32 | [50]
 33 | [GAME] Your guess of 50 is lower.
 34 | ```
 35 | 
 36 | By default, the environment returns observations in the following format:
 37 | ```python
 38 | {
 39 |   player_id: int : [
 40 |     (sender_id: int, message: str),
 41 |     ...
 42 |   ]
 43 | }
 44 | ```
 45 | where each step can product zero, one or many message tuples.
 46 | 
 47 | ## Gameplay
 48 | 
 49 | - **Number Range**:
 50 |     - Basic Mode: 1 to 20.
 51 |     - Hardcore Mode: 1 to 100.
 52 | - **Turns**: The player has a maximum of 10 turns to guess the correct number.
 53 | - *Hints*: After each guess, the player receives a hint indicating whether the target number is "higher" or "lower" than their guess.
 54 | - **Winning Condition**: The player wins the game when they correctly guess the target number within the allowed turns.
 55 | - **Restart Condition**: The player can reset the environment to start a new game with a different target number.
 56 | 
 57 | ## Key Rules
 58 | 
 59 | - **Valid Moves**:
 60 |     - The player must enter a valid number guess within the specified range for the chosen mode in the [number] format.
 61 |     - The guess must be a positive integer that falls within the range of numbers allowed (e.g., 1-20 for Basic mode and 1-100 for Hardcore mode).
 62 | 
 63 | - **Invalid Moves**:
 64 |     - Entering a number outside the specified range (e.g., [21] in Basic mode).
 65 |     - Entering a guess without the required format [number] will result in an invalid move.
 66 |     - Repeating a previously guessed number without progress will be invalid.
 67 | 
 68 | ## Rewards
 69 | | Outcome          | Reward for Player  |
 70 | |------------------|:------------------:|
 71 | | **Win**          |       `+1`         |
 72 | | **Lose**         |       `0`          |
 73 | | **Invalid Move** |       `-1`         |
 74 | 
 75 | ## Parameters
 76 | 
 77 | - `hardcore` (`bool`):
 78 |     - **Description**: Determines the difficulty level of the game by setting the range of numbers the player must guess from.
 79 |     - **Impact**:
 80 |         - **False** (Default): The game runs in Basic mode, with numbers ranging from 1 to 20.
 81 |         - **True**: The game runs in Hardcore mode, with numbers ranging from 1 to 100.
 82 | 
 83 | ## Variants
 84 | 
 85 | | Env-id                       | hardcore  |
 86 | |------------------------------|:---------:|
 87 | | `GuessTheNumber-v0`          |   `False` |
 88 | | `GuessTheNumber-v0-hardcore` |   `True`  |
 89 | 
 90 | ## Example Usage
 91 | 
 92 | ```python
 93 | import textarena as ta
 94 | 
 95 | ## initializa the environment
 96 | env = ta.make("GuessTheNumber-v0")
 97 | 
 98 | ## Wrap the environment for easier observation handling
 99 | env = ta.wrappers.LLMObservationWrapper(env=env)
100 | 
101 | ## Wrap the environment for pretty rendering
102 | env = ta.wrappers.PrettyRenderWrapper(env=env)
103 | 
104 | ## initalize agents
105 | agents = {
106 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
107 |     }
108 | 
109 | ## reset the environment to start a new game
110 | observations = env.reset(seed=490)
111 | 
112 | ## Game loop
113 | done = False
114 | while not done:
115 | 
116 |     # Get the current player
117 |     current_player_id = env.state.get("current_player")
118 | 
119 |     # Get the current observation for the player
120 |     obs = observations[current_player_id]
121 | 
122 |     # Agent decides on an action based on the observation
123 |     action = agents[current_player_id](obs)
124 | 
125 |     # Execute the action in the environment
126 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
127 | 
128 |     # Check if the game has ended
129 |     done = terminated or truncated
130 | 
131 |     # Optionally render the environment to see the current state
132 |     env.render()
133 | 
134 |     if done:
135 |         break
136 | 
137 | ## Finally, print the game results
138 | for player_id, agent in agents.items():
139 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
140 | print(f"Reason: {info['reason']}")
141 | ```
142 | 
143 | ## Troubleshooting
144 | 
145 | **Invalid Guess Format:**
146 | 
147 | - **Issue**: The player submits a guess in an incorrect format (e.g., missing square brackets).
148 | - **Solution**: Remind the player to submit guesses in the format [number], where number is their chosen guess.
149 | 
150 | **No Hint Provided:**
151 | 
152 | - **Issue**: The game does not give a "higher" or "lower" hint after an incorrect guess.
153 | - **Solution**: Ensure the step function correctly compares the player’s guess with the game number and adds an observation with the appropriate hint.
154 | 
155 | 
156 | ## Version History
157 | - **v0**
158 |   - Initial release 
159 | 
160 | 
161 | ### Contact
162 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/GuessTheNumber/example.py

- Extension: .py
- Language: python
- Size: 1290 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("GuessTheNumber-v0-hardcore")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/WordSearch/test.py

- Extension: .py
- Language: python
- Size: 3380 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.WordSearch.env import WordSearchEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["[8 2 8 12] [3 9 8 9]", "[3 9 8 9]"]  
 9 | 
10 | def generate_invalid_format_sequence():
11 |     
12 |     return ["[start_row 8 start_col 2 end_row 8 end_col 12]"]  
13 | 
14 | def generate_out_of_bounds_sequence():
15 |     
16 |     return ["[8 2 200 12]"]  
17 | 
18 | class TestWordSearchEnv(unittest.TestCase):
19 | 
20 |     
21 |     env_variants = [
22 |         {"hardcore": False},
23 |         {"hardcore": True},
24 |     ]
25 |     
26 |     
27 |     test_cases = {
28 |         "correct_move_basic": {
29 |             "hardcore": False,
30 |             "actions": generate_correct_move_sequence()
31 |         },
32 |         "invalid_format_basic": {
33 |             "hardcore": False,
34 |             "actions": generate_invalid_format_sequence()
35 |         },
36 |         "out_of_bounds_basic": {
37 |             "hardcore": False,
38 |             "actions": generate_out_of_bounds_sequence()
39 |         },
40 |     }
41 | 
42 |     @parameterized.expand([
43 |         (name, details["hardcore"], details["actions"]) 
44 |         for name, details in test_cases.items()
45 |     ])
46 |     def test_single_player_word_search(self, name, hardcore, action_sequence):
47 |         
48 |         
49 |         env_config = next((env for env in self.env_variants if env["hardcore"] == hardcore), None)
50 |         self.assertIsNotNone(env_config, f"Environment configuration not found for hardcore={hardcore}")
51 | 
52 |         env = WordSearchEnv(hardcore=env_config["hardcore"])
53 | 
54 |         observations = env.reset(seed=490)
55 | 
56 |         terminated = False
57 |         truncated = False
58 | 
59 |         for i, action in enumerate(action_sequence):
60 |             if terminated or truncated:
61 |                 break
62 |             player_id = 0
63 |             
64 |             observations, reward, truncated, terminated, info = env.step(player_id, action)
65 | 
66 |             if "correct_move" in name:
67 |                 self.assertFalse(truncated, "Game should not truncate for correct moves.")
68 |                 self.assertFalse(terminated, "Game should not terminate until the puzzle is complete.")
69 |             elif "invalid_format" in name:
70 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
71 |                 self.assertEqual(reward[0], -1, "Player should receive -1 reward for an invalid move format.")
72 |             elif "out_of_bounds" in name:
73 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an out-of-bounds move.")
74 |                 self.assertEqual(reward[0], -1, "Player should receive -1 for out-of-bounds move.")
75 |             else:
76 |                 self.fail(f"Unknown test case name: {name}")
77 | 
78 | def run_unit_test():
79 |     print("Running WordSearchEnv tests...")
80 |     unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/single_player/WordSearch/env.py

- Extension: .py
- Language: python
- Size: 25978 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | from typing import Any, Dict, Optional, Tuple, Union
  2 | import copy
  3 | import random
  4 | import textarena as ta
  5 | import re
  6 | import string
  7 | 
  8 | import nltk
  9 | from nltk.corpus import words
 10 | nltk.download('words')
 11 | 
 12 | class WordSearchEnv(ta.Env):
 13 |     
 14 | 
 15 |     def __init__(
 16 |         self, 
 17 |         hardcore: Optional[bool] = False,
 18 |     ):
 19 |         
 20 | 
 21 |         super().__init__()
 22 |         self.environment_name = "WordSearch"
 23 |         self.hardcore = hardcore
 24 |         self.num_words = 5
 25 |         self.num_incorrect_tries = 20
 26 | 
 27 |         
 28 |         self.state = ta.State(
 29 |             num_players=1,
 30 |             render_keys=["rendered_board"]
 31 |         )
 32 | 
 33 |         
 34 |         if hardcore:
 35 |             self.word_list = words.words("en")
 36 |         else:
 37 |             self.word_list = words.words("en-basic")
 38 | 
 39 |     def reset(
 40 |         self,
 41 |         seed: Optional[int] = None
 42 |     ) -> Optional[ta.Observations]:
 43 |         
 44 | 
 45 |         if seed is not None:
 46 |             random.seed(seed)
 47 |         else:
 48 |             random.seed()
 49 | 
 50 |         
 51 |         self.game_board, self.placed_words = self._generate_word_search()
 52 |         
 53 |         
 54 |         return self.state.reset(
 55 |             game_state={
 56 |                 "board": copy.deepcopy(self.game_board),
 57 |                 "rendered_board": self._render_board(self.game_board),
 58 |             },
 59 |             player_prompt_function=self._generate_player_prompt
 60 |         )
 61 | 
 62 |     def _generate_player_prompt(self, player_id: int) -> str:
 63 |         
 64 | 
 65 |         prompt = (
 66 |             f"You are Player {player_id}, and you are participating in a Word Search challenge "
 67 |             f"modeled as {'Hardcore' if self.hardcore else 'Basic'}. The objective is to find and highlight hidden words "
 68 |             f"on the grid below. The rows and columns are numbered for your reference.\n\n"
 69 |             "Here is the current state of the Word Search board:\n"
 70 |             "----------------------------------------\n"
 71 |             "Words you have already found are marked in square brackets [ ]. Each row and column is numbered for clarity.\n"
 72 |             "Current Word Search Board:\n"
 73 |         )
 74 | 
 75 |         grid_str = self._render_board(self.state.game_state["board"], show_words=False)
 76 |         prompt += grid_str
 77 | 
 78 |         prompt += (
 79 |             "\n\nYour task is to find the following words on the board:\n"
 80 |             "----------------------------------------\n"
 81 |         )
 82 |         prompt += "\n".join([f"{i+1}. {word}" for i, word in enumerate(self.placed_words)])
 83 | 
 84 |         prompt += (
 85 |             "\n\nTo locate a word, specify the row and column of its start and end letters. Note that words are either across or down.\n"
 86 |             "You may type your response and thoughts in any manner. But for your submissions, use the format '[start_row start_col end_row end_col]'.\n"
 87 |             "For instance, if you want to find the word 'HELLO' starting at row 1, column 1 and ending at row 1, column 5, enter '[1 1 1 5]'.\n"
 88 |             "\nGuidelines:\n"
 89 |             "- Each guess must be unique; you cannot repeat the same guess.\n"
 90 |             "- You have a total of 20 incorrect attempts remaining.\n"
 91 |             "- The history of your attempts will be recorded below.\n\n"
 92 |             "Make your guesses carefully and strategically. Good luck, Player {player_id}! Let's see how many words you can find!\n"
 93 |         )
 94 | 
 95 | 
 96 |         return prompt
 97 |     
 98 |     def _generate_word_search(self):
 99 |         
100 |         
101 |         self.words = random.sample(self.word_list, self.num_words)
102 |         self.words = [word.upper() for word in self.words]
103 |         self.words = sorted(self.words, key=lambda w: len(w), reverse=True)
104 |         self.directions = {word: random.choice(["across", "down"]) for word in self.words}
105 | 
106 |         self.highlighted_positions = set()
107 |         self.correct_words = set()
108 |         self.incorrect_attempts = []
109 | 
110 |         grid_size = self._determine_initial_grid_size(self.words)
111 |         grid = self._create_empty_grid(grid_size)
112 | 
113 |         self.placed_words = {}  
114 | 
115 |         for word in self.words:
116 |             placed = False
117 |             if not self.placed_words:  
118 |                 
119 |                 if self.directions[word] == "across":
120 |                     row = grid_size // 2
121 |                     col = (grid_size - len(word)) // 2
122 |                 else:
123 |                     row = (grid_size - len(word)) // 2
124 |                     col = grid_size // 2
125 | 
126 |                 if self._can_place_word(grid, word, self.directions[word], row, col):
127 |                     self._place_word_on_grid(grid, word, self.directions[word], row, col)
128 |                     self.placed_words[word] = (row, col, self.directions[word])
129 |                     placed = True
130 |             
131 |             else:
132 |                 
133 |                 possible_positions = self._find_overlaps(word, grid, self.directions)
134 |                 random.shuffle(possible_positions)  
135 |                 for pos in possible_positions:
136 |                     row, col, direction = pos
137 |                     if self._can_place_word(grid, word, direction, row, col):
138 |                         self._place_word_on_grid(grid, word, direction, row, col)
139 |                         self.placed_words[word] = (row, col, direction)
140 |                         placed = True
141 |                         break
142 | 
143 |             if not placed:
144 |                 
145 |                 for row in range(grid_size):
146 |                     for col in range(grid_size):
147 |                         if self._can_place_word(grid, word, self.directions[word], row, col):
148 |                             self._place_word_on_grid(grid, word, self.directions[word], row, col)
149 |                             self.placed_words[word] = (row, col, self.directions[word])
150 |                             placed = True
151 |                             break
152 |                     if placed:
153 |                         break
154 | 
155 |             if not placed:
156 |                 print(f"Could not place the word: {word}")
157 | 
158 |         
159 |         self._fill_empty_cells(grid)
160 | 
161 |         
162 |         
163 |         
164 | 
165 |         return grid, self.placed_words
166 | 
167 |     def _determine_initial_grid_size(self, words):
168 |         
169 |         max_length = max(len(word) for word in words)
170 |         return round(max_length * 1.5)  
171 | 
172 |     def _create_empty_grid(self, size):
173 |         
174 |         return [["." for _ in range(size)] for _ in range(size)]
175 | 
176 |     def _can_place_word(self, grid, word, direction, row, col):
177 |         
178 |         if direction == "across":
179 |             if col + len(word) > len(grid[0]):
180 |                 return False
181 |             for i, letter in enumerate(word):
182 |                 current_cell = grid[row][col + i]
183 |                 if current_cell != "." and current_cell != letter: 
184 |                     return False
185 |         else:  
186 |             if row + len(word) > len(grid):
187 |                 return False
188 |             for i, letter in enumerate(word):
189 |                 current_cell = grid[row + i][col]
190 |                 if current_cell != "." and current_cell != letter:
191 |                     return False
192 | 
193 |         return True
194 | 
195 |     def _place_word_on_grid(self, grid, word, direction, row, col):
196 |         
197 |         if direction == "across":
198 |             for i, letter in enumerate(word):
199 |                 grid[row][col + i] = letter
200 |         else:  
201 |             for i, letter in enumerate(word):
202 |                 grid[row + i][col] = letter
203 | 
204 |     def _find_overlaps(self, word, grid, directions):
205 |         
206 |         overlaps = []
207 |         for placed_word, (p_row, p_col, p_direction) in self.placed_words.items():
208 |             for i, letter in enumerate(word):
209 |                 for j, placed_letter in enumerate(placed_word):
210 |                     if letter == placed_letter:
211 |                         
212 |                         if p_direction == 'across':
213 |                             row = p_row - i
214 |                             col = p_col + j
215 |                             if directions[word] == 'down' and 0 <= row < len(grid) and 0 <= col < len(grid[0]):
216 |                                 if self._can_place_word(grid, word, 'down', row, col):
217 |                                     overlaps.append((row, col, 'down'))
218 |                         elif p_direction == 'down':
219 |                             row = p_row + j
220 |                             col = p_col - i
221 |                             if directions[word] == 'across' and 0 <= row < len(grid) and 0 <= col < len(grid[0]):
222 |                                 if self._can_place_word(grid, word, 'across', row, col):
223 |                                     overlaps.append((row, col, 'across'))
224 |         return overlaps
225 | 
226 |     def _fill_empty_cells(self, grid):
227 |         
228 |         for row in range(len(grid)):
229 |             for col in range(len(grid[0])):
230 |                 if grid[row][col] == ".":
231 |                     grid[row][col] = random.choice(string.ascii_uppercase)
232 | 
233 |     def _validate_and_replace_unintended_words(self, grid, words):
234 |         
235 |         grid_size = len(grid)
236 |         word_set = set(words)
237 | 
238 |         
239 |         for row_index, row in enumerate(grid):
240 |             row_str = "".join(row)
241 |             self._find_and_replace_unintended_words(grid, row_str, word_set, row_index, is_row=True)
242 | 
243 |         
244 |         for col_index in range(grid_size):
245 |             col_str = "".join(grid[row][col_index] for row in range(grid_size))
246 |             self._find_and_replace_unintended_words(grid, col_str, word_set, col_index, is_row=False)
247 | 
248 |     def _find_and_replace_unintended_words(self, grid, string, word_set, index, is_row):
249 |         
250 |         min_word_length = 3  
251 |         placed_positions = self._get_positions()
252 | 
253 |         for start in range(len(string)):
254 |             for end in range(start + min_word_length, len(string) + 1):
255 |                 substring = string[start:end]
256 |                 
257 |                 
258 |                 if is_row:
259 |                     substring_positions = {(index, start + i) for i in range(len(substring))}
260 |                 else:
261 |                     substring_positions = {(start + i, index) for i in range(len(substring))}
262 |                 
263 |                 
264 |                 if substring_positions & placed_positions:
265 |                     continue  
266 | 
267 |                 if substring in word_set:
268 |                     continue  
269 |                 
270 |                 
271 |                 if self._is_valid_word(substring):
272 |                     print(f"Unintended word found: {substring}")
273 |                     self._replace_unintended_word(grid, substring_positions)
274 | 
275 |     def _replace_unintended_word(self, grid, positions):
276 |         
277 |         for row, col in positions:
278 |             grid[row][col] = random.choice(string.ascii_uppercase)
279 | 
280 |     def _is_valid_word(self, word):
281 |         
282 |         return word.lower() in words.words("en")
283 |     
284 |     def _get_positions(self):
285 |         
286 |         positions = set()
287 |         for word, (row, col, direction) in self.placed_words.items():
288 |             if direction == "across":
289 |                 for position in [(row, col + i) for i in range(len(word))]:
290 |                     positions.add(position)
291 |             else:  
292 |                 for position in [(row + i, col) for i in range(len(word))]:
293 |                     positions.add(position)
294 |         return positions
295 |     
296 | 
297 |     def _render_board(self, grid, show_words=True):
298 |         
299 |         header = "   " + " ".join(f"C{i:02}" for i in range(len(grid)))
300 |         lines = [header]
301 |         for i, row in enumerate(grid):
302 |             row_str = f"R{i:02} "
303 |             for j, val in enumerate(row):
304 |                 if (i, j) in self.highlighted_positions:
305 |                     row_str += f"[{val}] " if show_words else f" {val}  "
306 |                 else:
307 |                     row_str += f" {val}  "
308 |             lines.append(row_str)
309 | 
310 |         return "\n".join(lines)
311 | 
312 |     def _check_word(self, grid, start_row, start_col, end_row, end_col):
313 |         
314 |         word = self._extract_word(grid, start_row, start_col, end_row, end_col)
315 |         
316 |         for placed_word, (row, col, direction) in self.placed_words.items():
317 |             if self._matches_position(word, row, col, direction, start_row, start_col, end_row, end_col):
318 |                 self.correct_words.add(placed_word)
319 |                 self._highlight_word(start_row, start_col, end_row, end_col)
320 |                 print(f"Correct! The word '{placed_word}' was found.")
321 |                 return True
322 |         
323 |         self.incorrect_attempts.append((start_row, start_col, end_row, end_col))
324 |         print("Incorrect attempt.")
325 |         return False
326 |         
327 |     def _highlight_word(self, start_row, start_col, end_row, end_col):
328 |         
329 |         if start_row == end_row:  
330 |             for col in range(min(start_col, end_col), max(start_col, end_col) + 1):
331 |                 self.highlighted_positions.add((start_row, col))
332 |         elif start_col == end_col:  
333 |             for row in range(min(start_row, end_row), max(start_row, end_row) + 1):
334 |                 self.highlighted_positions.add((row, start_col))
335 |         else:
336 |             print("Invalid input: Words can only be horizontal or vertical.")
337 | 
338 |     def _extract_word(self, grid, start_row, start_col, end_row, end_col):
339 |         
340 |         if start_row == end_row:  
341 |             return "".join(grid[start_row][col] for col in range(min(start_col, end_col), max(start_col, end_col) + 1))
342 |         elif start_col == end_col:  
343 |             return "".join(grid[row][start_col] for row in range(min(start_row, end_row), max(start_row, end_row) + 1))
344 |         else:
345 |             print("Invalid input: Words can only be horizontal or vertical.")
346 |             return ""
347 | 
348 |     def _matches_position(self, word, row, col, direction, start_row, start_col, end_row, end_col):
349 |         
350 |         if direction == "across" and row == start_row and col == min(start_col, end_col):
351 |             return len(word) == abs(end_col - start_col) + 1
352 |         elif direction == "down" and col == start_col and row == min(start_row, end_row):
353 |             return len(word) == abs(end_row - start_row) + 1
354 |         return False
355 |     
356 |     def step(
357 |         self,
358 |         player_id: int,
359 |         action: str,
360 |     ) -> Tuple[
361 |         Optional[ta.Observations],
362 |         Optional[ta.Rewards],
363 |         bool,
364 |         bool,
365 |         ta.Info
366 |     ]: 
367 |         
368 | 
369 |         
370 |         self.state.add_observation(
371 |             from_id=player_id,
372 |             to_id=-1,
373 |             message=action,
374 |             for_logging=True
375 |         )
376 | 
377 |         
378 |         action_search_pattern = re.compile(r"\[(\d+)\s(\d+)\s(\d+)\s(\d+)\]")
379 |         matches = action_search_pattern.findall(action)
380 |         matches = set(matches)
381 | 
382 |         if not matches:
383 |             
384 |             self.state.set_invalid_move(
385 |                 player_ids=[player_id],
386 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with valid 'start_row, start_col, end_row, end_col'."]
387 |             )
388 |         else:
389 |             for match in matches:
390 |                 print("Checking match:", match)
391 |                 start_row, start_col, end_row, end_col = [int(x) for x in match]
392 |                 if not (0 <= start_row < len(self.state.game_state["board"]) 
393 |                         and 0 <= start_col < len(self.state.game_state["board"][0]) 
394 |                         and 0 <= end_row < len(self.state.game_state["board"]) 
395 |                         and 0 <= end_col < len(self.state.game_state["board"][0])):
396 |                     
397 |                     self.state.set_invalid_move(
398 |                         player_ids=[player_id],
399 |                         reasons=[f"Invalid move format. Player {player_id} did not respond with valid 'start_row, start_col, end_row, end_col'."]
400 |                     )
401 |                     break
402 |                 elif (start_row, start_col, end_row, end_col) in self.incorrect_attempts:
403 |                     
404 |                     self.state.set_invalid_move(
405 |                         player_ids=[player_id],
406 |                         reasons=[f"Invalid move. The action has already been attempted."]
407 |                     )
408 |                     break
409 |                 elif not self._check_word(self.state.game_state["board"], start_row, start_col, end_row, end_col):
410 |                     
411 |                     self.num_incorrect_tries -= 1
412 |                     self.state.add_observation(
413 |                         from_id=ta.GAME_ID,
414 |                         to_id=player_id,
415 |                         message=f"[{start_row} {start_col} {end_row} {end_col}] is an incorrect attempt. {self.num_incorrect_tries} incorrect tries remaining.",
416 |                         for_logging=False
417 |                     )
418 |                     if self.num_incorrect_tries == 0:
419 |                         self.state.set_draw(reason="No more incorrect tries remaining.")
420 |                     break
421 |                 else:
422 |                     
423 |                     self.state.add_observation(
424 |                         from_id=-1,
425 |                         to_id=player_id,
426 |                         message=f"You have found a word. Updated Board state:\n{self._render_board(self.state.game_state['board'], show_words=True)}",
427 |                         for_logging=False
428 |                     )
429 |             
430 |             
431 |             if self._is_game_over():
432 |                 self.state.set_winners(
433 |                         player_ids=[player_id],
434 |                         reason=f"Congratulations! Player {player_id} completed the Crosswords puzzle."
435 |                     )
436 | 
437 |             
438 |             self.state.game_state["rendered_board"] = self._render_board(self.state.game_state["board"], show_words=True)
439 |         
440 |         return self.state.step()
441 |     
442 |     def _is_game_over(self) -> bool:
443 |         
444 | 
445 |         return len(self.correct_words) == len(self.placed_words)
446 |     
447 |     def render(self) -> None:
448 |         
449 | 
450 |         print(self.state.game_state["rendered_board"])
```

## File: textarena/envs/single_player/WordSearch/readme.md

- Extension: .md
- Language: markdown
- Size: 10181 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Word Search Environment Documentation
  2 | 
  3 | ## Overview
  4 | 
  5 | Word Search is a single-player puzzle game where the player finds the placement of words in a grid of random letters, where the words are given at the beginning. The player's objective is to correctly find all the words in the grid given, ensuring that the start and end position of the found word align correctly with the words in the grid. The environment supports a standard and a hardcore mode, influencing the difficulty of the words provided. 
  6 | 
  7 | ## Action Space
  8 | - **Format**: Actions are strings in the format [start_row start_col end_row end_col], where:
  9 |     - (start_row, start_col) are the beginning positions of the word, and (end_row, end_col) are the ending positions of the word.
 10 | - **Examples**:
 11 |     - To say that the word 'observation' starts at (8, 2) and ends at (8, 12): [8 2 8 12]
 12 | - **Notes**: Players can provide multiple guesses at once in the format of [start_row start_col end_row end_col]. Additional text may accompany the action, but it must contain the correct format for the action to be processed. Incorrectly formatted actions or wrong actions will be marked as invalid.
 13 | 
 14 | ## Observation Space
 15 | **Reset Observation:**
 16 | On reset, the observation provides the initial prompt and the state of the WordSearch grid. For example:
 17 | 
 18 | ```plaintext
 19 | [GAME] You are Player 0, and you are participating in a Word Search challenge modeled as Basic. The objective is to find and highlight hidden words on the grid below. The rows and columns are numbered for your reference.
 20 | 
 21 | Here is the current state of the Word Search board:
 22 | ----------------------------------------
 23 | Words you have already found are marked in square brackets [ ]. Each row and column is numbered for clarity.
 24 | Current Word Search Board:
 25 |    C00 C01 C02 C03 C04 C05 C06 C07 C08 C09 C10 C11 C12 C13 C14 C15
 26 | R00  T   C   U   M   I   N   Y   L   V   R   M   J   X   J   Z   B  
 27 | R01  G   L   I   H   V   R   N   G   W   R   J   V   K   V   O   K  
 28 | R02  X   W   H   G   C   D   N   W   G   C   N   R   D   B   G   M  
 29 | R03  X   Q   Y   K   T   K   J   A   X   P   U   H   C   O   S   U  
 30 | R04  H   C   W   K   J   A   B   I   I   R   W   V   A   L   W   G  
 31 | R05  M   Z   J   D   K   A   Z   K   V   O   K   U   I   S   L   Q  
 32 | R06  Y   W   Q   Y   P   E   J   T   A   F   R   T   L   S   R   Q  
 33 | R07  J   Z   N   W   P   O   F   N   K   I   G   I   L   F   J   E  
 34 | R08  I   L   O   B   S   E   R   V   A   T   I   O   N   F   W   Y  
 35 | R09  X   U   S   M   E   T   C   H   P   H   A   F   N   S   A   R  
 36 | R10  Y   V   W   E   X   K   U   L   P   O   E   M   C   P   I   H  
 37 | R11  E   R   S   L   U   U   E   H   B   U   V   Y   P   N   V   Y  
 38 | R12  J   F   D   R   P   V   M   R   A   G   Z   N   X   J   P   M  
 39 | R13  T   E   H   Z   J   E   F   N   Q   H   T   W   T   X   N   F  
 40 | R14  K   C   Q   N   O   P   Q   U   I   T   E   X   W   O   J   V  
 41 | R15  R   Y   A   M   J   H   P   T   K   Q   J   G   F   Z   P   S  
 42 | 
 43 | Your task is to find the following words on the board:
 44 | ----------------------------------------
 45 | 1. OBSERVATION
 46 | 2. THOUGHT
 47 | 3. PROFIT
 48 | 4. QUITE
 49 | 5. NUT
 50 | 
 51 | To locate a word, specify the row and column of its start and end letters. Note that words are either across or down.
 52 | You may type your response and thoughts in any manner. But for your submissions, use the format '[start_row start_col end_row end_col]'.
 53 | For instance, if you want to find the word 'HELLO' starting at row 1, column 1 and ending at row 1, column 5, enter '[1 1 1 5]'.
 54 | 
 55 | Guidelines:
 56 | - Each guess must be unique; you cannot repeat the same guess.
 57 | - You have a total of 20 incorrect attempts remaining.
 58 | - The history of your attempts will be recorded below.
 59 | 
 60 | Make your guesses carefully and strategically. Good luck, Player {player_id}! Let's see how many words you can find!
 61 | ```
 62 | 
 63 | **Step Observation:**
 64 | After each step, the environment returns the action and the updated WordSearch grid as the observation. For example:
 65 | ```plaintext
 66 | [Player 0] Let's start by finding the words on the board. Here's my attempt to locate each word:
 67 | 
 68 | 1. OBSERVATION: Found in row 8, starting from column 2 to column 12.
 69 |    - Guess: [8 2 8 12]
 70 | 
 71 | 2. THOUGHT: Let's look for this word.
 72 |    - The word THOUGHT can be found in column 10, starting from row 3 to row 9.
 73 |    - Guess: [3 10 9 10]
 74 | 
 75 | 3. PROFIT: Let's locate this word.
 76 |    - The word PROFIT can be found in row 14, starting from column 5 to column 10.
 77 |    - Guess: [14 5 14 10]
 78 | 
 79 | 4. QUITE: I'll try to find this one next.
 80 |    - The word QUITE can be found in row 14, starting from column 8 to column 12.
 81 |    - Guess: [14 8 14 12]
 82 | 
 83 | 5. NUT: Finally, let's find this word.
 84 |    - The word NUT can be found in column 5, starting from row 0 to row 2.
 85 |    - Guess: [0 5 2 5]
 86 | 
 87 | Let's enter these guesses and see if they're all correct!
 88 | 
 89 | [GAME] You have found a word. Updated Board state:
 90 |    C00 C01 C02 C03 C04 C05 C06 C07 C08 C09 C10 C11 C12 C13 C14 C15
 91 | R00  T   C   U   M   I   N   Y   L   V   R   M   J   X   J   Z   B  
 92 | R01  G   L   I   H   V   R   N   G   W   R   J   V   K   V   O   K  
 93 | R02  X   W   H   G   C   D   N   W   G   C   N   R   D   B   G   M  
 94 | R03  X   Q   Y   K   T   K   J   A   X   P   U   H   C   O   S   U  
 95 | R04  H   C   W   K   J   A   B   I   I   R   W   V   A   L   W   G  
 96 | R05  M   Z   J   D   K   A   Z   K   V   O   K   U   I   S   L   Q  
 97 | R06  Y   W   Q   Y   P   E   J   T   A   F   R   T   L   S   R   Q  
 98 | R07  J   Z   N   W   P   O   F   N   K   I   G   I   L   F   J   E  
 99 | R08  I   L  [O] [B] [S] [E] [R] [V] [A] [T] [I] [O] [N]  F   W   Y  
100 | R09  X   U   S   M   E   T   C   H   P   H   A   F   N   S   A   R  
101 | R10  Y   V   W   E   X   K   U   L   P   O   E   M   C   P   I   H  
102 | R11  E   R   S   L   U   U   E   H   B   U   V   Y   P   N   V   Y  
103 | R12  J   F   D   R   P   V   M   R   A   G   Z   N   X   J   P   M  
104 | R13  T   E   H   Z   J   E   F   N   Q   H   T   W   T   X   N   F  
105 | R14  K   C   Q   N   O   P   Q   U   I   T   E   X   W   O   J   V  
106 | R15  R   Y   A   M   J   H   P   T   K   Q   J   G   F   Z   P   S  
107 | ```
108 | 
109 | By default, the environment returns observations in the following format:
110 | ```python
111 | {
112 |   player_id: int : [
113 |     (sender_id: int, message: str),
114 |     (sender_id: int, message: str),
115 |     ...
116 |   ]
117 | }
118 | ```
119 | 
120 | ## Gameplay
121 | - **Grid Size**: The grid size is determined dynamically based on the length of the longest word and the total number of words to ensure adequate space for placement.
122 | - **Turns**: The player identifies words hidden within the grid by specifying the coordinates of the starting and ending positions. Incorrect guesses reduce the remaining attempts.
123 | - **Word Placement**: Words are placed either horizontally ("across") or vertically ("down") and may overlap with other words. The player must correctly locate the start and end coordinates to highlight them.
124 | - **Winning Condition**: The game is won when all the words listed have been correctly found and highlighted on the grid.
125 | 
126 | ## Key Rules
127 | - **Valid Moves**:
128 |     - The player must enter a valid start_row, start_col, end_row, end_col in the [start_row start_col end_row end_col] format.
129 | 
130 | - **Invalid Moves**:
131 |     - Entering a start_row, start_col, end_row, end_col that is outside the grid bounds.
132 |     - Repeating a guess
133 | 
134 | ## Rewards
135 | | Outcome          | Reward for Player  |
136 | |------------------|:------------------:|
137 | | **Win**          |       `+1`         |
138 | | **Lose**         |       `0`          |
139 | | **Invalid Move** |       `-1`         |
140 | 
141 | ## Parameters
142 | 
143 | - `hardcore` (`bool`):
144 |     - **Description:** Determines the type of words to spot
145 |     - **Impact:**
146 |         - **False:** Hidden words follow basic english.
147 |         - **True**: Hidden words would be uncommon and challenging words.
148 | 
149 | 
150 | ## Variants
151 | 
152 | | Env-id                    | hardcore |
153 | |---------------------------|:--------:|
154 | | `WordSearch-v0`           | `False`  |
155 | | `WordSearch-v0-hardcore`  | `True`   |
156 | 
157 | ## Example Usage
158 | ```python
159 | import textarena as ta
160 | 
161 | ## initializa the environment
162 | env = ta.make("WordSearch-v0")
163 | 
164 | ## Wrap the environment for easier observation handling
165 | env = ta.wrappers.LLMObservationWrapper(env=env)
166 | 
167 | ## Wrap the environment for pretty rendering
168 | env = ta.wrappers.PrettyRenderWrapper(env=env)
169 | 
170 | ## initalize agents
171 | agents = {
172 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
173 |     }
174 | 
175 | ## reset the environment to start a new game
176 | observations = env.reset(seed=490)
177 | 
178 | ## Game loop
179 | done = False
180 | while not done:
181 | 
182 |     # Get the current player
183 |     current_player_id = env.state.get("current_player")
184 | 
185 |     # Get the current observation for the player
186 |     obs = observations[current_player_id]
187 | 
188 |     # Agent decides on an action based on the observation
189 |     action = agents[current_player_id](obs)
190 | 
191 |     # Execute the action in the environment
192 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
193 | 
194 |     # Check if the game has ended
195 |     done = terminated or truncated
196 | 
197 |     # Optionally render the environment to see the current state
198 |     env.render()
199 | 
200 |     if done:
201 |         break
202 | 
203 | ## Finally, print the game results
204 | for player_id, agent in agents.items():
205 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
206 | print(f"Reason: {info['reason']}")
207 | ```
208 | 
209 | ## Troubleshooting
210 | 
211 | **Incorrect Word Highlighting**
212 | 
213 | - **Issue**: A word is marked as found even though the coordinates or letters do not match the actual word placement.
214 | - **Solution**: Verify that the starting and ending coordinates match the word’s correct location in the grid. Ensure the format [start_row start_col end_row end_col] is followed precisely.
215 | 
216 | **Repeated Guesses**
217 | 
218 | - **Issue**: The same guess is made multiple times, reducing the remaining attempts unnecessarily.
219 | - **Solution**: Check the history of previous guesses before submitting a new one to avoid repeats. Use unique starting and ending coordinates for each guess.
220 | 
221 | I**nsufficient Grid Size**
222 | 
223 | - **Issue**: Some words cannot be placed because the grid is too small.
224 | - **Solution**: Adjust the word list or increase the grid size in the settings to ensure adequate space for all words.
225 | 
226 | 
227 | ## Version History
228 | - **v0**
229 |   - Initial release 
230 | 
231 | 
232 | ### Contact
233 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/WordSearch/example.py

- Extension: .py
- Language: python
- Size: 1277 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("WordSearch-v0")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/Crosswords/test.py

- Extension: .py
- Language: python
- Size: 4140 bytes
- Created: 2024-11-14 10:14:57
- Modified: 2024-11-14 10:14:57

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.Crosswords.env import CrosswordsEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["[7 2 C]"]  
 9 | 
10 | def generate_invalid_format_sequence():
11 |     
12 |     return ["row 2 col 8 D"]  
13 | 
14 | def generate_out_of_bounds_sequence():
15 |     
16 |     return ["[130 3 R], [6 111 J]"]  
17 | 
18 | def generate_invalid_move_sequence():
19 |     
20 |     return ["[2 2 R]"]  
21 | 
22 | class TestCrosswordsEnv(unittest.TestCase):
23 | 
24 |     
25 |     env_variants = [
26 |         {"hardcore": False, "max_turns": 10, "num_words": 5},
27 |         {"hardcore": True, "max_turns": 10, "num_words": 5}
28 |     ]
29 | 
30 |     
31 |     test_cases = {
32 |         "correct_move_easy": {
33 |             "hardcore": False,
34 |             "actions": generate_correct_move_sequence()
35 |         },
36 |         "invalid_format_easy": {
37 |             "hardcore": False,
38 |             "actions": generate_invalid_format_sequence()
39 |         },
40 |         "out_of_bounds_easy": {
41 |             "hardcore": False,
42 |             "actions": generate_out_of_bounds_sequence()
43 |         },
44 |         "invalid_move_easy": {
45 |             "hardcore": False,
46 |             "actions": generate_invalid_move_sequence()
47 |         }
48 |     }
49 | 
50 |     @parameterized.expand([
51 |         (name, details['hardcore'], details['actions'])
52 |         for name, details in test_cases.items()
53 |     ])
54 |     def test_crosswords_outcomes(self, name, hardcore, actions):
55 |         
56 |         env_config = next((env for env in self.env_variants if env['hardcore'] == hardcore), None)
57 |         self.assertIsNotNone(env_config, f"Invalid hardcore level: {hardcore}")
58 | 
59 |         env = CrosswordsEnv(hardcore=env_config['hardcore'], max_turns=env_config['max_turns'], num_words=env_config['num_words'])
60 | 
61 |         observations = env.reset(seed=490)
62 | 
63 |         terminated = False
64 |         truncated = False
65 |         
66 |         for i, action in enumerate(actions):
67 |             if terminated or truncated:
68 |                 break
69 |             player_id = 0
70 |             obs = observations
71 | 
72 |             
73 |             observations, reward, truncated, terminated, info = env.step(player_id, action)
74 | 
75 |             
76 |             if "correct_move" in name:
77 |                 self.assertFalse(truncated, "Game should not truncate for correct moves.")
78 |                 self.assertFalse(terminated, "Game should not terminate until the puzzle is complete.")
79 |             elif "invalid_format" in name:
80 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
81 |                 self.assertEqual(reward[0], -1, "Player should receive -1 reward for an invalid move format.")
82 |             elif "out_of_bounds" in name:
83 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an out-of-bounds move.")
84 |                 self.assertEqual(reward[0], -1, "Player should receive -1 for out-of-bounds move.")
85 |             elif "invalid_move" in name:
86 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move.")
87 |                 self.assertEqual(reward[0], -1, "Player should receive -1 for violating Sudoku rules.")
88 |             else:
89 |                 self.fail(f"Unknown test case name: {name}")
90 | 
91 |     
92 |     
93 |     
94 | 
95 | if __name__ == '__main__':
96 |     unittest.main()
```

## File: textarena/envs/single_player/Crosswords/env.py

- Extension: .py
- Language: python
- Size: 17661 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | from typing import Any, Dict, Optional, Tuple, Union
  2 | import copy
  3 | import random
  4 | import textarena as ta
  5 | import re
  6 | import json
  7 | 
  8 | class CrosswordsEnv(ta.Env):
  9 |     
 10 | 
 11 |     def __init__(
 12 |         self, 
 13 |         hardcore: Optional[bool] = False, 
 14 |         max_turns: Optional[int] = 100, 
 15 |         num_words: Optional[int] = 5
 16 |     ):
 17 |         
 18 | 
 19 |         super().__init__()
 20 |         self.environment_name = "Crosswords"
 21 |         self.hardcore = hardcore
 22 |         self.max_turns = max_turns
 23 |         self.num_words = num_words
 24 | 
 25 |         
 26 |         self.state = ta.State(
 27 |             num_players=1,
 28 |             max_turns=max_turns,
 29 |             render_keys=["rendered_board"], 
 30 |         )
 31 | 
 32 |         
 33 |         with open("textarena/envs/single_player/Crosswords/words_clues.jsonl", "r") as f:
 34 |             word_data = f.readlines()
 35 |         self.word_data = [json.loads(x) for x in word_data if json.loads(x)["hardcore"]==hardcore]
 36 | 
 37 |     
 38 |     def reset(
 39 |         self, 
 40 |         seed: Optional[int] = None
 41 |     ) -> Optional[ta.Observations]:
 42 |         
 43 |         if seed is not None:
 44 |             random.seed(seed)
 45 |         else:
 46 |             random.seed()
 47 | 
 48 |         
 49 |         self.game_board, self.placed_words, self.clues = self._generate_board() 
 50 |         self.game_board_hidden = self._hide_letters(self.game_board) 
 51 | 
 52 |         
 53 |         return self.state.reset(
 54 |             game_state={
 55 |                 "board": copy.deepcopy(self.game_board_hidden),
 56 |                 "rendered_board": self._render_board(self.game_board_hidden, show_letters=True),
 57 |             },
 58 |             player_prompt_function=self._generate_player_prompt
 59 |         )
 60 | 
 61 | 
 62 |     def _generate_player_prompt(self, player_id: int) -> str:
 63 |         
 64 |         prompt = (
 65 |             f"You are Player {player_id}. You are playing Crosswords ({'Hardcore' if self.hardcore else 'Basic'}).\n"
 66 |             "Here is the current state of the Crosswords grid. Each row is numbered, and each column is also numbered.\n"
 67 |             "The cells that need to be populated with letters are represented by '_', and those that do not need words are represented by '.'.\n\n"
 68 |             "Current Crosswords Grid:\n"
 69 |         )
 70 | 
 71 |         grid_str = self._render_board(self.game_board_hidden, show_letters=False)
 72 |         prompt += grid_str
 73 | 
 74 |         prompt += "\n\nHere are the clues for the words you need to find:\n"
 75 |         prompt += self._clue_generator()
 76 |         prompt += ("\n\nYou may provide your response in any manner. However, note that any wrong guesses will result in you losing. Hence, plan your approach and risk appetite. Only guesses in the format of [row column letter] will be fetched from your response.\n"
 77 |                    "As you play, the history of your choices will be appended below. Use the information to complete the game.\n")
 78 |     
 79 |         return prompt
 80 | 
 81 | 
 82 |     def _generate_board(self):
 83 |         
 84 |         
 85 |         sampled_word_data = random.sample(self.word_data, self.num_words)
 86 |         sampled_word_data_sorted = sorted(sampled_word_data, key=lambda x: len(x["word"]), reverse=True)
 87 |         words = [x["word"] for x in sampled_word_data_sorted]
 88 |         directions = {x["word"]: random.choice(["across", "down"]) for x in sampled_word_data_sorted}
 89 |         clues = {x["word"]: random.sample(list(x["clues"].values()), 1)[0] for x in sampled_word_data_sorted}
 90 | 
 91 |         
 92 |         grid_size = self._determine_initial_grid_size(words)
 93 |         grid = self._create_empty_grid(grid_size)
 94 | 
 95 |         placed_words = {}  
 96 | 
 97 |         for word in words:
 98 |             placed = False
 99 |             if not placed_words:  
100 |                 
101 |                 if directions[word] == "across":
102 |                     row = grid_size // 2
103 |                     col = (grid_size - len(word)) // 2
104 |                 else:
105 |                     row = (grid_size - len(word)) // 2
106 |                     col = grid_size // 2
107 | 
108 |                 if self._can_place_word(grid, word, directions[word], row, col):
109 |                     self._place_word_on_grid(grid, word, directions[word], row, col)
110 |                     placed_words[word] = (row, col, directions[word])
111 |                     placed = True
112 |             
113 |             else:
114 |                 
115 |                 possible_positions = self._find_overlaps(word, grid, placed_words, directions)
116 |                 random.shuffle(possible_positions)  
117 |                 for pos in possible_positions:
118 |                     row, col, direction = pos
119 |                     if self._can_place_word(grid, word, direction, row, col):
120 |                         self._place_word_on_grid(grid, word, direction, row, col)
121 |                         placed_words[word] = (row, col, direction)
122 |                         placed = True
123 |                         break
124 | 
125 |             if not placed:
126 |                 
127 |                 for row in range(grid_size):
128 |                     for col in range(grid_size):
129 |                         if self._can_place_word(grid, word, directions[word], row, col):
130 |                             self._place_word_on_grid(grid, word, directions[word], row, col)
131 |                             placed_words[word] = (row, col, directions[word])
132 |                             placed = True
133 |                             break
134 |                     if placed:
135 |                         break
136 | 
137 |             if not placed:
138 |                 print(f"Could not place the word: {word}")
139 | 
140 |         return grid, placed_words, clues
141 | 
142 |     def _determine_initial_grid_size(self, words):
143 |         
144 |         max_length = max(len(word) for word in words)
145 |         return round(max_length * 1.5)  
146 | 
147 |     def _create_empty_grid(self, size):
148 |         
149 |         return [["." for _ in range(size)] for _ in range(size)]
150 | 
151 |     def _can_place_word(self, grid, word, direction, row, col):
152 |         
153 |         if direction == "across":
154 |             if col + len(word) > len(grid[0]):
155 |                 return False
156 |             for i, letter in enumerate(word):
157 |                 current_cell = grid[row][col + i]
158 |                 if current_cell != "." and current_cell != letter:
159 |                     return False
160 |         else:  
161 |             if row + len(word) > len(grid):
162 |                 return False
163 |             for i, letter in enumerate(word):
164 |                 current_cell = grid[row + i][col]
165 |                 if current_cell != "." and current_cell != letter:
166 |                     return False
167 | 
168 |         return True
169 | 
170 |     def _place_word_on_grid(self, grid, word, direction, row, col):
171 |         
172 |         if direction == "across":
173 |             for i, letter in enumerate(word):
174 |                 grid[row][col + i] = letter
175 |         else:  
176 |             for i, letter in enumerate(word):
177 |                 grid[row + i][col] = letter
178 | 
179 |     def _find_overlaps(self, word, grid, placed_words, directions):
180 |         
181 |         overlaps = []
182 |         for placed_word, (p_row, p_col, p_direction) in placed_words.items():
183 |             for i, letter in enumerate(word):
184 |                 for j, placed_letter in enumerate(placed_word):
185 |                     if letter == placed_letter:
186 |                         
187 |                         if p_direction == 'across':
188 |                             row = p_row - i
189 |                             col = p_col + j
190 |                             if directions[word] == 'down' and 0 <= row < len(grid) and 0 <= col < len(grid[0]):
191 |                                 if self._can_place_word(grid, word, 'down', row, col):
192 |                                     overlaps.append((row, col, 'down'))
193 |                         elif p_direction == 'down':
194 |                             row = p_row + j
195 |                             col = p_col - i
196 |                             if directions[word] == 'across' and 0 <= row < len(grid) and 0 <= col < len(grid[0]):
197 |                                 if self._can_place_word(grid, word, 'across', row, col):
198 |                                     overlaps.append((row, col, 'across'))
199 |         return overlaps
200 | 
201 |     
202 |     def _render_board(self, grid, show_letters=False):
203 |         
204 |         
205 |         header = "   " + " ".join(f"C{i:02}" for i in range(len(grid)))
206 |         lines = [header]
207 |         for i, row in enumerate(grid):
208 |             
209 |             row_str = f"R{i:02} "
210 |             for j, val in enumerate(row):
211 |                 if show_letters:
212 |                     row_str += f" {val}  "
213 |                 else:
214 |                     row_str += f" _  " if val != "." else " .  "
215 |             lines.append(row_str)
216 | 
217 |         return "\n".join(lines)
218 | 
219 |     def _hide_letters(self, grid):
220 |         
221 |         return [['_' if cell != "." else cell for cell in row] for row in grid]
222 |     
223 |     def step(
224 |         self,
225 |         player_id: int,
226 |         action: str
227 |     ) -> Tuple[
228 |         Optional[ta.Observations], 
229 |         Optional[ta.Rewards], 
230 |         bool, 
231 |         bool, 
232 |         ta.Info 
233 |     ]:
234 |         
235 | 
236 |         
237 |         self.state.add_observation(
238 |             from_id=player_id,
239 |             to_id=-1,
240 |             message=action,
241 |             for_logging=True
242 |         )
243 | 
244 |         
245 |         
246 |         action_search_pattern = re.compile(r"\[(\d+)\s(\d+)\s([a-zA-Z])\]")
247 |         
248 |         matches = action_search_pattern.findall(action)
249 |         matches = set(matches) 
250 |         
251 | 
252 |         if not matches:
253 |             self.state.set_invalid_move(
254 |                 player_ids=[player_id],
255 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with valid 'row column letter'."]
256 |             )
257 |         else:
258 |             for match in matches:
259 |                 print("Checking match", match)
260 |                 row, col, letter = match
261 |                 row, col, letter = int(row), int(col), str(letter)
262 |                 if row < 0 or row >= len(self.state.game_state["board"]) or col < 0 or col >= len(self.state.game_state["board"][0]):
263 |                     self.state.set_invalid_move(
264 |                         player_ids=[player_id],
265 |                         reasons=[f"Invalid move. The specified coordinate is out of bounds."]
266 |                     )
267 |                     break
268 |                 elif self.state.game_state["board"][row][col] == ".":
269 |                     self.state.set_invalid_move(
270 |                         player_ids=[player_id],
271 |                         reasons=[f"Invalid move. The specified coordinate is a black cell."]
272 |                     )
273 |                     break
274 |                 elif not self._is_move_correct(row, col, letter):
275 |                     self.state.set_invalid_move(
276 |                         player_ids=[player_id],
277 |                         reasons=[f"Invalid move. The specified letter is incorrect."]
278 |                     )
279 |                     break
280 |                 else:
281 |                     self.state.game_state["board"][row][col] = letter.upper()
282 |                     self.state.add_observation(
283 |                         from_id=-1,
284 |                         to_id=player_id,
285 |                         message=f"Board state: \n{self._render_board(self.state.game_state['board'], show_letters=True)}",
286 |                         for_logging=False
287 |                     )
288 | 
289 |             
290 |             if self._is_game_over(): 
291 |                 self.state.set_winners(
292 |                         player_ids=[player_id],
293 |                         reason=f"Congratulations! Player {player_id} completed the Crosswords puzzle."
294 |                     )
295 |                 
296 |             
297 |             self.state.game_state["rendered_board"] = self._render_board(self.state.game_state["board"], show_letters=True)
298 | 
299 |         return self.state.step()
300 | 
301 |     def _is_game_over(self) -> bool:
302 |         
303 |         return all("_" not in row for row in self.state.game_state["board"])
304 |     
305 |     def render(self):
306 |         
307 |         print(self.state.game_state["rendered_board"])
308 | 
309 |     def _clue_generator(self):
310 |         
311 |         res = []
312 |         for i, set in enumerate(zip(self.placed_words.values(), self.clues.values())):
313 |             res.append(f"{i+1}. {set[1]}: {set[0]}")
314 | 
315 |         return "\n".join(res)
316 |     
317 |     def _is_move_correct(self, row, col, letter):
318 |         
319 |         return self.game_board[row][col].upper() == letter.upper()
```

## File: textarena/envs/single_player/Crosswords/words_clues.jsonl

- Extension: .jsonl
- Language: unknown
- Size: 85528 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```unknown
  1 | {"word": "learning", "hardcore": false, "clues": {"1": "Acquiring knowledge or skills through study or experience is often referred to as this. (8 letters)  ", "2": "The process of gaining understanding, especially through education, describes this concept. (8 letters)  ", "3": "In a classroom, students engage in this activity to enhance their knowledge. (8 letters)  ", "4": "This term embodies the journey of discovering new information or abilities. (8 letters)  ", "5": "What you do when you absorb new facts or master a new skill. (8 letters)  ", "6": "This continuous process is essential for personal and professional growth. (8 letters)  ", "7": "Engaging with new ideas or concepts leads to this valuable experience. (8 letters)  ", "8": "This word captures the essence of education and intellectual development. (8 letters)  ", "9": "When one seeks to grasp new information, they are actively involved in this. (8 letters)  ", "10": "The act of acquiring knowledge, often associated with formal education. (8 letters)"}}
  2 | {"word": "short", "hardcore": false, "clues": {"1": "A synonym for brief or not lengthy. (5 letters)  ", "2": "This adjective describes something that doesn't last long. (5 letters)  ", "3": "Opposite of tall, often used to describe stature. (5 letters)  ", "4": "When a piece of writing is concise, it can be described as this. (5 letters)  ", "5": "A term for a person's attention span when it quickly fades. (5 letters)  ", "6": "Describing a duration that is less than expected. (5 letters)  ", "7": "This word can refer to a lack of something necessary. (5 letters)  ", "8": "Often used to describe a meeting that doesn\u2019t take much time. (5 letters)  ", "9": "A term for clothing that doesn\u2019t reach the ankles. (5 letters)  ", "10": "This word can refer to a summary or condensed version of something. (5 letters)"}}
  3 | {"word": "orange", "hardcore": false, "clues": {"1": "A bright citrus fruit often found in juice form. (6 letters)  ", "2": "This color is commonly associated with sunsets and pumpkins. (6 letters)  ", "3": "It's the hue of a traffic signal that means caution. (6 letters)  ", "4": "A popular flavor for candies and desserts. (6 letters)  ", "5": "This fruit is a staple in many breakfast tables. (6 letters)  ", "6": "You might peel this before eating it as a snack. (6 letters)  ", "7": "The name of a famous fruit company known for its technology. (6 letters)  ", "8": "This color is created by mixing red and yellow. (6 letters)  ", "9": "It\u2019s the name of a character in a well-known animated movie who is a fruit. (6 letters)  ", "10": "A common color for Halloween decorations alongside black. (6 letters)"}}
  4 | {"word": "lift", "hardcore": false, "clues": {"1": "To elevate something physically or metaphorically. (4 letters)  ", "2": "A device used to move people or goods between floors. (4 letters)  ", "3": "To raise or hoist, often associated with heavy objects. (4 letters)  ", "4": "An increase in mood or spirits; something that boosts morale. (4 letters)  ", "5": "A ride in a car provided to someone by another. (4 letters)  ", "6": "An upward motion or action, especially in a gym. (4 letters)  ", "7": "To remove or take off, as in lifting a lid. (4 letters)  ", "8": "The action of raising a weight or object in fitness. (4 letters)  ", "9": "A synonym for 'elevator' in informal contexts. (4 letters)  ", "10": "To help someone or something become better or improved. (4 letters)"}}
  5 | {"word": "dog", "hardcore": false, "clues": {"1": "A loyal companion often referred to as man's best friend. (3 letters)  ", "2": "This four-legged animal is known for barking and wagging its tail. (3 letters)  ", "3": "A common pet that enjoys playing fetch and going for walks. (3 letters)  ", "4": "Canine species known for its diverse breeds and temperaments. (3 letters)  ", "5": "A furry friend that loves to cuddle and provide emotional support. (3 letters)  ", "6": "This animal often guards homes and is known for its loyalty. (3 letters)  ", "7": "A playful creature that enjoys chasing after balls and sticks. (3 letters)  ", "8": "Often seen wearing a collar, this pet is a favorite among families. (3 letters)  ", "9": "A creature that can be trained to perform tricks and obey commands. (3 letters)  ", "10": "A member of the Canidae family, often found in homes as a pet. (3 letters)"}}
  6 | {"word": "note", "hardcore": false, "clues": {"1": "A written message or reminder often left for someone. (4 letters)  ", "2": "A musical sound or pitch, often used in compositions. (4 letters)  ", "3": "A brief record of points or ideas taken during a lecture. (4 letters)  ", "4": "A bank bill or paper currency, often used for transactions. (4 letters)  ", "5": "To observe or pay attention to something significant. (4 letters)  ", "6": "A comment or annotation added to a document or text. (4 letters)  ", "7": "A small piece of paper used for writing quick reminders. (4 letters)  ", "8": "A term used to describe a particular tone in music. (4 letters)  ", "9": "To indicate or mark something for future reference. (4 letters)  ", "10": "A synonym for a message or communication sent to someone. (4 letters)"}}
  7 | {"word": "green", "hardcore": false, "clues": {"1": "The color of fresh grass and leaves is often described as this. (5 letters)  ", "2": "This hue is commonly associated with envy or jealousy. (5 letters)  ", "3": "In traffic lights, this color means go. (5 letters)  ", "4": "It\u2019s the opposite of red on the color wheel. (5 letters)  ", "5": "Many vegetables, like spinach and broccoli, are considered to be this color. (5 letters)  ", "6": "A term for environmentally friendly practices or products. (5 letters)  ", "7": "The shade commonly associated with St. Patrick's Day celebrations. (5 letters)  ", "8": "This color is often used to represent sustainability and nature. (5 letters)  ", "9": "A common color for recycling bins and eco-friendly branding. (5 letters)  ", "10": "In finance, it can refer to positive cash flow or profit. (5 letters)"}}
  8 | {"word": "elastic", "hardcore": false, "clues": {"1": "Stretchy and able to return to its original shape after being pulled (7 letters).  ", "2": "A type of material often used in clothing for flexibility and comfort (7 letters).  ", "3": "This word describes something that can easily adapt to changes (7 letters).  ", "4": "Often associated with bands or substances that can stretch (7 letters).  ", "5": "A characteristic of rubber that allows it to bend without breaking (7 letters).  ", "6": "This term can refer to an economic concept involving demand and supply responsiveness (7 letters).  ", "7": "A common feature in sportswear that enhances movement (7 letters).  ", "8": "In physics, it describes the ability of a solid to deform and recover (7 letters).  ", "9": "This trait is essential for items like hair ties and bungee cords (7 letters).  ", "10": "An adjective used to describe a non-rigid structure that can be stretched (7 letters)."}}
  9 | {"word": "peace", "hardcore": false, "clues": {"1": "A state of tranquility often sought after in conflicts. (5 letters)  ", "2": "Harmony among individuals or nations is often referred to as this. (5 letters)  ", "3": "The absence of war or violence in a community is described as such. (5 letters)  ", "4": "A common goal for diplomats negotiating treaties and agreements. (5 letters)  ", "5": "An ideal state where everyone coexists without strife. (5 letters)  ", "6": "A term used to signify calmness and serenity in one\u2019s life. (5 letters)  ", "7": "This word is often associated with a white dove as a symbol. (5 letters)  ", "8": "A feeling of contentment and absence of disturbance. (5 letters)  ", "9": "The opposite of chaos, often desired in personal and global contexts. (5 letters)  ", "10": "A crucial element for a prosperous and stable society. (5 letters)"}}
 10 | {"word": "driving", "hardcore": false, "clues": {"1": "Navigating a vehicle on a road or street is known as this action. (7 letters)  ", "2": "This activity often requires a license and can be exhilarating. (7 letters)  ", "3": "Taking control of a car's steering wheel while on the move is referred to as this. (7 letters)  ", "4": "A common daily task for commuters, involving movement from one place to another. (7 letters)  ", "5": "The act of operating a motor vehicle, often associated with freedom and adventure. (7 letters)  ", "6": "Engaging in the act of steering a vehicle on a journey or trip. (7 letters)  ", "7": "This term describes the skill required to maneuver a car effectively. (7 letters)  ", "8": "In many cases, this activity occurs on highways and city streets alike. (7 letters)  ", "9": "You might need lessons for this essential skill before hitting the road. (7 letters)  ", "10": "An essential function for transportation that involves acceleration and braking. (7 letters)"}}
 11 | {"word": "brass", "hardcore": false, "clues": {"1": "A metal alloy often used in musical instruments. (5 letters)  ", "2": "The color of some military uniforms and decorations. (5 letters)  ", "3": "A term for high-ranking military officers. (5 letters)  ", "4": "A shiny yellow-gold metal commonly used in fittings. (5 letters)  ", "5": "An ensemble of wind instruments, especially in a band. (5 letters)  ", "6": "A slang term for boldness or audacity. (5 letters)  ", "7": "The name of a famous British military band. (5 letters)  ", "8": "An important component in the making of coins. (5 letters)  ", "9": "A material known for its corrosion resistance in plumbing. (5 letters)  ", "10": "A term referring to the upper management in an organization. (5 letters)"}}
 12 | {"word": "bee", "hardcore": false, "clues": {"1": "A buzzing insect known for its role in pollination. (3 letters)  ", "2": "This small creature produces honey in hives. (3 letters)  ", "3": "It\u2019s essential for many flowering plants to reproduce. (3 letters)  ", "4": "A social insect that lives in colonies with a queen. (3 letters)  ", "5": "These insects are vital for maintaining healthy ecosystems. (3 letters)  ", "6": "You might find these flying around your garden in summer. (3 letters)  ", "7": "They communicate through a unique dance to show the location of flowers. (3 letters)  ", "8": "This insect's sting can be painful but is often a sign of a healthy environment. (3 letters)  ", "9": "In the animal kingdom, it's famous for its black and yellow stripes. (3 letters)  ", "10": "A creature that symbolizes hard work and teamwork in folklore. (3 letters)"}}
 13 | {"word": "reward", "hardcore": false, "clues": {"1": "A prize given for an achievement. (7 letters)  ", "2": "Something you earn for a job well done. (7 letters)  ", "3": "An incentive for good behavior or performance. (7 letters)  ", "4": "Compensation for a service or effort made. (7 letters)  ", "5": "A token of appreciation for a kind act. (7 letters)  ", "6": "What you receive in return for your hard work. (7 letters)  ", "7": "A benefit that comes as a result of an action. (7 letters)  ", "8": "Often given in the form of money or gifts. (7 letters)  ", "9": "A positive outcome that follows a successful endeavor. (7 letters)  ", "10": "An acknowledgment of a person's contributions or success. (7 letters)"}}
 14 | {"word": "mind", "hardcore": false, "clues": {"1": "A place where thoughts and ideas reside. (4 letters)  ", "2": "To focus on something; to pay attention. (4 letters)  ", "3": "The part of a person that thinks and feels. (4 letters)  ", "4": "To be concerned about something or someone. (4 letters)  ", "5": "The intellectual faculty of reasoning and understanding. (4 letters)  ", "6": "A synonym for sanity or mental clarity. (4 letters)  ", "7": "What you use to ponder a difficult problem. (4 letters)  ", "8": "To have an opinion or belief about something. (4 letters)  ", "9": "The essence of consciousness and awareness. (4 letters)  ", "10": "To remember or recall something from the past. (4 letters)"}}
 15 | {"word": "debt", "hardcore": false, "clues": {"1": "Owing money to someone can create a heavy burden. (4 letters)  ", "2": "The opposite of credit when referring to finances. (4 letters)  ", "3": "This financial obligation can lead to stress if unpaid. (4 letters)  ", "4": "Many students graduate with a significant amount of this. (4 letters)  ", "5": "A formal agreement to repay borrowed money. (4 letters)  ", "6": "This term describes what you owe on a credit card. (4 letters)  ", "7": "In business, it can refer to money owed to suppliers. (4 letters)  ", "8": "An obligation that can affect your credit score. (4 letters)  ", "9": "It can be a result of loans taken for a home or car. (4 letters)  ", "10": "The condition of being under financial obligation. (4 letters)"}}
 16 | {"word": "religion", "hardcore": false, "clues": {"1": "A system of faith and worship often involving a deity. (8 letters)  ", "2": "The belief system that guides moral and ethical behavior. (8 letters)  ", "3": "A structured set of beliefs held by a group or community. (8 letters)  ", "4": "The spiritual practice that can include rituals and scriptures. (8 letters)  ", "5": "A category encompassing Christianity, Islam, Hinduism, and more. (8 letters)  ", "6": "A framework for understanding existence and the universe's purpose. (8 letters)  ", "7": "The cultural practices and institutions surrounding worship. (8 letters)  ", "8": "An organized community of individuals sharing similar beliefs. (8 letters)  ", "9": "The pursuit of understanding the divine or sacred. (8 letters)  ", "10": "A topic often debated in philosophical and theological discussions. (8 letters)"}}
 17 | {"word": "attraction", "hardcore": false, "clues": {"1": "A force that draws people or objects together. (9 letters)  ", "2": "A term often used to describe a romantic pull between individuals. (9 letters)  ", "3": "The magnetic pull between two bodies in physics. (9 letters)  ", "4": "An event or place that draws visitors for entertainment or interest. (9 letters)  ", "5": "The quality of being appealing or charming to others. (9 letters)  ", "6": "A popular theme park feature designed to entertain guests. (9 letters)  ", "7": "The principle behind why people are drawn to certain activities or places. (9 letters)  ", "8": "The gravitational force that keeps celestial bodies in orbit. (9 letters)  ", "9": "A strong interest or liking for someone or something. (9 letters)  ", "10": "A synonym for allure or appeal, often used in marketing. (9 letters)"}}
 18 | {"word": "doubt", "hardcore": false, "clues": {"1": "A feeling of uncertainty or lack of conviction. (5 letters)  ", "2": "To question the truth or validity of something. (5 letters)  ", "3": "An emotion often experienced when faced with a tough decision. (5 letters)  ", "4": "The state of being unsure about something. (5 letters)  ", "5": "What you might feel when presented with conflicting information. (5 letters)  ", "6": "A synonym for skepticism or suspicion. (5 letters)  ", "7": "The opposite of certainty in one's beliefs. (5 letters)  ", "8": "What can arise when trust is lost in a relationship. (5 letters)  ", "9": "To hesitate or waver in one's opinion. (5 letters)  ", "10": "A common reaction when faced with ambiguous outcomes. (5 letters)"}}
 19 | {"word": "shade", "hardcore": false, "clues": {"1": "A place to escape the sun's heat. (5 letters)  ", "2": "A slight variation in color. (5 letters)  ", "3": "To protect from direct light. (5 letters)  ", "4": "A term for a ghostly figure. (5 letters)  ", "5": "A nuanced difference in tone. (5 letters)  ", "6": "A synonym for shadow or gloom. (5 letters)  ", "7": "To cover or obscure something. (5 letters)  ", "8": "A decorative screen for light. (5 letters)  ", "9": "A term for a protective covering. (5 letters)  ", "10": "A hue created by mixing colors. (5 letters)"}}
 20 | {"word": "girl", "hardcore": false, "clues": {"1": "A young female child often playing in the park. (4 letters)  ", "2": "A term used to describe a daughter in a family. (4 letters)  ", "3": "This character in stories often goes on adventures. (4 letters)  ", "4": "A common term for a female student in school. (4 letters)  ", "5": "In a friendship, she might be your closest companion. (4 letters)  ", "6": "Often seen wearing dresses and playing with dolls. (4 letters)  ", "7": "A term for a young female teen or adolescent. (4 letters)  ", "8": "In pop culture, she might be a singer or actress. (4 letters)  ", "9": "This word can refer to a female who is a friend. (4 letters)  ", "10": "A playful term sometimes used for a young woman. (4 letters)"}}
 21 | {"word": "detail", "hardcore": false, "clues": {"1": "- A tiny part that contributes to the whole (6 letters).  ", "2": "- Information that elaborates on a subject (6 letters).  ", "3": "- An intricate or minor aspect of something (6 letters).  ", "4": "- To describe something thoroughly and carefully (6 letters).  ", "5": "- A specific piece of information or fact (6 letters).  ", "6": "- The fine points of a complex issue (6 letters).  ", "7": "- To include all relevant aspects in a description (6 letters).  ", "8": "- A characteristic that adds depth to a narrative (6 letters).  ", "9": "- The act of giving precise information (6 letters).  ", "10": "- An element that enhances the overall picture (6 letters)."}}
 22 | {"word": "level", "hardcore": false, "clues": {"1": "- A flat surface or stage, often used in building or gaming. (5 letters)  ", "2": "- Equal in height or position; not inclined. (5 letters)  ", "3": "- The playing field in a video game, often with challenges. (5 letters)  ", "4": "- A degree or rank in a hierarchy or scale. (5 letters)  ", "5": "- To make something flat or even, as in construction. (5 letters)  ", "6": "- A term for the intensity of a sound or volume. (5 letters)  ", "7": "- A measurement of skill or achievement in a game. (5 letters)  ", "8": "- A state of balance or stability in a situation. (5 letters)  ", "9": "- To bring into alignment or equal standing. (5 letters)  ", "10": "- A stage of difficulty in a puzzle or challenge. (5 letters)"}}
 23 | {"word": "loud", "hardcore": false, "clues": {"1": "A sound that can be heard from a distance. (4 letters)  ", "2": "Synonymous with 'boisterous' or 'noisy'. (4 letters)  ", "3": "The opposite of quiet or silent. (4 letters)  ", "4": "A volume level that can disturb the peace. (4 letters)  ", "5": "A term often used to describe a raucous party. (4 letters)  ", "6": "An adjective for a voice that carries far. (4 letters)  ", "7": "Often associated with rock concerts or fireworks. (4 letters)  ", "8": "A descriptor for a clamor or uproar. (4 letters)  ", "9": "A characteristic of a shout or scream. (4 letters)  ", "10": "Used to describe a speaker with an assertive presence. (4 letters)"}}
 24 | {"word": "apparatus", "hardcore": false, "clues": {"1": "A set of tools or equipment used for a specific purpose. (8 letters)  ", "2": "An arrangement of machinery designed for a particular function. (8 letters)  ", "3": "This term refers to devices or structures that help perform tasks. (8 letters)  ", "4": "Scientific instruments collectively used for experiments or research. (8 letters)  ", "5": "A complex system used to achieve a specific outcome or action. (8 letters)  ", "6": "The equipment needed for a particular activity or operation. (8 letters)  ", "7": "In a laboratory, this is essential for conducting various experiments. (8 letters)  ", "8": "The framework or setup that enables a process to take place. (8 letters)  ", "9": "Machinery that serves a specific purpose in various fields. (8 letters)  ", "10": "Often found in gyms, this term describes devices for physical training. (8 letters)"}}
 25 | {"word": "daughter", "hardcore": false, "clues": {"1": "A female offspring in a family. (7 letters)  ", "2": "The child of a mother and father. (7 letters)  ", "3": "She may call her parents \"Mom\" and \"Dad.\" (7 letters)  ", "4": "Often celebrated on a special day in June. (7 letters)  ", "5": "A term used to describe a girl in relation to her parents. (7 letters)  ", "6": "In some cultures, she is an important part of family lineage. (7 letters)  ", "7": "A role often depicted in coming-of-age stories. (7 letters)  ", "8": "She may inherit family traits and traditions. (7 letters)  ", "9": "In fairy tales, she might be a princess. (7 letters)  ", "10": "A beloved member of a family, often cherished and supported. (7 letters)"}}
 26 | {"word": "interest", "hardcore": false, "clues": {"1": "A feeling of wanting to know more about something. (8 letters)  ", "2": "The cost of borrowing money, often expressed as a percentage. (8 letters)  ", "3": "A hobby or activity that captures one's attention. (8 letters)  ", "4": "A financial return or profit from an investment. (8 letters)  ", "5": "The state of wanting to learn or engage in a subject. (8 letters)  ", "6": "A stake or share in something, like a business or property. (8 letters)  ", "7": "A person's or group's concern or involvement in a matter. (8 letters)  ", "8": "A topic that sparks engagement or curiosity in discussions. (8 letters)  ", "9": "A legal entitlement or claim to a property or asset. (8 letters)  ", "10": "The motivation behind someone's actions or decisions. (8 letters)"}}
 27 | {"word": "and", "hardcore": false, "clues": {"1": "A conjunction often used to connect ideas (3 letters).  ", "2": "This word ties two thoughts together seamlessly (3 letters).  ", "3": "It\u2019s the glue that binds phrases in a sentence (3 letters).  ", "4": "A common word found in lists and combinations (3 letters).  ", "5": "Utilized frequently in mathematical expressions, like addition (3 letters).  ", "6": "This word links two friends or two aspects of life (3 letters).  ", "7": "Often encountered in the phrase \"bread and butter\" (3 letters).  ", "8": "It's a small word with a big role in language (3 letters).  ", "9": "This conjunction can be found in many famous pairs (3 letters).  ", "10": "A simple connector that appears in almost every sentence (3 letters)."}}
 28 | {"word": "wise", "hardcore": false, "clues": {"1": "A person known for good judgment and insight. (4 letters)  ", "2": "Synonym for sagacious or prudent. (4 letters)  ", "3": "Having the ability to make sound decisions. (4 letters)  ", "4": "Often associated with age and experience. (4 letters)  ", "5": "Describes someone who provides valuable advice. (4 letters)  ", "6": "A quality admired in leaders and mentors. (4 letters)  ", "7": "The opposite of foolish or reckless. (4 letters)  ", "8": "A trait often sought after in counselors. (4 letters)  ", "9": "This adjective describes someone with deep understanding. (4 letters)  ", "10": "A characteristic of a sage or philosopher. (4 letters)"}}
 29 | {"word": "star", "hardcore": false, "clues": {"1": "A celestial body visible in the night sky (4 letters).  ", "2": "A famous person often in the spotlight (4 letters).  ", "3": "To excel or shine brightly in a particular field (4 letters).  ", "4": "A symbol often used to denote excellence or importance (4 letters).  ", "5": "An important figure in a movie or show (4 letters).  ", "6": "The central point of attention in a performance (4 letters).  ", "7": "A guide for navigation, especially at sea (4 letters).  ", "8": "A term for a prominent feature on a map (4 letters).  ", "9": "To mark a location or highlight something (4 letters).  ", "10": "A point of light in the universe, often twinkling (4 letters)."}}
 30 | {"word": "send", "hardcore": false, "clues": {"1": "To dispatch something to a destination. (4 letters)  ", "2": "To transmit a message electronically. (4 letters)  ", "3": "To cause to go or be taken to a place. (4 letters)  ", "4": "The act of delivering a letter or package. (4 letters)  ", "5": "To convey information from one person to another. (4 letters)  ", "6": "To issue a command or request to someone. (4 letters)  ", "7": "To forward an email or text to someone else. (4 letters)  ", "8": "To send out invitations for an event. (4 letters)  ", "9": "To release or launch a projectile. (4 letters)  ", "10": "To transfer data over a network. (4 letters)"}}
 31 | {"word": "conscious", "hardcore": false, "clues": {"1": "Aware of one's surroundings and thoughts. (9 letters)  ", "2": "Mindful and alert to the present moment. (9 letters)  ", "3": "Not in a state of sleep or unconsciousness. (9 letters)  ", "4": "Having knowledge of one's own existence. (9 letters)  ", "5": "Engaged in a state of awareness and thought. (9 letters)  ", "6": "Able to perceive and respond to stimuli. (9 letters)  ", "7": "Capable of reflection and self-awareness. (9 letters)  ", "8": "Fully aware of one's feelings and emotions. (9 letters)  ", "9": "Not oblivious; aware of what is happening. (9 letters)  ", "10": "In a state of active mental engagement. (9 letters)"}}
 32 | {"word": "sign", "hardcore": false, "clues": {"1": "A symbol that conveys meaning or information. (4 letters)  ", "2": "An indication or gesture often used to direct or warn. (4 letters)  ", "3": "A mark that represents something, often seen on roads. (4 letters)  ", "4": "To write your name as a form of agreement or acknowledgment. (4 letters)  ", "5": "A display that provides information, such as a neon light. (4 letters)  ", "6": "A signal that suggests a particular action or decision. (4 letters)  ", "7": "A celestial body that can guide travelers at night. (4 letters)  ", "8": "To indicate or demonstrate something clearly. (4 letters)  ", "9": "An emblem that can represent a brand or organization. (4 letters)  ", "10": "A clue or hint that reveals what is to come next. (4 letters)"}}
 33 | {"word": "wave", "hardcore": false, "clues": {"1": "A gesture made by moving your hand back and forth. (4 letters)  ", "2": "A motion often associated with the ocean's surface. (4 letters)  ", "3": "To signal someone from a distance using your hand. (4 letters)  ", "4": "A sudden, powerful movement of water, often in storms. (4 letters)  ", "5": "A popular form of greeting in many cultures. (4 letters)  ", "6": "A series of undulating movements in a crowd or audience. (4 letters)  ", "7": "To cause to move in a smooth, flowing manner. (4 letters)  ", "8": "An electromagnetic disturbance that travels through space. (4 letters)  ", "9": "A pattern of motion seen in flags or banners in the wind. (4 letters)  ", "10": "A term used in physics to describe oscillations in energy. (4 letters)"}}
 34 | {"word": "solid", "hardcore": false, "clues": {"1": "A state of matter that is neither liquid nor gas. (5 letters)  ", "2": "Firm and stable in shape; not liquid or fluid. (5 letters)  ", "3": "Dependable and trustworthy; a reliable friend. (5 letters)  ", "4": "A term used to describe a strong and robust structure. (5 letters)  ", "5": "An unyielding substance, like a rock or metal. (5 letters)  ", "6": "Having a sound basis; substantial and valid. (5 letters)  ", "7": "In mathematics, a figure with three dimensions. (5 letters)  ", "8": "The opposite of hollow; completely filled. (5 letters)  ", "9": "A strong foundation necessary for building. (5 letters)  ", "10": "A descriptor for something that is not hollow or empty. (5 letters)"}}
 35 | {"word": "roof", "hardcore": false, "clues": {"1": "A structure that covers a building from above. (4 letters)  ", "2": "The top layer of a house that keeps out the elements. (4 letters)  ", "3": "What you might find on a house to shield it from rain. (4 letters)  ", "4": "The covering of a building, often sloped or flat. (4 letters)  ", "5": "A protective covering that can be made of shingles or tiles. (4 letters)  ", "6": "The uppermost part of a structure, crucial for insulation. (4 letters)  ", "7": "A place where you might find a chimney or skylight. (4 letters)  ", "8": "What keeps you dry when you\u2019re standing outside in a storm. (4 letters)  ", "9": "A component of a house that can be made of metal or thatch. (4 letters)  ", "10": "The part of a building that provides shelter from the sun. (4 letters)"}}
 36 | {"word": "sharp", "hardcore": false, "clues": {"1": "A knife's edge is often described as this. (5 letters)  ", "2": "Her wit is quick and often catches others off guard. (5 letters)  ", "3": "The taste of citrus can be quite intense and biting. (5 letters)  ", "4": "He made a clever remark that showed his intelligence. (5 letters)  ", "5": "The sudden pain in my back was a very intense sensation. (5 letters)  ", "6": "A well-defined image can be referred to as this. (5 letters)  ", "7": "She wore a tailored jacket that gave her a stylish appearance. (5 letters)  ", "8": "The critic gave a biting review of the latest film. (5 letters)  ", "9": "The student received a high score for his keen observations. (5 letters)  ", "10": "Her memory of the event was vivid and clear. (5 letters)"}}
 37 | {"word": "waiting", "hardcore": false, "clues": {"1": "- Pausing for something to happen or arrive. (7 letters)  ", "2": "- Remaining in one place until an event occurs. (7 letters)  ", "3": "- The act of staying put in anticipation. (7 letters)  ", "4": "- Biding one's time for a particular moment. (7 letters)  ", "5": "- An interval of time spent in expectation. (7 letters)  ", "6": "- The experience of lingering with hope. (7 letters)  ", "7": "- Holding off action until something changes. (7 letters)  ", "8": "- Staying idle while expecting a response. (7 letters)  ", "9": "- The state of being expectant or in suspense. (7 letters)  ", "10": "- Remaining inactive while looking for a sign. (7 letters)"}}
 38 | {"word": "development", "hardcore": false, "clues": {"1": "A process of growth or advancement in a particular area (10 letters).  ", "2": "The act of creating or improving something over time (10 letters).  ", "3": "A significant change or evolution in a project or idea (10 letters).  ", "4": "The unfolding of events leading to progress or innovation (10 letters).  ", "5": "The systematic effort to enhance skills or capabilities (10 letters).  ", "6": "A stage in the life cycle of a business or product (10 letters).  ", "7": "The act of making something more complex or sophisticated (10 letters).  ", "8": "An area of study focused on social or economic progress (10 letters).  ", "9": "The transition from a concept to a tangible outcome (10 letters).  ", "10": "A term often associated with urban planning and growth (10 letters)."}}
 39 | {"word": "tight", "hardcore": false, "clues": {"1": "- The fabric has little give, making it quite snug. (5 letters)  ", "2": "- This term describes a close bond between friends or family. (5 letters)  ", "3": "- When money is scarce, one might say they are running short. (5 letters)  ", "4": "- A term used to describe a secure grip or hold on something. (5 letters)  ", "5": "- In finance, it can refer to a budget that leaves little room for extras. (5 letters)  ", "6": "- The opposite of loose, often used to describe clothing or fastenings. (5 letters)  ", "7": "- A situation where there is little time available for tasks or decisions. (5 letters)  ", "8": "- When a knot is securely bound, it is often described as this. (5 letters)  ", "9": "- A descriptor for a well-fitted pair of shoes that may cause discomfort. (5 letters)  ", "10": "- In a race, when competitors are closely matched, it can be said it's very... (5 letters)"}}
 40 | {"word": "coal", "hardcore": false, "clues": {"1": "A black rock used as fuel for heating and power generation. (4 letters)  ", "2": "A fossil fuel that is often mined from the earth. (4 letters)  ", "3": "This substance is commonly associated with smoky chimneys. (4 letters)  ", "4": "A major energy source in the Industrial Revolution. (4 letters)  ", "5": "What you might find in a miner's lunch pail. (4 letters)  ", "6": "This material is often burned to produce electricity. (4 letters)  ", "7": "A common ingredient in barbecues for grilling. (4 letters)  ", "8": "A dense carbon-rich material formed from ancient plant matter. (4 letters)  ", "9": "It's often referred to as \"black gold.\" (4 letters)  ", "10": "A type of fuel that can create soot when burned. (4 letters)"}}
 41 | {"word": "regret", "hardcore": false, "clues": {"1": "A feeling of sorrow for something done or not done. (6 letters)  ", "2": "To wish one had acted differently in the past. (6 letters)  ", "3": "An emotion often linked to missed opportunities. (6 letters)  ", "4": "What you might feel after saying something hurtful. (6 letters)  ", "5": "To experience remorse over a poor decision. (6 letters)  ", "6": "A common sentiment when reflecting on life choices. (6 letters)  ", "7": "What lingers after a hasty or rash action. (6 letters)  ", "8": "An emotion that can lead to a desire for forgiveness. (6 letters)  ", "9": "The opposite of satisfaction when thinking about past actions. (6 letters)  ", "10": "A feeling that can weigh heavily on one's conscience. (6 letters)"}}
 42 | {"word": "top", "hardcore": false, "clues": {"1": "The highest point of a mountain. (3 letters)  ", "2": "The uppermost part of a structure. (3 letters)  ", "3": "A favorite or best performer in a category. (3 letters)  ", "4": "To achieve the highest score or ranking. (3 letters)  ", "5": "The lid or cover of a container. (3 letters)  ", "6": "The peak of popularity or success. (3 letters)  ", "7": "A position of leadership or authority. (3 letters)  ", "8": "The surface or exterior of something. (3 letters)  ", "9": "The upper side of a piece of furniture. (3 letters)  ", "10": "To place something above or over another object. (3 letters)"}}
 43 | {"word": "horse", "hardcore": false, "clues": {"1": "A strong animal often used in racing. (5 letters)  ", "2": "A common farm animal known for its mane. (5 letters)  ", "3": "This creature is often seen galloping in fields. (5 letters)  ", "4": "A term for a chess piece that moves in an L-shape. (5 letters)  ", "5": "A symbol of freedom often depicted in art. (5 letters)  ", "6": "A trusty companion for cowboys on the range. (5 letters)  ", "7": "This animal can be found in various breeds like Arabian and Thoroughbred. (5 letters)  ", "8": "A popular mount for equestrian sports and leisure riding. (5 letters)  ", "9": "This animal is known for its \"neigh\" sound. (5 letters)  ", "10": "A mythical creature resembling a horse with a single horn. (5 letters)"}}
 44 | {"word": "sudden", "hardcore": false, "clues": {"1": "An unexpected change in plans can be described as this. (6 letters)  ", "2": "Her sudden outburst caught everyone off guard. (6 letters)  ", "3": "He felt a sudden rush of adrenaline during the race. (6 letters)  ", "4": "The storm arrived with sudden ferocity, startling everyone. (6 letters)  ", "5": "A sudden decision often leads to spontaneous adventures. (6 letters)  ", "6": "The lights went out in a sudden blackout, plunging the room into darkness. (6 letters)  ", "7": "She experienced a sudden realization that changed her perspective. (6 letters)  ", "8": "His sudden departure left us all feeling confused and worried. (6 letters)  ", "9": "The sudden increase in temperature signaled a change in the weather. (6 letters)  ", "10": "They were met with sudden silence after the loud argument. (6 letters)"}}
 45 | {"word": "rule", "hardcore": false, "clues": {"1": "A guideline to follow in a game or competition. (4 letters)  ", "2": "An authoritative statement or principle governing conduct. (4 letters)  ", "3": "The act of controlling or managing a situation or group. (4 letters)  ", "4": "A regulation that dictates how something should be done. (4 letters)  ", "5": "To exercise power or authority over others. (4 letters)  ", "6": "A prescribed direction for conduct in a specific context. (4 letters)  ", "7": "A principle established to bring order and consistency. (4 letters)  ", "8": "What a monarch does over their realm. (4 letters)  ", "9": "A standard that determines what is acceptable or not. (4 letters)  ", "10": "To dominate or have influence in a particular area. (4 letters)"}}
 46 | {"word": "delicate", "hardcore": false, "clues": {"1": "A fragile flower that wilts at the slightest touch. (8 letters)  ", "2": "Her voice was soft and gentle, almost too fragile to hear. (8 letters)  ", "3": "The fabric was so fine that it required careful handling. (8 letters)  ", "4": "He had a sensitive approach to discussing her feelings. (8 letters)  ", "5": "The artist painted with a light touch, creating ethereal beauty. (8 letters)  ", "6": "She handled the antique vase with extreme care. (8 letters)  ", "7": "His health was precarious, needing constant attention. (8 letters)  ", "8": "The fine china was beautiful but needed special treatment. (8 letters)  ", "9": "Their relationship was tender and needed nurturing. (8 letters)  ", "10": "The recipe called for a light touch when mixing the ingredients. (8 letters)"}}
 47 | {"word": "stomach", "hardcore": false, "clues": {"1": "A muscular organ that aids in digestion. (7 letters)  ", "2": "The place where your food goes after eating. (7 letters)  ", "3": "Often referred to as the belly or abdomen. (7 letters)  ", "4": "This organ produces acid to help break down food. (7 letters)  ", "5": "You might feel butterflies in this part of your body. (7 letters)  ", "6": "A common term for the area where hunger is felt. (7 letters)  ", "7": "It plays a key role in the digestive system. (7 letters)  ", "8": "You might say you've \"had enough\" when it's full. (7 letters)  ", "9": "An area often associated with feelings of nausea. (7 letters)  ", "10": "In anatomy, it's the section between the esophagus and intestines. (7 letters)"}}
 48 | {"word": "see", "hardcore": false, "clues": {"1": "To perceive with the eyes. (3 letters)  ", "2": "To understand or comprehend something. (3 letters)  ", "3": "A common phrase for witnessing an event. (3 letters)  ", "4": "To visit someone or something. (3 letters)  ", "5": "What you do when you watch a movie. (3 letters)  ", "6": "To notice or detect something. (3 letters)  ", "7": "A synonym for \"view.\" (3 letters)  ", "8": "To experience or encounter. (3 letters)  ", "9": "To consider or regard. (3 letters)  ", "10": "To look at closely or examine. (3 letters)"}}
 49 | {"word": "road", "hardcore": false, "clues": {"1": "A path for vehicles to travel on. (4 letters)  ", "2": "A way to connect two places by driving. (4 letters)  ", "3": "This term often describes a route or highway. (4 letters)  ", "4": "A surface where cars and bikes can move. (4 letters)  ", "5": "What you might take to reach your destination. (4 letters)  ", "6": "A thoroughfare that can lead to adventure. (4 letters)  ", "7": "An essential part of a journey or trip. (4 letters)  ", "8": "A term commonly used in navigation and maps. (4 letters)  ", "9": "The place where traffic flows and signs are posted. (4 letters)  ", "10": "A stretch of pavement that can be traveled upon. (4 letters)"}}
 50 | {"word": "shoe", "hardcore": false, "clues": {"1": "Footwear typically worn for comfort or style (4 letters).  ", "2": "A common item for protecting your feet (4 letters).  ", "3": "This accessory often comes in pairs (4 letters).  ", "4": "What you might tie or fasten with laces (4 letters).  ", "5": "Essential gear for a jogger or walker (4 letters).  ", "6": "A type of covering found in many closets (4 letters).  ", "7": "This item can be made of leather, canvas, or rubber (4 letters).  ", "8": "Something you might kick off after a long day (4 letters).  ", "9": "Often worn while dancing or playing sports (4 letters).  ", "10": "A necessary piece of attire when going outdoors (4 letters)."}}
 51 | {"word": "Lahontan", "hardcore": true, "clues": {"1": "A historical figure known for his explorations in North America. (8 letters)  ", "2": "A large lake located in Nevada, named after a French explorer. (8 letters)  ", "3": "This term refers to a major river in eastern Nevada's Great Basin. (8 letters)  ", "4": "The name of a French explorer who documented Native American cultures. (8 letters)  ", "5": "A type of trout, often found in cold-water streams, associated with Lake Lahontan. (8 letters)  ", "6": "The last name of a prominent 17th-century cartographer and explorer. (8 letters)  ", "7": "Referring to a prehistoric lake that once covered parts of Nevada. (8 letters)  ", "8": "This term is linked to a region known for its distinctive geology and ecology. (8 letters)  ", "9": "A lake that was historically significant for both indigenous populations and settlers. (8 letters)  ", "10": "The surname of a botanist who studied flora around the Lahontan region. (8 letters)"}}
 52 | {"word": "outfling", "hardcore": true, "clues": {"1": "- To throw something away with force or abandon (8 letters).  ", "2": "- To cast aside or propel something outward (8 letters).  ", "3": "- To send an object flying through the air (8 letters).  ", "4": "- To fling something out with great energy (8 letters).  ", "5": "- To expel or discharge something forcefully (8 letters).  ", "6": "- To launch or hurl an item away from oneself (8 letters).  ", "7": "- To toss out with enthusiasm or vigor (8 letters).  ", "8": "- To propel away from the body in a swift motion (8 letters).  ", "9": "- To discard or let go of something in a dramatic fashion (8 letters).  ", "10": "- To release or throw something out into the open (8 letters)."}}
 53 | {"word": "skivvies", "hardcore": true, "clues": {"1": "Underneath your clothes, you might find these. (7 letters)  ", "2": "A casual term for a type of underwear. (7 letters)  ", "3": "These garments are often worn for comfort at home. (7 letters)  ", "4": "They are typically made from soft cotton or similar fabrics. (7 letters)  ", "5": "A slang term for briefs or boxers. (7 letters)  ", "6": "Often, these are the first thing you put on in the morning. (7 letters)  ", "7": "In some regions, this word refers to light, informal clothing. (7 letters)  ", "8": "You might not want to share your skivvies with anyone. (7 letters)  ", "9": "In a laundry basket, you\u2019d find these mixed with socks. (7 letters)  ", "10": "They come in various styles, from bikini to boxer. (7 letters)"}}
 54 | {"word": "candle", "hardcore": true, "clues": {"1": "A source of light made from wax and a wick. (6 letters)  ", "2": "Often used to create a romantic atmosphere. (6 letters)  ", "3": "This object is lit to mark a celebration or ritual. (6 letters)  ", "4": "It melts slowly, leaving behind a puddle of wax. (6 letters)  ", "5": "Commonly found on birthday cakes, often with a wish. (6 letters)  ", "6": "This item can be scented to enhance relaxation. (6 letters)  ", "7": "Used in power outages when the lights go out. (6 letters)  ", "8": "A popular gift for holidays, often in decorative forms. (6 letters)  ", "9": "It can symbolize hope when lit in dark times. (6 letters)  ", "10": "Often used in meditation or during calming practices. (6 letters)"}}
 55 | {"word": "castable", "hardcore": true, "clues": {"1": "A term describing materials that can be shaped by pouring into a mold. (8 letters)  ", "2": "Refers to a quality of certain metals that allows them to be formed when melted. (8 letters)  ", "3": "Describes a type of plastic that can be molded into various shapes. (8 letters)  ", "4": "In filmmaking, it pertains to the ability to select actors for roles in a production. (8 letters)  ", "5": "Used in art to indicate substances suitable for making sculptures or figures. (8 letters)  ", "6": "Characterizes a substance that can be easily formed into a specific design. (8 letters)  ", "7": "Refers to the capability of a liquid material to be formed into a solid shape. (8 letters)  ", "8": "In the context of fishing, it can mean something that can be thrown out to catch fish. (8 letters)  ", "9": "Describes a characteristic of certain ceramics when they can be shaped before firing. (8 letters)  ", "10": "Relates to the flexibility of certain materials in being molded or shaped. (8 letters)"}}
 56 | {"word": "posnet", "hardcore": true, "clues": {"1": "A small cooking pot traditionally used over an open flame. (6 letters)  ", "2": "A vessel often associated with medieval or rustic cooking methods. (6 letters)  ", "3": "This type of pot is great for making stews or soups while camping. (6 letters)  ", "4": "A metal container used to hold food while cooking in a fire. (6 letters)  ", "5": "Commonly found in historical kitchens, this pot is often suspended. (6 letters)  ", "6": "A simple cooking implement favored by outdoor enthusiasts. (6 letters)  ", "7": "This item is essential for cooking over a campfire. (6 letters)  ", "8": "A traditional cooking tool that holds food above a heat source. (6 letters)  ", "9": "Often made of cast iron, it serves as a reliable cooking pot. (6 letters)  ", "10": "This pot is known for its ability to withstand high temperatures. (6 letters)"}}
 57 | {"word": "chipmunk", "hardcore": true, "clues": {"1": "A small rodent known for its cheek pouches. (8 letters)  ", "2": "This furry creature is often seen gathering acorns. (8 letters)  ", "3": "A common sight in North American forests and parks. (8 letters)  ", "4": "It shares its habitat with squirrels but is smaller. (8 letters)  ", "5": "Known for its quick movements and distinctive stripes. (8 letters)  ", "6": "A popular character in animated films and shows. (8 letters)  ", "7": "These little animals are often associated with autumn. (8 letters)  ", "8": "They are known to make a variety of chirping sounds. (8 letters)  ", "9": "A playful critter often spotted near picnic areas. (8 letters)  ", "10": "This animal stores food in its burrow for winter. (8 letters)"}}
 58 | {"word": "palinurid", "hardcore": true, "clues": {"1": "A type of marine crustacean known for its spiny appearance. (8 letters)  ", "2": "This creature is often referred to as a spiny lobster. (8 letters)  ", "3": "Found in oceans, these animals are prized for their culinary value. (8 letters)  ", "4": "The scientific classification of these lobsters falls under the family Palinuridae. (8 letters)  ", "5": "These crustaceans are typically found hiding among rocks and reefs. (8 letters)  ", "6": "Known for their long antennae, these creatures are adept at evasion. (8 letters)  ", "7": "They play an important role in marine ecosystems as both predators and prey. (8 letters)  ", "8": "In some cultures, they are considered a delicacy and are often served grilled. (8 letters)  ", "9": "Their hard exoskeletons provide protection from predators in their habitat. (8 letters)  ", "10": "Divers often seek these lobsters for sport as well as for food. (8 letters)"}}
 59 | {"word": "acetoxyphthalide", "hardcore": true, "clues": {"1": "A chemical compound derived from phthalic acid. (14 letters)  ", "2": "This substance is often used in organic synthesis. (14 letters)  ", "3": "A derivative that plays a role in various chemical reactions. (14 letters)  ", "4": "An aromatic compound containing both acetoxy and phthalide groups. (14 letters)  ", "5": "This term describes a specific type of phthalide ester. (14 letters)  ", "6": "A compound that may be encountered in laboratory settings. (14 letters)  ", "7": "Used in the production of certain pharmaceuticals and dyes. (14 letters)  ", "8": "This molecule features a unique combination of functional groups. (14 letters)  ", "9": "It can be part of a larger framework in organic chemistry. (14 letters)  ", "10": "A lesser-known compound that may appear in advanced studies. (14 letters)"}}
 60 | {"word": "deambulatory", "hardcore": true, "clues": {"1": "A term describing something related to walking or moving about. (12 letters)  ", "2": "Referring to a mode of movement that involves ambulation. (12 letters)  ", "3": "Describing a form of activity characterized by walking. (12 letters)  ", "4": "An adjective that pertains to the act of strolling or wandering. (12 letters)  ", "5": "Used in medical contexts to describe patients who can walk. (12 letters)  ", "6": "Relating to the act of moving from place to place on foot. (12 letters)  ", "7": "An uncommon word for describing walking behavior or habits. (12 letters)  ", "8": "Characterizing exercises or activities that involve walking. (12 letters)  ", "9": "Describing a state or condition conducive to ambulation. (12 letters)  ", "10": "An academic term often used in discussions of locomotion. (12 letters)"}}
 61 | {"word": "decate", "hardcore": true, "clues": {"1": "A period of ten years in history or a person's life can be referred to as a ______. (6 letters)  ", "2": "This term describes a span often used to categorize trends in music or fashion over ten years. (6 letters)  ", "3": "In academic terms, a ______ can signify a group of ten years used for statistical analysis. (6 letters)  ", "4": "You might celebrate a milestone during a ______, such as an anniversary of a significant event. (6 letters)  ", "5": "In the context of a school curriculum, a ______ might refer to a ten-year educational plan. (6 letters)  ", "6": "Many historians divide events into ______s to analyze changes over time. (6 letters)  ", "7": "A decade is also a common timeframe for planning major life goals or projects. (6 letters)  ", "8": "In the realm of cinema, the term ______ can describe trends in film styles over ten years. (6 letters)  ", "9": "Pop culture often reflects the themes and styles of a specific ______, influencing generations. (6 letters)  ", "10": "When looking back at history, one might examine the achievements of a specific ______. (6 letters)"}}
 62 | {"word": "prisonous", "hardcore": true, "clues": {"1": "A term describing a toxic substance that can harm living beings. (8 letters)  ", "2": "Referring to a plant that can cause serious illness if ingested. (8 letters)  ", "3": "Describing something that is harmful or deadly, often used in a figurative sense. (8 letters)  ", "4": "An adjective for a creature that can inflict pain or suffering through its venom. (8 letters)  ", "5": "Characterizing an environment that is detrimental to health or well-being. (8 letters)  ", "6": "Used to describe a feeling or atmosphere that is suffocating or oppressive. (8 letters)  ", "7": "Indicating a relationship or influence that is harmful or destructive. (8 letters)  ", "8": "A word that denotes something that produces a sense of danger or risk. (8 letters)  ", "9": "Referring to substances that are dangerous to touch or ingest. (8 letters)  ", "10": "An adjective often associated with a toxic or harmful substance in nature. (8 letters)"}}
 63 | {"word": "corsite", "hardcore": true, "clues": {"1": "A type of gemstone often used in jewelry. (7 letters)  ", "2": "A popular material for crafting intricate designs. (7 letters)  ", "3": "This mineral is valued for its unique color and clarity. (7 letters)  ", "4": "Often found in metamorphic rocks, it has a vibrant hue. (7 letters)  ", "5": "Jewelry enthusiasts seek this stone for its beauty. (7 letters)  ", "6": "Known for its durability, it\u2019s a favorite among artisans. (7 letters)  ", "7": "This gem is often associated with healing properties. (7 letters)  ", "8": "You might find this stone in a stunning necklace. (7 letters)  ", "9": "A coveted gem, often set in rings and pendants. (7 letters)  ", "10": "This mineral is sometimes confused with other gemstones. (7 letters)"}}
 64 | {"word": "horsepower", "hardcore": true, "clues": {"1": "A unit of power often used to measure engine strength. (hp)  ", "2": "The measurement that indicates how powerful a car's engine is. (10 letters)  ", "3": "This term originated from a comparison with the power of draft animals. (10 letters)  ", "4": "Used to describe the output of motors and engines in various vehicles. (10 letters)  ", "5": "A key specification to consider when buying a performance car. (10 letters)  ", "6": "This term can be abbreviated as \"hp\" in automotive discussions. (10 letters)  ", "7": "The power needed to lift 550 pounds one foot in one second. (10 letters)  ", "8": "Often associated with racehorses, but used more commonly in mechanics. (10 letters)  ", "9": "An important factor in determining a vehicle's acceleration and speed. (10 letters)  ", "10": "A metric often compared between electric and gasoline engines. (10 letters)"}}
 65 | {"word": "dukhn", "hardcore": true, "clues": {"1": "- A term often associated with pain or suffering in a spiritual context. (6 letters)  ", "2": "- In some cultures, it refers to the emotional distress linked to loss. (6 letters)  ", "3": "- This word might describe a deep sense of sorrow or grief. (6 letters)  ", "4": "- A concept in certain philosophies representing the nature of human existence. (6 letters)  ", "5": "- In Buddhist teachings, it's linked to the cycle of suffering and desire. (6 letters)  ", "6": "- Reflects a state of unhappiness or discontent in life. (6 letters)  ", "7": "- Often discussed in relation to the impermanence of happiness. (6 letters)  ", "8": "- This term encapsulates the human experience of pain and dissatisfaction. (6 letters)  ", "9": "- A foundational idea in many Eastern religions focusing on suffering. (6 letters)  ", "10": "- Used to describe the existential struggles faced by individuals. (6 letters)"}}
 66 | {"word": "pentagynian", "hardcore": true, "clues": {"1": "A botanical term describing plants with five pistils. (11 letters)  ", "2": "Referring to a flower structure featuring five female reproductive parts. (11 letters)  ", "3": "Descriptive of a plant species characterized by pentamerous gynoecium. (11 letters)  ", "4": "A term used in botany for species with multiple pistils arranged in fives. (11 letters)  ", "5": "This adjective relates to flowering plants with five distinct carpels. (11 letters)  ", "6": "Denoting a category of flowering plants based on their gynoecium structure. (11 letters)  ", "7": "A word describing the reproductive feature of certain flowering plants. (11 letters)  ", "8": "Relating to a specific floral arrangement with five pistils in a flower. (11 letters)  ", "9": "Used in taxonomy to classify plants with five styles in the ovary. (11 letters)  ", "10": "This term is often used in discussions about floral morphology and structure. (11 letters)"}}
 67 | {"word": "protariff", "hardcore": true, "clues": {"1": "Supportive of protective taxes on imports, this adjective reflects a certain economic policy. (9 letters)  ", "2": "Often associated with policies favoring domestic industries, this term is linked to tariffs. (9 letters)  ", "3": "Describing a stance that advocates for trade barriers, this word is key in economic debates. (9 letters)  ", "4": "In the context of trade, this term denotes a preference for imposing tariffs to shield local businesses. (9 letters)  ", "5": "This economic descriptor is often used in discussions about import taxes and domestic protectionism. (9 letters)  ", "6": "Typically used in political discourse, it represents a viewpoint favoring tariff increases. (9 letters)  ", "7": "A policy that prioritizes local over foreign goods can be described with this nine-letter term. (9 letters)  ", "8": "Related to economic protectionism, this word embodies a supportive attitude towards tariffs. (9 letters)  ", "9": "This term characterizes a viewpoint that argues for levying taxes on imported goods. (9 letters)  ", "10": "In the realm of trade, this word signifies a tendency to endorse tariffs for local advantage. (9 letters)"}}
 68 | {"word": "nonracial", "hardcore": true, "clues": {"1": "- Not pertaining to or based on race (8 letters).  ", "2": "- Describing something that is free from racial considerations (8 letters).  ", "3": "- Inclusive of all backgrounds without bias (8 letters).  ", "4": "- A term used to indicate neutrality in racial matters (8 letters).  ", "5": "- Referring to interactions that do not involve racial identity (8 letters).  ", "6": "- Characterizing policies that do not favor any race (8 letters).  ", "7": "- Describing a viewpoint that transcends racial divisions (8 letters).  ", "8": "- A concept promoting equality irrespective of race (8 letters).  ", "9": "- Pertaining to behavior that is unbiased by race (8 letters).  ", "10": "- Denoting a perspective that embraces diversity without racial focus (8 letters)."}}
 69 | {"word": "impetrate", "hardcore": true, "clues": {"1": "To obtain something through request or solicitation. (9 letters)  ", "2": "To ask for a favor or a right formally. (9 letters)  ", "3": "To seek or secure something, often through persuasion. (9 letters)  ", "4": "To request an official grant or permission. (9 letters)  ", "5": "To achieve a desired goal by making a request. (9 letters)  ", "6": "To earnestly ask for something, typically in a legal context. (9 letters)  ", "7": "To make a plea in hopes of receiving a benefit. (9 letters)  ", "8": "To petition for a particular outcome or result. (9 letters)  ", "9": "To solicit a favor or privilege from a higher authority. (9 letters)  ", "10": "To gain access to something valuable through application. (9 letters)"}}
 70 | {"word": "Rebecca", "hardcore": true, "clues": {"1": "A classic novel by Daphne du Maurier. (7 letters)  ", "2": "The name of a famous character in a Hitchcock film. (7 letters)  ", "3": "A popular female name that means \"to tie\" in Hebrew. (7 letters)  ", "4": "The title character who haunts Manderley in literature. (7 letters)  ", "5": "A story that begins with \"Last night I dreamt I went to Manderley again.\" (7 letters)  ", "6": "A winner of the 1938 Booker Prize for its author. (7 letters)  ", "7": "This name is often associated with gothic romance. (7 letters)  ", "8": "The first name of the protagonist in a famous novel. (7 letters)  ", "9": "A name that evokes themes of jealousy and obsession. (7 letters)  ", "10": "A literary work that explores identity and memory. (7 letters)"}}
 71 | {"word": "zolotnik", "hardcore": true, "clues": {"1": "A historical Russian unit of weight for precious metals. (8 letters)  ", "2": "An old measure often used in the context of gold and silver. (8 letters)  ", "3": "This term refers to a weight equivalent to 4.26 grams in Russian tradition. (8 letters)  ", "4": "A word that signifies a small measure, commonly linked to jewelry. (8 letters)  ", "5": "In Russia, this weight was crucial for trading and crafting fine items. (8 letters)  ", "6": "A term that might appear in discussions about traditional Russian currency. (8 letters)  ", "7": "You might encounter this word in a lesson about imperial Russian weights. (8 letters)  ", "8": "It's a measurement that reflects the value of precious materials in history. (8 letters)  ", "9": "A unit historically used by jewelers to describe the weight of gems. (8 letters)  ", "10": "This word has its roots in the Russian language, pertaining to metallurgy. (8 letters)"}}
 72 | {"word": "Thracian", "hardcore": true, "clues": {"1": "A historical group known for their fierce warriors from the Balkans. (8 letters)  ", "2": "This ancient civilization thrived in what is now Bulgaria and parts of Greece. (8 letters)  ", "3": "Famous for their unique music and dance, the people of this region are called? (8 letters)  ", "4": "A term referring to the ancient inhabitants of Thrace, often depicted in mythology. (8 letters)  ", "5": "A language once spoken in southeastern Europe, now mostly extinct. (8 letters)  ", "6": "These ancient people were often at odds with the Romans and Greeks. (8 letters)  ", "7": "Known for their colorful pottery and vibrant culture in ancient times. (8 letters)  ", "8": "This adjective describes anything related to the ancient region of Thrace. (8 letters)  ", "9": "A group of tribes that included the Bessi and the Dii in ancient history. (8 letters)  ", "10": "A term used in archaeology to describe artifacts from the Thracian civilization. (8 letters)"}}
 73 | {"word": "Guianese", "hardcore": true, "clues": {"1": "A resident or native of a South American country known for its rainforests and rivers. (7 letters)  ", "2": "Relating to the culture or people of French Guiana. (7 letters)  ", "3": "The language spoken by some people in the region of Guiana. (7 letters)  ", "4": "Describing the nationality of those from the coastal region of South America. (7 letters)  ", "5": "Referring to the diverse ethnic groups found in the Guiana region. (7 letters)  ", "6": "A term for individuals hailing from the territory bordered by the Amazon River. (7 letters)  ", "7": "Associated with the unique flora and fauna found in Guiana. (7 letters)  ", "8": "Relating to the historical colonial influences in French Guiana. (7 letters)  ", "9": "Describing the heritage of the people from the Guiana Shield area. (7 letters)  ", "10": "Connected to the vibrant traditions of the indigenous tribes in Guiana. (7 letters)"}}
 74 | {"word": "Icelandian", "hardcore": true, "clues": {"1": "A native or inhabitant of a Nordic island nation in the North Atlantic (9 letters).  ", "2": "Relating to the culture and language of a country known for its volcanoes and geysers (9 letters).  ", "3": "This term describes someone from a nation famous for its dramatic landscapes and glaciers (9 letters).  ", "4": "A citizen of a land where the midnight sun shines in summer (9 letters).  ", "5": "The adjective form of the country known for its strong literary heritage and sagas (9 letters).  ", "6": "This word characterizes a people who enjoy geothermal hot springs (9 letters).  ", "7": "Describes the unique cuisine that includes dishes like fermented shark (9 letters).  ", "8": "An individual from a country whose capital is Reykjavik (9 letters).  ", "9": "Pertaining to a nation that celebrates a national day on June 17th (9 letters).  ", "10": "This term encompasses the language spoken by approximately 300,000 people (9 letters)."}}
 75 | {"word": "vexatious", "hardcore": true, "clues": {"1": "A term describing something that causes annoyance or irritation. (8 letters)  ", "2": "Referring to actions or behaviors that provoke frustration. (8 letters)  ", "3": "An adjective often used to describe bothersome legal disputes. (8 letters)  ", "4": "Describing a situation that is troublesome or excessively complicated. (8 letters)  ", "5": "Used to characterize persistent and nagging problems. (8 letters)  ", "6": "A word that encapsulates feelings of irritation or exasperation. (8 letters)  ", "7": "Often associated with issues that are more trouble than they are worth. (8 letters)  ", "8": "Describing a person who continually causes annoyance. (8 letters)  ", "9": "A legal term for cases that are frivolous and cause unnecessary delay. (8 letters)  ", "10": "Referring to something that is irritatingly difficult to deal with. (8 letters)"}}
 76 | {"word": "unimitably", "hardcore": true, "clues": {"1": "- In a way that cannot be replicated or copied. (11 letters)  ", "2": "- Describing something that is uniquely original. (11 letters)  ", "3": "- Performing an action in a manner that is unparalleled. (11 letters)  ", "4": "- Characteristic of a style that stands alone in its uniqueness. (11 letters)  ", "5": "- When something is done so exceptionally that it defies imitation. (11 letters)  ", "6": "- Reflecting a quality that is distinctively one-of-a-kind. (11 letters)  ", "7": "- Acting in a fashion that is impossible to duplicate. (11 letters)  ", "8": "- Denoting an approach that is singular and extraordinary. (11 letters)  ", "9": "- Signifying a method that is unmatched in its originality. (11 letters)  ", "10": "- Describing a talent or skill that is truly irreplaceable. (11 letters)"}}
 77 | {"word": "goodyear", "hardcore": true, "clues": {"1": "A famous tire company known for its blimps. (8 letters)  ", "2": "The last name of the man who founded a prominent American tire manufacturer. (8 letters)  ", "3": "This brand is synonymous with quality automotive tires. (8 letters)  ", "4": "A company that sponsors various sporting events, including NASCAR. (8 letters)  ", "5": "Known for the iconic Goodyear Blimp, often seen at major events. (8 letters)  ", "6": "Their tires are a common sight on vehicles across the globe. (8 letters)  ", "7": "This corporation was established in 1898 and is based in Ohio. (8 letters)  ", "8": "A brand recognized for innovations in tire technology and design. (8 letters)  ", "9": "This company\u2019s name is often associated with the phrase \"the right tire for every ride.\" (8 letters)  ", "10": "A leading tire manufacturer that also produces airships. (8 letters)"}}
 78 | {"word": "agacante", "hardcore": true, "clues": {"1": "A tall, elegant tree often found in tropical regions, known for its striking appearance. (8 letters)  ", "2": "This word refers to a type of tree valued for its shade and beauty in landscaping. (8 letters)  ", "3": "Commonly associated with warm climates, this tree can provide shelter and wood. (8 letters)  ", "4": "In some cultures, this tree symbolizes strength and resilience in nature. (8 letters)  ", "5": "The agacante is known for its vibrant blooms that attract various pollinators. (8 letters)  ", "6": "Often found in botanical gardens, this tree is admired for its unique foliage. (8 letters)  ", "7": "This tree can grow to impressive heights, making it a prominent feature in parks. (8 letters)  ", "8": "Its wood is sometimes used in crafting furniture or decorative items. (8 letters)  ", "9": "The agacante is a popular choice for urban planting due to its hardiness. (8 letters)  ", "10": "Known for its adaptability, this tree can thrive in various soil types. (8 letters)"}}
 79 | {"word": "spiffed", "hardcore": true, "clues": {"1": "Dressed up in a snazzy outfit for the evening. (6 letters)  ", "2": "Polished and refined, ready for a special occasion. (6 letters)  ", "3": "Looking sharp and well-groomed for an important event. (6 letters)  ", "4": "Dapper and stylish, he walked into the room. (6 letters)  ", "5": "The party-goers were all spiffed up for the gala. (6 letters)  ", "6": "Glamorously attired, she stole the spotlight. (6 letters)  ", "7": "He felt spiffed after a fresh haircut and new suit. (6 letters)  ", "8": "The team was spiffed for the championship celebration. (6 letters)  ", "9": "She spiffed the place up with elegant decorations. (6 letters)  ", "10": "He was spiffed and ready to impress during the interview. (6 letters)"}}
 80 | {"word": "humerocubital", "hardcore": true, "clues": {"1": "The anatomical term for the joint connecting the upper arm and the forearm. (13 letters)  ", "2": "A reference to the relationship between the humerus and the ulna. (13 letters)  ", "3": "This term describes the area where the elbow is located. (13 letters)  ", "4": "An adjective used in medical contexts relating to the elbow joint. (13 letters)  ", "5": "A term that combines elements of the arm and the forearm. (13 letters)  ", "6": "Used in anatomy to describe structures related to the elbow. (13 letters)  ", "7": "A word that describes a specific type of joint in the human body. (13 letters)  ", "8": "This term is often found in discussions about arm mobility. (13 letters)  ", "9": "Referring to the region where the upper limb bends at the elbow. (13 letters)  ", "10": "An essential term in orthopedic studies focused on arm joints. (13 letters)"}}
 81 | {"word": "dietitian", "hardcore": true, "clues": {"1": "A professional who advises on nutrition and healthy eating habits. (8 letters)  ", "2": "An expert in food and nutrition, essential for meal planning. (8 letters)  ", "3": "This specialist helps individuals manage dietary restrictions. (8 letters)  ", "4": "A key figure in hospitals, often guiding patients on nutrition. (8 letters)  ", "5": "They assess nutritional needs and develop personalized meal plans. (8 letters)  ", "6": "Trained to help people achieve health goals through diet choices. (8 letters)  ", "7": "Often found in schools, promoting healthy eating among students. (8 letters)  ", "8": "They may work with athletes to optimize performance through nutrition. (8 letters)  ", "9": "A trusted advisor for those seeking to lose weight or gain health. (8 letters)  ", "10": "Professionals who can help combat chronic diseases through diet. (8 letters)"}}
 82 | {"word": "Kotoko", "hardcore": true, "clues": {"1": "A popular Ghanaian football club known for its passionate fan base. (6 letters)  ", "2": "The name of a famous song by the Ghanaian musician, Yaa Pono. (6 letters)  ", "3": "A traditional Ghanaian dish that features a spicy sauce. (6 letters)  ", "4": "The nickname often used for the Kumasi-based sports team. (6 letters)  ", "5": "This word can refer to a common name in some West African cultures. (6 letters)  ", "6": "A key player in Ghana's history, often linked to the Ashanti region. (6 letters)  ", "7": "A term that may refer to a local brand of clothing in Ghana. (6 letters)  ", "8": "The name of a vibrant market area in Kumasi, Ghana. (6 letters)  ", "9": "A cultural reference to a legendary figure in Ashanti folklore. (6 letters)  ", "10": "The mascot of a well-known Ghanaian sports organization. (6 letters)"}}
 83 | {"word": "unpocketed", "hardcore": true, "clues": {"1": "Unclaimed and left behind, as in a lost item. (9 letters)  ", "2": "Not stored away in a pocket, exposed to the open air. (9 letters)  ", "3": "Describes something that hasn't been tucked away. (9 letters)  ", "4": "Referring to an object that remains outside of one's possession. (9 letters)  ", "5": "Free from the confines of fabric, as in clothing. (9 letters)  ", "6": "Lacking the security of being held in a pocket. (9 letters)  ", "7": "In a state of being visibly accessible, not hidden. (9 letters)  ", "8": "When something is left out, not stowed away. (9 letters)  ", "9": "Denotes an item that is not secured in a garment. (9 letters)  ", "10": "Suggests a state of being unprotected from loss or theft. (9 letters)"}}
 84 | {"word": "grandame", "hardcore": true, "clues": {"1": "A term often used to refer to an elderly woman or grandmother. (7 letters)  ", "2": "This word is synonymous with matriarch in a family setting. (7 letters)  ", "3": "In literature, she is often depicted as a wise and nurturing figure. (7 letters)  ", "4": "A charming old lady might be affectionately called this. (7 letters)  ", "5": "This term can also imply a sense of dignity and respect. (7 letters)  ", "6": "In some cultures, this word denotes a revered elder woman. (7 letters)  ", "7": "She might be the keeper of family traditions and stories. (7 letters)  ", "8": "A character resembling this term often appears in fairy tales. (7 letters)  ", "9": "The word is derived from the French term for grandmother. (7 letters)  ", "10": "In a game of charades, this could represent a loving elder. (7 letters)"}}
 85 | {"word": "chromatize", "hardcore": true, "clues": {"1": "To convert something into colors or hues in a visual context. (9 letters)  ", "2": "To enhance the vibrancy of colors in a painting. (9 letters)  ", "3": "To apply a color spectrum effect in photography. (9 letters)  ", "4": "To alter the appearance of an object by adding color. (9 letters)  ", "5": "To transform a grayscale image into a colorful one. (9 letters)  ", "6": "To represent an object through its various color phases. (9 letters)  ", "7": "To change the color properties of a substance or material. (9 letters)  ", "8": "To infuse a design with bright and varied colors. (9 letters)  ", "9": "To process an image in a way that emphasizes its colors. (9 letters)  ", "10": "To create a visual effect that enhances color differentiation. (9 letters)"}}
 86 | {"word": "bubble", "hardcore": true, "clues": {"1": "A floating sphere of air often seen in drinks. (6 letters)  ", "2": "A playful, light-hearted moment that bursts with joy. (6 letters)  ", "3": "What forms when soap and water are agitated together. (6 letters)  ", "4": "An economic term for an inflated market condition. (6 letters)  ", "5": "A spherical cavity within a liquid, commonly formed in boiling. (6 letters)  ", "6": "A protective layer, often found in packaging materials. (6 letters)  ", "7": "An airy, light treat often associated with desserts. (6 letters)  ", "8": "A term used for a small, rounded mass of gas or liquid. (6 letters)  ", "9": "A temporary state of bliss or isolation from reality. (6 letters)  ", "10": "What kids often chase after in the backyard on a sunny day. (6 letters)"}}
 87 | {"word": "hysteresis", "hardcore": true, "clues": {"1": "The phenomenon where a system's output depends on its past inputs is known as ___. (9 letters)  ", "2": "In physics, the lagging effect observed in magnetic materials is referred to as ___. (9 letters)  ", "3": "This term describes the dependence of a mechanical system's state on its previous states, called ___. (9 letters)  ", "4": "When discussing thermodynamics, the term for the energy loss due to lag is called ___. (9 letters)  ", "5": "In engineering, the delay in response of a material to an applied force is often attributed to ___. (9 letters)  ", "6": "The concept often seen in control systems, where the output does not immediately follow the input, is known as ___. (9 letters)  ", "7": "In economics, the term for the delayed effect of policy changes on an economy can also be described using ___. (9 letters)  ", "8": "The term for the difference in a system's performance when switching between states is called ___. (9 letters)  ", "9": "In the context of magnetic fields, the loop representing energy loss is referred to as a hysteresis ___. (9 letters)  ", "10": "This scientific term is crucial when analyzing systems that exhibit memory effects, known as ___. (9 letters)"}}
 88 | {"word": "mucosity", "hardcore": true, "clues": {"1": "A term describing the quality of being slimy or sticky in texture. (8 letters)  ", "2": "The state of having an abundance of mucus. (8 letters)  ", "3": "This word refers to the viscous nature of bodily secretions. (8 letters)  ", "4": "A scientific term often used in discussions about respiratory health. (8 letters)  ", "5": "Describes the condition of tissues that produce excessive mucus. (8 letters)  ", "6": "A feature commonly associated with certain medical conditions, like allergies. (8 letters)  ", "7": "This term may be used in microbiology to describe slime layers. (8 letters)  ", "8": "Often related to the consistency of various secretions in the body. (8 letters)  ", "9": "A characteristic of snot or phlegm in the human body. (8 letters)  ", "10": "This word is derived from the Latin term for mucus. (8 letters)"}}
 89 | {"word": "fantastically", "hardcore": true, "clues": {"1": "- In a manner that is extraordinarily imaginative or remarkable. (12 letters)  ", "2": "- To an incredible degree; beyond what is ordinary. (12 letters)  ", "3": "- Describing something that exceeds normal expectations. (12 letters)  ", "4": "- In a way that evokes wonder or is almost unbelievable. (12 letters)  ", "5": "- When something happens in a way that is surprisingly great. (12 letters)  ", "6": "- Used to express an extreme level of enthusiasm or creativity. (12 letters)  ", "7": "- An adverb meaning 'in an impressive or extravagant way.' (12 letters)  ", "8": "- Suggesting a sense of wonder or dreamlike quality. (12 letters)  ", "9": "- Characterizing a situation that is out of this world. (12 letters)  ", "10": "- Describing an event that is both magical and extraordinary. (12 letters)"}}
 90 | {"word": "tiemannite", "hardcore": true, "clues": {"1": "A rare mineral known for its unique composition of thallium and sulfur. (9 letters)  ", "2": "This dark, crystalline substance is often found in volcanic environments. (9 letters)  ", "3": "A mineral that bears the name of a German chemist, it contains thallium. (9 letters)  ", "4": "Found primarily in certain types of ores, this mineral is of interest to geologists. (9 letters)  ", "5": "Characterized by its metallic luster, this mineral is often studied in mineralogy. (9 letters)  ", "6": "The formula for this thallium-bearing mineral is Tl2S. (9 letters)  ", "7": "This mineral is named after the scientist who first described it in the 19th century. (9 letters)  ", "8": "Tiemandite is sometimes confused with similar-looking sulfide minerals. (9 letters)  ", "9": "It is considered a minor mineral but has significance in the study of thallium. (9 letters)  ", "10": "This mineral's occurrence is often linked to hydrothermal processes. (9 letters)"}}
 91 | {"word": "discreetness", "hardcore": true, "clues": {"1": "Keeping secrets with care and caution is a sign of this quality. (10 letters)  ", "2": "The trait of being subtle and unobtrusive in behavior. (10 letters)  ", "3": "An essential virtue for those who handle confidential matters. (10 letters)  ", "4": "This quality allows one to maintain privacy without drawing attention. (10 letters)  ", "5": "The practice of being tactful and judicious in conversation. (10 letters)  ", "6": "In relationships, this characteristic helps to foster trust and respect. (10 letters)  ", "7": "Exercising this virtue can prevent misunderstandings and gossip. (10 letters)  ", "8": "A synonym for prudence, often valued in social settings. (10 letters)  ", "9": "The art of saying less while still conveying important information. (10 letters)  ", "10": "Valued in diplomacy, this trait helps navigate sensitive situations. (10 letters)"}}
 92 | {"word": "contestant", "hardcore": true, "clues": {"1": "A participant in a reality show. (9 letters)  ", "2": "One who competes for a prize. (9 letters)  ", "3": "A player in a game or challenge. (9 letters)  ", "4": "An individual vying for victory. (9 letters)  ", "5": "Someone trying to win a competition. (9 letters)  ", "6": "A hopeful in a talent showcase. (9 letters)  ", "7": "A member of a quiz or trivia match. (9 letters)  ", "8": "An entrant in a beauty pageant. (9 letters)  ", "9": "A player in a game show arena. (9 letters)  ", "10": "A rival in a sporting event. (9 letters)"}}
 93 | {"word": "proddle", "hardcore": true, "clues": {"1": "To poke or push gently, often used when trying to get someone's attention (7 letters).  ", "2": "A light nudge that might encourage movement or action (7 letters).  ", "3": "To stimulate or incite someone to take action, perhaps playfully (7 letters).  ", "4": "This word can mean to poke someone figuratively to get a reaction (7 letters).  ", "5": "A gentle push that might lead to further discussion or activity (7 letters).  ", "6": "To urge someone on with a slight touch or encouragement (7 letters).  ", "7": "Commonly associated with softly prompting someone for a response (7 letters).  ", "8": "To nudge someone, either physically or metaphorically, in a subtle way (7 letters).  ", "9": "Often used in contexts of encouragement or light teasing (7 letters).  ", "10": "This action might be taken to draw attention in a playful manner (7 letters)."}}
 94 | {"word": "gullyhole", "hardcore": true, "clues": {"1": "A narrow channel carved by water flow. (9 letters)  ", "2": "A small depression in the landscape often filled with water. (9 letters)  ", "3": "Where rainwater collects, forming a natural basin. (9 letters)  ", "4": "A term used in geology to describe a specific land feature. (9 letters)  ", "5": "A wet area often found between hills or mountains. (9 letters)  ", "6": "A natural drainage feature in a rural setting. (9 letters)  ", "7": "A term for a low spot in an otherwise flat terrain. (9 letters)  ", "8": "Often associated with erosion and sediment deposition. (9 letters)  ", "9": "A geographical term that might feature in a hiking guide. (9 letters)  ", "10": "A place where wildlife might gather due to water availability. (9 letters)"}}
 95 | {"word": "coalizer", "hardcore": true, "clues": {"1": "A person or thing that combines elements into one. (8 letters)  ", "2": "An agent that brings together disparate parts for a common purpose. (8 letters)  ", "3": "A unifier that merges ideas or entities into a cohesive whole. (8 letters)  ", "4": "Someone who facilitates collaboration among different groups. (8 letters)  ", "5": "An individual who promotes solidarity and teamwork. (8 letters)  ", "6": "A catalyst for integration in social or organizational contexts. (8 letters)  ", "7": "A term for one who joins forces with others for a shared goal. (8 letters)  ", "8": "A figure who seeks to harmonize various interests or factions. (8 letters)  ", "9": "An organizer known for creating alliances and partnerships. (8 letters)  ", "10": "A professional who specializes in collaborative efforts and synergy. (8 letters)"}}
 96 | {"word": "halimous", "hardcore": true, "clues": {"1": "The term for a type of fish often found in warm waters is known as halimous. (8 letters)  ", "2": "In certain cuisines, this ingredient is prized for its delicate flavor and texture. (8 letters)  ", "3": "A popular choice in seafood dishes, this fish is sometimes grilled or baked. (8 letters)  ", "4": "In Mediterranean cooking, halimous may be paired with herbs and lemon. (8 letters)  ", "5": "This fish is often featured in aquaculture due to its fast growth rate. (8 letters)  ", "6": "If you're dining out, you might find halimous listed on the menu as a specialty. (8 letters)  ", "7": "Culinary experts often recommend halimous for its health benefits and light taste. (8 letters)  ", "8": "Halibut is a common name that might come to mind when thinking of halimous. (8 letters)  ", "9": "This fish is frequently enjoyed in sushi or sashimi forms in Japanese cuisine. (8 letters)  ", "10": "When preparing a feast, consider halimous as a centerpiece for a seafood platter. (8 letters)"}}
 97 | {"word": "sonnetish", "hardcore": true, "clues": {"1": "A style of poetry reminiscent of traditional sonnets. (8 letters)  ", "2": "Describing verses that have a lyrical quality similar to sonnets. (8 letters)  ", "3": "Referring to a poetic form that channels the essence of sonnet structure. (8 letters)  ", "4": "Evocative of the rhythm and meter found in classic sonnets. (8 letters)  ", "5": "Relating to a piece of writing that mimics sonnet-like expressions. (8 letters)  ", "6": "Characterizing poetry that captures the emotional depth typical of sonnets. (8 letters)  ", "7": "Suggesting a blend of sonnet form with modern poetic elements. (8 letters)  ", "8": "Indicating a poetic style that borrows from the sonnet tradition. (8 letters)  ", "9": "Expressing sentiments in a manner akin to that of a sonnet. (8 letters)  ", "10": "Portraying a literary work that reflects sonnet-inspired themes. (8 letters)"}}
 98 | {"word": "nonvirile", "hardcore": true, "clues": {"1": "Lacking qualities traditionally associated with masculinity. (9 letters)  ", "2": "Describing someone who is not displaying male characteristics. (9 letters)  ", "3": "A term for behavior or traits that are not manly. (9 letters)  ", "4": "Often used to describe a lack of strength or assertiveness. (9 letters)  ", "5": "Referring to someone who does not embody virility. (9 letters)  ", "6": "In literature, it might describe a character with gentle traits. (9 letters)  ", "7": "An adjective for someone perceived as soft or effeminate. (9 letters)  ", "8": "Characterizing a person who is not aggressive or dominant. (9 letters)  ", "9": "This word might be used in discussions about gender roles. (9 letters)  ", "10": "Indicates a departure from traditional masculine norms. (9 letters)"}}
 99 | {"word": "inventively", "hardcore": true, "clues": {"1": "- She approached the problem inventively, coming up with a unique solution that surprised everyone. (10 letters)  ", "2": "- The artist expressed himself inventively, using materials in unexpected ways to create his masterpiece. (10 letters)  ", "3": "- To stand out in the competition, the team needed to think inventively about their marketing strategy. (10 letters)  ", "4": "- The scientist worked inventively, developing a new method that revolutionized the field of research. (10 letters)  ", "5": "- His inventively crafted story captivated readers with its unexpected twists and imaginative plots. (10 letters)  ", "6": "- The chef cooked inventively, combining flavors that had never been paired before to delight diners. (10 letters)  ", "7": "- She decorated the room inventively, transforming the space into a whimsical wonderland. (10 letters)  ", "8": "- The engineer solved the challenge inventively, utilizing technology in a way that no one had considered. (10 letters)  ", "9": "- They approached the project inventively, brainstorming ideas that pushed the boundaries of traditional thinking. (10 letters)  ", "10": "- His inventively designed gadgets always caught the eye of tech enthusiasts at the fair. (10 letters)"}}
100 | {"word": "hogshouther", "hardcore": true, "clues": {"1": "A term often used to describe a large, boisterous gathering. (10 letters)  ", "2": "This word refers to a playful or festive event involving many people. (10 letters)  ", "3": "A celebration characterized by lively music and dancing. (10 letters)  ", "4": "In an informal context, it can describe a raucous party atmosphere. (10 letters)  ", "5": "A gathering known for its joyous and often chaotic vibe. (10 letters)  ", "6": "This word can imply a communal feast or a shared celebratory event. (10 letters)  ", "7": "A term that evokes imagery of merriment and social interaction. (10 letters)  ", "8": "Often associated with good food, laughter, and a sense of community. (10 letters)  ", "9": "Can describe a boisterous event, often marked by drinking and revelry. (10 letters)  ", "10": "Sometimes used to depict a large, enthusiastic crowd enjoying themselves. (10 letters)"}}
```

## File: textarena/envs/single_player/Crosswords/readme.md

- Extension: .md
- Language: markdown
- Size: 11369 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Crosswords Environment Documentation
  2 | 
  3 | ## Overview
  4 | Crosswords is a single-player puzzle game where the player fills in a crossword grid with words based on provided clues. The player’s objective is to correctly guess all the words using the hints given, ensuring that the letters align correctly in the grid. The environment supports a standard and a hardcore mode, influencing the difficulty of the words provided.
  5 | 
  6 | ## Action Space
  7 | - **Format**: Actions are strings in the format [row col letter], where:
  8 |     - row and col are grid indices (starting from 0) indicating the cell position.
  9 |     - letter is the character the player wants to place in the specified cell.
 10 | 
 11 | - **Examples**:
 12 |     - To place the letter 'A' in row 4, column 7: [4 7 A]
 13 | 
 14 | - **Notes**: Players can provide multiple guesses at once in the format [row col letter]. Additional text may accompany the action, but it must contain the correct format for the action to be processed. Incorrectly formatted actions or wrong guesses will be marked as invalid.
 15 | 
 16 | ## Observation Space
 17 | 
 18 | **Reset Observation:**
 19 | On reset, the observation provides the initial prompt and the state of the Crosswords grid. For example:
 20 | 
 21 | ```plaintext
 22 | [GAME] You are Player 0. You are playing Crosswords (Basic).
 23 | Here is the current state of the Crosswords grid. Each row is numbered, and each column is also numbered.
 24 | The cells that need to be populated with letters are represented by '_', and those that do not need words are represented by '.'.
 25 | 
 26 | Current Crosswords Grid:
 27 |    C00 C01 C02 C03 C04 C05 C06 C07 C08 C09 C10 C11 C12 C13
 28 | R00  _   .   .   .   .   .   .   .   .   .   .   .   .   .  
 29 | R01  _   .   .   .   .   .   .   .   .   .   .   .   .   .  
 30 | R02  _   .   .   .   .   .   .   _   .   .   .   .   .   .  
 31 | R03  .   .   .   .   .   .   _   _   _   _   .   .   .   .  
 32 | R04  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
 33 | R05  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
 34 | R06  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
 35 | R07  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
 36 | R08  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
 37 | R09  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
 38 | R10  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
 39 | R11  .   .   .   .   .   .   .   .   .   .   .   .   .   .  
 40 | R12  .   .   .   .   .   .   .   .   .   .   .   .   .   .  
 41 | R13  .   .   .   .   .   .   .   .   .   .   .   .   .   .  
 42 | 
 43 | Here are the clues for the words you need to find:
 44 | 1. Fully aware of one's feelings and emotions. (9 letters): (2, 7, 'down')
 45 | 2. The covering of a building, often sloped or flat. (4 letters): (3, 6, 'across')
 46 | 3. To consider or regard. (3 letters): (0, 0, 'down')
 47 | 
 48 | You may provide your response in any manner. However, note that any wrong guesses will result in you losing. Hence, plan your approach and risk appetite. Only guesses in the format of [row column letter] will be fetched from your response.
 49 | As you play, the history of your choices will be appended below. Use the information to complete the game.
 50 | 
 51 | ```
 52 | 
 53 | **Step Observation:**
 54 | After each step, the environment returns the action and the updated Crosswords grid as the observation. For example:
 55 | 
 56 | ```plaintext
 57 | [Player 0] Let's analyze the clues and the current grid to fill in the answers strategically.
 58 | 
 59 | 1. Clue 1: Fully aware of one's feelings and emotions. (9 letters)  : (2, 7, 'down')
 60 |    - A potential answer could be "self-aware".
 61 | 
 62 | 2. Clue 2: The covering of a building, often sloped or flat. (4 letters)  : (3, 6, 'across')
 63 |    - A potential answer could be "roof".
 64 | 
 65 | 3. Clue 3: To consider or regard. (3 letters)  : (0, 0, 'down')
 66 |    - A potential answer could be "see".
 67 | 
 68 | Now, let's start filling in the grid based on the answers we've deduced.
 69 | 
 70 | Filling in the Grid:
 71 | 1. For Clue 3 (0, 0, 'down'), I will fill in "see".
 72 |    - [0 0 s]
 73 |    - [1 0 e]
 74 |    - [2 0 e]
 75 | 
 76 | 2. For Clue 2 (3, 6, 'across'), I will fill in "roof".
 77 |    - [3 6 r]
 78 |    - [3 7 o]
 79 |    - [3 8 o]
 80 |    - [3 9 f]
 81 | 
 82 | 3. For Clue 1 (2, 7, 'down'), I will fill in "self-aware".
 83 |    - [2 7 s]
 84 |    - [3 7 e]
 85 |    - [4 7 l]
 86 |    - [5 7 f]
 87 |    - [6 7 -]
 88 |    - [7 7 a]
 89 |    - [8 7 w]
 90 |    - [9 7 a]
 91 |    - [10 7 r]
 92 |    - [11 7 e]
 93 | 
 94 | I will now enter these letters in the grid:
 95 | 
 96 | 1. Filling "see":
 97 |    - [0 0 s]
 98 |    - [1 0 e]
 99 |    - [2 0 e]
100 | 
101 | 2. Filling "roof":
102 |    - [3 6 r]
103 |    - [3 7 o]
104 |    - [3 8 o]
105 |    - [3 9 f]
106 | 
107 | 3. Filling "self-aware":
108 |    - [2 7 s]
109 |    - [3 7 e]
110 |    - [4 7 l]
111 |    - [5 7 f]
112 |    - [6 7 -] (this cell is already filled)
113 |    - [7 7 a]
114 |    - [8 7 w]
115 |    - [9 7 a]
116 |    - [10 7 r]
117 |    - [11 7 e]
118 | 
119 | Now, let's execute the moves one by one:
120 | 
121 | - [0 0 s]
122 | - [1 0 e]
123 | - [2 0 e]
124 | - [3 6 r]
125 | - [3 7 o]
126 | - [3 8 o]
127 | - [3 9 f]
128 | - [2 7 s]
129 | - [3 7 e]
130 | - [4 7 l]
131 | - [5 7 f]
132 | - [7 7 a]
133 | - [8 7 w]
134 | - [9 7 a]
135 | - [10 7 r]
136 | - [11 7 e]
137 | 
138 | Let's execute these moves.
139 | 
140 | Executing Moves:
141 | 1. [0 0 s]
142 | 2. [1 0 e]
143 | 3. [2 0 e]
144 | 4. [3 6 r]
145 | 5. [3 7 o]
146 | 6. [3 8 o]
147 | 7. [3 9 f]
148 | 8. [2 7 s]
149 | 9. [3 7 e]
150 | 10. [4 7 l]
151 | 11. [5 7 f]
152 | 12. [7 7 a]
153 | 13. [8 7 w]
154 | 14. [9 7 a]
155 | 15. [10 7 r]
156 | 16. [11 7 e]
157 | 
158 | Let's now finalize the moves by confirming the letters.
159 | 
160 | Moves:
161 | 1. [0 0 s]
162 | 2. [1 0 e]
163 | 3. [2 0 e]
164 | 4. [3 6 r]
165 | 5. [3 7 o]
166 | 6. [3 8 o]
167 | 7. [3 9 f]
168 | 8. [2 7 s]
169 | 9. [3 7 e]
170 | 10. [4 7 l]
171 | 11. [5 7 f]
172 | 12. [7 7 a]
173 | 13. [8 7 w]
174 | 14. [9 7 a]
175 | 15. [10 7 r]
176 | 16. [11 7 e]
177 | 
178 | This should complete the crossword grid successfully.
179 | 
180 | [GAME] Board state:    
181 |    C00 C01 C02 C03 C04 C05 C06 C07 C08 C09 C10 C11 C12 C13
182 | R00  _   .   .   .   .   .   .   .   .   .   .   .   .   .  
183 | R01  _   .   .   .   .   .   .   .   .   .   .   .   .   .  
184 | R02  _   .   .   .   .   .   .   _   .   .   .   .   .   .  
185 | R03  .   .   .   .   .   .   _   _   _   F   .   .   .   .  
186 | R04  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
187 | R05  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
188 | R06  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
189 | R07  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
190 | R08  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
191 | R09  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
192 | R10  .   .   .   .   .   .   .   _   .   .   .   .   .   .  
193 | R11  .   .   .   .   .   .   .   .   .   .   .   .   .   .  
194 | R12  .   .   .   .   .   .   .   .   .   .   .   .   .   .  
195 | R13  .   .   .   .   .   .   .   .   .   .   .   .   .   .  
196 | 
197 | ```
198 | 
199 | By default, the environment returns observations in the following format:
200 | ```python
201 | {
202 |   player_id: int : [
203 |     (sender_id: int, message: str),
204 |     (sender_id: int, message: str),
205 |     ...
206 |   ]
207 | }
208 | ```
209 | 
210 | ## Gameplay
211 | - **Grid Size**: The grid size is variable and dynamically generated based on the longest word and the number of words included.
212 | - **Turns**: The player fills empty cells ('_') with letters to match the words in the clues.
213 | - **Word Placement**: Words are placed either horizontally ("across") or vertically ("down") based on the clues. Players must fill in the letters one by one, ensuring they match the word locations and directions.
214 | - **Winning Condition**: The game is won when all cells with letters are filled correctly based on the crossword solution.
215 | - **Restart Condition**: The player can restart if they choose or when all allowed turns are exhausted without solving the crossword.
216 | 
217 | ## Key Rules
218 | - **Valid Moves**:
219 | 
220 |     - The player must enter a valid row, column, and letter in the [row col letter] format.
221 |     - The move must not overwrite a filled cell or place a letter that doesn’t match the crossword solution.
222 | 
223 | - **Invalid Moves**:
224 | 
225 |     - Entering a row, column, or letter outside the grid bounds.
226 |     - Overwriting an already filled cell.
227 |     - Placing a letter that doesn’t align with the correct solution will result in the move being marked as invalid.
228 | 
229 | ## Rewards
230 | | Outcome          | Reward for Player  |
231 | |------------------|:------------------:|
232 | | **Win**          |       `+1`         |
233 | | **Lose**         |       `0`          |
234 | | **Invalid Move** |       `-1`         |
235 | 
236 | ## Parameters
237 | 
238 | - `hardcore` (`bool`):
239 |     - **Description:** Determines how many clues the player has to begin with.
240 |     - **Impact:**
241 |         - **Easy:** Player is provided with 50 pre-filled positions. It has to only guess 31 values.
242 |         - **Medium**: Player is provided with 40 pre-filled positions. It has to only guess 41 values.
243 |         - **Hard**: Player is provided with 30 pre-filled positions. It has to only guess 51 values.
244 | 
245 | - `max_turns` (`int`):
246 |     - **Description:** Determines how many turns the player has to make its decisions.
247 |     - **Impact:** This affects the number of tries it can make to complete the game. 
248 | 
249 | - `num_words` (`int`):
250 |     - **Description:** Determines how many words the player has to guess.
251 |     - **Impact:** More words means the player has to factor in more overlapping words. 
252 | 
253 | ## Variants
254 | 
255 | | Env-id                    | hardcore | max_turns | num_words |
256 | |---------------------------|:--------:|:---------:|:---------:|
257 | | `Crosswords-v0`           | `False`  |  `30`     |  `8`      |
258 | | `Crosswords-v0-hardcore`  | `True`   |  `30`     |  `8`      |
259 | 
260 | ## Example Usage
261 | ```python
262 | import textarena as ta
263 | 
264 | ## initializa the environment
265 | env = ta.make("Crosswords-v0")
266 | 
267 | ## Wrap the environment for easier observation handling
268 | env = ta.wrappers.LLMObservationWrapper(env=env)
269 | 
270 | ## Wrap the environment for pretty rendering
271 | env = ta.wrappers.PrettyRenderWrapper(env=env)
272 | 
273 | ## initalize agents
274 | agents = {
275 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
276 |     }
277 | 
278 | ## reset the environment to start a new game
279 | observations = env.reset(seed=490)
280 | 
281 | ## Game loop
282 | done = False
283 | while not done:
284 | 
285 |     # Get the current player
286 |     current_player_id = env.state.get("current_player")
287 | 
288 |     # Get the current observation for the player
289 |     obs = observations[current_player_id]
290 | 
291 |     # Agent decides on an action based on the observation
292 |     action = agents[current_player_id](obs)
293 | 
294 |     # Execute the action in the environment
295 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
296 | 
297 |     # Check if the game has ended
298 |     done = terminated or truncated
299 | 
300 |     # Optionally render the environment to see the current state
301 |     env.render()
302 | 
303 |     if done:
304 |         break
305 | 
306 | ## Finally, print the game results
307 | for player_id, agent in agents.items():
308 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
309 | print(f"Reason: {info['reason']}")
310 | ```
311 | 
312 | ## Troubleshooting
313 | 
314 | **Unplaced Word Issue**
315 | 
316 | - **Issue**: A word cannot be placed on the grid, and a message such as "Could not place the word: <word>" is displayed.
317 | - **Solution**: Reduce the num_words parameter to allow more space or adjust the grid size by increasing the multiplier in `_determine_initial_grid_siz`e.
318 | 
319 | **Invalid Action Format**
320 | 
321 | - **Issue**: Player actions are flagged as invalid due to improper formatting or out-of-bound coordinates.
322 | - **Solution**: Ensure actions are submitted in the correct [row col letter] format. Double-check that row and col values are within grid boundaries and the target cell is empty.
323 | 
324 | **Missing Words and Clues File**
325 | 
326 | - **Issue**: The words_clues.jsonl file is not found at the specified path, causing initialization to fail.
327 | - **Solution**: Confirm that the words_clues.jsonl file exists in textarena/envs/single_player/Crosswords/. Verify that the path is correct and that the file is formatted properly.
328 | 
329 | 
330 | ## Version History
331 | - **v0**
332 |   - Initial release 
333 | 
334 | 
335 | ### Contact
336 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/Crosswords/example.py

- Extension: .py
- Language: python
- Size: 1277 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("Crosswords-v0")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/LogicPuzzle/test.py

- Extension: .py
- Language: python
- Size: 3771 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.LogicPuzzle.env import LogicPuzzleEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["[wednesday Alice O]", "[tuesday Charlie O]"]  
 9 | 
10 | def generate_invalid_format_sequence():
11 |     
12 |     return ["[day_people wednesday Alice O]", "(tuesday Charlie X)"]  
13 | 
14 | def generate_complete_sequence():
15 |     
16 |     return ["[wednesday Alice O] [wednesday Bob X] [wednesday Charlie X] [monday Alice X] [monday Bob O] [monday Charlie X] [tuesday Alice X] [tuesday Bob X] [tuesday Charlie O] [wednesday soccer O] [wednesday basketball X] [wednesday tennis X] [monday soccer X] [monday basketball O] [monday tennis X] [tuesday soccer X] [tuesday basketball X] [tuesday tennis O]"]  
17 | 
18 | 
19 | class TestLogicPuzzleEnv(unittest.TestCase):
20 | 
21 |     
22 |     env_variants = [
23 |         {"difficulty": "easy"},
24 |         {"difficulty": "hard"}
25 |     ]
26 | 
27 |     
28 |     test_cases = {
29 |         "correct_move_easy": {
30 |             "difficulty": "easy",
31 |             "actions": generate_correct_move_sequence()
32 |         },
33 |         "invalid_format_easy": {
34 |             "difficulty": "easy",
35 |             "actions": generate_invalid_format_sequence()
36 |         },
37 |         "complete_easy": {
38 |             "difficulty": "easy",
39 |             "actions": generate_complete_sequence()
40 |         }
41 |     }
42 | 
43 |     @parameterized.expand([
44 |         (name, details['difficulty'], details['actions'])
45 |         for name, details in test_cases.items()
46 |     ])
47 |     def test_logicpuzzle_outcomes(self, name, difficulty, actions):
48 |         
49 |         env_config = next((env for env in self.env_variants if env['difficulty'] == difficulty), None)
50 |         self.assertIsNotNone(env_config, f"Invalid difficulty level: {difficulty}")
51 | 
52 |         env = LogicPuzzleEnv(difficulty=difficulty)
53 | 
54 |         _ = env.reset(seed=490)
55 | 
56 |         terminated = False
57 |         truncated = False
58 | 
59 |         for i, action in enumerate(actions):
60 |             if terminated or truncated:
61 |                 break
62 |             player_id = 0
63 | 
64 |             
65 |             observations, reward, truncated, terminated, info = env.step(player_id, action)
66 | 
67 |             
68 |             if "correct_move" in name:
69 |                 self.assertFalse(terminated, f"Test case {name}: The game terminated unexpectedly.")
70 |                 self.assertFalse(truncated, f"Test case {name}: The game was truncated unexpectedly.")
71 |             elif "invalid_format" in name:
72 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
73 |                 self.assertEqual(reward[0], -1, "Player should receive -1 reward for an invalid move format.")
74 |             elif "complete" in name:
75 |                 self.assertTrue(terminated, "Game should terminate after completing the puzzle.")
76 |                 self.assertEqual(reward[0], 1, "Player should receive 1 reward for completing the puzzle.")
77 |             else:
78 |                 raise ValueError(f"Invalid test case: {name}")
79 |             
80 | def run_unit_test():
81 |     print("Running LogicPuzzleEnv tests...")
82 |     unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/single_player/LogicPuzzle/env.py

- Extension: .py
- Language: python
- Size: 13718 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | from typing import Any, Dict, List, Tuple, Optional
  2 | import random
  3 | import copy
  4 | import textarena as ta
  5 | import time
  6 | import json
  7 | import re
  8 | 
  9 | class LogicPuzzleEnv(ta.Env):
 10 |     
 11 | 
 12 |     def __init__(
 13 |         self,
 14 |         difficulty: Optional[str] = "easy",
 15 |     ):
 16 |         
 17 |         super().__init__()
 18 |         self.environment_name = "LogicPuzzle"
 19 |         self.difficulty = difficulty
 20 | 
 21 |         
 22 |         self.state = ta.State(
 23 |             num_players=1,
 24 |             render_keys=["rendered_board"]
 25 |         )
 26 | 
 27 |         
 28 |         with open("textarena/envs/single_player/LogicPuzzle/game_board_clues.jsonl", "r") as f:
 29 |             game_board_data = f.readlines()
 30 |         self.game_board_data = [json.loads(line) for line in game_board_data if json.loads(line)["difficulty"] == self.difficulty]
 31 | 
 32 |     def reset(
 33 |         self,
 34 |         seed: Optional[int] = None
 35 |     ) -> Optional[ta.Observations]:
 36 |         
 37 | 
 38 |         if seed is not None:
 39 |             random.seed(seed)
 40 |         else:
 41 |             random.seed()
 42 |         
 43 |         
 44 |         self.game_board, self.game_board_solution, self.clues = self._load_game_board() 
 45 | 
 46 |         
 47 |         return self.state.reset(
 48 |             game_state={
 49 |                 "board": copy.deepcopy(self.game_board),
 50 |                 "rendered_board": self._render_board(self.game_board)
 51 |             },
 52 |             player_prompt_function=self._generate_player_prompt
 53 |         )
 54 |     
 55 |     def _generate_player_prompt(self, player_id: int) -> str:
 56 |         
 57 |         prompt = (
 58 |             f"You are Player {player_id} in the Logic Puzzle game.\n"
 59 |             "Your goal is to solve the puzzle by correctly assigning items to categories based on the clues provided.\n"
 60 |             "\n"
 61 |             "To make a move, specify the row and column for each item in the shown tables, followed by the mark ('X' or 'O').\n"
 62 |             "Use the format: '[row col X]' or '[row col O]', where:\n"
 63 |             "- 'O' indicates the item is assigned to the category.\n"
 64 |             "- 'X' indicates the item is not assigned to the category.\n"
 65 |             "\n"
 66 |             "Example: To mark an item in the 'people_locations' grid, enter '[park Alice X]' or '[park Alice O]'.\n"
 67 |             "Only items shown in the current grids can be marked, and you can update a cell if needed.\n"
 68 |             "\n"
 69 |             "Note:\n"
 70 |             "- You may revisit and update previously marked cells as your understanding evolves. As long as the update is a mark that is different from the previous.\n"
 71 |             "- Each move will be recorded in the history.\n"
 72 |             "\n"
 73 |             "Here are the clues to assist you:\n"
 74 |             f"{self._return_clues()}\n"
 75 |             "\n"
 76 |             "Current state of the puzzle:\n"
 77 |             f"{self._render_board(self.game_board)}"
 78 |         )
 79 |         return prompt
 80 | 
 81 | 
 82 |     
 83 |     def _load_game_board(self):
 84 |         
 85 |         selected_game_board = random.choice(self.game_board_data)
 86 |         solution = selected_game_board["solution"]
 87 |         clues = selected_game_board["clue"]
 88 |         game_board, game_board_solution = self._create_game_board(solution)
 89 |         return game_board, game_board_solution, clues
 90 |     
 91 |     def _create_game_board(self, solution: Dict[str, List[str]]):
 92 |         
 93 |         game_board = {}
 94 |         game_board_solution = {}
 95 | 
 96 |         categories = list(solution.keys())
 97 |         index = random.choice(categories)
 98 | 
 99 |         for category in categories:
100 |             if category != index:
101 |                 shuffled_items = solution[category][:]
102 |                 random.shuffle(shuffled_items)
103 | 
104 |                 game_board[f"{index}_{category}"] = {
105 |                     name: {item: None for item in shuffled_items} for name in solution[index]
106 |                 }
107 | 
108 |                 game_board_solution[f"{index}_{category}"] = {
109 |                     name: {item: "O" if item == solution[category][solution[index].index(name)] else "X" for item in shuffled_items} for name in solution[index]
110 |                 }
111 |         
112 |         return game_board, game_board_solution
113 |     
114 |     def _render_board(self, game_board: Dict[str, Dict[str, Dict[str, Any]]]) -> str:
115 |         
116 |         output = []
117 | 
118 |         for grid_name, grid_data in game_board.items():
119 |             
120 |             items = list(next(iter(grid_data.values())).keys())
121 |             
122 |             max_name_width = max(len(name) for name in grid_data.keys()) + 2
123 |             max_col_width = max(len(item) for item in items) + 2
124 | 
125 |             
126 |             output.append(f"\n{'=' * (max_name_width + max_col_width * len(items) + len(items) + 5)}")
127 |             output.append(f"{grid_name.center(max_name_width + max_col_width * len(items) + len(items) + 5)}")
128 |             output.append(f"{'=' * (max_name_width + max_col_width * len(items) + len(items) + 5)}")
129 | 
130 |             
131 |             output.append(" " * max_name_width + " | ".join(f"{item:^{max_col_width}}" for item in items) + " |")
132 |             output.append("-" * (max_name_width + len(items) * (max_col_width + 3) - 1))
133 | 
134 |             
135 |             for name, marks in grid_data.items():
136 |                 row = f"{name:<{max_name_width}}" + " | ".join(
137 |                     f"{marks[item] if marks[item] else ' ':^{max_col_width}}" for item in items
138 |                 )
139 |                 output.append(f"{row} |")
140 | 
141 |             
142 |             output.append("=" * (max_name_width + len(items) * (max_col_width + 3) - 1))
143 | 
144 |         return "\n".join(output)
145 |     
146 |     def _return_clues(self):
147 |         
148 |         return "\n".join([f"- {clue}" for clue in self.clues])
149 |     
150 |     def step(
151 |         self,
152 |         player_id: int,
153 |         action: str
154 |     ) -> Tuple[
155 |         Optional[ta.Observations], 
156 |         Optional[ta.Rewards], 
157 |         bool, 
158 |         bool, 
159 |         ta.Info 
160 |     ]:
161 |         
162 |         
163 |         self.state.add_observation(
164 |             from_id=player_id,
165 |             to_id=-1,
166 |             message=action,
167 |             for_logging=True
168 |         )
169 | 
170 |         
171 |         action_search_pattern = re.compile(r"\[([a-zA-Z]+)\s([a-zA-Z]+)\s([XO])\]") 
172 |         matches = action_search_pattern.findall(action) 
173 |         matches = set(matches)
174 | 
175 |         if not matches:
176 |             self.state.set_invalid_move(
177 |                 player_ids=[player_id],
178 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with a valid move in square brackets."]
179 |             )
180 |         else:
181 |             for match in matches:
182 |                 print("Checking match:", match)
183 |                 row, col, mark = match
184 |                 if not self._is_within_bounds(row, col):
185 |                     
186 |                     self.state.set_invalid_move(
187 |                         player_ids=[player_id],
188 |                         reasons=[f"Invalid move. The item is not within the bounds of the grid."]
189 |                     )
190 |                     break
191 |                 elif self._is_repeated_mark(row, col, mark):
192 |                     
193 |                     self.state.set_invalid_move(
194 |                         player_ids=[player_id],
195 |                         reasons=[f"Invalid move. The item has already been marked with the same value."]
196 |                     )
197 |                     break
198 |                 else:
199 |                     
200 |                     self._mark_item(row, col, mark)
201 |                     self.state.game_state["rendered_board"] = self._render_board(self.game_board)
202 |                     self.state.add_observation(
203 |                         from_id=-1,
204 |                         to_id=player_id,
205 |                         message=f"[{row} {col} {mark}] is valid. Game Board:\n{self._render_board(self.game_board)}",
206 |                         for_logging=False
207 |                     )
208 | 
209 |             if self._is_solved():
210 |                 self.state.set_winners(
211 |                     player_ids=[player_id],
212 |                     reason=[f"Congratulations! Player {player_id} has solved the logic puzzle!"]
213 |                 )
214 |         
215 |         return self.state.step()
216 |     
217 |     def _is_within_bounds(self, row: str, col: str) -> bool:
218 |         
219 |         for grid_name, grid_data in self.game_board.items():
220 |             if row in grid_data:
221 |                 if col in grid_data[row]:
222 |                     return True
223 |         return False
224 |     
225 |     def _is_repeated_mark(self, row: str, col: str, mark: str) -> bool:
226 |         
227 |         for grid_name, grid_data in self.game_board.items():
228 |             if row in grid_data:
229 |                 if col in grid_data[row]:
230 |                     if grid_data[row][col] == mark:
231 |                         return True
232 |         return False
233 |     
234 |     def _mark_item(self, row: str, col: str, mark: str):
235 |         
236 |         for grid_name, grid_data in self.game_board.items():
237 |             if row in grid_data:
238 |                 if col in grid_data[row]:
239 |                     grid_data[row][col] = mark
240 |     
241 |     def _is_solved(self) -> bool:
242 |         
243 |         for grid_name, grid_data in self.game_board.items():
244 |             solution_data = self.game_board_solution.get(grid_name)
245 |             if solution_data is None:
246 |                 return False
247 | 
248 |             for name, items in grid_data.items():
249 |                 solution_items = solution_data.get(name)
250 |                 if solution_items is None:
251 |                     return False
252 | 
253 |                 for item, value in items.items():
254 |                     solution_value = solution_items.get(item)
255 |                     if solution_value is None:
256 |                         return False
257 |                     if value != solution_value:
258 |                         return False
259 | 
260 |         print("All values match between grids and grids_solution.")
261 |         return True
262 |     
263 |     def render(self):
264 |         
265 |         print(self.state.game_state["rendered_board"])
```

## File: textarena/envs/single_player/LogicPuzzle/README.md

- Extension: .md
- Language: markdown
- Size: 18706 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Logic Puzzle Environment Documentation
  2 | 
  3 | ## _TODO_
  4 | - can the prompt be improved?
  5 | - should we add more boards as part of increasing the difficulty?
  6 | - should there be more clues to make it easier? Maybe 5 is too little.
  7 | 
  8 | ## Overview
  9 | The Logic Puzzle Environment is a single-player logic-based game where the player deduces the correct associations between items across multiple categories, such as people, locations, and times. The goal is to solve the puzzle by marking each item’s relationship accurately based on a set of clues. Players receive a board layout with categories on each axis and are prompted to mark relationships using ‘X’ or ‘O’ for each item’s status in the grid. The environment verifies each move, provides feedback for invalid or repeated moves, and updates the rendered board layout. Clues, player move history, and the current board state are available to assist players in working toward the puzzle’s solution within a structured and interactive gameplay environment.
 10 | 
 11 | ## Action Space
 12 | - **Format:** Actions are strings in the format [row col marker], where:
 13 | - **Examples:**
 14 |     - To mark the valid relationship between 'wednesday'(row) and 'Alice': [wednesday Alice O]
 15 | - **Notes:** Multiple moves can be made at one go. Additional text may accompany the action, but it must contain the correct format for the action to be processed. Incorrectly formatted actions will be marked as invalid.
 16 | 
 17 | ## Observation Space
 18 | **Reset Observation:**
 19 | On reset, the observation provides the initial prompt and the initial puzzle grid. For example:
 20 | ```plaintext
 21 | [GAME] You are Player 0 in the Logic Puzzle game.
 22 | Your goal is to solve the puzzle by correctly assigning items to categories based on the clues provided.
 23 | 
 24 | To make a move, specify the row and column for each item in the shown tables, followed by the mark ('X' or 'O').
 25 | Use the format: '[row col X]' or '[row col O]', where:
 26 | - 'O' indicates the item is assigned to the category.
 27 | - 'X' indicates the item is not assigned to the category.
 28 | 
 29 | Example: To mark an item in the 'people_locations' grid, enter '[park Alice X]' or '[park Alice O]'.
 30 | Only items shown in the current grids can be marked, and you can update a cell if needed.
 31 | 
 32 | Note:
 33 | - You may revisit and update previously marked cells as your understanding evolves. As long as the update is a mark that is different from the previous.
 34 | - Each move will be recorded in the history.
 35 | 
 36 | Here are the clues to assist you:
 37 | - Alice plays soccer.
 38 | - Bob does not play tennis.
 39 | - Charlie plays tennis.
 40 | - Wednesday is not Charlie's day.
 41 | - Bob plays basketball on Monday.
 42 | 
 43 | Current state of the puzzle:
 44 | 
 45 | ==============================================
 46 |                   day_people
 47 | ==============================================
 48 |             Charlie  |   Alice   |    Bob    |
 49 | ----------------------------------------------
 50 | wednesday            |           |           |
 51 | monday               |           |           |
 52 | tuesday              |           |           |
 53 | ==============================================
 54 | 
 55 | =======================================================
 56 |                        day_sport
 57 | =======================================================
 58 |               soccer    |  basketball  |    tennis    |
 59 | -------------------------------------------------------
 60 | wednesday               |              |              |
 61 | monday                  |              |              |
 62 | tuesday                 |              |              |
 63 | =======================================================
 64 | ```
 65 | 
 66 | **Step Observations:**
 67 | After each step, the environment returns the action and the updated puzzle grid as the observation. For example:
 68 | ```plaintext
 69 | [Player 0] Let's analyze the clues step by step to fill in the grids.
 70 | 
 71 | 1. **Alice plays soccer.**
 72 |    - This means Alice is assigned to the soccer category.
 73 | 
 74 | 2. **Bob does not play tennis.**
 75 |    - This means we cannot mark Bob under tennis.
 76 | 
 77 | 3. **Charlie plays tennis.**
 78 |    - This means Charlie is assigned to the tennis category.
 79 | 
 80 | 4. **Wednesday is not Charlie's day.**
 81 |    - Since Charlie does not play on Wednesday, we can eliminate Wednesday for Charlie.
 82 | 
 83 | 5. **Bob plays basketball on Monday.**
 84 |    - This means Bob is assigned to basketball on Monday.
 85 | 
 86 | Now, let's fill in the grids based on these clues.
 87 | 
 88 | 1. For Alice:
 89 |    - She plays soccer, so I will mark her under soccer.
 90 |    - Therefore, I will make the move: `[wednesday Alice X]`, `[monday Alice X]`, `[tuesday Alice O]` (since she plays soccer on Tuesday).
 91 | 
 92 | 2. For Charlie:
 93 |    - He plays tennis, but cannot be assigned to Wednesday. Thus, he can only be assigned to Monday or Tuesday for tennis.
 94 |    - Since Monday is taken by Bob (who plays basketball), Charlie must be assigned to tennis on Tuesday.
 95 |    - Therefore, I will make the move: `[wednesday Charlie X]`, `[monday Charlie X]`, `[tuesday Charlie O]`.
 96 | 
 97 | 3. For Bob:
 98 |    - He plays basketball on Monday, which we can now mark. This means he cannot play on Tuesday or Wednesday for tennis.
 99 |    - Therefore, I will make the move: `[wednesday Bob X]`, `[monday Bob O]`, `[tuesday Bob X]`.
100 | 
101 | Now, let's execute these moves:
102 | 
103 | 1. Mark Alice for soccer on Tuesday:
104 |    - `[tuesday Alice O]`
105 | 
106 | 2. Mark Bob for basketball on Monday:
107 |    - `[monday Bob O]`
108 | 
109 | 3. Mark Charlie for tennis on Tuesday:
110 |    - `[tuesday Charlie O]`
111 | 
112 | Updating the grid:
113 | - Alice is assigned soccer on Tuesday.
114 | - Bob is assigned basketball on Monday.
115 | - Charlie is assigned tennis on Tuesday.
116 | 
117 | Here are the moves:
118 | 
119 | \```
120 | [tuesday Alice O]
121 | [monday Bob O]
122 | [tuesday Charlie O]
123 | \```
124 | 
125 | Now let's make these moves.
126 | 
127 | **Final Moves:**
128 | 1. `[tuesday Alice O]`
129 | 2. `[monday Bob O]`
130 | 3. `[tuesday Charlie O]`
131 | [GAME] [tuesday Charlie O] is valid. Game Board:
132 | 
133 | ==============================================
134 |                   day_people
135 | ==============================================
136 |             Charlie  |   Alice   |    Bob    |
137 | ----------------------------------------------
138 | wednesday            |           |           |
139 | monday               |           |           |
140 | tuesday        O     |           |           |
141 | ==============================================
142 | 
143 | =======================================================
144 |                        day_sport
145 | =======================================================
146 |               soccer    |  basketball  |    tennis    |
147 | -------------------------------------------------------
148 | wednesday               |              |              |
149 | monday                  |              |              |
150 | tuesday                 |              |              |
151 | =======================================================
152 | [GAME] [tuesday Alice O] is valid. Game Board:
153 | 
154 | ==============================================
155 |                   day_people
156 | ==============================================
157 |             Charlie  |   Alice   |    Bob    |
158 | ----------------------------------------------
159 | wednesday            |           |           |
160 | monday               |           |           |
161 | tuesday        O     |     O     |           |
162 | ==============================================
163 | 
164 | =======================================================
165 |                        day_sport
166 | =======================================================
167 |               soccer    |  basketball  |    tennis    |
168 | -------------------------------------------------------
169 | wednesday               |              |              |
170 | monday                  |              |              |
171 | tuesday                 |              |              |
172 | =======================================================
173 | [GAME] [wednesday Alice X] is valid. Game Board:
174 | 
175 | ==============================================
176 |                   day_people
177 | ==============================================
178 |             Charlie  |   Alice   |    Bob    |
179 | ----------------------------------------------
180 | wednesday            |     X     |           |
181 | monday               |           |           |
182 | tuesday        O     |     O     |           |
183 | ==============================================
184 | 
185 | =======================================================
186 |                        day_sport
187 | =======================================================
188 |               soccer    |  basketball  |    tennis    |
189 | -------------------------------------------------------
190 | wednesday               |              |              |
191 | monday                  |              |              |
192 | tuesday                 |              |              |
193 | =======================================================
194 | [GAME] [monday Bob O] is valid. Game Board:
195 | 
196 | ==============================================
197 |                   day_people
198 | ==============================================
199 |             Charlie  |   Alice   |    Bob    |
200 | ----------------------------------------------
201 | wednesday            |     X     |           |
202 | monday               |           |     O     |
203 | tuesday        O     |     O     |           |
204 | ==============================================
205 | 
206 | =======================================================
207 |                        day_sport
208 | =======================================================
209 |               soccer    |  basketball  |    tennis    |
210 | -------------------------------------------------------
211 | wednesday               |              |              |
212 | monday                  |              |              |
213 | tuesday                 |              |              |
214 | =======================================================
215 | [GAME] [monday Charlie X] is valid. Game Board:
216 | 
217 | ==============================================
218 |                   day_people
219 | ==============================================
220 |             Charlie  |   Alice   |    Bob    |
221 | ----------------------------------------------
222 | wednesday            |     X     |           |
223 | monday         X     |           |     O     |
224 | tuesday        O     |     O     |           |
225 | ==============================================
226 | 
227 | =======================================================
228 |                        day_sport
229 | =======================================================
230 |               soccer    |  basketball  |    tennis    |
231 | -------------------------------------------------------
232 | wednesday               |              |              |
233 | monday                  |              |              |
234 | tuesday                 |              |              |
235 | =======================================================
236 | [GAME] [wednesday Charlie X] is valid. Game Board:
237 | 
238 | ==============================================
239 |                   day_people
240 | ==============================================
241 |             Charlie  |   Alice   |    Bob    |
242 | ----------------------------------------------
243 | wednesday      X     |     X     |           |
244 | monday         X     |           |     O     |
245 | tuesday        O     |     O     |           |
246 | ==============================================
247 | 
248 | =======================================================
249 |                        day_sport
250 | =======================================================
251 |               soccer    |  basketball  |    tennis    |
252 | -------------------------------------------------------
253 | wednesday               |              |              |
254 | monday                  |              |              |
255 | tuesday                 |              |              |
256 | =======================================================
257 | [GAME] [tuesday Bob X] is valid. Game Board:
258 | 
259 | ==============================================
260 |                   day_people
261 | ==============================================
262 |             Charlie  |   Alice   |    Bob    |
263 | ----------------------------------------------
264 | wednesday      X     |     X     |           |
265 | monday         X     |           |     O     |
266 | tuesday        O     |     O     |     X     |
267 | ==============================================
268 | 
269 | =======================================================
270 |                        day_sport
271 | =======================================================
272 |               soccer    |  basketball  |    tennis    |
273 | -------------------------------------------------------
274 | wednesday               |              |              |
275 | monday                  |              |              |
276 | tuesday                 |              |              |
277 | =======================================================
278 | [GAME] [monday Alice X] is valid. Game Board:
279 | 
280 | ==============================================
281 |                   day_people
282 | ==============================================
283 |             Charlie  |   Alice   |    Bob    |
284 | ----------------------------------------------
285 | wednesday      X     |     X     |           |
286 | monday         X     |     X     |     O     |
287 | tuesday        O     |     O     |     X     |
288 | ==============================================
289 | 
290 | =======================================================
291 |                        day_sport
292 | =======================================================
293 |               soccer    |  basketball  |    tennis    |
294 | -------------------------------------------------------
295 | wednesday               |              |              |
296 | monday                  |              |              |
297 | tuesday                 |              |              |
298 | =======================================================
299 | [GAME] [wednesday Bob X] is valid. Game Board:
300 | 
301 | ==============================================
302 |                   day_people
303 | ==============================================
304 |             Charlie  |   Alice   |    Bob    |
305 | ----------------------------------------------
306 | wednesday      X     |     X     |     X     |
307 | monday         X     |     X     |     O     |
308 | tuesday        O     |     O     |     X     |
309 | ==============================================
310 | 
311 | =======================================================
312 |                        day_sport
313 | =======================================================
314 |               soccer    |  basketball  |    tennis    |
315 | -------------------------------------------------------
316 | wednesday               |              |              |
317 | monday                  |              |              |
318 | tuesday                 |              |              |
319 | =======================================================
320 | ```
321 | 
322 | By default, the environment returns observations in the following format:
323 | ```python
324 | {
325 |   player_id: int : [
326 |     (sender_id: int, message: str),
327 |     (sender_id: int, message: str),
328 |     ...
329 |   ]
330 | }
331 | ```
332 | 
333 | ## Gameplay
334 | **Board Configuration:** The game begins with a grid layout displaying various items across categories like people, locations, and times, depending on the puzzle’s difficulty. Each category pair forms a grid where the player marks items to establish their relationships based on given clues. Items are initially unmarked, allowing the player to deduce correct associations using a process of elimination and logical inference.
335 | 
336 | **Turns:** Players make moves by marking cells with either ‘X’ or ‘O’, signifying whether an item is excluded from or included in a given category. Moves follow the format [row col X] or [row col O], where row and col are the item labels within a specific grid. Each turn updates the game board, with feedback for invalid or repeated moves.
337 | 
338 | **Objective:** To solve the puzzle, the player must correctly associate all items in line with the clues provided. By interpreting and applying these clues, the player can gradually deduce the relationships and fill the grid with accurate marks.
339 | 
340 | **Winning Condition:** The game is won when the player completes all item-category associations accurately, consistent with the provided solution. Feedback is provided when all marks align correctly, confirming the player has solved the puzzle.
341 | 
342 | ## Key Rules
343 | 
344 | - **Valid Moves:**
345 |     - Each move must specify an item in square brackets and follow the structure [row col mark].
346 |     - The player may enter either [X] to exclude or [O] to include an item in a category.
347 |     - Example moves include [Alice park X] or [Bob school O].
348 |     - It is possible for the player to revisit a past move, as long as it is changing it to a different marker.
349 | 
350 | - **Invalid Moves:**
351 |     - Selecting a cell that does not exist within the grid’s row or column limits.
352 |     - Re-entering a mark for an item that already has the same value.
353 |     - Providing a command that does not follow the [row col mark] format or uses unsupported symbols.
354 | 
355 | ## Rewards
356 | | Outcome          | Reward for Player  |
357 | |------------------|:------------------:|
358 | | **Win**          |       `+1`         |
359 | | **Lose**         |       `0`          |
360 | | **Invalid Move** |       `-1`         |
361 | 
362 | ## Variants
363 | 
364 | | Env-id                    |   difficulty   |
365 | |---------------------------|:--------------:|
366 | | `LogicPuzzle-v0`        |    `easy`      |
367 | | `LogicPuzzle-v0-hard`   |    `hard`      |
368 | 
369 | ## Example Usage
370 | ```python
371 | import textarena as ta
372 | 
373 | ## initializa the environment
374 | env = ta.make("LogicPuzzle-v0")
375 | 
376 | ## Wrap the environment for easier observation handling
377 | env = ta.wrappers.LLMObservationWrapper(env=env)
378 | 
379 | ## Wrap the environment for pretty rendering
380 | env = ta.wrappers.PrettyRenderWrapper(env=env)
381 | 
382 | ## initalize agents
383 | agents = {
384 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
385 |     }
386 | 
387 | ## reset the environment to start a new game
388 | observations = env.reset(seed=490)
389 | 
390 | ## Game loop
391 | done = False
392 | while not done:
393 | 
394 |     # Get the current player
395 |     current_player_id = env.state.get("current_player")
396 | 
397 |     # Get the current observation for the player
398 |     obs = observations[current_player_id]
399 | 
400 |     # Agent decides on an action based on the observation
401 |     action = agents[current_player_id](obs)
402 | 
403 |     # Execute the action in the environment
404 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
405 | 
406 |     # Check if the game has ended
407 |     done = terminated or truncated
408 | 
409 |     # Optionally render the environment to see the current state
410 |     env.render()
411 | 
412 |     if done:
413 |         break
414 | 
415 | ## Finally, print the game results
416 | for player_id, agent in agents.items():
417 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
418 | print(f"Reason: {info['reason']}")
419 | ```
420 | 
421 | ## Troubleshooting
422 | 
423 | **Missing Puzzle File**
424 | 
425 | - **Issue**: The puzzle JSON file containing game data is not found at the specified path.
426 | - **Solution**: Verify the file path in textarena/envs/single_player/LogicPuzzle/test.jsonl exists, and check that the file format is valid for loading puzzle data.
427 | 
428 | **Invalid Move Format**
429 | 
430 | - **Issue**: The player’s move input does not follow the [row col mark] format.
431 | - **Solution**: Revise the player's original prompt to enter moves in square brackets with a valid row, column, and mark ('X' or 'O') structure, such as [Alice park X].
432 | 
433 | 
434 | ## Version History
435 | - **v0**
436 |   - Initial release 
437 | 
438 | 
439 | ### Contact
440 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/LogicPuzzle/example.py

- Extension: .py
- Language: python
- Size: 1278 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("LogicPuzzle-v0")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/LogicPuzzle/game_board_clues.jsonl

- Extension: .jsonl
- Language: unknown
- Size: 15833 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```unknown
 1 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "locations": ["home", "work", "park"], "times": ["morning", "afternoon", "evening"]}, "difficulty": "easy", "clue": ["Alice is at home in the morning.", "Bob works in the afternoon.", "Charlie goes to the park in the evening.", "The person at home is not Bob.", "The person at the park is not Alice."]}
 2 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "locations": ["home", "work", "park"], "times": ["morning", "afternoon", "evening"]}, "difficulty": "easy", "clue": ["In the morning, Alice is at home.", "Charlie is not at work.", "Bob is at work in the afternoon.", "The park is visited by Charlie.", "Alice is not at work."]}
 3 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "locations": ["home", "work", "park"], "times": ["morning", "afternoon", "evening"]}, "difficulty": "easy", "clue": ["Charlie is at the park in the evening.", "Alice is not at work.", "Bob is at work during the afternoon.", "Alice spends her time at home in the morning.", "The evening is reserved for Charlie."]}
 4 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "locations": ["home", "work", "park"], "times": ["morning", "afternoon", "evening"]}, "difficulty": "easy", "clue": ["Bob is at work, which is not during the evening.", "Alice is at home during the morning.", "Charlie goes to the park after work.", "The only person at home in the morning is Alice.", "In the evening, the park is where Charlie is."]}
 5 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "locations": ["home", "work", "park"], "times": ["morning", "afternoon", "evening"]}, "difficulty": "easy", "clue": ["Alice is at home when the sun is rising.", "Bob works in the afternoon.", "Charlie enjoys the park in the evening.", "The morning is when Alice stays home.", "In the afternoon, it's Bob at work."]}
 6 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "locations": ["home", "work", "park"], "times": ["morning", "afternoon", "evening"]}, "difficulty": "hard", "clue": ["If Alice is home, then it must be morning.", "Bob cannot be at home or at the park.", "Charlie is at the location where the sun sets.", "The person who works does not enjoy evening walks.", "If it's evening, then Charlie must be at the park."]}
 7 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "locations": ["home", "work", "park"], "times": ["morning", "afternoon", "evening"]}, "difficulty": "hard", "clue": ["Alice's presence in the morning excludes Bob from being at home.", "If it's afternoon, then Bob is definitely at work.", "The park is not visited in the morning.", "Charlie\u2019s location is determined by the time of day.", "If Bob is at work, then Alice is not there."]}
 8 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "locations": ["home", "work", "park"], "times": ["morning", "afternoon", "evening"]}, "difficulty": "hard", "clue": ["If Charlie is not at work, he must be at the park.", "Alice cannot be at the park when the sun is high.", "The person who works does so in the afternoon, not in the evening.", "When Alice is home, Bob is at work.", "If it's evening, Charlie is definitely at the park."]}
 9 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "locations": ["home", "work", "park"], "times": ["morning", "afternoon", "evening"]}, "difficulty": "hard", "clue": ["Alice\u2019s home location rules out her being at work.", "Bob can only be at work in the afternoon.", "Charlie\u2019s evening is reserved for the park.", "In the morning, only one person is home.", "If Bob is not at the park, he must be at work."]}
10 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "locations": ["home", "work", "park"], "times": ["morning", "afternoon", "evening"]}, "difficulty": "hard", "clue": ["If it\u2019s morning, Alice is home, excluding others from that time.", "When Bob is working, he cannot be at the park.", "Charlie\u2019s evening must end at the park.", "If it\u2019s evening, then Charlie is at the park.", "Bob\u2019s work hours coincide with the afternoon, leaving morning for Alice."]}
11 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "car": ["red", "blue", "green"], "fuel": ["gasoline", "diesel", "electric"]}, "difficulty": "easy", "clue": ["Alice drives a red car.", "Bob does not drive a green car.", "Charlie uses electric fuel.", "The blue car is not driven by Alice.", "The car fueled by diesel is driven by Bob."]}
12 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "car": ["red", "blue", "green"], "fuel": ["gasoline", "diesel", "electric"]}, "difficulty": "easy", "clue": ["The red car is not used by Charlie.", "Alice does not use diesel fuel.", "Bob drives a blue car.", "Charlie drives a green car.", "The fuel used by Alice is gasoline."]}
13 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "car": ["red", "blue", "green"], "fuel": ["gasoline", "diesel", "electric"]}, "difficulty": "easy", "clue": ["Charlie does not drive a blue car.", "The green car is not driven by Bob.", "Alice\u2019s car is red.", "Bob does not use electric fuel.", "The car that Charlie drives is not red."]}
14 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "car": ["red", "blue", "green"], "fuel": ["gasoline", "diesel", "electric"]}, "difficulty": "easy", "clue": ["Alice drives a gasoline car.", "Bob drives a blue diesel car.", "The green car is not Alice's.", "Charlie uses electric fuel.", "The red car is driven by Alice."]}
15 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "car": ["red", "blue", "green"], "fuel": ["gasoline", "diesel", "electric"]}, "difficulty": "easy", "clue": ["Bob's car is blue and not electric.", "Alice's car is red.", "Charlie drives a green car.", "The fuel used by Bob is diesel.", "Alice uses gasoline."]}
16 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "car": ["red", "blue", "green"], "fuel": ["gasoline", "diesel", "electric"]}, "difficulty": "hard", "clue": ["If Charlie drives the green car, then Alice must drive the red car.", "Bob does not drive the car that uses gasoline.", "If Alice does not use electric fuel, she drives the red car.", "The driver of the blue car cannot be Charlie.", "If Bob drives a blue car, then Charlie does not drive a red car."]}
17 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "car": ["red", "blue", "green"], "fuel": ["gasoline", "diesel", "electric"]}, "difficulty": "hard", "clue": ["If Alice's car is red, then Bob's car must be blue.", "The car powered by diesel is not Alice's.", "If Charlie drives a green car, then he uses electric fuel.", "Bob cannot be the driver of the green car.", "If Alice uses gasoline, then Bob uses diesel."]}
18 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "car": ["red", "blue", "green"], "fuel": ["gasoline", "diesel", "electric"]}, "difficulty": "hard", "clue": ["If Bob is not driving the blue car, then Alice must be driving the red car.", "Charlie does not drive a diesel car.", "If Alice drives a gasoline car, then Bob's car must be blue.", "The driver of the green car cannot be Alice.", "If Charlie drives the electric car, then Bob drives the blue car."]}
19 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "car": ["red", "blue", "green"], "fuel": ["gasoline", "diesel", "electric"]}, "difficulty": "hard", "clue": ["If Alice\u2019s fuel is gasoline, then Bob\u2019s cannot be electric.", "The color of the car driven by Charlie is green.", "If Bob drives a blue car, then Alice does not use diesel.", "The red car belongs to Alice.", "If Charlie does not drive a red car, he must drive the green one."]}
20 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "car": ["red", "blue", "green"], "fuel": ["gasoline", "diesel", "electric"]}, "difficulty": "hard", "clue": ["If Bob drives a blue car, then Alice drives a red one.", "If the green car is not driven by Charlie, then he must be driving electric.", "Alice does not drive a blue car.", "Bob\u2019s fuel cannot be electric.", "If Charlie drives the electric car, then the red car must belong to Alice."]}
21 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "food": ["pizza", "burger", "salad"], "drink": ["water", "soda", "beer"]}, "difficulty": "easy", "clue": ["Alice is not having a burger.", "Bob's meal is a burger.", "Charlie is eating a salad.", "Alice is drinking water.", "Charlie is not drinking soda."]}
22 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "food": ["pizza", "burger", "salad"], "drink": ["water", "soda", "beer"]}, "difficulty": "easy", "clue": ["Bob is drinking soda.", "Alice is not eating salad.", "Charlie is not drinking beer.", "Alice's meal is pizza.", "Bob is not having water."]}
23 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "food": ["pizza", "burger", "salad"], "drink": ["water", "soda", "beer"]}, "difficulty": "easy", "clue": ["Charlie is the only one who has salad.", "Bob's drink is soda.", "Alice is not drinking beer.", "Pizza is Alice's meal.", "Bob does not drink water."]}
24 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "food": ["pizza", "burger", "salad"], "drink": ["water", "soda", "beer"]}, "difficulty": "easy", "clue": ["Alice's drink is water.", "Bob is not eating pizza.", "Charlie is drinking beer.", "Bob's meal is a burger.", "Alice does not eat a salad."]}
25 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "food": ["pizza", "burger", "salad"], "drink": ["water", "soda", "beer"]}, "difficulty": "easy", "clue": ["Alice eats pizza.", "Bob's drink is soda.", "Charlie has a salad.", "Charlie does not drink water.", "Bob does not eat salad."]}
26 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "food": ["pizza", "burger", "salad"], "drink": ["water", "soda", "beer"]}, "difficulty": "hard", "clue": ["If Alice is having pizza, then her drink is not beer.", "Charlie will only drink beer if he is eating salad.", "If Bob is drinking soda, then Alice must be having water.", "The person who is eating a burger is not the same person who drinks beer.", "The one who drinks water must be eating pizza."]}
27 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "food": ["pizza", "burger", "salad"], "drink": ["water", "soda", "beer"]}, "difficulty": "hard", "clue": ["If Charlie is eating a salad, then he is not drinking soda.", "Alice cannot drink beer or soda, but one of them must be true for Bob.", "If Bob has a burger, then he does not drink water.", "The drink of the person eating pizza is not soda.", "If Alice is drinking water, then Bob must be eating a burger."]}
28 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "food": ["pizza", "burger", "salad"], "drink": ["water", "soda", "beer"]}, "difficulty": "hard", "clue": ["If Bob is drinking soda, then Alice must be having pizza.", "The one who drinks beer must not eat pizza.", "If Charlie is not drinking water, then he must be drinking beer.", "The person who has a burger cannot be Alice.", "If Alice does not drink soda, then Charlie cannot eat a salad."]}
29 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "food": ["pizza", "burger", "salad"], "drink": ["water", "soda", "beer"]}, "difficulty": "hard", "clue": ["If Alice is having pizza, then Charlie must be eating salad.", "If Bob is drinking soda, then he must be eating a burger as well.", "The one who eats a salad is drinking beer.", "If Alice drinks water, then Bob does not eat pizza.", "If Charlie is not drinking beer, then he is eating a salad."]}
30 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "food": ["pizza", "burger", "salad"], "drink": ["water", "soda", "beer"]}, "difficulty": "hard", "clue": ["If Alice drinks water, then she is not eating a salad.", "Charlie will only drink beer if he is eating salad and not pizza.", "The one who eats pizza is not drinking soda.", "If Bob is eating a burger, then Alice must be drinking water.", "If Alice is not having pizza, then Charlie is eating a salad."]}
31 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "sport": ["soccer", "basketball", "tennis"], "day": ["wednesday", "monday", "tuesday"]}, "difficulty": "easy", "clue": ["Alice plays soccer.", "Bob does not play tennis.", "Charlie plays tennis.", "Wednesday is not Charlie's day.", "Bob plays basketball on Monday."]}
32 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "sport": ["soccer", "basketball", "tennis"], "day": ["wednesday", "monday", "tuesday"]}, "difficulty": "easy", "clue": ["Charlie does not play soccer.", "Alice does not play basketball.", "Bob plays basketball on Monday.", "Wednesday is Alice's day.", "The sport played on Tuesday is tennis."]}
33 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "sport": ["soccer", "basketball", "tennis"], "day": ["wednesday", "monday", "tuesday"]}, "difficulty": "easy", "clue": ["Bob plays basketball.", "Charlie does not play basketball.", "Alice plays soccer.", "Tuesday is not Alice's day.", "Monday is Bob's day."]}
34 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "sport": ["soccer", "basketball", "tennis"], "day": ["wednesday", "monday", "tuesday"]}, "difficulty": "easy", "clue": ["Alice's favorite sport is not basketball.", "Bob does not play soccer.", "Charlie plays tennis on Tuesday.", "Wednesday is Alice's day.", "Bob plays on Monday."]}
35 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "sport": ["soccer", "basketball", "tennis"], "day": ["wednesday", "monday", "tuesday"]}, "difficulty": "easy", "clue": ["Charlie does not play soccer.", "Alice plays soccer.", "Bob plays basketball on Monday.", "Tuesday is tennis day.", "Wednesday is not Charlie's day."]}
36 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "sport": ["soccer", "basketball", "tennis"], "day": ["wednesday", "monday", "tuesday"]}, "difficulty": "hard", "clue": ["If Alice doesn't play basketball, then Bob plays on Monday.", "If Wednesday is Charlie's day, then Alice plays soccer.", "Charlie plays tennis if and only if Bob plays basketball.", "Alice plays soccer on a day that is not Tuesday.", "If Bob plays basketball, then Charlie does not play soccer."]}
37 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "sport": ["soccer", "basketball", "tennis"], "day": ["wednesday", "monday", "tuesday"]}, "difficulty": "hard", "clue": ["If Charlie plays on Tuesday, then Alice must play on Wednesday.", "Bob's sport is not soccer if Alice plays on Wednesday.", "If Alice plays soccer, then Tuesday cannot be Bob's day.", "Charlie plays tennis only if it is not Wednesday.", "If Alice is not playing on Monday, then Bob plays basketball on that day."]}
38 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "sport": ["soccer", "basketball", "tennis"], "day": ["wednesday", "monday", "tuesday"]}, "difficulty": "hard", "clue": ["If Bob plays basketball, then Charlie must play tennis.", "Alice plays on a day that is not Monday or Tuesday.", "If Wednesday is Alice's day, then Charlie does not play on Tuesday.", "If Charlie plays on Tuesday, then Bob plays basketball.", "Alice's sport is soccer if and only if Bob's day is Monday."]}
39 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "sport": ["soccer", "basketball", "tennis"], "day": ["wednesday", "monday", "tuesday"]}, "difficulty": "hard", "clue": ["If Alice plays soccer, then Wednesday must be her day.", "If Bob does not play basketball, then Charlie must play on Tuesday.", "Charlie plays tennis unless Alice's day is Wednesday.", "If Monday is Bob's day, then Alice does not play basketball.", "If Charlie is not playing on Tuesday, then Bob must be playing basketball."]}
40 | {"solution": {"people": ["Alice", "Bob", "Charlie"], "sport": ["soccer", "basketball", "tennis"], "day": ["wednesday", "monday", "tuesday"]}, "difficulty": "hard", "clue": ["If Bob plays basketball on Monday, then Alice plays soccer.", "Alice's sport is not basketball if Bob plays on Monday.", "If Charlie plays tennis, then Wednesday is Alice's day.", "If Bob does not play soccer, then Alice plays on Wednesday.", "Charlie plays on Tuesday only if Alice is not playing soccer."]}
```

## File: textarena/envs/single_player/FifteenPuzzle/test.py

- Extension: .py
- Language: python
- Size: 2874 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
 1 | import unittest
 2 | from parameterized import parameterized
 3 | from textarena.envs.single_player.FifteenPuzzle.env import FifteenPuzzleEnv
 4 | 
 5 | 
 6 | def generate_correct_move_sequence():
 7 |     
 8 |     return ["[down]", "[right]"]  
 9 | 
10 | def generate_invalid_move_sequence():
11 |     
12 |     return ["[up]"]  
13 | 
14 | def generate_invalid_format_sequence():
15 |     
16 |     return ["(down)", "down"]  
17 | 
18 | class TestFifteenPuzzleEnv(unittest.TestCase):
19 | 
20 |     test_cases = {
21 |         "correct_move": {
22 |             "actions": generate_correct_move_sequence()
23 |         },
24 |         "invalid_move": {
25 |             "actions": generate_invalid_move_sequence()
26 |         },
27 |         "invalid_format": {
28 |             "actions": generate_invalid_format_sequence()
29 |         }
30 |     }
31 | 
32 |     @parameterized.expand([
33 |         (name, details["actions"])
34 |         for name, details in test_cases.items()
35 |     ])
36 |     def test_fifteenpuzzle_outcomes(self, name, action_sequence):
37 |         
38 |         
39 |         env = FifteenPuzzleEnv()
40 | 
41 |         _ = env.reset(seed=490)
42 | 
43 |         terminated = False
44 |         truncated = False
45 | 
46 |         for i, action in enumerate(action_sequence):
47 |             if terminated or truncated:
48 |                 break
49 |             player_id = 0
50 | 
51 |             
52 |             observations, reward, truncated, terminated, info = env.step(player_id, action)
53 | 
54 |             
55 |             if "correct_move" in name:
56 |                 self.assertFalse(terminated, f"Test case {name}: The game terminated unexpectedly.")
57 |                 self.assertFalse(truncated, f"Test case {name}: The game was truncated unexpectedly.")
58 |             elif "invalid_move" in name:
59 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
60 |                 self.assertEqual(reward[0], -1, "Player should receive -1 reward for an invalid move format.")
61 |             elif "invalid_format" in name:
62 |                 self.assertTrue(truncated or terminated, "Game should terminate due to an invalid move format.")
63 |                 self.assertEqual(reward[0], -1, "Player should receive -1 reward for an invalid move format.")
64 |             else:
65 |                 self.fail(f"Unknown test case name: {name}")
66 | 
67 | def run_unit_test():
68 |     print("Running FifteenPuzzleEnv tests...")
69 |     unittest.main(argv=['first-arg-is-ignored'], exit=False)
```

## File: textarena/envs/single_player/FifteenPuzzle/env.py

- Extension: .py
- Language: python
- Size: 8059 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | from typing import Any, Dict, List, Tuple, Optional, Union
  2 | import random
  3 | import textarena as ta
  4 | import re
  5 | 
  6 | class FifteenPuzzleEnv(ta.Env):
  7 |     
  8 | 
  9 |     def __init__(
 10 |         self,
 11 |     ):
 12 |         
 13 | 
 14 |         super().__init__()
 15 |         self.environment_name = "FifteenPuzzle"
 16 | 
 17 |         
 18 |         self.state = ta.State(
 19 |             num_players=1,
 20 |             render_keys=["rendered_board"],
 21 |             max_turns=100
 22 |         )
 23 | 
 24 |     def reset(
 25 |         self,
 26 |         seed: Optional[int] = None
 27 |     ) -> Optional[ta.Observations]:
 28 |         
 29 | 
 30 |         
 31 |         if seed is not None:
 32 |             random.seed(seed)
 33 |         else:
 34 |             random.seed()
 35 | 
 36 |         
 37 |         self.board = self._generate_board()
 38 |         
 39 |         
 40 |         return self.state.reset(
 41 |             game_state={
 42 |                 "board": self.board,
 43 |                 "rendered_board": self._render_board(self.board)
 44 |             },
 45 |             player_prompt_function=self._generate_player_prompt
 46 |         )
 47 |     
 48 |     def _generate_player_prompt(self, player_id: int) -> str:
 49 |         
 50 |         prompt = (
 51 |             f"You are Player {player_id}. You are playing the 15-Puzzle game.\n"
 52 |             "The objective of the game is to arrange the numbered tiles in ascending order from 1 to 15, with the empty space located in the bottom-right corner.\n"
 53 |             "To make a move, you can slide a tile into the empty space (represented by a double underscore, e.g. __) by using one of the following commands:\n"
 54 |             "- 'up': Move the tile below the empty space up.\n"
 55 |             "- 'down': Move the tile above the empty space down.\n"
 56 |             "- 'left': Move the tile to the right of the empty space left.\n"
 57 |             "- 'right': Move the tile to the left of the empty space right.\n"
 58 |             "To submit your move, type the direction (e.g., 'up', 'down', 'left', or 'right') in square brackets, e.g. [up].\n"
 59 |             "The current board layout is shown below. Use the information to solve the puzzle.\n"
 60 |         )
 61 | 
 62 |         prompt += self.state.game_state["rendered_board"]
 63 |         return prompt
 64 |     
 65 |     def _generate_board(self):
 66 |         
 67 |         tiles = list(range(1, 16)) + [None]
 68 |         random.shuffle(tiles)
 69 |         return [tiles[i:i + 4] for i in range(0, 16, 4)] 
 70 |     
 71 |     def _render_board(self, board):
 72 |         
 73 |         rendered_board = ""
 74 |         for row in board:
 75 |             rendered_board += ' '.join(['__' if x is None else f"{x:2}" for x in row]) + "\n"
 76 |         return rendered_board
 77 |     
 78 |     def step(
 79 |         self,
 80 |         player_id: int,
 81 |         action: str
 82 |     ) -> Tuple[
 83 |         Optional[ta.Observations], 
 84 |         Optional[ta.Rewards], 
 85 |         bool, 
 86 |         bool, 
 87 |         ta.Info 
 88 |     ]:
 89 |         
 90 |         
 91 | 
 92 |         
 93 |         self.state.add_observation(
 94 |             from_id=player_id,
 95 |             to_id=-1,
 96 |             message=action,
 97 |             for_logging=True
 98 |         )
 99 | 
100 |         
101 |         action_search_pattern = re.compile(r"\[([a-zA-Z]+)\]") 
102 |         match = action_search_pattern.search(action)
103 | 
104 |         if match is None:
105 |             self.state.set_invalid_move(
106 |                 player_ids=[player_id],
107 |                 reasons=[f"Invalid move format. Player {player_id} did not respond with a valid direction in square brackets."]
108 |             )
109 |         else:
110 |             direction = match.group(1)
111 |             if not self._move(direction):
112 |                 self.state.set_invalid_move(
113 |                     player_ids=[player_id],
114 |                     reasons=[f"Invalid move. The tile cannot be moved in the specified direction."]
115 |                 )
116 |             else:
117 |                 
118 |                 self.state.game_state["rendered_board"] = self._render_board(self.board)
119 |                 self.state.add_observation(
120 |                     from_id=-1,
121 |                     to_id=player_id,
122 |                     message=f"Game Board:\n{self._render_board(self.board)}",
123 |                     for_logging=False
124 |                 )
125 |             
126 |         
127 |         if self._is_solved():
128 |             self.state.set_winners(
129 |                 player_ids=[player_id],
130 |                 reason=f"Congratulations! Player {player_id} have successfully solved the 15-Puzzle."
131 |             )
132 |         
133 |         return self.state.step()
134 |     
135 |     def _is_solved(self) -> bool:
136 |         
137 |         correct_tiles = list(range(1, 16)) + [None]
138 |         current_tiles = [tile for row in self.board for tile in row]
139 |         return current_tiles == correct_tiles
140 | 
141 |     def _move(self, direction: str) -> bool:
142 |         
143 |         empty_row, empty_col = self._get_empty_position()
144 |         target_row, target_col = empty_row, empty_col
145 | 
146 |         if direction == 'up' and empty_row < 3:
147 |             target_row += 1
148 |         elif direction == 'down' and empty_row > 0:
149 |             target_row -= 1
150 |         elif direction == 'left' and empty_col < 3:
151 |             target_col += 1
152 |         elif direction == 'right' and empty_col > 0:
153 |             target_col -= 1
154 |         else:
155 |             
156 |             return False
157 | 
158 |         
159 |         self.board[empty_row][empty_col], self.board[target_row][target_col] = (
160 |             self.board[target_row][target_col],
161 |             self.board[empty_row][empty_col],
162 |         )
163 |         return True
164 |     
165 |     def _get_empty_position(self):
166 |         
167 |         for r in range(4):
168 |             for c in range(4):
169 |                 if self.board[r][c] is None:
170 |                     return r, c
171 |                 
172 |     def render(self):
173 |         
174 |         print(self.state.game_state["rendered_board"])
```

## File: textarena/envs/single_player/FifteenPuzzle/readme.md

- Extension: .md
- Language: markdown
- Size: 7634 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```markdown
  1 | # Fifteen Puzzle Environment Documentation
  2 | 
  3 | ## Overview
  4 | The 15-Puzzle Environment is a single-player tile-sliding puzzle game in which the player arranges numbered tiles in ascending order from 1 to 15, with an empty space located at the bottom-right corner. The player can slide tiles into the empty space to progress toward the solved state, aiming to complete the puzzle within a set number of moves. Each turn, the environment prompts the player for a move, validates the input, and updates the board layout accordingly. The player’s move history and the current board layout are displayed to help track progress and guide gameplay.
  5 | 
  6 | ## Action Space
  7 | - **Format:** Actions are strings in the format [direction], where:
  8 | - **Examples:**
  9 |     - To move the bottom tile "up", and therein move the empty tile "down": [up]
 10 | - **Notes:** Additional text may accompany the action, but it must contain the correct format for the action to be processed. Incorrectly formatted actions will be marked as invalid.
 11 | 
 12 | ## Observation Space
 13 | **Reset Observation:**
 14 | On reset, the observation provides the initial prompt and the initial puzzle grid. For example:
 15 | ```plaintext
 16 | [GAME] You are Player 0. You are playing the 15-Puzzle game.
 17 | The objective of the game is to arrange the numbered tiles in ascending order from 1 to 15, with the empty space located in the bottom-right corner.
 18 | To make a move, you can slide a tile into the empty space (represented by a double underscore, e.g. __) by using one of the following commands:
 19 | - 'up': Move the tile below the empty space up.
 20 | - 'down': Move the tile above the empty space down.
 21 | - 'left': Move the tile to the right of the empty space left.
 22 | - 'right': Move the tile to the left of the empty space right.
 23 | To submit your move, type the direction (e.g., 'up', 'down', 'left', or 'right') in square brackets, e.g. [up].
 24 | The current board layout is shown below. Use the information to solve the puzzle.
 25 |  1  6  7  3
 26 |  4 13 11 14
 27 |  5 10  2 12
 28 | 15  8  9 __
 29 | ```
 30 | 
 31 | **Step Observations:**
 32 | After each step, the environment returns the action and the updated puzzle grid as the observation. For example:
 33 | ```plaintext
 34 | [Player 0] To solve the 15-Puzzle, the goal is to rearrange the tiles into the correct order. Let's analyze the current board:
 35 | 
 36 | \```
 37 |  1  6  7  3
 38 |  4 13 11 14
 39 |  5 10  2 12
 40 | 15  8  9 __
 41 | \```
 42 | 
 43 | The empty space (__) is currently at the bottom right corner. The goal is to arrange the tiles in ascending order, with the empty space at the bottom right.
 44 | 
 45 | The current configuration is:
 46 | 
 47 | - Row 0: 1, 6, 7, 3
 48 | - Row 1: 4, 13, 11, 14
 49 | - Row 2: 5, 10, 2, 12
 50 | - Row 3: 15, 8, 9, __
 51 | 
 52 | Let's consider our options. The tile above the empty space is 9, which can be moved down into the empty space.
 53 | 
 54 | Therefore, the first move I will make is to slide the tile 9 down into the empty space.
 55 | 
 56 | Let's execute this move:
 57 | 
 58 | [down]
 59 | [GAME] Game Board:
 60 |  1  6  7  3
 61 |  4 13 11 14
 62 |  5 10  2 __
 63 | 15  8  9 12
 64 | ```
 65 | 
 66 | By default, the environment returns observations in the following format:
 67 | ```python
 68 | {
 69 |   player_id: int : [
 70 |     (sender_id: int, message: str),
 71 |     (sender_id: int, message: str),
 72 |     ...
 73 |   ]
 74 | }
 75 | ```
 76 | 
 77 | ## Gameplay
 78 | **Board Configuration:** The game starts with a 4x4 grid of numbered tiles from 1 to 15, along with an empty space represented by a double underscore (__). The tiles are shuffled into a random order, which the player must rearrange to match the solved configuration with tiles in ascending order and the empty space in the bottom-right corner.
 79 | 
 80 | **Turns:** The player makes moves by typing a direction in the format [direction], where direction can be up, down, left, or right, indicating the direction to slide a tile into the empty space. The game defaults to a maximum of 100 turns, but this number can be adjusted based on the player’s preference.
 81 | 
 82 | **Objective:** To complete the game, the player must rearrange the tiles until they reach the solved configuration. The player can only move tiles that are adjacent to the empty space, strategically sliding tiles to solve the puzzle within the allowed turns.
 83 | 
 84 | **Winning Condition:** The game is won when the tiles are arranged in ascending order from 1 to 15, with the empty space located at the bottom-right corner, and the player has achieved this within the set number of turns.
 85 | 
 86 | ## Key Rules
 87 | 
 88 | - Valid Moves:
 89 | 
 90 |     - The player must enter a command in square brackets that specifies one of the four possible directions:
 91 |         - [up]: Moves the tile below the empty space, up.
 92 |         - [down]: Moves the tile above the empty space, down.
 93 |         - [left]: Moves the tile to the right of the empty space, left.
 94 |         - [right]: Moves the tile to the left of the empty space, right.
 95 |     - The selected tile moves only if it is adjacent to the empty space in the specified direction.
 96 | 
 97 | - Invalid Moves:
 98 | 
 99 |     - Entering a direction that does not align with a tile adjacent to the empty space.
100 |     - Using an unsupported direction format or any input that does not follow the [direction] structure.
101 | 
102 | ## Rewards
103 | | Outcome          | Reward for Player  |
104 | |------------------|:------------------:|
105 | | **Win**          |       `+1`         |
106 | | **Lose**         |       `0`          |
107 | | **Invalid Move** |       `-1`         |
108 | 
109 | ## Variants
110 | 
111 | | Env-id                    |
112 | |---------------------------|
113 | | `FifteenPuzzle-v0`        |
114 | 
115 | ## Example Usage
116 | ```python
117 | import textarena as ta
118 | 
119 | ## initializa the environment
120 | env = ta.make("FifteenPuzzle-v0")
121 | 
122 | ## Wrap the environment for easier observation handling
123 | env = ta.wrappers.LLMObservationWrapper(env=env)
124 | 
125 | ## Wrap the environment for pretty rendering
126 | env = ta.wrappers.PrettyRenderWrapper(env=env)
127 | 
128 | ## initalize agents
129 | agents = {
130 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
131 |     }
132 | 
133 | ## reset the environment to start a new game
134 | observations = env.reset(seed=490)
135 | 
136 | ## Game loop
137 | done = False
138 | while not done:
139 | 
140 |     # Get the current player
141 |     current_player_id = env.state.get("current_player")
142 | 
143 |     # Get the current observation for the player
144 |     obs = observations[current_player_id]
145 | 
146 |     # Agent decides on an action based on the observation
147 |     action = agents[current_player_id](obs)
148 | 
149 |     # Execute the action in the environment
150 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
151 | 
152 |     # Check if the game has ended
153 |     done = terminated or truncated
154 | 
155 |     # Optionally render the environment to see the current state
156 |     env.render()
157 | 
158 |     if done:
159 |         break
160 | 
161 | ## Finally, print the game results
162 | for player_id, agent in agents.items():
163 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
164 | print(f"Reason: {info['reason']}")
165 | ```
166 | 
167 | ## Troubleshooting
168 | 
169 | **Invalid Move Format:**
170 | 
171 |   - **Issue**: The player submits a move in an incorrect format (e.g., missing square brackets).
172 |   - **Solution**: Remind the player to submit moves in the format `[direction]`, where direction can be up, down, left, or right.
173 | 
174 | **Tile Cannot Be Moved:**
175 | 
176 |   - **Issue**: The player attempts to move a tile in a direction where it is blocked (e.g., trying to move a tile up at the top row).
177 |   - **Solution**: Provide feedback that the move is invalid and encourage the player to check the board layout before selecting a direction.
178 | 
179 | **Rendering Display Issues:**
180 | 
181 |   - **Issue**: The board layout is not displayed correctly or shows misaligned elements.
182 |   - **Solution**: Check the `_render_board` function for spacing issues and ensure each row is joined with consistent spacing for clarity.
183 | 
184 | 
185 | ## Version History
186 | - **v0**
187 |   - Initial release 
188 | 
189 | 
190 | ### Contact
191 | If you have questions or face issues with this specific environment, please reach out directly to bobby_cheng@i2r.a-star.edu.sg
```

## File: textarena/envs/single_player/FifteenPuzzle/example.py

- Extension: .py
- Language: python
- Size: 1280 bytes
- Created: 2024-11-16 14:23:46
- Modified: 2024-11-16 14:23:46

### Code

```python
 1 | import textarena as ta
 2 | 
 3 | 
 4 | env = ta.make("FifteenPuzzle-v0")
 5 | 
 6 | 
 7 | env = ta.wrappers.LLMObservationWrapper(env=env)
 8 | 
 9 | 
10 | env = ta.wrappers.PrettyRenderWrapper(env=env)
11 | 
12 | 
13 | agents = {
14 |     0: ta.basic_agents.OpenRouter(model_name="gpt-4o-mini")
15 |     }
16 | 
17 | 
18 | observations = env.reset(seed=490)
19 | 
20 | 
21 | done = False
22 | while not done:
23 | 
24 |     
25 |     current_player_id = env.state.get("current_player")
26 | 
27 |     
28 |     obs = observations[current_player_id]
29 | 
30 |     
31 |     action = agents[current_player_id](obs)
32 | 
33 |     
34 |     observations, rewards, truncated, terminated, info = env.step(current_player_id, action)
35 | 
36 |     
37 |     done = terminated or truncated
38 | 
39 |     
40 |     env.render()
41 | 
42 |     if done:
43 |         break
44 | 
45 | 
46 | for player_id, agent in agents.items():
47 |     print(f"{agent.agent_identifier}: {rewards[player_id]}")
48 | print(f"Reason: {info['reason']}")
```

## File: textarena/envs/single_player/Sudoku/archive/sudoku_bob.py

- Extension: .py
- Language: python
- Size: 20126 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | from abc import ABC, abstractmethod
  2 | from typing import Any, Dict, Optional, Tuple, List
  3 | import time
  4 | import copy
  5 | import random
  6 | import textarena as ta
  7 | 
  8 | class SudokuEnv(ta.Env):
  9 |     
 10 | 
 11 |     environment_name = "Sudoku"
 12 | 
 13 |     def __init__(self, difficulty: str = "Easy", max_incorrect: int = 5, time_limit: Optional[int] = None):
 14 |         
 15 |         self.ENVIRONMENT_NAME = f"Sudoku ({difficulty})"
 16 |         self.difficulty = difficulty
 17 |         self.max_incorrect = max_incorrect
 18 |         self.time_limit = time_limit  
 19 | 
 20 |         
 21 |         self.game_state = ta.State({
 22 |             "grid": [],
 23 |             "incorrect_attempts": 0,
 24 |             "start_time": None,
 25 |             "time_elapsed": 0,
 26 |             "completed": False,
 27 |             "logs": []
 28 |         }
 29 |         )
 30 | 
 31 |     def _load_puzzle(self, difficulty: str) -> List[List[int]]:
 32 |         
 33 |         
 34 |         difficulty_levels = {
 35 |             "Easy": 28,     
 36 |             "Medium": 32,  
 37 |             "Hard": 36,    
 38 |         }
 39 |         clues = difficulty_levels.get(difficulty, 28)  
 40 | 
 41 |         
 42 |         full_grid = self._generate_full_grid()
 43 | 
 44 |         
 45 |         puzzle_grid = self._remove_cells(full_grid, clues)
 46 | 
 47 |         return puzzle_grid
 48 | 
 49 |     def _generate_full_grid(self) -> List[List[int]]:
 50 |         
 51 |         grid = [[0 for _ in range(9)] for _ in range(9)]
 52 |         self._fill_grid(grid)
 53 |         return grid
 54 | 
 55 |     def _fill_grid(self, grid: List[List[int]]) -> bool:
 56 |         
 57 |         empty = self._find_empty(grid)
 58 |         if not empty:
 59 |             return True  
 60 |         row, col = empty
 61 | 
 62 |         numbers = list(range(1, 10))
 63 |         random.shuffle(numbers)
 64 |         for num in numbers:
 65 |             if self.is_safe(grid, row, col, num):
 66 |                 grid[row][col] = num
 67 |                 if self._fill_grid(grid):
 68 |                     return True
 69 |                 grid[row][col] = 0
 70 |         return False
 71 | 
 72 |     def _find_empty(self, grid: List[List[int]]) -> Optional[Tuple[int, int]]:
 73 |         
 74 |         for i in range(9):
 75 |             for j in range(9):
 76 |                 if grid[i][j] == 0:
 77 |                     return (i, j)
 78 |         return None
 79 | 
 80 |     def is_safe(self, grid: List[List[int]], row: int, col: int, num: int) -> bool:
 81 |         
 82 |         
 83 |         if num in grid[row]:
 84 |             return False
 85 |         
 86 |         if num in [grid[i][col] for i in range(9)]:
 87 |             return False
 88 |         
 89 |         start_row, start_col = 3 * (row // 3), 3 * (col // 3)
 90 |         for i in range(start_row, start_row + 3):
 91 |             for j in range(start_col, start_col + 3):
 92 |                 if grid[i][j] == num:
 93 |                     return False
 94 |         return True
 95 | 
 96 |     def _remove_cells(self, grid: List[List[int]], clues: int) -> List[List[int]]:
 97 |         
 98 |         puzzle = copy.deepcopy(grid)
 99 |         cells = [(i, j) for i in range(9) for j in range(9)]
100 |         random.shuffle(cells)
101 | 
102 |         while len(cells) > (81 - clues):
103 |             row, col = cells.pop()
104 |             removed = puzzle[row][col]
105 |             puzzle[row][col] = 0
106 | 
107 |             
108 |             grid_copy = copy.deepcopy(puzzle)
109 |             solutions = []
110 |             self._count_solutions(grid_copy, solutions)
111 |             if len(solutions) != 1:
112 |                 
113 |                 puzzle[row][col] = removed
114 | 
115 |         return puzzle
116 | 
117 |     def _solve_sudoku(self, grid: List[List[int]]) -> bool:
118 |         
119 |         empty = self._find_empty(grid)
120 |         if not empty:
121 |             return True  
122 |         row, col = empty
123 | 
124 |         for num in range(1, 10):
125 |             if self.is_safe(grid, row, col, num):
126 |                 grid[row][col] = num
127 |                 if self._solve_sudoku(grid):
128 |                     return True
129 |                 grid[row][col] = 0
130 |         return False
131 | 
132 |     def _count_solutions(self, grid: List[List[int]], solutions: List[List[List[int]]], limit: int = 2) -> int:
133 |         
134 |         if len(solutions) >= limit:
135 |             return len(solutions)
136 | 
137 |         empty = self._find_empty(grid)
138 |         if not empty:
139 |             solutions.append(copy.deepcopy(grid))
140 |             return len(solutions)
141 |         row, col = empty
142 | 
143 |         for num in range(1, 10):
144 |             if self.is_safe(grid, row, col, num):
145 |                 grid[row][col] = num
146 |                 self._count_solutions(grid, solutions, limit)
147 |                 grid[row][col] = 0
148 |         return len(solutions)
149 | 
150 |     def reset(
151 |         self,
152 |         seed: Optional[int] = None
153 |     ) -> Tuple[Optional[Dict[int, str]], Dict[str, Any]]:
154 |         
155 |         if seed is not None:
156 |             random.seed(seed)
157 |         else:
158 |             random.seed()
159 | 
160 |         self.state = ""
161 | 
162 |         
163 |         self.initial_grid = self._load_puzzle(self.difficulty)
164 | 
165 |         self.game_state["grid"] = copy.deepcopy(self.initial_grid)
166 |         self.game_state["incorrect_attempts"] = 0
167 |         self.game_state["completed"] = False
168 |         self.game_state["logs"] = ["[GAME] New Sudoku game started!"]
169 |         self.game_state["start_time"] = time.time()
170 |         self.game_state["time_elapsed"] = 0
171 |         self.game_state["render"] = ["grid", "incorrect_attempts", "time_elapsed"]
172 | 
173 |         observations = {
174 |             0: self._generate_player_prompt(0)
175 |         }
176 |         info = {
177 |             "difficulty": self.difficulty,
178 |             "max_incorrect": self.max_incorrect,
179 |             "time_limit": self.time_limit
180 |         }
181 |         
182 |         return observations, info
183 | 
184 |     def _generate_player_prompt(self, player_id: int) -> str:
185 |         
186 |         prompt = (
187 |             f"You are Player {player_id}. You are playing Sudoku ({self.difficulty}).\n"
188 |             "Here is the current state of the Sudoku grid. Each row is numbered from 1 to 9, and each column is also numbered from 1 to 9.\n"
189 |             "Empty cells are represented by '.', and pre-filled cells contain digits from 1 to 9.\n\n"
190 |             "Current Sudoku Grid:\n"
191 |         )
192 |         
193 |         
194 |         grid_str = self._get_grid_string_with_indices()
195 |         prompt += f"{grid_str}\n\n"
196 |         
197 |         prompt += (
198 |             "Your objective is to fill the empty cells in the 9x9 grid with digits from 1 to 9 such that:\n"
199 |             "1. Each row contains all digits from 1 to 9 without repetition.\n"
200 |             "2. Each column contains all digits from 1 to 9 without repetition.\n"
201 |             "3. Each of the nine 3x3 subgrids contains all digits from 1 to 9 without repetition.\n\n"
202 |             "Rules and Instructions:\n"
203 |             "1. **Do not overwrite** the initial numbers provided in the grid.\n"
204 |             "2. **Only fill** empty cells represented by '.'.\n"
205 |             "3. **Respond only** with a single move at a time in the following format: 'row column number'.\n"
206 |             "   - Example: To place the number 7 in row 5, column 3, respond with '5 3 7'.\n"
207 |             "4. **Ensure** that your move does not violate Sudoku rules. Invalid moves will result in penalties.\n"
208 |             "5. **Do not** include any additional text or explanations in your response.\n\n"
209 |             "Examples:\n"
210 |             "- **Valid Move**:\n"
211 |             "  - Grid Snippet Before Move:\n"
212 |             "  \n"
213 |             "  - Move: `5 3 7`\n"
214 |             "  - Explanation: Placing 7 at row 5, column 3 does not violate any Sudoku rules.\n\n"
215 |             "- **Invalid Move** (Overwriting a pre-filled cell):\n"
216 |             "  - Grid Snippet Before Move:\n"
217 |             "  \n"
218 |             "  - Move: `1 1 9`\n"
219 |             "  - Explanation: Cell (1,1) is already filled with 5. You cannot overwrite it.\n\n"
220 |             "- **Invalid Move** (Violating Sudoku rules):\n"
221 |             "  - Grid Snippet Before Move:\n"
222 |             "  \n"
223 |             "  - Move: `1 3 5`\n"
224 |             "  - Explanation: Placing 5 in row 1, column 3 violates the rule since 5 already exists in row 1.\n\n"
225 |             "Good luck!\n\n"
226 |         )
227 |         
228 |         if self.time_limit:
229 |             prompt += f"You have {self.time_limit} seconds to complete the puzzle.\n"
230 |         
231 |         return prompt
232 | 
233 |     def step(
234 |         self,
235 |         player_id: int,
236 |         action: str,
237 |     ) -> Tuple[
238 |         Optional[Dict[int, str]],  
239 |         Optional[Dict[int, int]],  
240 |         bool,  
241 |         bool,  
242 |         Dict[str, Any],  
243 |     ]:
244 |         
245 |         
246 |         
247 | 
248 |         self.state += f"Player {player_id}: {action}\n"
249 |         observation = f"Player {player_id} made a move: {action}"
250 | 
251 |         observations = {
252 |             0: observation
253 |         }
254 | 
255 |         
256 |         elapsed_time = time.time() - self.game_state["start_time"]
257 |         if self.time_limit and elapsed_time > self.time_limit:
258 |             self.game_state["completed"] = True
259 |             self.game_state["time_elapsed"] = round(elapsed_time, 1)
260 |             self.game_state["logs"].append("[GAME] Time limit exceeded.")
261 |             info = {"reason": "Time limit exceeded."}
262 |             return observations, {"score": -100}, True, True, info
263 | 
264 |         
265 |         try:
266 |             row, col, num = map(int, action.strip().split())
267 |             if not (1 <= row <= 9 and 1 <= col <= 9 and 1 <= num <= 9):
268 |                 raise ValueError
269 |         except ValueError:
270 |             
271 |             self.game_state["time_elapsed"] = round(elapsed_time, 1)
272 |             self.game_state["incorrect_attempts"] += 1
273 |             reward = -10
274 |             info = {"message": "Invalid action format. Use 'row column number' with values between 1 and 9."}
275 |             self.game_state["logs"].append(f"[INVALID ACTION] {action}")
276 |             return observations, {"score": reward}, self._check_truncated(), self._check_terminated(), info
277 | 
278 |         row_idx, col_idx = row - 1, col - 1
279 | 
280 |         
281 |         if self.initial_grid[row_idx][col_idx] != 0:
282 |             self.game_state["time_elapsed"] = round(elapsed_time, 1)
283 |             self.game_state["incorrect_attempts"] += 1
284 |             reward = -10
285 |             info = {"message": f"Cell ({row}, {col}) is already filled with {self.initial_grid[row_idx][col_idx]}."}
286 |             self.game_state["logs"].append(f"[INVALID MOVE] Attempt to overwrite initial cell ({row}, {col}).")
287 |             return observations, {"score": reward}, self._check_truncated(), self._check_terminated(), info
288 | 
289 |         
290 |         if self._is_move_correct(row_idx, col_idx, num):
291 |             self.game_state["time_elapsed"] = round(elapsed_time, 1)
292 |             self.game_state["grid"][row_idx][col_idx] = num
293 |             reward = 1
294 |             info = {"message": f"Placed {num} at ({row}, {col}). Correct move."}
295 |             self.game_state["logs"].append(f"[CORRECT MOVE] Placed {num} at ({row}, {col}).")
296 |         else:
297 |             self.game_state["time_elapsed"] = round(elapsed_time, 1)
298 |             self.game_state["incorrect_attempts"] += 1
299 |             reward = -10
300 |             info = {"message": f"Incorrect move: Cannot place {num} at ({row}, {col})."}
301 |             self.game_state["logs"].append(f"[INCORRECT MOVE] Attempted to place {num} at ({row}, {col}).")
302 | 
303 |         
304 |         if self._is_puzzle_complete():
305 |             self.game_state["time_elapsed"] = round(elapsed_time, 1)
306 |             self.game_state["completed"] = True
307 |             reward += 10  
308 |             info["message"] = "Puzzle completed successfully!"
309 |             self.game_state["logs"].append("[GAME] Puzzle completed successfully!")
310 | 
311 |         return observations, reward, self._check_truncated(), self._check_terminated(), info
312 | 
313 |     def render(self):
314 |         
315 |         grid_str = self._get_grid_string_with_indices()
316 |         print(grid_str)
317 |         print(f"Incorrect Attempts: {self.game_state['incorrect_attempts']}/{self.max_incorrect}")
318 |         if self.time_limit:
319 |             elapsed_time = int(time.time() - self.game_state["start_time"])
320 |             print(f"Time Elapsed: {elapsed_time} seconds / {self.time_limit} seconds")
321 | 
322 |     def _get_grid_string_with_indices(self) -> str:
323 |         
324 |         header = "   " + " ".join([f"C{j+1}" for j in range(9)])  
325 |         lines = [header]
326 |         for i, row in enumerate(self.game_state["grid"]):
327 |             row_str = f"R{i+1} "  
328 |             for j, num in enumerate(row):
329 |                 cell = str(num) if num != 0 else "."
330 |                 row_str += f"{cell} "
331 |                 if (j + 1) % 3 == 0 and j < 8:
332 |                     row_str += "| "
333 |             lines.append(row_str.strip())
334 |             if (i + 1) % 3 == 0 and i < 8:
335 |                 lines.append("   " + "- " * 11)
336 |         return "\n".join(lines)
337 | 
338 | 
339 |     def _is_move_correct(self, row: int, col: int, num: int) -> bool:
340 |         
341 |         
342 |         if num in self.game_state["grid"][row]:
343 |             return False
344 |         
345 |         if num in [self.game_state["grid"][i][col] for i in range(9)]:
346 |             return False
347 |         
348 |         start_row, start_col = 3 * (row // 3), 3 * (col // 3)
349 |         for i in range(start_row, start_row + 3):
350 |             for j in range(start_col, start_col + 3):
351 |                 if self.game_state["grid"][i][j] == num:
352 |                     return False
353 |         return True
354 | 
355 |     def _is_puzzle_complete(self) -> bool:
356 |         
357 |         for i in range(9):
358 |             for j in range(9):
359 |                 num = self.game_state["grid"][i][j]
360 |                 if num == 0 or not self._is_move_correct_complete(i, j, num):
361 |                     return False
362 |         return True
363 | 
364 |     def _is_move_correct_complete(self, row: int, col: int, num: int) -> bool:
365 |         
366 |         
367 |         self.game_state["grid"][row][col] = 0
368 |         correct = self._is_move_correct(row, col, num)
369 |         self.game_state["grid"][row][col] = num
370 |         return correct
371 | 
372 |     def _check_truncated(self) -> bool:
373 |         
374 |         if self.time_limit:
375 |             elapsed_time = time.time() - self.game_state["start_time"]
376 |             return elapsed_time > self.time_limit
377 |         return False
378 | 
379 |     def _check_terminated(self) -> bool:
380 |         
381 |         if self.game_state["completed"]:
382 |             return True
383 |         if self.game_state["incorrect_attempts"] >= self.max_incorrect:
384 |             self.game_state["completed"] = True
385 |             self.game_state["logs"].append("[GAME] Maximum number of incorrect attempts reached.")
386 |             return True
387 |         return False
```

## File: textarena/envs/single_player/Sudoku/archive/sudoku.py

- Extension: .py
- Language: python
- Size: 4401 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | 
  2 | 
  3 | SUDOKU_SOURCE = "MathMindsAGI/sudoku_v1"
  4 | 
  5 | import random
  6 | from datasets import load_dataset
  7 | from typing import Optional
  8 | import textarena as ta
  9 | import random
 10 | 
 11 | 
 12 | class SudokuEnv(ta.Env):
 13 |     environment_name = "Sudoku"
 14 | 
 15 |     def __init__(self):
 16 |         self.board = self.generate_board()
 17 |         self.game_state = ta.State(
 18 |             render={"board": self.board}, logs=[], player_map={0: "Player"}
 19 |         )
 20 | 
 21 |     def generate_board(self):
 22 |         
 23 |         
 24 |         dataset = load_dataset(SUDOKU_SOURCE)
 25 |         return random.choice(dataset["train"])["grid"]  
 26 | 
 27 |     def reset(
 28 |         self, seed: Optional[int] = None
 29 |     ) -> tuple[Optional[ta.Observation], Optional[ta.Info]]:
 30 |         if seed is not None:
 31 |             random.seed(seed)
 32 |         self.board = self.generate_board()
 33 |         self.game_state.render = {"board": self.board}
 34 |         self.game_state.logs = [(ta.GAME_ID, "New Sudoku game started.")]
 35 |         return {0: [(ta.GAME_ID, "Sudoku board reset.")]}, {}
 36 | 
 37 |     def step(
 38 |         self, player_id: int, action: str
 39 |     ) -> tuple[ta.Observation, ta.Reward, bool, bool, ta.Info]:
 40 |         
 41 |         message = (0, action)
 42 |         try:
 43 |             row, col, value = map(int, action.split(","))
 44 |             if self.board[row][col] != 0:
 45 |                 return (
 46 |                     {0: [message, (ta.GAME_ID, "Cell is already filled.")]},
 47 |                     {0: -1},
 48 |                     True,
 49 |                     False,
 50 |                     {},
 51 |                 )
 52 |             self.board[row][col] = value
 53 |             self.game_state.render["board"] = self.board
 54 |             self.game_state.logs.append(
 55 |                 (player_id, f"Player placed {value} at ({row}, {col}).")
 56 |             )
 57 |             if self.check_valid() and self.check_complete():
 58 |                 return (
 59 |                     {0: [message, (ta.GAME_ID, "You completed the Sudoku!")]},
 60 |                     {0: 100},
 61 |                     True,
 62 |                     False,
 63 |                     {},
 64 |                 )
 65 |             return (
 66 |                 {0: [message, (ta.GAME_ID, f"Placed {value} at ({row}, {col}).")]},
 67 |                 {0: 0},
 68 |                 False,
 69 |                 False,
 70 |                 {},
 71 |             )
 72 |         except Exception:
 73 |             return (
 74 |                 {
 75 |                     0: [
 76 |                         message,
 77 |                         (ta.GAME_ID, "Invalid action. Use format 'row,col,value'."),
 78 |                     ]
 79 |                 },
 80 |                 {0: -1},
 81 |                 True,
 82 |                 False,
 83 |                 {},
 84 |             )
 85 | 
 86 |     def render(self):
 87 |         board_str = "\n".join(
 88 |             [
 89 |                 " ".join(str(cell) if cell != 0 else "." for cell in row)
 90 |                 for row in self.board
 91 |             ]
 92 |         )
 93 |         print(board_str)
 94 | 
 95 |     def is_valid_group(self, group):
 96 |         
 97 |         group = [num for num in group if num != 0]  
 98 |         return len(group) == len(set(group)) and all(1 <= num <= 9 for num in group)
 99 | 
100 |     def check_valid(self):
101 |         
102 | 
103 |         
104 |         for row in self.board:
105 |             if not self.is_valid_group(row):
106 |                 return False
107 | 
108 |         
109 |         for col_idx in range(9):
110 |             col = [self.board[row_idx][col_idx] for row_idx in range(9)]
111 |             if not self.is_valid_group(col):
112 |                 return False
113 | 
114 |         
115 |         for box_row in range(0, 9, 3):
116 |             for box_col in range(0, 9, 3):
117 |                 subgrid = [
118 |                     self.board[r][c]
119 |                     for r in range(box_row, box_row + 3)
120 |                     for c in range(box_col, box_col + 3)
121 |                 ]
122 |                 if not self.is_valid_group(subgrid):
123 |                     return False
124 | 
125 |         
126 |         return True
127 | 
128 |     def check_complete(self):
129 |         
130 |         return all(all(cell != 0 for cell in row) for row in self.board)
```

## File: textarena/envs/single_player/WordLadder/archive/word_ladder.py

- Extension: .py
- Language: python
- Size: 5102 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
  1 | 
  2 | 
  3 | import textarena as ta
  4 | import networkx as nx
  5 | import nltk
  6 | from nltk.corpus import words
  7 | import random
  8 | import re
  9 | 
 10 | nltk.download("words")
 11 | WORD_LIST_REGEX = re.compile(r"^[a-zA-Z]+$")
 12 | 
 13 | 
 14 | class WordLadderEnv(ta.Env):
 15 |     
 16 | 
 17 |     def __init__(self, word_len: int = 4):
 18 |         super().__init__()
 19 |         self.word_graph = None
 20 |         self.build_word_graph(word_len=word_len)
 21 | 
 22 |     def build_word_graph(self, word_len: int):
 23 |         
 24 |         graph = nx.Graph()
 25 |         k_len_words = [word for word in words.words() if len(word) == word_len]
 26 |         graph.add_nodes_from(k_len_words)
 27 |         for i, word in enumerate(k_len_words):
 28 |             for other_word in k_len_words[i + 1 :]:
 29 |                 if sum(a != b for a, b in zip(word, other_word)) == 1:
 30 |                     graph.add_edge(word, other_word)
 31 |         
 32 |         graph.remove_nodes_from(list(nx.isolates(graph)))
 33 |         self.word_graph = graph
 34 | 
 35 |     def reset(self, seed=None) -> tuple[ta.Observation, ta.Info]:
 36 |         
 37 |         
 38 |         if seed is not None:
 39 |             random.seed(seed)
 40 |         else:
 41 |             random.seed()
 42 |         start_word = random.choice(list(self.word_graph.nodes()))
 43 |         current_word = start_word
 44 |         for _ in range(100):
 45 |             current_word = random.choice(list(self.word_graph.neighbors(current_word)))
 46 |         target_word = current_word
 47 |         assert target_word != start_word
 48 |         self.game_state = ta.State(
 49 |             render={"start_word": start_word, "target_word": target_word},
 50 |             logs=[],
 51 |             player_map={0: "Player"},
 52 |         )
 53 |         return (
 54 |             {0: [(ta.GAME_ID, self._get_prompt(start_word, target_word))]},
 55 |             {"start_word": start_word, "target_word": target_word},
 56 |         )
 57 | 
 58 |     def _get_prompt(self, start_word, target_word):
 59 |         
 60 |         return (
 61 |             "You are playing the word ladder game."
 62 |             f"Find a sequence of words to convert '{start_word}' to '{target_word}'"
 63 |         )
 64 | 
 65 |     def step(self, player_id, action):
 66 |         
 67 |         message = (0, action)
 68 |         start_word = self.game_state.render["start_word"]
 69 |         target_word = self.game_state.render["target_word"]
 70 |         match = WORD_LIST_REGEX.match(action)
 71 |         if not match:
 72 |             return (
 73 |                 {0: [message, (ta.GAME_ID, "Invalid word list format.")]},
 74 |                 {0: -1},
 75 |                 True,
 76 |                 False,
 77 |                 {},
 78 |             )
 79 |         word_list = action.split(",")
 80 |         word_list = [word.strip() for word in word_list]
 81 |         if word_list[0] != start_word or word_list[-1] != target_word:
 82 |             return (
 83 |                 {
 84 |                     0: [
 85 |                         message,
 86 |                         (
 87 |                             ta.GAME_ID,
 88 |                             "Word list must start and end with the given words.",
 89 |                         ),
 90 |                     ]
 91 |                 },
 92 |                 {0: -1},
 93 |                 True,
 94 |                 False,
 95 |                 {},
 96 |             )
 97 |         if not all(
 98 |             sum(a != b for a, b in zip(word_list[i], word_list[i + 1])) == 1
 99 |             for i in range(len(word_list) - 1)
100 |         ):
101 |             return (
102 |                 {
103 |                     0: [
104 |                         message,
105 |                         (ta.GAME_ID, "Words must differ by exactly one letter."),
106 |                     ]
107 |                 },
108 |                 {0: -1},
109 |                 True,
110 |                 False,
111 |                 {},
112 |             )
113 |         if word_list[-1] != target_word:
114 |             return (
115 |                 {0: [message, (ta.GAME_ID, "The last word must be the target word.")]},
116 |                 {0: -1},
117 |                 True,
118 |                 False,
119 |                 {},
120 |             )
121 |         return (
122 |             {0: [message, (ta.GAME_ID, "You found the word ladder!")]},
123 |             {0: 1},
124 |             False,
125 |             True,
126 |             {},
127 |         )
128 | 
129 |     def render(self):
130 |         start_word = self.game_state.render["start_word"]
131 |         target_word = self.game_state.render["target_word"]
132 |         print(f"Start word: {start_word}")
133 |         print(f"Target word: {target_word}")
134 |         for i, log in self.game_state.logs:
135 |             if i == 0:
136 |                 print(f"Player: {log}")
137 |             else:
138 |                 print(f"GAME: {log}")
```

## File: textarena/envs/single_player/Crosswords/utils/words_clues_generator.py

- Extension: .py
- Language: python
- Size: 2822 bytes
- Created: 2024-10-29 13:31:22
- Modified: 2024-10-29 13:31:22

### Code

```python
 1 | from openai import OpenAI
 2 | import random
 3 | import nltk
 4 | import os
 5 | import tqdm
 6 | import json
 7 | from typing import Optional
 8 | import argparse
 9 | 
10 | 
11 | from nltk.corpus import words
12 | nltk.download('words')
13 | 
14 | 
15 | client = OpenAI(base_url="https://openrouter.ai/api/v1", api_key=os.getenv("OPENROUTER_API_KEY"))
16 | 
17 | def get_clue_examples(word: str) -> list:
18 |     
19 |     try:
20 |         response = client.chat.completions.create(
21 |             model="gpt-4o-mini",
22 |             messages=[
23 |                 {"role": "user", "content": f"I am getting clues that will be used for the game 'crosswords'. Provide 10 distinct clue sentences for the word '{word}', each in its own line without any numerical point form. Include the number of letters in the word in parentheses at the end of each clue, e.g. (5 letters)."}
24 |             ],
25 |             temperature=0.7,
26 |         )
27 |         
28 |         clues_text = response.choices[0].message.content.strip()
29 |         clues_list = clues_text.split("\n")
30 |         clues_list = clues_list[:10] if len(clues_list) >= 10 else clues_list
31 |         
32 |         return dict([(f"{i+1}", clues_list[i]) for i in range(len(clues_list))])
33 |     except Exception as e:
34 |         return [f"An error occurred: {e}"]
35 | 
36 | def main(num_words: Optional[int] = 10):
37 |     easy_words = random.sample(words.words("en-basic"), num_words)
38 |     hard_words = random.sample(words.words("en"), num_words)
39 | 
40 |     easy_tag = [False] * num_words
41 |     hard_tag = [True] * num_words
42 | 
43 |     all_words = easy_words + hard_words
44 |     all_tags = easy_tag + hard_tag
45 | 
46 |     
47 |     with open("textarena/envs/single_player/crosswords/crosswords_dataset.jsonl", "w") as f:
48 |         for word, tag in tqdm.tqdm(zip(all_words, all_tags)):
49 |             clues = get_clue_examples(word)
50 |             
51 |             json_line = json.dumps({"word": word, "hardcore": tag, "clues": clues})
52 |             f.write(json_line + "\n")
53 | 
54 |     print("Dataset generated and saved to 'textarena/envs/single_player/crosswords/crosswords_dataset.jsonl'.")
55 | 
56 | if __name__ == "__main__":
57 |     parser = argparse.ArgumentParser(description="Generate a crossword dataset.")
58 |     parser.add_argument("--num_words", type=int, default=10, help="Number of easy and hard words to include in the dataset.")
59 |     args = parser.parse_args()
60 | 
61 |     
62 |     main(args.num_words)
```

## File: textarena/envs/single_player/LogicPuzzle/utils/game_board_generator.py

- Extension: .py
- Language: python
- Size: 4920 bytes
- Created: 2024-11-11 15:23:27
- Modified: 2024-11-11 15:23:27

### Code

```python
  1 | from openai import OpenAI
  2 | import os
  3 | import json
  4 | import re
  5 | import tqdm
  6 | 
  7 | 
  8 | client = OpenAI(base_url="https://openrouter.ai/api/v1", api_key=os.getenv("OPENROUTER_API_KEY"))
  9 | 
 10 | 
 11 | solutions = [
 12 |     {
 13 |         "people": ["Alice", "Bob", "Charlie"],
 14 |         "locations": ["home", "work", "park"],
 15 |         "times": ["morning", "afternoon", "evening"],
 16 |     },
 17 |     {
 18 |         "people": ["Alice", "Bob", "Charlie"],
 19 |         "car": ["red", "blue", "green"],
 20 |         "fuel": ["gasoline", "diesel", "electric"],
 21 |     },
 22 |     {
 23 |         "people": ["Alice", "Bob", "Charlie"],
 24 |         "food": ["pizza", "burger", "salad"],
 25 |         "drink": ["water", "soda", "beer"],
 26 |     },
 27 |     {
 28 |         "people": ["Alice", "Bob", "Charlie"],
 29 |         "sport": ["soccer", "basketball", "tennis"],
 30 |         "day": ["wednesday", "monday", "tuesday"],
 31 |     }
 32 | ]
 33 | 
 34 | def get_all_combinations(entry):
 35 |     
 36 |     return list(zip(*entry.values()))
 37 | 
 38 | def get_clue_examples(solution: dict) -> dict:
 39 |     
 40 |     try:
 41 |         response = client.chat.completions.create(
 42 |             model="gpt-4o-mini",
 43 |             messages=[
 44 |                 {
 45 |                     "role": "user",
 46 |                     "content": (
 47 |                         f"I am designing a logic puzzle with a unique solution format.\n"
 48 |                         f"Each category (such as {', '.join(solution.keys())}) has specific values assigned to unique index positions, representing the correct solution.\n"
 49 |                         "\n"
 50 |                         "For example, the solution structure given is:\n"
 51 |                         f"{get_all_combinations(solution)}\n"
 52 |                         "where each tuple in the list matches the correct combination that you have to create clues for.\n"
 53 |                         "\n"
 54 |                         "Please create 5 sets of 5 clues each for this solution in 'easy' and 'hard' difficulty levels. This means there should be 5 sets of clues for each difficulty.\n"
 55 |                         "\nFor the **easy clues:**\n"
 56 |                         "- Provide direct assignments or straightforward eliminations that guide players towards identifying correct category pairings.\n"
 57 |                         
 58 |                         
 59 |                         "\nFor the **hard clues:**\n"
 60 |                         "- Use conditional, relational, or sequential reasoning, adding challenge by indirectly referencing the solution relationships.\n"
 61 |                         "Each set should support the unique solution derived from the input structure provided above.\n"
 62 |                         "Your response should be in a JSON format, where the keys are the difficulty levels ('easy', 'hard') and the values are lists of 5 clues for each difficulty level."
 63 |                     )
 64 |                 }
 65 |             ],
 66 |             temperature=0.7,
 67 |         )
 68 |         
 69 |         
 70 |         clues_text = response.choices[0].message.content.strip()
 71 |         json_match = re.search(r"```json\n({.*?})\n```", clues_text, re.DOTALL)
 72 |         
 73 |         if json_match:
 74 |             json_data = json.loads(json_match.group(1))
 75 |             return json_data
 76 |         else:
 77 |             print("Warning: No JSON data found in the response.")
 78 |             return {"easy": [], "hard": []}  
 79 |         
 80 |     except Exception as e:
 81 |         print(f"Error while generating clues: {e}")
 82 |         return {"easy": [], "hard": []}
 83 | 
 84 | def main():
 85 |     
 86 |     output_file = "textarena/envs/single_player/LogicPuzzle/game_board_clues.jsonl"
 87 |     
 88 |     with open(output_file, "w") as f:
 89 |         for solution in tqdm.tqdm(solutions, desc="Generating clues"):
 90 |             res = get_clue_examples(solution)
 91 |             for difficulty, clues in res.items():
 92 |                 for clue in clues:
 93 |                     json_line = json.dumps({"solution": solution, "difficulty": difficulty, "clue": clue})
 94 |                     f.write(json_line + "\n")
 95 |     
 96 |     print("Clues generation completed and saved to:", output_file)
 97 | 
 98 | 
 99 | if __name__ == "__main__":
100 |     main()
```

